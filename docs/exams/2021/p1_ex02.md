---
id: ex-2021-02
year: 2021
exam: parcial 1
tags:
 - complejidad
---

Como parte de un proyecto internacional, se quiere diseñar un sistema que permite guardar y consultar el historial de posiciones de ciertos elementos. Se sabe que el sistema necesitará internamente un diccionario para guardar la información (`Clave=elemento`, `Valor=posición`).

Se van a considerar sólo las siguientes estructuras de datos para implementar el diccionario, que se implementarán en las clases en paréntesis:

- Array con duplicados (`DiccionarioArrayDuplicados`)
- Array ordenado sin duplicados (`DiccionarioArrayOrdenado`)
- Árbol binario de búsqueda (`DiccionarioArbol`)
- Tabla hash con listas (`DiccionarioHash`)

Se pide:

- (a) (1,5 puntos) Diseñe un algoritmo que calcule la menor clave almacenada (`claveMin`), y otro que calcule el menor valor (`valorMin`), usando las siguientes signaturas y los métodos de la interfaz `Diccionario<K,V>` especificados al final del enunciado:
```java
K claveMin(Diccionario d) {
    //TODO a rellenar por el alumno
}
V valorMin(Diccionario d) {
    //TODO a rellenar por el alumno
}
```

Utilice el interfaz de `Diccionario<K,V>` que se muestra a continuación:

![](./p1/p1_ex02.png)

??? note "Mostrar solución"
    ```java
    public K claveMin(Diccionario<K, V> d) {
        K min = null;

        for (K key : d.keys()) {
            if (key.compareTo(min) < 0) {
                min = key;
            }
        }
        return min;
    }
    ```

    ```java
    public V valorMin(Diccionario<K, V> d) {
        V min = null;

        for (K key : d.keys()) {
            V v = d.get(key);
            if (v.compareTo(min) < 0) {
                min = v;
            }
        }
        return min;
    }
    ```


- (b) (0,5 puntos) Si `claveMin` y `valorMin` pudieran tener acceso a la estructura de datos interna de cada una de las implementaciones consideradas (p.e., la tabla hash en `DiccionarioHash`), ¿podría diseñarse una alternativa de menor complejidad?. Razone su respuesta sin escribir el algoritmo. 

??? note "Mostrar solución"
    Los métodos implementados tienen complejidad en tiempo de ejecución $O(n)$, pero `claveMin` podría usar ser más eficiente en `DiccionarioArrayOrdenado` y `DiccionarioArbol`, porque las claves están ordenadas. Para `valorMin` no sería posible.
    
    El algoritmo para la interfaz tiene complejidad $O(n)$, porque tiene que recorrer todas las claves y todos los valores.
    
    En `DiccionarioHash` y `DiccionarioArrayDuplicados` también habría que recorrer todos los elementos, así que la complejidad sería similar.
    
    En `DiccionarioArrayOrdenado` y `DiccionarioArbol` las claves están ordenadas.
    
    Por tanto, en `DiccionarioArrayOrdenado` se podría conseguir $O(1)$ para `claveMin`, porque simplemente hay que acceder al primer elemento. En `DiccionarioArbol` tendríamos complejidad $O(log(n))$, porque hay que recorrer toda la profundidad ($log2(n)$, en un árbol balanceado).
    
    Para `valorMin` no se podría conseguir un algoritmo mejor porque los valores no están ordenados, sólo las claves.


Elija entre las implementaciones consideradas la mejor adaptada para cada uno de los siguientes usos del sistema. Razone su respuesta usando los criterios de complejidad.

- (c) (1 punto) Directorio de salas en la universidad. Consultas (`get`) frecuentes, actualizaciones (`put`, `remove`) poco frecuentes.

??? note "Mostrar solución"
    `DiccionarioHash`, porque tiene búsquedas muy rápidas ($O(1)$). Además, al haber pocas actualizaciones podremos dimensionar la tabla correctamente.


- (d) (1 punto) Registro de seguridad de la posición en cada hora de los miembros del personal. Consultas poco frecuentes, actualizaciones muy frecuentes y no se deben sobreescribir valores antiguos.

??? note "Mostrar solución"
    `DiccionarioArrayDuplicados`. No se deben sobreescribir valores, y es el único con esa condición en caso de actualización. Además, las consultas son $O(n)$, pero priman las actualizaciones ($O(1)$).


- (e) (1 punto) Prevención de colisiones de vehículos con actualizaciones y consultas cada minuto. Consultas y actualizaciones igual de frecuentes. 

??? note "Mostrar solución"
    `DiccionarioHash`. Tanto consultas como actualizaciones tienen complejidad $O(1)$.
