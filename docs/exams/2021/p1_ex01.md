---
id: ex-2021-01
year: 2021
exam: parcial 1
tags:
 - complejidad
 - grafos
---

Se quiere desarrollar un algoritmo para saber si un grafo no dirigido es acíclico, es decir, no tiene ciclos. Ejemplos:

![](./p1/p1_ex01-1.png)

Se pide:

- (a) (3,5 puntos) Diseñe el algoritmo tomando como referencia la siguiente signatura.
```java
boolean tieneCiclos(EdgeWeightedGraph g) {
    //TODO a rellenar por el alumno}
```
Primero, explique las estructuras de datos que necesita en el código y qué uso se les va a dar. Segundo, implemente la solución en Java. Nota: Puede desarrollar métodos auxiliares si lo necesita.

Puede utilizar los siguientes métodos:
![](./p1/p1_ex01-2.png)

??? note "Mostrar solución"

    ```java
    interface Solucion {
        boolean tieneCiclos(EdgeWeightedGraph g);
    }
    ```

    Solución Iterativa:

    ```java
    class Iterativa implements Solucion {

        @Override
        public boolean tieneCiclos(EdgeWeightedGraph g) {

            List<Integer> pendientes = new ArrayList<Integer>();
            List<Integer> visitadosNodos = new ArrayList<Integer>();
            List<Edge> visitadosArcos = new ArrayList<Edge>();

            Integer nodo = 0;

            for (int i = 0; i < g.V(); i++) {

                if (visitadosNodos.contains(i)) continue;

                pendientes.add(i);

                while (!pendientes.isEmpty()) {

                    nodo = pendientes.remove(0);
                    visitadosNodos.add(nodo);

                    for (Edge arco : g.adj(nodo)) {

                        Integer otro = arco.other(nodo);

                        if (!visitadosArcos.contains(arco) &&
                            pendientes.contains(otro)) {
                            return true; // ciclo detectado
                        } else {
                            if (!pendientes.contains(otro) &&
                                !visitadosArcos.contains(arco)) {
                                pendientes.add(otro);
                            }
                        }

                        visitadosArcos.add(arco);
                    }
                }
            }
            return false;
        }
    }
    ```

    Solución Recursiva:

    ```java
    class Recursiva implements Solucion {

        @Override
        public boolean tieneCiclos(EdgeWeightedGraph g) {

            Set<Integer> seen = new HashSet<Integer>();
            Set<Edge> seenArcos = new HashSet<Edge>();

            for (int v = 0; v < g.V(); v++) {
                if (seen.contains(v)) continue;

                if (dfs(g, v, seen, seenArcos)) {
                    return true;
                }
            }
            return false;
        }

        boolean dfs(EdgeWeightedGraph g, int v,
                    Set<Integer> seen,
                    Set<Edge> seenArcos) {

            if (seen.contains(v)) {
                return true; // ciclo detectado
            }

            seen.add(v);

            for (Edge e : g.adj(v)) {

                if (seenArcos.contains(e)) continue;

                seenArcos.add(e);
                int neighbour = e.other(v);

                if (dfs(g, neighbour, seen, seenArcos)) {
                    return true;
                }
            }
            return false;
        }
    }
    ```


- (b) (0,5 putnos) ¿Qué tipo de algoritmo ha diseñado? Recursivo/iterativo (Razone su respuesta)

??? note "Mostrar solución"
    La solución dependerá de la respuesta a la pregunta (a).


- (c) (1 punto) Realice un cálculo de la complejidad del algoritmo propuesto.

??? note "Mostrar solución"
    La solución dependerá de la respuesta a la pregunta (a).
