---
id: ex-2021-02
year: 2021
exam: parcial 2 recuperacion
tags:
 - hebras
---
Se desea implementar un sistema que simule un conjunto de jugadores de un equipo de fútbol americano, que están sedientos, y una persona que actuará como aguador. Cada jugador se encargará periódicamente de extraer un vaso de una lista de vasos compartida, y de llenarlo de agua de una botella también compartida. El aguador comprobará continuamente que haya disponibles vasos y agua en la botella, rellenando ambos en caso contrario. Tanto los jugadores como el aguador tienen que poder trabajar de forma concurrente.

Se incluye la implementación de las clases necesarias, además del método `ExtraordinarioP2.main`, que permite probar el programa con 20 jugadores y un aguador. 

```java
import java.util.List;
import java.util.ArrayList;

public class ExtraordinarioP2 {

    public static void main(String[] args) {
        Botella botella = new Botella();
        botella.litros = 100;

        List<Vaso> vasos = new ArrayList<Vaso>();

        Aguador aguador = new Aguador(botella, vasos);
        aguador.start();

        for (int i = 0; i < 20; i++) {
            Jugador jugador = new Jugador(botella, vasos);
            jugador.start();
        }
    }
}
```

```java
public class Vaso {
    Integer capacidad;

    public Vaso(int capacidad) {
        this.capacidad = capacidad;
    }
}
```

```java
public class Botella {
    Integer litros;
}
```

```java
import java.util.List;

class Aguador extends Thread {

    private Botella botella;
    private List<Vaso> vasos;

    public Aguador(Botella botella, List<Vaso> vasos) {
        this.botella = botella;
        this.vasos = vasos;
    }

    /*
     * El aguador rellena la botella de agua, y pone vasos nuevos.
     */
    public void run() {
        while (true) {
            synchronized (this.botella) {
                if (this.botella.litros < 1) {
                    System.out.println("Aguador rellena botella");
                    this.botella.litros = 10;
                }
            }

            synchronized (this.vasos) {
                if (this.vasos.size() < 1) {
                    for (int i = 0; i < 10; i++) {
                        this.vasos.add(new Vaso(1));
                    }
                    System.out.println("Aguador añade vaso");
                }
            }
        }
    }
}
```

```java
import java.util.List;

class Jugador extends Thread {

    private Botella botella;
    private List<Vaso> vasos;

    public Jugador(Botella botella, List<Vaso> vasos) {
        this.botella = botella;
        this.vasos = vasos;
    }

    /*
     * Cada jugador extrae un vaso, lo llena de agua y bebe.
     */
    public void run() {
        Vaso vaso = null;

        while (true) {
            try {
                System.out.println("Jugador intenta beber");

                synchronized (this.vasos) {
                    if (this.vasos.size() < 1) {
                        continue;
                    }
                    if (vaso == null) {
                        vaso = this.vasos.remove(0);
                        System.out.println("Jugador ha cogido vaso");
                    }
                }

                synchronized (this.botella) {
                    if (this.botella.litros < vaso.capacidad) {
                        continue;
                    }
                    Thread.sleep(500);
                    this.botella.litros -= vaso.capacidad;
                    System.out.println("Jugador ha bebido");
                }

                // Tira el vaso
                vaso = null;

                Thread.sleep(6000);

            } catch (InterruptedException ignored) {
            }
        }
    }
}
```

Nota: Se recuerda que un bloque `synchronized` se asocia al objeto en el parámetro. Se garantiza exclusión mutua entre los bloques sincronizados que se invocan con el mismo objeto.

- (a) (2 puntos) ¿Existe algún problema de acceso concurrente en esta implementación? Si es así, ¿De qué tipo es? Justifique su respuesta.

??? note "Mostrar solución" 
    Sí existe. Hay bloqueo exclusivo de los recursos, con espera, y en orden inverso: `Aguador` bloquea `botella` y luego `vasos`, mientras que `Jugador` bloquea los `vasos` primero.


- (b) (1 punto) Si existiera algún problema ¿Cómo lo solucionaría?

??? note "Mostrar solución" 
    La solución más sencilla es invertir el orden del bloqueo en `Aguador` o en `Jugador`. Analizando el código vemos que no se necesita bloquear sobre ambos recursos a la vez, así que una mejor solución sería separar las dos regiones críticas: primero bloquear `vasos`, acabar el bloque, y luego bloquear la `botella` (o viceversa).


- (c) (1 punto) Los `vasos` tienen una capacidad de 1 litro. Sin modificar la implementación de `Jugador`, ¿Cuál es el número máximo de jugadores que podrían beber por minuto?

??? note "Mostrar solución" 
    Nos piden el máximo, con lo que usaremos el caso mejor. Para que un jugador pueda beber, tiene que haber bloqueado los vasos (500ms de espera) y luego la botella (1000ms). Ese es el mínimo tiempo necesario por jugador, y durante el cual los recursos están bloqueados. El tiempo de espera tras beber no afecta, porque se puede aumentar el número de jugadores.
    
    Por tanto, el número máximo de jugadores sería 60s/ (1.5s/1 jugador) = 40 jugadores.
    
    Para este máximo, hemos supuesto que el tiempo de procesamiento (bloqueo) por el aguador, el de las operaciones básicas y el consumido por los cambios de contexto son despreciables.
    
    Se podría aumentar el número de jugadores por minuto separando los dos bloques `synchronized` (ver respuesta anterior), de forma que el tiempo de espera se reparta entre los dos elementos. De esa forma, el primer jugador tardaría 1.5s en beber, pero los siguientes podrían tardar sólo 1s (la espera sobre los vasos puede darse a la vez que la espera sobre la botella). En ese caso, en el primer minuto podría haber 59 jugadores, y 60 en los siguientes.
    
    Si se considera que NO se puede aumentar el número de jugadores en ExtraordinarioP2, el número máximo sería 20 (es el número de jugadores que añadimos), que podrían llegar a beber 2 veces en ese minuto (20 jugadores tardan 30 segundos en completar, que es menor que el tiempo de espera post-bebida).
    

- (d) (1 punto) Si se desease sustituir los bloques sincronizados por métodos sincronizados ¿En qué clase o clases los implementaría?

??? note "Mostrar solución" 
    Los métodos sincronizados aplican un bloqueo sobre el objeto al que pertenecen. Por tanto, estos métodos deben estar definidos sobre un objeto común a todas las hebras. Esto descarta Jugador y Aguador. En este caso, el único objeto compartido es Botella. Para bloquear sobre la lista de vasos, habría que crear una clase que represente la lista.
