---
id: ex-2017-01
year: 2017
exam: parcial 1
tags:
 - complejidad
---

En un proyecto se necesita programar una clase que represente un conjunto de palabras (`String`), sin que haya duplicados almacenados. Con este fin se realizan dos fases:

1. **fase 1** de carga de todas las palabras, con un método:
```java
public void put (String palabra)
```

2. **fase 2** de consulta, con un método:
```java
boolean get (String palabra)
```
que devuelve `TRUE` si, y solo si, la palabra dada como parámetro está en el diccionario.

Se proponen varias opciones:
<ol>
<li> Las palabras se meten en un array, una tras otra; al acabar la **fase 1**, el array se ordena y se eliminan los duplicados, pasando a la **fase 2** donde se usa el array sin duplicados. </li>

<li> Las palabras se meten en un diccionario implementado con una tabla hash, de forma que solo hay que almacenar la clave (es decir la palabra); si la clave está en el diccionario, `get()` devuelve `TRUE`. </li>

<li> Se combinan las opciones anteriores: las palabras (1) se meten en un array, (2) se ordena el array, (3) se eliminan duplicados, (4) los datos del array se cargan en un diccionario implementado con una tabla hash y (5) el método `get()` devuelve `TRUE` si, y solo si, la palabra está en el diccionario. </li>
</ol>

- (a) (2,5 puntos) Razone la complejidad de los métodos `put()` y `get()` en cada una de las opciones propuestos.

??? note "Mostrar solución"
    1. **Fase 1**: $O($insertar al final del array $n$ veces$) + O($ordenar$) + O($borrar duplicados$) = O(n) + O(nlogn) + O(n)$

    $= O(nlog n)$

    **Fase 2**: $O($búsqueda array ordenado$) = O(logn)$

    2. **Fase 1**: $O($insertar $n$ veces$) = O(n)$

    **Fase 2**: $O(1)$

    3. **Fase 1** $= (1) + O($transferir array $\rightarrow$ hash$) = O(nlogn) + O(n) = O(nlogn)$

    **Fase 2** $= O(1)$


- (b) (2,5 puntos) Escriba el método `public void put(String palabra)` modificando el método `public void put(String clave, String valor)` del ejercicio 2 para que tenga la funcionalidad solicitada, usando internamente una tabla hash. Puede utilizar como base el código que aparece a continuación, rellenando los espacios que se indican.

```java
public class HashListas {
    private List<String>[] slots; // slots de la tabla Hash
    private int nDatos = 0; // número de datos de la tabla

    /**
     * Constructor
     * @param nSlots número de ranuras
     */
    public HashListas(int nSlots) {
        slots = new List[nSlots];
        for (int i = 0; i < nSlots; i++) {
            slots[i] = new ArrayList<String>(0);
        }
    }

    /**
     * Calcula función hash e índice en slots
     * @param clave String
     * @return índice en slots
     */
    private int getIdx(String clave) {
        return Math.abs(clave.hashCode()) % slots.length;
    }

    /**
     * Mete una nueva palabra en el diccionario
     * Si ya existe otra palabra, no hace nada
     * @param clave palabra para almacenar
     */
    public void put(String clave) {

    }

    /**
     * Devuelve el valor asociado a la clave
     * @param clave palabra que comprobamos
     * @return true si está en el diccionario;
     *         false en caso contrario
     */
    public boolean get(String clave) {

    }
}
```


??? note "Mostrar solución"
    ```java
    public class HashListas {
        private List<String>[] slots; // slots de la tabla Hash
        private int nDatos = 0; // número de datos de la tabla

        /**
         * Constructor
         * @param nSlots número de ranuras
         */
        public HashListas(int nSlots) {
            slots = new List[nSlots];
            for (int i = 0; i < nSlots; i++) {
                slots[i] = new ArrayList<String>(0);
            }
        }

        /**
         * Calcula función hash e índice en slots
         * @param clave String
         * @return índice en slots
         */
        private int getIdx(String clave) {
            return Math.abs(clave.hashCode()) % slots.length;
        }

        /**
         * Mete una nueva palabra en el diccionario
         * Si ya existe otra palabra, no hace nada
         * @param clave palabra para almacenar
         */
        public void put(String clave) {
            int idx = getIdx(clave);
            put(slots[idx], clave);
        }

        private void put(List<String> list, String clave) {
            for (String palabra : list) {
                if (palabra.compareTo(clave) == 0) {
                    return;
                }
            }
            list.add(clave);
            nDatos++;
        }

        /**
         * Devuelve el valor asociado a la clave
         * @param clave palabra que comprobamos
         * @return true si está en el diccionario;
         *         false en caso contrario
         */
        public boolean get(String clave) {
            int idx = getIdx(clave);
            return get(slots[idx], clave);
        }

        private boolean get(List<String> list, String clave) {
            for (String palabra : list) {
                if (palabra.compareTo(clave) == 0) {
                    return true;
                }
            }
            return false;
        }
    }
    ```
