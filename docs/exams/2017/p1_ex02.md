---
id: ex-2017-02
year: 2017
exam: parcial 1
tags:
 - grafos
---

Se implementa un árbol binario de búsqueda (BST) con valores enteros positivos como un array, colocando su raíz principal en la posición 1 del array y, para todo nodo del mismo en la posición i, su hijo izquierdo en la posición 2*i, y su hijo derecho en la posición 2*i+1. La posición 0 del array mantiene el contador del número de nodos en el árbol. Un nodo no existe si su posición en el array no existe (se sale del tamaño del array) o el valor en el array es -1. Por ejemplo:

![](./p1/p1_ex02.png)

| Índice | 0 | 1 | 2 | 3  | 4 | 5 | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 |
|--------|---|---|---|----|---|---|----|----|----|----|----|----|----|----|----|----|
| Valor  | 9 | 8 | 3 | 10 | 1 | 6 | -1 | 14 | -1 | -1 | 4  | 7  | -1 | -1 | 13 | -1 |

Con esta representación de un árbol, se pide:

- (a) (2,5 puntos) Programar un recorrido en el árbol que imprima ordenados los contenidos de los nodos visitados:

public void recorrer (int[] arbol) {...}

En el ejemplo dado, debería imprimir:

1 3 4 6 7 8 10 13 14

Nota: suponga que no es necesario comprobar si la representación del árbol proporcionada es correcta.

??? note "Mostrar solución"
    public void recorrer(int[] arbol) {
        recorrer(arbol, 1);
    }
    
    private void recorrer(int[] arbol, int i) {
        if (i < arbol.length && arbol[i] >= 0) {
            recorrer(arbol, 2 * i);
            System.out.println(arbol[i]);
            recorrer(arbol, 2 * i + 1);
        }
    }
    
    
- (b) (2,5 puntos) Razonar la complejidad de dicho recorrido.

??? note "Mostrar solución"
    La complejidad (en tiempo) del algoritmo es lineal, es decir O(n), siendo n el número de nodos, puesto que recorre el árbol visitando todos sus nodos, y en cada uno de ellos realiza un trabajo de orden constante, es decir O(1).
    
    NOTA:
    
    Para la solución de la ecuación de recurrencia
    
    T(n) = T(n/2) + C + T(n/2) = 2 T(n/2) + C
    
    que se resuelve como O(n), **ver apuntes**.