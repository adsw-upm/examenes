---
id: ex-2024-02
year: 2024
exam: parcial 1
tags:
 - complejidad
---

Se disponen las siguientes clases que representan árboles de búsqueda binaria:

```java
public class Nodo {
    int clave;
    int valor;
    Nodo iz, der;
    // ...
}

public class BST {

    private Nodo raiz;

    /**
     * Este método calcula el número de nodos que tienen un valor
     * igual al parámetro dado.
     *
     * @param unValor El valor para el cálculo
     * @return El número de nodos que tengan un valor igual al parámetro
     */
    public int cuentaValores(int unValor) {
        // ...
    }

    /**
     * Este método calcula el número de nodos cuya clave está incluida
     * en el rango proporcionado por los parámetros.
     *
     * @param minClave Número menor en el rango
     * @param maxClave Número mayor en el rango
     * @return El número de nodos cuya clave está en el rango
     */
    public int cuentaClaves(int minClave, int maxClave) {
        // ...
    }

    public int m() {
        return m(raiz);
    }

    private int m(Nodo nodo) {
        if (nodo == null)
            return 0;

        int i = m(nodo.iz);
        int j = m(nodo.der);

        return 1 + i + j;
    }
}
```

Nota: En relación a los métodos solicitados en las preguntas (a), (b), y (c):

- En la evaluación de estas preguntas, se tendrá en cuenta la complejidad de la solución elegida. En la calificación, se valorará la complejidad de la solución propuesta.
- No se puede cambiar la signatura de estas clases. Si son necesarios métodos auxiliares podrán incluirse métodos o atributos adicionales, pero habrá que mantener su signatura.

Se puede suponer que los árboles que soportan estas clases son árboles equilibrados. Se pide:

- (a) (1,5 puntos) Implemente el método `cuentaValores`, según la especificación descrito en el código mostrado.

??? note "Mostrar solución"
    ```java
    public int cuentaValores(int unValor) {
        return cuentaValores(raiz, unValor, 0);
    }

    private int cuentaValores(Nodo n, int unValor, int num) {
        if (n == null)
            return num;

        if (n.valor == unValor)
            num++;

        num = cuentaValores(n.iz, unValor, num);
        num = cuentaValores(n.der, unValor, num);

        return num;
    }
    ```


- (b) (0,5 puntos) Calcule la complejidad de la solución implementada de la clase `cuentaValores`. 

??? note "Mostrar solución"
    La complejidad de esta implementación es $N$, donde $N$ es el número de elementos del árbol. La implementación recorre el árbol con un algoritmo de pre-orden. Hay que recorrer el árbol entero porque los valores pueden estar ubicados en cualquier parte del árbol.


- (c) (2 puntos) Implemente el método `cuentaClaves`. `cuentaClaves` devuelve el número de nodos que tiene como clave una clave mayor que `minClave` y menor que `maxClave`.

??? note "Mostrar solución"
    ```java
    public int cuentaClaves(int minClave, int maxClave) {
        return cuentaClaves(raiz, minClave, maxClave, 0);
    }

    private int cuentaClaves(Nodo n, int minClave, int maxClave, int num) {
        if (n == null)
            return num;

        if (n.clave > minClave && n.clave < maxClave) {
            num++;
            num = cuentaClaves(n.iz, minClave, maxClave, num);
            num = cuentaClaves(n.der, minClave, maxClave, num);
            return num;
        }

        if (n.clave <= minClave)
            return cuentaClaves(n.der, minClave, maxClave, num);

        if (n.clave >= maxClave)
            return cuentaClaves(n.iz, minClave, maxClave, num);

        return num;
    }
    ```


- (d) (1 punto) ¿Cuál es la funcionalidad del método `m`? 

??? note "Mostrar solución"
    El método `m` es una implementación del método `size` de `Diccionario`. Esta implementación cuenta el número de elementos del árbol, recorriendo todo el árbol.


- (e) (0,5 puntos) ¿Cuál es la complejidad del método `m`? 

??? note "Mostrar solución"
    Es un algoritmo de complejidad $N$. Suponiendo que el árbol es equilibrado, la función de recurrencia de el algoritmo que se utiliza es:
    
    $T(n)=O(1)+T(n-1/2)+T(n-1/2)=O(1)+T(n-1)=O(n)$


- (f) (0,5 puntos) ¿Qué tipo de función es la implementación del método `m`? 
    1. Una función pre-orden
    2. Una función en-orden
    3. Una función post-orden

??? note "Mostrar solución"
    La implementación es una función de post-orden. Primero recorre el sub-árbol izquierdo, después el derecho, y finalmente la función de visita es sumar l1 y los valores devueltos por el recorrido de la izquierda y la derecha.
