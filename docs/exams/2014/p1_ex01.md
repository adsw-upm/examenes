---
id: ex-2014-01
year: 2014
exam: parcial 1
tags:
 - complejidad
---

Se necesita comprobar la bondad de los algoritmos de construcción de laberintos que se puedan desarrollar para la práctica del Pacman. El objetivo es poder construir un laberinto conexo, esto es, un terreno en el que todas las casillas estén conectadas, bien directamente o bien a través de otras que las interconecten. De esta forma, no habrá zonas del laberinto aisladas.

Para ello, se pide desarrollar una clase auxiliar, llamada `Conectividad`, que averigüe si un terreno es conexo o no. La especificación de la clase es la siguiente:

```java
package es.upm.dit.adsw.pacman2;

public class Conectividad {
    private final Terreno terreno;

    /**
     * @param terreno
     */
    public Conectividad(Terreno terreno) {
        this.terreno = terreno;
    }

    /**
     * Determina si el terreno es conexo
     * @return true si el terreno es conexo, false en caso contrario
     */
    public boolean esConexo() { ... }
}
```

- (a) (3,5 puntos) Implementación del método `esConexo()`. Este método ha de comprobar que desde cualquier casilla del terreno se puede alcanzar cualquier otra casilla.

Sugerencia: Se propone el siguiente algoritmo para determinar si un terreno tiene casillas conexas.

Se define un conjunto de casillas visitadas (ya analizadas alguna vez) y una lista de casillas pendientes (aún no analizadas).

Se elige una casilla inicial, por ejemplo (0,0), y se añade a la lista de pendientes.

Mientras haya casillas pendientes:
  1. Se saca una casilla de la lista de pendientes.
  2. Se añade la casilla al conjunto de visitadas.
  3. Para cada dirección:
     * Si existe una casilla adyacente accesible (no separada por una pared)
     * Y no ha sido visitada, se añade a la lista de pendientes.

Cuando ya no hay casillas pendientes:
  * O bien se han visitado todas las casillas
  * O existen zonas aisladas que no se han podido alcanzar

Si el tamaño del conjunto de visitadas coincide con el número total de casillas (N^2), entonces el terreno es conexo.

??? note "Mostrar solución"
    Una posible implementación del método `esConexo()` es la siguiente:

    ```java
    public boolean esConexo() {
        Set<Casilla> visitadas = new HashSet<Casilla>();
        List<Casilla> pendientes = new ArrayList<Casilla>();

        Casilla origen = terreno.getCasilla(0, 0);
        pendientes.add(origen);

        while (!pendientes.isEmpty()) {
            Casilla c = pendientes.remove(0);
            visitadas.add(c);

            for (Direccion d : Direccion.values()) {
                if (!c.hayPared(d)) {
                    Casilla v = terreno.getCasilla(c, d);
                    if (v != null && !visitadas.contains(v)) {
                        pendientes.add(v);
                    }
                }
            }
        }

        int N = terreno.getN();
        return visitadas.size() == N * N;
    }
    ```


- (b) (1,5 puntos) Complejidad temporal del algoritmo. (0,5 puntos) Determine la complejidad temporal del algoritmo programado en el apartado anterior. (1 punto) Justifique su respuesta. Se considera más importante el razonamiento sobre la complejidad que el cálculo correcto.

??? note "Mostrar solución"

    Dado que el algoritmo recorre, en el **peor de los casos**, todas las casillas del terreno, la complejidad básica será:

    [
    O(N^2) \times (\text{complejidad de las operaciones})
    ]

    Las operaciones básicas (comparaciones, asignaciones, accesos simples) tienen complejidad O(1).

    El acceso a las estructuras de datos depende de su implementación. En el caso de`HashSet` las operaciones de inserción, borrado y búsqueda tienen complejidad O(1) de forma habitual. En el caso de `ArrayList`n la operación `remove(0)` implica desplazar todos los elementos restantes, por lo que su complejidad es O(N).

    Por lo tanto, para el primer caso tenemos que el algoritmo es O(N²) y para el segundo O(N³).
