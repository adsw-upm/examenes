---
id: ex-2013-01
year: 2013
exam: parcial 1
tags:
 - complejidad
---

Tenemos arrays de datos que están ordenados en orden ascendente, pero con los datos desplazados una distancia \( h \ge 0 \). Por ejemplo:

| h | array                  |
|---|------------------------|
| 0 | [1, 3, 5, 7, 11, 13]   |
| 1 | [13, 1, 3, 5, 7, 11]   |
| 2 | [11, 13, 1, 3, 5, 7]   |
| 3 | [7, 11, 13, 1, 3, 5]   |
| … | …                      |

Supondremos que todos los datos del array son distintos.

- (a) (1,5 puntos) Dados un array y el desplazamiento \( h \), desarrolle un algoritmo de complejidad $O(1)$ que devuelva el número mayor conociendo el array y el desplazamiento:
```java
int getMayor1(int[] array, int h)
```
Demuestre que el algoritmo es efectivamente de complejidad $O(1)$.

??? note "Mostrar solución"
    Una solución sería:
    ```java
    private static int getMayor1(int[] array, int h) {
        return array[(array.length - 1 + h) % array.length];
    }
    ```
    El algoritmo es de complejidad $O(1)$ porque el número de pasos del algoritmo es independiente de $n$.

- (b) (1,5 puntos) Desarrolle un algoritmo de complejidad $O(n)$ que devuelva el número mayor conociendo el array, pero sin saber el desplazamiento:
```java
int getMayor2(int[] array)
```
Demuestre que el algoritmo es de complejidad $O(n)$.

??? note "Mostrar solución"
    Una solución sería:
    ```java
    private static int getMayor2(int[] array) {
        int mayor = Integer.MIN_VALUE;
        for (int num : array) {
            if (mayor < num)
                mayor = num;
        }
        return mayor;
    }
    ```
    El algoritmo es de complejidad $O(n)$ porque es un bucle que se ejecuta $n$ veces.
    

- (c) (2 puntos) Desarrolle un algoritmo de complejidad $O(log n)$ que devuelva el número mayor conociendo el array, pero sin conocer el desplazamiento:
```java
int getMayor3(int[] array)
```

Pista:

Hay que usar el algoritmo del apartado (a) probando con diferentes valores de $h$. Para un valor de $h$:
    - Sabemos que es el correcto si el número siguiente es menor que ```array[h]```.
    - Sabemos si hay que aumentar o disminuir $h$ comparando ```array[h]``` con ```array[0]```.

??? note "Mostrar solución"
    La siguiente solución utiliza un método auxiliar, `busca`:

    ```java
    private static int getMayor3(int[] array) {
        return busca(array, 0, array.length);
        }

        private static int busca(int[] array, int a, int z) {
            if (a >= z)
                return array[a];
            int h = (a + z) / 2;
            int num = array[h];
            int num_1 = array[(h + 1) % array.length];
            if (num > num_1)
                return num;
            if (array[0] < num)
                return busca(array, h + 1, z);
            else
                return busca(array, a, h);
        }
    ```
    El algoritmo es de complejidad $O(log n)$ porque es un esquema de división sucesiva. Más desarrollado:
        - Al principio, $h$ puede estar entre $O$ y $N-1$;
        - Tras 1 paso, $h$ puede estar entre $(O y N/2)$ o entre $(N/2 y N)$; es decir, hemos reducido las opciones a la mitad $(N/2)$;
        - Tras $k$ pasos, el rango es $N/2^k$; de forma que el rango se reduce a 1 ($h$ encontrado) cuando $1 \leq N/2^k \rightarrow k=log(N)$;  cuando $1 \leq N/2^k \rightarrow k = log_2 (N) ⊂ O(log N)$
