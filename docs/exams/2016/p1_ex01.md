---
id: ex-2016-01
year: 2016
exam: parcial 1
tags:
 - complejidad
---

Queremos desplegar un conjunto de sensores de contaminación en Madrid. Cada sensor `S` está en unas coordenadas `(x, y)` medidas en metros en una cuadrícula centrada en la Puerta del Sol, yendo el eje X de oeste a este y el eje Y de sur a norte.

Los sensores son frágiles y pueden fallar. Pero no queremos quedarnos sin datos, así que se les facilita la capacidad de que puedan mandar sus mediciones a otro sensor, que debe estar a una distancia menor que `d0` metros.

```java
public class Sensor {
    private final String id;
    private final int x, y;

    public Sensor(String id, int x, int y) {
        this.id = id;
        this.x = x;
        this.y = y;
    }

    public double distancia(Sensor b) {
        int dx = Math.abs(x - b.x);
        int dy = Math.abs(y - b.y);
        return Math.sqrt(dx * dx + dy * dy);
    }
}
```

- (a) (3,5 puntos) Dada una lista con todos los sensores, escriba un método que cargue un diccionario donde cada sensor está asociado a una lista con los sensores que están a su alcance (a menos de `d0` metros). Nótese que si el sensor `A` está dentro del alcance de `B`, también está `B` dentro del alcance de A. Razone la complejidad de este método:
```java
public class Red {
    private Diccionario diccionario = new …

    public void cargar(List<Sensor> sensores, double d0) {…}
```

??? note "Mostrar solución"
    Solución usando un diccionario de la biblioteca de Java
    
    ```java
    public class Red {
        private Map<Sensor, List<Sensor>> diccionario = new HashMap<>();
        public void cargar(List<Sensor> sensores, double d0) {
            for (int i = 0; i < sensores.size(); i++) {
                Sensor s1 = sensores.get(i);
                List<Sensor> lista = new ArrayList<>();
                for (int j = 0; j < sensores.size(); j++) {
                    if (i == j)
                        continue;
                    Sensor s2 = sensores.get(j);
                    if (s1.distancia(s2) < d0)
                        lista.add(s2);
            }
            diccionario.put(s1, lista);
        }
    }
    ```

    Para usar un diccionario como el del ejercicio 3, hay que cambiar `CV` y la implementación de la misma manera:

    ```java
    class CVExamen {
        final Sensor clave;
        List<Sensor> valor;

        CVExamen(Sensor clave, List<Sensor> valor) {
            this.clave = clave;
            this.valor = valor;
        }
    }

    public interface Diccionario {
        void put(Sensor clave, List<Sensor> valor);
        List<Sensor> get(Sensor clave);
        List<Sensor> remove(Sensor clave);
        int size();
        void clear();
    }
    ```
    
    Complejidad.
    
    Siendo $N$ el número de sensores, tenemos un bucle exterior que se hace $N$ veces. Cada pasada por el bucle incluye:
    
    - bucle interior: $N$ veces, de complejidad $O(n)$.
    
    - `diccionario.put()`, donde lacomplejidad,  si el número de ranuras es sensiblemente superior a $N$ es $O(1)$, si no es $O(n)$.
    
    El total es, por tanto $O(n) + … = O(n)$
    
    Y la operación total de carga $N × O(n) \rightarrow O(n2)$


- (b) (3,5 puntos) Escriba un método para crear un diccionario que, para cada sensor `S`, contenga el conjunto de sensores a los que mandará regularmente una copia de sus medidas. Sabiendo que los sensores de destino podrían verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se envían a los `F` sensores que a su vez tengan menos sensores a su alcance.

```java
public Diccionario cercanos (int f) {…}
```

El algoritmo es como sigue:

1. Para cada sensor `S` obtenemos la lista de nodos a distancia alcanzable (pregunta (a));

2. Ordenamos la lista en función del número de sensores al alcance de cada sensor;

3. Nos quedamos con los F primeros sensores en una nueva lista;

4. Asociamos la nueva lista a S en el diccionario de resultado.

NOTAS:

- Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java;
- Como algoritmo de ordenación, elija uno de los presentados en clase, adaptando el código al caso;
- Puede usar métodos auxiliares si lo cree oportuno. Privados, por supuesto.

Razone la complejidad de su código

??? note "Mostrar solución"
    Probablemente, el número de sensores dentro del alcance sea un número pequeño. En ese caso la ordenación se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenación.

    En la solución que sigue se recurre al algoritmo de inserción.

    Usando la biblioteca de Java:

    ```java
    public Map<Sensor, List<Sensor>> cercanos(int f) {
        Map<Sensor, List<Sensor>> resultado = new HashMap<>();

        for (Sensor sensor : diccionario.keySet()) {
            List<Sensor> list1 = getListaOrdenadaSensores(sensor);
            List<Sensor> list2 = new ArrayList<>();

            int m = Math.min(f, list1.size());
            for (int i = 0; i < m; i++)
                list2.add(list1.get(i));

            resultado.put(sensor, list2);
        }
        return resultado;
    }

    private List<Sensor> getListaOrdenadaSensores(Sensor sensor) {
        List<Sensor> list0 = diccionario.get(sensor);
        List<Sensor> list1 = new ArrayList<>(list0);
        sort(list1);
        return list1;
    }

    private void sort(List<Sensor> list) {
        // inserción
        for (int i = 1; i < list.size(); i++)
            inserta(list, i, list.get(i));
    }

    // inserta sensor en datos, entre 0 y z-1
    private void inserta(List<Sensor> datos, int z, Sensor sensor) {
        int j = z;
        while (0 < j && compareTo(sensor, datos.get(j - 1)) < 0)
            j--;

        if (j != z) {
            datos.remove(sensor);
            datos.add(j, sensor);
        }
    }

    private int compareTo(Sensor s1, Sensor s2) {
        int size1 = diccionario.get(s1).size();
        int size2 = diccionario.get(s2).size();
        return size2 - size1;
    }
    ```

    Con respecto a la complejidad, hay que revisar $N$ sensores.
    
    Para cada sensor hay que localizar su lista de sensores en el diccionario: `get()`.
    
    Si el número de ranuras es sensiblemente superior a $N$, la complejidad es $O(1)$. De lo contrario, será $O(n)$.
    
    Seguimos en el supuesto de que esta operación es $O(1)$.

    Cada lista, de $X$ elementos, hay que ordenarla. Si usamos un algoritmo de inserción como el de arriba, por término medio será la ordenación de un array de $x$ elementos: $O(x2)$:

    1. Podemos pensar que $X$ sea constante, independientemente de $N$, en cuyo caso la ordenación será de tiempo constante, $O(1)$;
    
    2. Podemos pensar que $X$ sea proporcional a $N$, en cuyo caso la ordenación será una proporción de $N$: $O(n2)$.

    Nos quedamos con $f$ elementos: $O(1)$.
    
    Y hacemos una operación `put()` en el diccionario de salida.
    
    Si el número de ranuras es sensiblemente superior a $N$, la complejidad es $O(1)$. De lo contrario, será $O(n)$.
    
    Seguimos en el supuesto de que esta operación es $O(1)$.

    En el caso 1, el total es $N × (O(1) + O(1) + O(1) + O(1)) \rightarrow N × O(1) \rightarrow O(n)$.
    
    En el caso 2, el total es $N × (O(1) + O(n2) + O(1) + O(1)) \rightarrow N × O(n2) \rightarrow O(n3)$.

    Resumiendo, si el número de sensores dentro del alcance es independiente de $N$, la complejidad es $O(n)$. Si el número de sensores dentro del alcance es proporcional a $N$, la complejidad depende del algoritmo de ordenación.
