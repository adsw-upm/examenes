---
id: ex-2016-02
year: 2016
exam: parcial 1
tags:
 - complejidad
---

- (a) (3,5 puntos) Escriba un método para crear un diccionario que, para cada sensor S, contenga el conjunto de sensores a los que mandará regularmente una copia de sus medidas. Sabiendo que los sensores de destino podrían verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se envían a los F sensores que a su vez tengan menos sensores a su alcance.

```java
public Diccionario cercanos (int f) {…}
```

NOTA: El algoritmo es como sigue:
    - 1. para cada sensor S obtenemos la lista de nodos a distancia alcanzable (pregunta 1)
    - 2. ordenamos la lista en función del número de sensores al alcance de cada sensor
    - 3. nos quedamos con los F primeros sensores en una nueva lista
    - 4. asociamos la nueva lista a S en el diccionario de resultado

NOTAS:
    - Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java.
    - Como algoritmo de ordenación, elija uno de los presentados en clase, adaptando el código al caso.
    - Puede usar métodos auxiliares si lo cree oportuno. Privados, por supuesto.

Razone la complejidad de su código

??? note "Mostrar solución"
    Probablemente, el número de sensores dentro del alcance sea un número pequeño. En ese caso la ordenación se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenación.

    En la solución que sigue se recurre al algoritmo de inserción.

    Usando la biblioteca de Java:

    ```java
    public Map<Sensor, List<Sensor>> cercanos(int f) {
        Map<Sensor, List<Sensor>> resultado = new HashMap<>();

        for (Sensor sensor : diccionario.keySet()) {
            List<Sensor> list1 = getListaOrdenadaSensores(sensor);
            List<Sensor> list2 = new ArrayList<>();

            int m = Math.min(f, list1.size());
            for (int i = 0; i < m; i++)
                list2.add(list1.get(i));

            resultado.put(sensor, list2);
        }
        return resultado;
    }

    private List<Sensor> getListaOrdenadaSensores(Sensor sensor) {
        List<Sensor> list0 = diccionario.get(sensor);
        List<Sensor> list1 = new ArrayList<>(list0);
        sort(list1);
        return list1;
    }

    private void sort(List<Sensor> list) {
        // inserción
        for (int i = 1; i < list.size(); i++)
            inserta(list, i, list.get(i));
    }

    // inserta sensor en datos, entre 0 y z-1
    private void inserta(List<Sensor> datos, int z, Sensor sensor) {
        int j = z;
        while (0 < j && compareTo(sensor, datos.get(j - 1)) < 0)
            j--;

        if (j != z) {
            datos.remove(sensor);
            datos.add(j, sensor);
        }
    }

    private int compareTo(Sensor s1, Sensor s2) {
        int size1 = diccionario.get(s1).size();
        int size2 = diccionario.get(s2).size();
        return size2 - size1;
    }
    ```

    Con respecto a la complejidad, hay que revisar N sensores.
    
    Para cada sensor hay que localizar su lista de sensores en el diccionario: get().
    
    Si el número de ranuras es sensiblemente superior a N, la complejidad es O(1).
    
    De lo contrario, será O(n).
    
    Seguimos en el supuesto de que esta operación es O(1).

    Cada lista, de X elementos, hay que ordenarla. Si usamos un algoritmo de inserción como el de arriba, por término medio será la ordenación de un array de x elementos: O(x2):
        - 1. Podemos pensar que X sea constante, independientemente de N, en cuyo caso la ordenación será de tiempo constante, O(1).
        - 2. Podemos pensar que X sea proporcional a N, en cuyo caso la ordenación será una proporción de N: O(n2)

    Nos quedamos con f elementos: O(1).
    
    Y hacemos una operación put() en el diccionario se salida.
    
    Si el número de ranuras es sensiblemente superior a N, la complejidad es O(1).
    
    De lo contrario, será O(n).
    
    Seguimos en el supuesto de que esta operación es O(1).

    En el caso 1, el total es N × (O(1) + O(1) + O(1) + O(1)) -> N × O(1) -> O(n)
    
    En el caso 2, el total es N × (O(1) + O(n2) + O(1) + O(1)) -> N × O(n2) -> O(n3)

    Resumiendo, si el número de sensores dentro del alcance es independiente de N, la complejidad es O(n). Si el número de sensores dentro del alcance es proporcional a N, la complejidad depende del algoritmo de ordenación.