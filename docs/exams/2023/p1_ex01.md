---
id: ex-2023-01
year: 2023
exam: parcial 1
tags:
 - grafos
 - princeton
---

El siguiente código ofrece una implementación de un algoritmo de potenciación de dos números ($a^b$):

```java
static int potenciaLenta(int a, int b) {
    if(b == 0) {
        return 1;
    }
    return a * potenciaLenta(a, b-1);
}
```

- (a) (0.5 puntos) Exprese, **en función de $a$ y $b$**, la complejidad del algoritmo implementado en `potenciaLenta`. Puede suponer que la multiplicación de dos números es $O(1)$.

??? note "Mostrar solución"
    $T(a, b) = T(a, b-1) + O(1)$ y $T(a, 0) = O(1)$.
    
    Por tanto: $T(b) = O(b)$.
    
    En otras palabras: la complejidad es $O(n)$, siendo $n=b$.


-(b) (0.5 puntos) Reimplemente el algoritmo de `potenciaLenta` usando únicamente código iterativo.
    
??? "Mostrar solución"    
    ```java
    
    	static int potenciaLentaIt(int n, int p) {
    		int res = 1;
    		for(int i=0; i<p; i++) {
    			res = res * n;
    		}
    		return res;
    	}
    ```


- (c) (1.5 puntos) Diseñe e implemente un algoritmo de potenciación con complejidad logarítmica basado en la estrategia de "divide y vencerás".

Su algoritmo debería aprovechar que $a^b = (a^2)^{b/2}$.
Recuerde que tanto la base como el exponente siempre deben ser un número entero.

??? "Mostrar solución"    
    ```java
    	static int potenciaOptimizada(int n, int p) {
    		if(p == 0) {
    			return 1;
    		}
    		if (p % 2 == 0) {
    			return potenciaOptimizada(n*n, p/2);
    		}
    		else {
    			return n * potenciaOptimizada(n*n, (p-1)/2);
    		}
    	}
    ```
