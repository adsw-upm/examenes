---
id: ex-2025-02
year: 2025
exam: parcial 2
tags:
 - grafos
---

En las prácticas de la asignatura se ha trabajado con un grafo creado a partir de un archivo que contiene un histórico de partidas de ajedrez. En el grafo cada nodo representa un estado del tablero de ajedrez. Dos nodos están conectados por una arista dirigida si en el archivo de partidas aparece alguna jugada que lleva del tablero que representa el primer nodo al tablero que representa el segundo nodo. El peso de cada arista representa el número de veces que esa jugada aparece en el archivo de partidas. El modelo de datos utilizado para representar el grafo es el siguiente:

![](img/grafo.png){height=10cm}

Una de las peculiaridades de este grafo es que puede contener ciclos, y esto dificulta la aplicación de algunos algoritmos. El primer objetivo de este ejercicio es diseñar e implementar un algoritmo que borre el mínimo número de aristas necesarias para eliminar todos los ciclos. Para ello, se puede ignorar la direccionalidad de las aristas, es decir, se puede considerar que el grafo es no dirigido. Eliminaremos los ciclos de forma que se sigan manteniendo las jugadas más repetidas, es decir, las de mayor peso.

- (a) (3 puntos) Implementar el método `public void eliminarCiclos()` para la clase `GrafoPartidas` que borra del grafo el mínimo número de aristas para eliminar todos los ciclos. 

Al no tener en cuenta la direccionalidad de las aristas, la solución obtenida puede contener nodos que no son alcanzables desde el tablero inicial del ajedrez. 

??? note "Mostrar solución"
    Una posible solución para el método `eliminarCiclos()` basada en el algoritmo de Prim (o Jarnik) es la siguiente:

    ```{.java .numberLines fontSize=/footnotesize}
    public void eliminarCiclos() {
      Nodo inicio = nodos.get(Tablero.tableroBasico()); 
      Set<Nodo> visitados = new HashSet<>();
      Set<Enlace> nuevosEnlaces = new HashSet<>();
      Set<Enlace> porVisitar = new HashSet<>(inicio.getEnlaces());
      visitados.add(inicio);
      while (!porVisitar.isEmpty()) {
        Enlace mejor = null;
        int maxPeso = Integer.MIN_VALUE;
        for (Enlace enlace : porVisitar) {
          if (enlace.getPeso() > maxPeso) {
            maxPeso = enlace.getPeso();
            mejor = enlace;
          }
        }
        porVisitar.remove(mejor);
        Nodo nodoA = mejor.getOrigen();
        Nodo nodoB = mejor.getDestino();
        if (visitados.contains(nodoA) && visitados.contains(nodoB)) continue;
        nuevosEnlaces.add(mejor);
        Nodo nuevo = visitados.contains(nodoA) ? nodoB : nodoA;
        visitados.add(nuevo);
        for (Enlace e : nuevo.getEnlaces()) {
          Nodo otro = e.getOtro(nuevo);
          if (!visitados.contains(otro)) {
            porVisitar.add(e);
          }
        }
      }
      this.enlaces = nuevosEnlaces;
      for (Nodo nodo : nodos.values()) {
        Set<Enlace> filtrados = new HashSet<>();
        for (Enlace e : nodo.getEnlaces()) {
          if (nuevosEnlaces.contains(e)) {
            filtrados.add(e);
          }
        }
        nodo.getEnlaces().clear();
        nodo.getEnlaces().addAll(filtrados);
      }
    }
    ```

    Si se utilizan estructuras de datos adecuadas, como un `PriorityQueue` para los enlaces, se puede optimizar aún más el proceso de selección del enlace con mayor peso.


- (b) (2 puntos) Implementar el método `public void eliminarNodosInalcanzables()` para la clase `GrafoPartidas` que elimina del grafo todos los nodos que no son alcanzables desde el tablero inicial del ajedrez.

Nota: en ambos apartados se eliminarán elementos del grafo, y cuando esto suceda, se deben eliminar todas las referencias a esos elementos. Por ejemplo, si se elimina un nodo, se deben eliminar todas las aristas que lo referencian. O si se elimina una arista, habrá que eliminarla tanto del conjunto de aristas del grafo como de todos los nodos que la referencian.

??? note "Mostrar solución"
    Una posible solución para el método `eliminarNodosInalcanzables()` es la siguiente (tanto BFS como Dijkstra son adecuados para este propósito):
    
    ```{.java .numberLines fontSize=/footnotesize}
    public void eliminarNodosInalcanzables() {
        Set<Nodo> visitados = new HashSet<>();
        Stack<Nodo> pila = new Stack<>();
        Nodo inicio = nodos.get(Tablero.tableroBasico());
        pila.push(inicio);
        visitados.add(inicio);
    
        while (!pila.isEmpty()) {
            Nodo nodo = pila.pop();
            for (Enlace e : nodo.getEnlacesSalientes()) {
                Nodo otro = e.getDestino();
                if (!visitados.contains(otro)) {
                    visitados.add(otro);
                    pila.push(otro);
                }
            }
        }
    
        Set<Tablero> nodosAEliminar = new HashSet<>();
        for (Map.Entry<Tablero, Nodo> entry : nodos.entrySet()) {
            if (!visitados.contains(entry.getValue())) {
                nodosAEliminar.add(entry.getKey());
            }
        }
    
        for (Tablero t : nodosAEliminar) {
            Nodo nodo = nodos.get(t);
            for (Enlace e : nodo.getEnlaces()) {
                enlaces.remove(e);
                Nodo otro = e.getOtro(nodo);
                otro.getEnlaces().remove(e);
            }
            nodos.remove(t);
        }
    }
    ```
