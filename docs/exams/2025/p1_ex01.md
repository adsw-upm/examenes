---
id: ex-2025-01
year: 2023
exam: parcial 1
tags:
 - ???
---

Una estudiante de Teleco está preparando sus planes para hacer un Erasmus el curso que viene. Analizando la oferta de destinos, ha decidido una serie de preferencias:

- El país al que más le gustaría ir es Polonia, sobre cualquier otra variable.
- Prefiere ir a un destino en el que pueda estar al menos 9 meses de estancia.
- Si hay varias opciones con una duración de al menos 9 meses, priorizará los destinos con más plazas disponibles.
- Está segura de que necesita una beca, así que los destinos que no la ofrezcan irán al final de la lista.
- Si con todos los criterios anteriores no se puede decidir entre dos destinos, se quedará con la universidad cuyo nombre sea mayor lexicográficamente (la mayor por orden alfabético).

Con esos criterios en mente, ha creado una clase en Java con toda la información de los destinos.Ahora necesita implementar un algoritmo que le permita seleccionar el destino que más le conviene. Para empezar, tiene que poder ordenar los destinos según sus preferencias.

![](p1/p1_ex01.png)

- (a) (1,5 puntos) Modifique la clase `DestinoErasmus` de forma que pueda ser ordenada según los criterios de la estudiante. No es necesario escribir los constructores, getters y setters, ni los métodos `toString` y `equals`. 

??? note "Mostrar solución"
    Para hacer que los objetos `DestinoErasmus` sean ordenables, hay que implementar la interfaz `Comparable` y se sobrecargar el método `compareTo`:

    ```java
    public class DestinoErasmus implements Comparable<DestinoErasmus> {

    	@Override
    	public int compareTo(DestinoErasmus otro) {
    		if (this.pais.equals("Polonia") && !otro.pais.equals("Polonia")) return -1;
    		if (!this.pais.equals("Polonia") && otro.pais.equals("Polonia")) return 1;
    		if (this.duracion < 9 && otro.duracion >= 9) return 1;
    		if (this.duracion >= 9 && otro.duracion < 9) return -1;
    		if (this.plazas < otro.plazas) return 1;
    		if (this.plazas > otro.plazas) return -1;
    		if (!this.beca && otro.beca) return 1;
    		if (this.beca && !otro.beca) return -1;
    		return this.universidad.compareTo(otro.universidad);
    	}
    }
    ```


La estudiante está ahora evaluando sus posibilidades y decide que en vez de intentar aplicar al primer destino de su lista, lo hará en uno que esté menos solicitado. Para ello, suponiendo que aún no ha ordenado la lista de destinos, quiere saber cual es el destino que estaría en la posición i-esima después de ordenarlos.

- (b) (2 puntos) Implemente un algoritmo que permita encontrar, en una lista desordenada, el elemento que ocuparía la posición `i` si la lista estuviera ordenada. La nota de este ejercicio dependerá de la eficiencia del algoritmo propuesto. Utilice la siguiente cabecera de método:
```java
public DestinoErasmus destinoEnPosicion(List<DestinoErasmus> destinos, int i)
```

??? note "Mostrar solución"
    Existen varias maneras de resolver el problema. La más sencilla es ordenar la lista y devolver el elemento en la posición `i`. Sin embargo, esto no es eficiente, ya que los algoritmos de ordenación vistos tienen una complejidad de $O(n log n)$ u $O(n^2)$. Para resolver el problema sin tener que ordenar la lista completa, se puede ir ordenando la lista hasta llegar a la posición `i` deseada. Un ejemplo basado en la ordenación por selección sería:

    ```java

    public DestinoErasmus destinoEnPosicion(List<DestinoErasmus> destinos, int i) {
    		if (i < 0 || i >= destinos.size()) return null;
    		List<DestinoErasmus> copia = new ArrayList<>(destinos);
    		for (int j = 0; j <= i; j++) {
    			int minIndex = j;
    			for (int k = j + 1; k < copia.size(); k++) {
    				if (copia.get(k).compareTo(copia.get(minIndex)) < 0) {
    					minIndex = k;
    				}
    			}
    			DestinoErasmus temp = copia.get(j);
    			copia.set(j, copia.get(minIndex));
    			copia.set(minIndex, temp);
    		}
    		return copia.get(i);
    	}
    ```


- (c) (1 punto) Analice la complejidad del algoritmo desarrollado en función de `n`, el número de destinos en la lista, y de `i`, la posición del destino que se quiere encontrar. Nota: La respuesta debe estar justificada y solo se valorará si el algoritmo cumple con el enunciado.

??? note "Mostrar solución"
    Con la solución anterior, el algoritmo tiene una complejidad de $O(i*n)$, ya que se recorre la lista `i` veces, y en cada iteración se recorre el resto de la lista (`n` elementos) para encontrar el mínimo.


- (d) (0,5 puntos) Existe una solución para el algoritmo pedido llamada `QuickSelect`, que se basa en el algoritmo de ordenación `QuickSort`. Sin necesidad de escribir el código, razone qué complejidad tendrá esta solución, en media, en función de `n` e `i`.

??? note "Mostrar solución"
    La solución `QuickSelect` tiene una complejidad media de $O(n)$. El algoritmo se basa en `Quicksort`, que va dividiendo la lista en dos partes según un pivote. Para este problema no sería necesario ordenar toda la lista, sino que se podría parar cuando se encuentra el pivote que acabe en la posición `i` deseada. 
