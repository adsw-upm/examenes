---
id: ex-2025-01
year: 2025
exam: parcial 1
tags:
 - ???
---


# Ejercicio 2: `DiccionarioTrie`

Se requiere implementar `DiccionarioTrie`, un tipo de diccionario que almacena valores de tipo `int` asociados a claves de tipo `String`.
Esta clase será similar a `DiccionarioArbol`, salvo que los nodos estarán representados por la clase `NodoTrie`.
Se proporciona el siguiente código:

```java
class NodoTrie {
    public Map<char, NodoTrie> hijos;
    public int valor;
    public NodoTrie(int valor) {
        this.valor = valor;
        this.hijos = new ArrayMap<char, NodoTrie>();
    }
}
class DiccionarioTrie {
    private NodoTrie raiz;
    public DiccionarioTrie() {
        this.raiz = new NodoTrie(0);
    } ...
}
```

Además, se muestra la estructura de un `DiccionarioTrie` con 3 palabras (`CASA`, `CALLE` y `CERO`):

![](img/ejemplotrie.png){.center width=80%}

El número de cada nodo representa su valor.
Las letrasFuerzaBruta en las relaciones entre nodos corresponden a una clave en el diccionario `hijos` de cada nodo, cuyo valor es el nodo representado a la derecha.
Nótese que, además de los nodos correspondientes a cada palabra, la estructura muestra varios nodos intermedios con valor `0`.
Estos nodos corresponden a prefijos de alguna de las palabras guardadas (p.e., `CAS`, `CAL`, `CE`).

Se pide:

1. **[ 0.5 puntos ]** Dibuje el estado de un `DiccionarioTrie` en que se han añadido las palabras `aprobar`, `adsw` y `nota`, con valores `100`, `200` y `300`, respectivamente.
2. **[ 1.5 puntos ]** Implemente el método `put(String clave, int valor)`. El método debe asignar el valor dado a la clave dada. Si el diccionario ya contenía esa clave, su valor se sobreescribe.
3. **[ 2 puntos ]** Implemente el método `Integer sum(String clave)`. El método devuelve la suma de los valores asociados a **todas las palabras que empiecen por la clave dada** (prefijo). Para el diccionario mostrado en el ejemplo, la operación `sum("ca")` devolvería el valor `2`, y `sum("")` devolvería `4`.
4. **[ 1 punto ]** Razone el orden de complejidad en tiempo de ejecución en el caso peor para los métodos `put` y `sum` en función de: el número de palabras (`n`), la longitud de la palabra más larga (`l`) y la longitud de la clave dada como argumento (`k`). Es decir, calcule `T(n, l, k)`.


??? note "Mostrar solución"
    
    1. 
    
    ![](img/soluciontrie.png){width=80%}
    
    2.
    
    
    ```java
    	public void put(String palabra, int valor) {
    		NodoTrie target = this.raiz;
    		for(int i=0; i<palabra.length(); i++) {
    			char c = palabra.getCharAt(i);
    			if (!target.hijos.contains(c)) {
    				target.hijos.insert(c, new NodoTrie(c, 0));
    			}
    			target = target.hijos.get(c);
    		}
    		target.valor = valor;
    	}
    
    ```
    
    3.
    
    Hay que encontrar el nodo correspondiente al prefijo, y después sumar todos los valores a partir de ese nodo (`sumFrom`).
    
    ```java
    	public int sum(String prefijo) {
    		NodoTrie target = this.raiz;
    		for(int i=0; i<prefijo.length(); i++) {
    			char c = palabra.getCharAt(i);
    			if (!target.hijos.contains(c)) {
    				return 0;
    			}
    			target = target.hijos.get(c);
    		}
    		return this.sumFrom(prefijo, target);
    	}
    
    	public int sumFrom(NodoTrie nodo) {
    		int cuenta = nodo.valor;
    		for(NodoTrie hijo: nodo.hijos.values()) {
    			cuenta += sumFrom(hijo);
    		}
    		return cuenta;
    	}
    ```
    
    
    4.
    
    * `put`: `T(n, l, k) = O(k)` en todos los casos, porque se recorre o añade un nodo por cada letra en la palabra clave.
    * `sum`: El caso peor es aquel en que todas las palabras tienen la longitud máxima (`l`), y coinciden en prefijo con la clave dada (`k`), pero no coinciden en ninguna otra letra. En ese caso, se recorren `k` nodos hasta llegar al prefijo (profundidad `k`), y luego `n` ramas de profundidad `l`, por lo que: `T(n, l, k) = O(k + n * (l-k))`. También se aceptan respuestas del tipo `O(l * n)`.
    