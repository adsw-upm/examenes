---
id: ex-2018-02
year: 2018
exam: parcial 2
tags:
 - monitores
 - hebras
---

Se desea realizar un monitor para gestionar paso de peatones en una carretera con acceso exclusivo por parte de varias hebras (threads). Hay dos tipos de hebras, los coches y los peatones.

Los peatones y los coches irán apareciendo aleatoriamente para cruzar el paso de peatones.

En el paso de peatones no puede haber a la vez coches y peatones. Los coches esperan a que no haya peatones para pasar. Igualmente, los peatones esperan a que no haya coches. En caso de conflicto se da prioridad a los peatones.
```java
public class Coche extends Thread {
    private int idCoche;
    private PasoPeatones monitor;

    public Coche(PasoPeatones monitor, int idCoche) {
        this.idCoche = idCoche;
        this.monitor = monitor;
        this.start();
    }

    public void run() {
        try {
            this.monitor.entrarCoche(idCoche);
            Thread.sleep(…); // tiempo aleatorio para cruzar
            this.monitor.salirCoche(idCoche);
        } catch (InterruptedException e) {}
    }
}

public class Peaton extends Thread {
    private int idPeaton;
    private PasoPeatones monitor;

    public Peaton(PasoPeatones monitor, int idPeaton) {
        this.idPeaton = idPeaton;
        this.monitor = monitor;
        this.start();
    }

    public void run() {
        try {
            this.monitor.entrarPeaton(idPeaton);
            Thread.sleep(...); // tiempo aleatorio para cruzar
            this.monitor.salirPeaton(idPeaton);
        } catch (InterruptedException e) {}
    }
}
```

- (a) (5 puntos) Crear un monitor PasoPeatones que gestione el acceso al paso de peatones según las condiciones expuestas en el enunciado.
```java
public class PasoPeatones {
...
}
```

??? note "Mostrar solución"
    ```java
    /**
     * Monitor paso de peatones.
     */
    public class PasoPeatones {
    
        private int nPeatonesIn = 0; //Número de peatones en el paso de peatones
    
        public class Coche extends Thread {
            private int idCoche;
            private PasoPeatones monitor;
    
            public Coche(PasoPeatones monitor, int idCoche) {
                this.idCoche = idCoche;
                this.monitor = monitor;
                this.start();
            }
    
            public void run() {
                try {
                    this.monitor.entrarCoche(idCoche);
                    Thread.sleep(…); // tiempo aleatorio para cruzar
                    this.monitor.salirCoche(idCoche);
                } catch (InterruptedException e) {}
            }
        }
    
        public class Peaton extends Thread {
            private int idPeaton;
            private PasoPeatones monitor;
    
            public Peaton(PasoPeatones monitor, int idPeaton) {
                this.idPeaton = idPeaton;
                this.monitor = monitor;
                this.start();
            }
    
            public void run() {
                try {
                    this.monitor.entrarPeaton(idPeaton);
                    Thread.sleep(...); //tiempo aleatorio para cruzar
                    this.monitor.salirPeaton(idPeaton);
                } catch (InterruptedException e) {}
            }
        }
    
        private int nCochesIn = 0; //Número de coches en el paso de peatones
        private int nPeatonesWaiting = 0; //Número de peatones esperando para entrar en el paso de peatones
    
        /**
         * Getter.
         *
         * @return número de peatones autorizados a pasar por el paso de peatones en este momento.
         */
        public synchronized int getNPeatonesIn() {
            return nPeatonesIn;
        }
    
        /**
         * Getter.
         *
         * @return número de coches autorizados a pasar por el paso de peatones en este momento.
         */
        public synchronized int getNCochesIn() {
            return nCochesIn;
        }
    
        /**
         * Solicitud de permiso para entrar un peatón al paso de peatones.
         * El thread peaton que llama se queda esperando hasta que pueda entrar.
         */
        public synchronized void entraPeaton() {
            nPeatonesWaiting++;
            while (nCochesIn > 0)
                waiting();
            nPeatonesWaiting--;
            nPeatonesIn++;
        }
    
        /**
         * Devolución del permiso de acceso al paso de peatones de un peatón.
         *
         * @throws IllegalMonitorStateException si no hay peatón que pueda salir del paso de peatones.
         */
        public synchronized void salePeaton()
                throws IllegalMonitorStateException {
            try {
                if (nPeatonesIn <= 0)
                    throw new IllegalMonitorStateException();
                nPeatonesIn--;
            } finally {
                if (nPeatonesIn == 0) notifyAll();
            }
        }
    
        /**
         * Devolución del permiso de acceso al paso de peatones de un coche.
         * El thread coche que llama se queda esperando hasta que pueda entrar.
         */
        public synchronized void entraCoches() {
            while (nPeatonesIn > 0 || nPeatonesWaiting > 0)
                waiting();
            nCochesIn++;
        }
    
        /**
         * Devolución del permiso de acceso al paso de peatones de un coche.
         *
         * @throws IllegalMonitorStateException si no hay coche que pueda salir del paso de peatones.
         */
        public synchronized void saleCoche()
                throws IllegalMonitorStateException {
            try {
                if (nCochesIn < 1)
                    throw new IllegalMonitorStateException();
                nCochesIn--;
            } finally {
                if (nCochesIn == 0) notifyAll();
            }
        }
    
        private void waiting() {
            try {
                wait();
            } catch (InterruptedException ignored) {
            }
        }
    }
    ```