---

id: ex-2012-02
year: 2012
exam: parcial 1
tags:
 - complejidad

---

# Problema 2 (5 puntos)

Dado el siguiente algoritmo de ordenación:

```java
public void sort(long[] datos) {
    for (int i = 1; i < datos.length; i++) {
        long x = datos[i];
        int j = i;
        while (j > 0 && x < datos[j - 1]) {
            datos[j] = datos[j - 1];
            j--;
        }
        datos[j] = x;
    }
}
```

---

## (0.5 puntos) Indique el nombre del algoritmo

??? note "Mostrar solución"
    Se trata del algoritmo de ordenación por inserción.

---

## (3 puntos) Indique qué cambios haría en el código, indicando el número de línea, para conseguir que el método devolviera el número de veces que compara dos elementos del array.

??? note "Mostrar solución"
    La comparación se efectúa al comprobar la condición del bucle en la línea `5`.
    El cuerpo del bucle se ejecuta si `j > 0` **y además** `x < datos[j - 1]`.
    Por tanto, en ese caso se ha efectuado una comparación entre `x` y un elemento del array.

    Sin embargo, si el bucle no se ejecuta puede ser por dos causas:

    1. `j == 0`, en cuyo caso **no** se llega a efectuar la comparación, ya que el operador `&&` no evalúa el segundo término.  
    2. `j > 0` y `x >= datos[j - 1]`, en cuyo caso **sí** se efectúa la comparación.

    Para contar correctamente las comparaciones, hay que desdoblar la condición del bucle.  
    Una forma de hacerlo es:

    ```java
    public int sort(long[] datos) {
        int numeroComparaciones = 0;
        for (int i = 1; i < datos.length; i++) {
            long x = datos[i];
            int j = i;
            while (j > 0) {
                ++numeroComparaciones;
                if (x < datos[j - 1]) {
                    datos[j] = datos[j - 1];
                    j--;
                } else {
                    break;
                }
            }
            datos[j] = x;
        }
        return numeroComparaciones;
    }
    ```

    Líneas modificadas:

    - **Línea 1** sustituida por:

    ```java
    public int sort(long[] datos) {
        int numeroComparaciones = 0;
    ```

    - **Líneas 5–8** sustituidas por:

    ```java
    while (j > 0) {
        ++numeroComparaciones;
        if (x < datos[j - 1]) {
            datos[j] = datos[j - 1];
            j--;
        } else {
            break;
        }
    }
    ```

    - Después de la línea 10 se añade:

    ```java
    return numeroComparaciones;
    ```

    Otra solución alternativa con una variable auxiliar:

    ```java
    public int sort2(long[] datos) {
        int numeroComparaciones = 0;
        for (int i = 1; i < datos.length; i++) {
            long x = datos[i];
            int j = i;
            boolean menor = true;
            while (j > 0 && menor) {
                ++numeroComparaciones;
                if (x < datos[j - 1]) {
                    datos[j] = datos[j - 1];
                    j--;
                } else {
                    menor = false;
                }
            }
            datos[j] = x;
        }
        return numeroComparaciones;
    }
    ```

---

## (1.5 puntos) Programe una prueba en JUnit3 de la modificación realizada en el apartado b), para el caso `{3, 1, 2}`.

??? note "Mostrar solución"
    En este caso se efectúan **3 comparaciones**. La prueba es:

    ```java
    public void test() {
        long[] datos = {3, 1, 2};
        P2 algoritmo = new P2();
        assertEquals(3, algoritmo.sort(datos));
    }
    ```
