---
id: ex-2012-02
year: 2012
exam: parcial 1
tags:
  - complejidad
---


Problema 2 (5 puntos)
Dado el siguiente algoritmo de ordenacián:

```java
public void sort(long[] datos) {
	for (int i = 1; i < datos.length; i++) {
		long x = datos[i];
		int j = i;
		while (j > 0 && x < datos[j - 1]) {
			datos[j] = datos[j-1];
			j--;
		}
		datos[j] = x;
	}
}
```

- (0.5 puntos) Indique el nombre del algoritmo 
??? note "Mostrar solución"
    Se trata del algoritmo de ordenacián por inserción.
- (3 puntos) Indique qué cambios harña en el cádigo, indicando el número de lñnea, para conseguir que el método   devolviera el número de veces que compara dos elementos del array.

??? note "Mostrar solución"
    La comparacián se efectúa al comprobar la condicián del bucle en la lñnea 5. El cuerpo del bucle se   ejecuta si j > y además x < datos[j-1]. Por tanto, en este caso se ha efectuado una comparacián entre   x y un elemento del array.
    Sin embargo, si el bucle no se ejecuta puede ser por dos causas: 

    1) Que j == 0, en cuyo caso no se   llega a efectuar la comparacián, ya que el operador && no evalúa el segundo término si el primero es   falso. 

    2) Que j >0 y x >= datos[j-1]. En este caso s  se efectúa la comparacián.

    Por tanto, para contar adecuadamente el número de comparaciones hay que desdoblar la condicián   del bucle, separando las dos condiciones. Una forma de hacerlo es la siguiente:

    ```java
    public int sort(long[] datos) {
    int numeroComparaciones = 0;
    for (int i = 1; i < datos.length; i++) {
    long x = datos[i];
    int j = i;
    while (j > 0) {
    ++numeroComparaciones;
    if(x < datos[j - 1]) {
    datos[j] = datos[j-1];
    j--;
    } else {
    break;
    }
    }
    datos[j] = x;
    }
    return numeroComparaciones;
    }
    ```
    Se han marcado de distinto color las lñneas modificadas:
    Lñnea 1 sustituida por
    ```java
    public int sort(long[] datos) {
    int numeroComparaciones = 0;
    ```
    Lineas 5-8 sustituidas por:
    ```java
    while (j > 0) {
    ++ numeroComparaciones;
    if(x < datos[j - 1]) {
    datos[j] = datos[j-1];
    j--;
    } else {
    break;
    }
    }
    ```

    Después de la lñnea 10 se ha añadido:

    ```java
    return numeroComparaciones;
    ```

    Otra solucián alternativa con una variable auxiliar puede ser:

    ```java
    public int sort2(long[] datos) {
    int numeroComparaciones = 0;
    for (int i = 1; i < datos.length; i++) {
    long x = datos[i];
    int j = i;
    boolean menor = true;
    while (j > 0 && menor) {
    ++numeroComparaciones;
    if(x < datos[j - 1]) {
    datos[j] = datos[j-1];
    j--;
    } else {
    menor = false;
    }
    }
    datos[j] = x;
    }
    return numeroComparaciones;
    }
    ```
- (1.5 puntos) Programe una prueba en JUnit3 de la modificacián realizada en el apartado b), para el caso {3, 1, 2}.
??? note "Mostrar solución"
    En este caso se efectúan 3 comparaciones. La prueba es:
    ```java
    public void test() {
    long[] datos = {3, 1, 2};
    P2 algoritmo = new P2();
    assertEquals(3, algoritmo.sort(datos));
    }
    ```