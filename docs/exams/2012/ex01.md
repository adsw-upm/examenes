---
id: ex-2012-01
year: 2012
exam: final
tags:
  - ordenación
  - complejidad
hide:
  - tags
---

## A. (1.5 puntos) 
Se pide escribir un algoritmo de ordenación con la siguiente interfaz

```java
int[] ordena(long[] datos)
```
de tal forma que los datos de entrada no se modifican y el método devuelve un array que contiene en qué posición debería ir del dato correspondiente para estar en orden ascendente. Por ejemplo:
```
datos:   [8, 42, 46, 24, 29, 7]
indices: [1,  4,  5,  2,  3, 0]
```
que se lee como que

 - datos[0] se ordenaría en la posición 1
 - datos[1] se ordenaría en la posición 4
 - datos[2] se ordenaría en la posición 5
 - etc.

NOTA: Si hubiera 2 datos de igual valor, da igual cual de ellos va antes o después. Elija lo que le sea más cómodo.


??? note "Mostrar solución"
    Una posible solución es:
    ```java
    public int[] sort(long[] datos) {
        int[] indices = new int[datos.length];
        Arrays.fill(indices, -1);
        for (int i = 0; i < indices.length; i++) {
            int iMenor = -1;
            long menor = Long.MAX_VALUE;
            for (int j = 0; j < datos.length; j++) {
                if (indices[j] < 0 && datos[j] < menor) {
                    iMenor = j;
                    menor = datos[j];
                }
            }
            indices[iMenor] = i;
        }
        return indices;
    }
    ```

## B. (1.5 puntos) 
Estime la complejidad del  algoritmo  del  punto anterior,  contando  el  número  de  comparaciones entre datos (enteros `long`) que hay que hacer en el caso peor.

??? note "Mostrar solución"
    Hay 2 bucles, uno dentro del otro.
    El bucle exterior se hace $N$ veces.
    En el bucle interior, la primera vez se hacen $N-1$ comparaciones; la segunda vez, $N-2$; la tercera $N-3$, etc. 
    En total $(N-1) + (N-2) + ... + 1 \leftarrow \mathcal{O}(N^2)$
