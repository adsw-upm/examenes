---
id: ex-2019-01
year: 2019
exam: parcial 2
tags:
 - monitores
---

Se quiere desarrollar un sistema de gestión de eventos. Este sistema está compuesto por un conjunto de productores y consumidores. Los productores ponen eventos con una prioridad asociada en el sistema. Los consumidores recogen eventos del sistema para procesarlos.

Los eventos se representan con la clase `Event` definida como sigue (no hay que desarrollarla):
```java
public class Event {
    private EventInformation info;
    private EventPriority priority;
    // getters & setters
}
```

`EventInformation` indica la información asociada al evento. No es necesario conocer los detalles de esta clase, ni desarrollarla. 

`EventPriority` indica la prioridad del evento, definida como sigue:
```java
public enum EventPriority {High, Low}
```

Dado el siguiente esquema:
```java
public class EventManager {
    // Número máximo de eventos de cada nivel de prioridad que se pueden almacenar
    public final int MAX_PENDING_EVENTS = ...;
    ...
    /** Añadir un evento para procesar. Si el número de eventos pendientes
    * con la prioridad correspondiente es igual al máximo, la hebra que
    * llama se bloquea hasta que haya hueco
    */
    ... void putEvent (Event anEvent) {...}
    /** Recuperar un evento para su procesamiento. Devuelve un evento de prioridad High
    * si lo hay, si no un evento de prioridad Low, y si tampoco hay ninguno se bloquea
    * la hebra que llama hasta que haya alguno.
    */
    ... Event getEvent() {...}
    /** Número total de eventos pendientes de procesamiento. */
    ... int getPendingEvents() {...}
}
```

- (a) (4,5 puntos) Desarrolle el monitor `EventManager`. Se puede utilizar el siguiente esquema:
```java
public class Buffer {

    private Event[] b;
    private int in, out, count;

    public Buffer (int size) {
        b = new Event[size]; I
        in = 0; out = 0; count = 0;
    }

    public void put (Event e) {
        b[in] = e;
        in = (in + 1) % b.length; ++count;
    }

    public Event get() {
        Event e = boOut];
        out = (out + 1) % b.length; --count;
        return e;
    }

    public int getCount() { return count;}
}
```

??? note "Mostrar solución"
    ```java
    public class GestorEventos {

        private int MaxPendingEvents;
        private Buffer highPriority;
        private Buffer lowPriority;

        public GestorEventos(int MaxPendingEvents) {
            this.MaxPendingEvents = MaxPendingEvents;
            highPriority = new Buffer(MaxPendingEvents);
            lowPriority = new Buffer(MaxPendingEvents);
        }

        public synchronized void PutEvent(Event anEvent) 
                throws InterruptedException {

            if (anEvent.getPriority() == EventPriority.High) {

                while (highPriority.GetCount() == MaxPendingEvents) {
                    wait();
                }
                highPriority.Put(anEvent);

            } else {

                while (lowPriority.GetCount() == MaxPendingEvents) {
                    wait();
                }
                lowPriority.Put(anEvent);
            }

            notifyAll();
        }

        public synchronized Event GetEvent() 
                throws InterruptedException {

            while (highPriority.GetCount() == 0 &&
                   lowPriority.GetCount() == 0) {
                wait();
            }

            if (highPriority.GetCount() > 0) {
                notifyAll();
                return highPriority.Get();
            }

            notifyAll();
            return lowPriority.Get();
        }

        public synchronized int GetPendingEvents() {
            return lowPriority.GetCount() + highPriority.GetCount();
        }
    }
    ```

Suponiendo que el tiempo de proceso de los consumidores es mayor que el de los productores, puede ocurrir que las colas de eventos pendientes se mantengan llenas durante un tiempo prolongado y, por tanto, se bloqueen los productores.

- (b) (2,5 puntos) Para corregir este problema, se pide desarrollar una clase `ThreadManager` que cree hebras consumidoras cuando el número de eventos pendientes sea mayor al 90% del número máximo de eventos. Esta clase responde al
siguiente esquema:
```java
public class ThreadManager {
    private final int DELAY = ...; //intervalo de comprobación (ms)
    ...
    public void main(...) {
        while(true) {
            Thread.sleep(DELAY);
            // comprobar si el número de eventos pendientes es mayor que el 90% del máximo
            // en ese caso, crear una nueva hebra de clase Consumer
        }
    }
}
```

La clase `Consumer` responde al esquema siguiente y no es necesario desarrollarla:
```java
public class Consumer
    extends Thread {
        public Consumer(...) {...}
        public void run() {...}
}
```

??? note "Mostrar solución"
    ```java
    public class ThreadManager {

        public static void main(String[] args) throws InterruptedException {

            int DELAY = 10000; // intervalo de comprobación (ms)
            Consumer c;

            // Obtener un gestor. No se había que hacer
            GestorEventos gestor = ...;

            while (true) {

                Thread.sleep(DELAY);

                if (gestor.GetPendingEvents() > gestor.MAX_PENDING_EVENTS * 0.9) {
                    Consumer consumer = new Consumer(gestor);
                    consumer.start();
                }
            }
        }
    }
    ```
