---
id: ex-2019-02
year: 2019
exam: parcial 1
tags:
 - complejidad
---

Se desea realizar una herramienta de análisis de textos literarios. Una de sus funciones consiste en recorrer el texto extrayendo cada palabra y añadiéndola a un diccionario. El diccionario tiene como claves las palabras que aparecen en el texto, y como valor el número de veces que aparece cada una de ellas, que se actualiza cada vez que se lee una palabra. Al final del proceso se debe ordenar el diccionario, de forma que aparezcan en primer lugar las palabras más utilizadas:
```Java
while (queda texto sin analizar) {
    String palabra = siguientePalabra();
    Diccionario.actualizar(palabra); //añadir si no estaba e incrementar no. de apariciones
}
Diccionario.ordenar(); // ordenar palabras de mayor a menor número de apariciones
```

Se consideran varias opciones para la implementación del diccionario:
    - (1) Un array ordenado de elementos (palabra, número)
    - (2) Una tabla hash con direccionamiento abierto
    - (3) Una tabla hash con listas de desbordamiento
    - (4) Un árbol binario de búsqueda (BST)

Suponiendo que los textos analizados contienen como máximo 100.000 palabras:

- (a) (3 puntos) Indique las ventajas e inconvenientes de cada opción e indique razonadamente cuál sería preferible para esta aplicación, argumentando en términos de tiempo de ejecución y ocupación de memoria.

??? note "Mostrar solución"
    (1) + ocupa la memoria imprescindible; - tiempo de inserción O(n) (hay que insertar la palabra en su sitio).
    (2) + ocupa la memoria imprescindible; - tiempo de inserción O(1) si la tabla tiene un tamaño suficiente, pero se dispara si el grado de ocupación es alto.
    (3) + tiempo de inserción O(1) si las claves se distribuyen uniformemente; - ocupa memoria adicional para las listas de acceso.
    (4) - ocupa memoria adicional para los enlaces de los nodos; - tiempo de inserción O(log n).

    Basándonos en estas consideraciones, para la primera fase de la aplicación, en la que sólo se hacen inserciones en la tabla, sería preferible la opción (3) desde el punto de vista del tiempo de ejecución, y la opción (1) desde el punto de vista de la ocupación de memoria.

- (b) (2 puntos) Para la opción recomendada, indique razonadamente cuál sería la mejor forma de implementar la ordenación final. (2 puntos)

??? note "Mostrar solución"
    Para un hash con listas habría que extraer un array con todos los pares <clave, valor> (complejidad O(n) ) y ordenarlo por valores. Se puede usar MergeSort (complejidad O(n log n) ), con lo que la complejidad total sería O(n) + O (n log n) = O (n log n).
    
    Si el uso de memoria es importante, MergeSort tiene el inconveniente de necesitar memoria adicional O(n). Este caso sería preferible usar QuickSort para ordenar el array.
