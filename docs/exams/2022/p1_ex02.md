---
id: ex-2022-02
year: 2022
exam: parcial 1
tags:
 - complejidad
---

Dado un conjunto de números, la distancia entre un elemento del conjunto y el resto del conjunto es la mínima diferencia entre ese número y otro cualquiera del conjunto. Por ejemplo, la distancia de 10 en el conjunto {3,6,10,16,17} es 4, y la de 16 es 1. El elemento más aislado del conjunto es el elemento que tenga la distancia mayor. Si varios números tienen esa misma distancia mayor, el más aislado es uno cualquiera de ellos. En el conjunto anterior, el elemento más aislado es el 10. Podemos suponer que el conjunto tiene al menos un número. Si solo hay uno, seria el más aislado y su distancia es infinito.

```java
public class BSTAislados {

    private Nodo raíz = null;

    public int distancia(Nodo nodo) {
        // SOLUCION Pregunta 2.c
    }
}
```

```java
public class Nodo {
    public int numero;
    public Nodo iz, der;
    // Disponibles los getters y setters
}
```


- (a) (1,5 puntos) Se dispone un conjunto de números ordenado por el valor de los números con un array. No hay ninguna estructura de datos adicional, en relación con el conjunto de números. ¿Qué complejidad tendrá el algoritmo más eficiente que calcule el número más aislado del conjunto? Justifique la respuesta. No se está pidiendo una implementación.

??? note "Mostrar solución"
    Si los números están ordenados por valor, los números más próximos a uno dado son el anterior y el siguiente. La distancia de un número es la menor de las diferencias con el anterior y el siguiente. Este es un cálculo de complejidad constante y no depende del tamaño del conjunto. Pero el más aislado puede ser cualquiera de los números, porque, aunque estén ordenados, la deferencia entre un número y el siguiente puede ser cualquiera. Para calcular el más aislado hay que recorrer todo el array y calcular la distancia para cada posición, y el más aislado será el que tenga distancia mayor. 

    Complejidad $O(n)$ donde $n$ es el tamaño del conjunto.


- (b) (1,5 puntos) Se dispone un conjunto de números ordenado por el valor de los números con un árbol binario. No hay ninguna estructura de datos adicional, en relación con el conjunto de números. Se supone que los números que incluye el árbol se han insertado de forma aleatoria y son valores aleatorios. ¿Qué complejidad tendrá el algoritmo más eficiente que calcule el número más aislado del conjunto? Justifique la respuesta. No se está pidiendo una implementación.

??? note "Mostrar solución"
    En el caso de que representemos el conjunto mediante un árbol binario seguimos necesitando recorrer todo el árbol para encontrar el más aislado. La diferencia entre el valor de un nodo y cualquiera de sus descendientes directos o indirectos puede ser cualquiera. Podemos utilizar como algoritmos un algoritmo de recorrido del árbol en orden. Recorreremos empezando por los números más pequeños y terminaremos con los grandes. En el recorrido del árbol, actualizamos los tres últimos nodos visitados (por ejemplo, un array de tres elementos que incluye el nodo que visitamos y los dos anteriores, ese array puede ser un parámetro del método que recorre los nodos o un atributo auxiliar). La distancia del nodo anterior al nodo que visitamos es la menor de las diferencias entre el penúltimo nodo, el ante-penúltimo y el que visitamos. La diferencia del primer nodo la calculamos en la segunda visita, y la última visita calculamos la del último con el penúltimo. En total visitamos todos los nodos y el calculo de las distancias es constante.

    Complejidad de orden $O(n)$ donde $n$ es el tamaño del conjunto y del árbol.


- (c) (2 puntos) Se dispone de un árbol binario que incluye el conjunto de números ordenado por el valor de cada número que representan los nodos. Implemente el método que devuelve la distancia del número para el nodo en el parámetro. La respuesta debe incluir: 
    
    1. La implementación del algoritmo. La puntuación de la pregunta será mayor para soluciones más eficientes, y menor para las soluciones más ineficientes. En las clases `Nodo` y `BSTAislados` se puede incluir cualquier atributo o método auxiliar.
    2. La complejidad del algoritmo implementado.

??? note "Mostrar solución"
    ```java
    public class BSTAislados {
        private Nodo raiz = null;
    
        public int distancia(Nodo nodo) {
            if (nodo.iz != null && nodo.der != null) {
                Nodo i = maxMenor(nodo.iz);
                Nodo d = minMayor(nodo.der);
                int dist = (Math.abs(nodo.numero - i.numero) < Math.abs(nodo.numero - d.numero)) ?
                            Math.abs(nodo.numero - i.numero) :
                            Math.abs(nodo.numero - d.numero);
                return dist;
            }
    
            Nodo otro = raiz;
            int minDist = Integer.MAX_VALUE;
    
            if (nodo.iz != null) {
                Nodo i = maxMenor(nodo.iz);
                minDist = Math.abs(nodo.numero - i.numero);
            }
    
            if (nodo.der != null) {
                Nodo i = minMayor(nodo.der);
                minDist = Math.abs(nodo.numero - i.numero);
            }
    
            while (otro != null) {
                if (Math.abs(nodo.numero - otro.numero) < minDist)
                    minDist = Math.abs(nodo.numero - otro.numero);
    
                if (nodo.numero < otro.numero)
                    otro = otro.iz;
                else
                    otro = otro.der;
            }
    
            return minDist;
        }
    
        private Nodo maxMenor(Nodo n) {
            if (n.der == null)
                return n;
            Nodo d = n.der;
            while (d.der != null)
                d = d.der;
            return d;
        }
    
        private Nodo minMayor(Nodo n) {
            if (n.iz == null)
                return n;
            Nodo i = n.iz;
            while (i.iz != null)
                i = i.iz;
            return i;
        }
    }
    ```

    Si un nodo tiene descendientes izquierdo y derecho, el número menor más próximo es el mayor del sub-árbol izquierdo, el nodo más abajo por las ramas derechas del subárbol izquierdo. Y el mayor más próximo es el menor del sub-árbol derecho, que es el que se encuentra más abajo por las ramas izquierdas del sub-árbol derecho. Si el nodo no tiene descendientes, el nodo más próximo es uno de sus antecesores hasta llegar a la raíz y si tiene un solo descendiente puede ser el más próximo de su rama descendiente, o uno de sus antecesores hasta la raíz. Si es un antecesor, tiene que ser un nodo en el camino que va desde la raíz hasta el nodo. Si la profundidad del árbol es $log n$, y buscamos el mayor menor o el menor mayor, como mucho recorremos $log n$ nodos. Si recorremos desde la raíz hasta el nodo, como mucho recorremos $log n$ nodos (cuando el nodo no tiene descendientes). Si recorremos desde la raíz al nodo y desde el nodo por su descendiente, en total el recorrido como mucho es $log n$.

    Complejidad $O(log n)$.
