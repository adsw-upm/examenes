---
id: ex-2022-01
year: 2022
exam: parcial 1
tags:
 - grafos
 - princeton
---

Un grafo multigrafo permite que haya varios arcos entre dos nodos. En una entidad bancaria se quiere modelar las transferencias ejecutadas entre los bancos durante un día en una clase (`Banco`). En esta clase, se dispone de un atributo (`transferGrafo`) que es un multigrafo que modela estas transferencias:
    
- Un nodo modela un banco.   
- Un arco modela una transacción. Su peso representa la cantidad transferida.

Una transferencia (la clase `Transfer`) se modela mediante los identificadores del banco origen y del banco destino, la cantidad, el nombre del ordenante y el nombre del beneficiario. Además, se quiere relacionar cada arco del grafo con la información de su transferencia asociada. 

menorCamino

| `public java.util.List<Edge> menorCamino(java.util.List<java.util.List<Edge>> listaCaminos)` | Seleccionar el camino con el menor coste total. |
|---|---|
| Parameters | `listaCaminos` - una lista de caminos del grafo del sistema entre dos vértices. |
| Returns | La respuesta es un camino que sea el mínimo de la lista recibida. Si hubieran varios caminos mínimos con el mismo coste, se puede retornar cualquiera de ellos. |



numeroVecesUsadoArco

|`public java.util.Map<Edge, java.lang.Integer> numeroVecesUsadoArco(java.util.List<java.util.List<Edge>> listaCaminos)` | Determina cuántas veces aparece cada arco en una lista de caminos |
|---|---|
|Parameters | `listaCaminos` - una lista de caminos del grafo del sistema entre dos vértices.
| Returns | devuelve un diccionario, en el que la clave es un arco y el valor un entero que representa el número de veces que el arco aparece en el parámetro de entrada.|


Edge

| Tipo | Método | Descripción |
| :--- | :--- | :--- |
| int | *compareTo(Edge that)* | Compares two edges by weight. |
| int | *either()* | Returns either endpoint of this edge. |
| int | *other(int vertex)* | Returns the endpoint of this edge that is different from the given vertex. |
| Double | *weight()* | Returns the weight of this edge. |

List

| Tipo | Método | Descripción |
| :--- | :--- | :--- |
| boolean | *add(E e)* | Appends the specified element to the end of this list (optional operation). |
| boolean | *contains(Object o)* | Returns true if this list contains the specified element. |
| E | *get(int index)* | Returns the element at the specified position in this list. |
| boolean | *isEmpty()* | Returns true if this list contains no elements. |
| E | *remove(int index)* | Removes the element at the specified position in this list (optional operation). |
| int | *size()* | Returns the number of elements in this list. |

Map

| Tipo | Método | Descripción |
| :--- | :--- | :--- |
| boolean | *containsKey(Object key)* | Returns true if this map contains a mapping for the specified key. |
| V | *get(Object key)* | Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. |
| boolean | *isEmpty()* | Returns true if this map contains no key-value mappings. |
| V | *put(K key, V value)* | Associates the specified value with the specified key in this map. |
| V | *remove(Object key)* | Removes the mapping for the specified key from this map if present. |
| int | *size()* | Returns the number of key-value mappings in this map. |

Se pide:

- (a) (1,5 puntos) Proponga un atributo de una clase adecuada para relacionar un arco con su transferencia asociada y desarrolle el método `ponerTransfer` para mantener esta relación e integrar la transferencia en el grafo. 

??? note "Mostrar solución"
    ```java
    import edu.princeton.cs.algs4.*;
    import java.util.Map;
    import java.util.HashMap;
    import java.util.List;
    import java.util.ArrayList;

    public class Banco {

        private int nBancos;
        private Map<DirectedEdge, Transfer> arcosTransfer;
        private EdgeWeightedDigraph transferGrafo;

        public Banco() {
            this.arcosTransfer = new HashMap<DirectedEdge, Transfer>();
            this.transferGrafo = new EdgeWeightedDigraph(nBancos);
        }

        /**
         * Añadir una transferencia en el grafo y en la estructura que relacione
         * una arista y su transferencia asociada
         * @param transfer Transferencia a incluir
         */
        public void ponerTransfer(Transfer transfer) {
            DirectedEdge arco = new DirectedEdge(
                transfer.getBancoOrigen(),
                transfer.getBancoDestino(),
                transfer.getCantidad()
            );
            arcosTransfer.put(arco, transfer);
            transferGrafo.addEdge(arco);
        }

        /**
         * Calcular la cantidad neta de las transferencias ejecutadas
         * durante un día entre bank1 y bank2
         * @param banco1 Identificador de un banco
         * @param banco2 Identificador de otro banco
         * @return cantidad neta durante un día entre bank1 y bank2
         */
        public Double netoTransfer(int banco1, int banco2) {
            double nBanco1 = 0;
            double nBanco2 = 0;

            if (banco1 < 0 || banco1 >= transferGrafo.V()) return null;
            if (banco2 < 0 || banco2 >= transferGrafo.V()) return null;

            // Calcular el total de dinero banco1 -> banco2
            for (DirectedEdge arco : transferGrafo.adj(banco1)) {
                if (arco.to() == banco2) {
                    nBanco1 += arco.weight();
                }
            }

            // Calcular el total de dinero banco2 -> banco1
            for (DirectedEdge arco : transferGrafo.adj(banco2)) {
                if (arco.to() == banco1) {
                    nBanco2 += arco.weight();
                }
            }

            return nBanco1 - nBanco2;
        }

        /**
         * Generar la lista de las transferencias que ha generado
         * el ordenante durante un día
         * @param ordenante Usuario que ordena la transferencia
         * @return Lista de las transferencias de un ordenante
         */
        public List<Transfer> clienteTransfer(String ordenante) {
            List<Transfer> lista = new ArrayList<Transfer>();

            for (DirectedEdge arco : transferGrafo.edges()) {
                Transfer transfer = arcosTransfer.get(arco);
                if (transfer.getOrdenante().equals(ordenante)) {
                    lista.add(transfer);
                }
            }

            return lista;
        }
    }
    ```

- (b) (2 puntos) Desarrolle el método `netoTransfer` que retorne la cantidad de dinero neto transferido entre dos bancos en un día. Habrá que restar la cantidad de las transferencias entre los dos bancos.

??? note "Mostrar solución"
    Vacío

- (c) (1,5 puntos) Desarrolle el método `clienteTransfer` que retorne la lista no ordenada de las transferencias que ha ejecutado una persona (ordenante) durante un día.

??? note "Mostrar solución"
    Vacío


NOTA: los grafos de U. Princeton usado en esta asignatura permiten crear multigrafos.