---
id: ex-2022-02
year: 2022
exam: parcial 2
tags:
 - hebras
---

El problema de los lectores/escritores est" compuesto de un conjunto de hebras que comparten datos. Las hebras lectoras (Lectora) s!lo leen los datos, mientras que las hebras escritoras (Escritora) leen y escriben los datos. Varios lectoras pueden acceder simult"neamente a los datos compartidos, mientras que una escritora tiene que acceder con exclusi!n mutua con otros lectores o escritores. A continuaci!n, se muestra una implementaci!n muy sencilla de un monitor que gestione a las hebras lectoras y escritoras para acceder a los datos compartidos:

```java
public class GestorLE implements Gestor {
    private boolean bloqueoEscritor = false;
    private boolean bloqueoLector = false;
    private int nLectores = 0;
    private int nEscritores = 0;

    public synchronized void empiezaLeer(int idLector) throws InterruptedException {
        while (bloqueoEscritor)
            wait();
        bloqueoLector = true;
        nLectores++;
    }

    public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {
        while (bloqueoEscritor || bloqueoLector)
            wait();
        nEscritores++;
        bloqueoEscritor = true;
    }

    public synchronized void terminaLeer(int idLector) {
        nLectores--;
        if (nLectores == 0) {
            bloqueoLector = false;
            notifyAll();
        }
    }

    public synchronized void terminaEscribir(int idEscritor) {
        nEscritores--;
        bloqueoEscritor = false;
        notifyAll();
    }
}
```

El c!digo de las hebras lectoras y escritoras est" implementado como un bucle acotado que solicitan el acceso a los datos (empiezaLeer / empiezaEscribir), usan los datos durante un tiempo aleatorio, terminan el acceso a los datos (terminLeer / terminaEscribir) y est"n ociosos durante un tiempo aleatorio. Las clases Lectora y Escritora extienden Thread y que su constructor recibe como par"metro una instancia de GestorLE y su identificador.

- (a) (0,5 puntos) Analice y justifique si el monitor en este enunciado puede producir inanici!n o hambruna.

??? note "Mostrar solución"
    Esa solución puede tener inanición. Por ejemplo, 2 lectores y un escritor. El primer lector pide acceso y se lo da el gestor. El escritor intenta entrar y queda bloqueado. Antes de que termine de leer el primer lector, el segundo lector empieza a leer. El primer lector termina de leer (pero el segundo está leyendo y el escritor sigue bloqueado). Antes de que termine el segundo lector, el primero empieza a leer, y después termina el segundo (el escritor sigue bloqueado), y seguimos así indefinidamente, y los lectores entre ellos no dejar trabajar al escritor.


- (b) (1,5 puntos) Escribe una clase con un m$todo main, que construye un GestorLE, dos hebras lectoras y dos hebras escritoras, cuyos par"metros son un identificador de la hebra y un objeto de la clase GestorLE para su sincronizaci!n. Los identificadores de las hebras ser"n respectivamente 1, 2, 3 y 4. La prueba debe arrancar las hebras, los objetos necesarios y escribir un mensaje por consola informando que todas las hebras hayan terminado su ejecuci!n.

??? note "Mostrar solución"
    ```java
    public static void main(String[] args) {
        GestorLE gestor = new GestorLE();
        Lector lector = new Lector(gestor, 1);
        Escritor escritor = new Escritor(gestor, 3);
        Lector lector2 = new Lector(gestor, 2);
        Escritor escritor4 = new Escritor(gestor, 4);

        lector.start();
        lector2.start();
        escritor.start();
        escritor4.start();

        try {
            lector.join();
            lector2.join();
            escritor.join();
            escritor4.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Todos han terminado");
    }
    ```


- (c) (1,5 puntos) Cambie la clase GestorLE de este enunciado para que dos hebras escritoras no puedan acceder a los datos, antes de que al menos una hebra haya accedido despu$s de la %ltima escritura. En este caso, habr#a que bloquear a la segunda escritora, antes de que accediera a los datos alguna hebra lectora.

??? note "Mostrar solución"
    ```java
    public class GestorLE2 implements Gestor {
        private boolean bloqueoEscritor = false;
        private boolean bloqueoLector = false;
        private int nLectores = 0;
        private int nEscritores = 0;
        private boolean leido = true;

        public synchronized void empiezaLeer(int idLector) throws InterruptedException {
            while (bloqueoEscritor) {
                wait();
            }
            bloqueoLector = true;
            nLectores++;
        }

        public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {
            while (bloqueoEscritor || bloqueoLector || !leido) {
                wait();
            }
            nEscritores++;
            bloqueoEscritor = true;
        }

        public synchronized void terminaLeer(int idLector) {
            nLectores--;
            leido = true;
            if (nLectores == 0) {
                bloqueoLector = false;
                notifyAll();
            }
        }

        public synchronized void terminaEscribir(int idEscritor) {
            nEscritores--;
            bloqueoEscritor = false;
            leido = false;
            notifyAll();
        }
    }
    ```


- (d) (1,5 puntos) Cambie la clase GestorLE de este enunciado para que no puedan acceder m"s de tres lecturas para una misma escritura (no se puede leer en mismo dato mas de tres veces).

??? note "Mostrar solución"
    ```java
    public class GestorLE3 implements Gestor {
        private boolean bloqueoEscritor = false;
        private boolean bloqueoLector = false;
        private int nLectores = 0;
        private int nEscritores = 0;
        private int lecturas = 0;
    
        public synchronized void empiezaLeer(int idLector) throws InterruptedException {
            while (bloqueoEscritor || lecturas > 2) {
                wait();
            }
            bloqueoLector = true;
            nLectores++;
            lecturas++;
        }
    
        public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {
            while (bloqueoEscritor || bloqueoLector) {
                wait();
            }
            nEscritores++;
            bloqueoEscritor = true;
        }
    
        public synchronized void terminaLeer(int idLector) {
            nLectores--;
            if (nLectores == 0) {
                bloqueoLector = false;
                notifyAll();
            }
        }
    
        public synchronized void terminaEscribir(int idEscritor) {
            nEscritores--;
            bloqueoEscritor = false;
            lecturas = 0;
            notifyAll();
        }
    }
    ```

En los dos %ltimos ejercicios, no es necesario reescribir por completo la clase GestorLE. Es suficiente indicar donde se incluyen las nuevas l#neas de c!digo, o el n%mero de l#neas que haya que borrar.