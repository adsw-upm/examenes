---
id: ex-2022-02
year: 2022
exam: parcial 2
tags:
 - hebras
---

El problema de los lectores/escritores está compuesto de un conjunto de hebras que comparten datos. Las hebras lectoras (`Lectora`) sólo leen los datos, mientras que las hebras escritoras (`Escritora`) leen y escriben los datos. Varios lectoras pueden acceder simultáneamente a los datos compartidos, mientras que una escritora tiene que acceder con exclusión mutua con otros lectores o escritores. A continuación, se muestra una implementación muy sencilla de un monitor que gestione a las hebras lectoras y escritoras para acceder a los datos compartidos:

```java
public class GestorLE implements Gestor {
    private boolean bloqueoEscritor = false;
    private boolean bloqueoLector = false;
    private int nLectores = 0;
    private int nEscritores = 0;

    public synchronized void empiezaLeer(int idLector) throws InterruptedException {
        while (bloqueoEscritor)
            wait();
        bloqueoLector = true;
        nLectores++;
    }

    public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {
        while (bloqueoEscritor || bloqueoLector)
            wait();
        nEscritores++;
        bloqueoEscritor = true;
    }

    public synchronized void terminaLeer(int idLector) {
        nLectores--;
        if (nLectores == 0) {
            bloqueoLector = false;
            notifyAll();
        }
    }

    public synchronized void terminaEscribir(int idEscritor) {
        nEscritores--;
        bloqueoEscritor = false;
        notifyAll();
    }
}
```

El código de las hebras lectoras y escritoras está implementado como un bucle acotado que solicitan el acceso a los datos (`empiezaLeer` / `empiezaEscribir`), usan los datos durante un tiempo aleatorio, terminan el acceso a los datos (`terminLeer` / `terminaEscribir`) y están ociosos durante un tiempo aleatorio. Las clases `Lectora` y `Escritora` extienden `Thread` y que su constructor recibe como parámetro una instancia de `GestorLE` y su identificador.

- (a) (0,5 puntos) Analice y justifique si el monitor en este enunciado puede producir inanición o hambruna.

??? note "Mostrar solución"
    Esa solución puede tener inanición. Por ejemplo, 2 lectores y un escritor. El primer lector pide acceso y se lo da el gestor. El escritor intenta entrar y queda bloqueado. Antes de que termine de leer el primer lector, el segundo lector empieza a leer. El primer lector termina de leer (pero el segundo está leyendo y el escritor sigue bloqueado). Antes de que termine el segundo lector, el primero empieza a leer, y después termina el segundo (el escritor sigue bloqueado), y seguimos así indefinidamente, y los lectores entre ellos no dejar trabajar al escritor.


- (b) (1,5 puntos) Escribe una clase con un método `main`, que construye un `GestorLE`, dos hebras lectoras y dos hebras escritoras, cuyos parámetros son un identificador de la hebra y un objeto de la clase `GestorLE` para su sincronización. Los identificadores de las hebras serán respectivamente 1, 2, 3 y 4. La prueba debe arrancar las hebras, los objetos necesarios y escribir un mensaje por consola informando que todas las hebras hayan terminado su ejecución.

??? note "Mostrar solución"
    ```java
    public static void main(String[] args) {
        GestorLE gestor = new GestorLE();
        Lector lector = new Lector(gestor, 1);
        Escritor escritor = new Escritor(gestor, 3);
        Lector lector2 = new Lector(gestor, 2);
        Escritor escritor4 = new Escritor(gestor, 4);

        lector.start();
        lector2.start();
        escritor.start();
        escritor4.start();

        try {
            lector.join();
            lector2.join();
            escritor.join();
            escritor4.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(áTodos han terminadoá);
    }
    ```


- (c) (1,5 puntos) Cambie la clase `GestorLE` de este enunciado para que dos hebras escritoras no puedan acceder a los datos, antes de que al menos una hebra haya accedido después de la última escritura. En este caso, habr#a que bloquear a la segunda escritora, antes de que accediera a los datos alguna hebra lectora.

??? note "Mostrar solución"
    ```java
    public class GestorLE2 implements Gestor {
        private boolean bloqueoEscritor = false;
        private boolean bloqueoLector = false;
        private int nLectores = 0;
        private int nEscritores = 0;
        private boolean leido = true;

        public synchronized void empiezaLeer(int idLector) throws InterruptedException {
            while (bloqueoEscritor) {
                wait();
            }
            bloqueoLector = true;
            nLectores++;
        }

        public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {
            while (bloqueoEscritor || bloqueoLector || !leido) {
                wait();
            }
            nEscritores++;
            bloqueoEscritor = true;
        }

        public synchronized void terminaLeer(int idLector) {
            nLectores--;
            leido = true;
            if (nLectores == 0) {
                bloqueoLector = false;
                notifyAll();
            }
        }

        public synchronized void terminaEscribir(int idEscritor) {
            nEscritores--;
            bloqueoEscritor = false;
            leido = false;
            notifyAll();
        }
    }
    ```


- (d) (1,5 puntos) Cambie la clase `GestorLE` de este enunciado para que no puedan acceder más de tres lecturas para una misma escritura (no se puede leer en mismo dato mas de tres veces).

??? note "Mostrar solución"
    ```java
    public class GestorLE3 implements Gestor {
        private boolean bloqueoEscritor = false;
        private boolean bloqueoLector = false;
        private int nLectores = 0;
        private int nEscritores = 0;
        private int lecturas = 0;
    
        public synchronized void empiezaLeer(int idLector) throws InterruptedException {
            while (bloqueoEscritor || lecturas > 2) {
                wait();
            }
            bloqueoLector = true;
            nLectores++;
            lecturas++;
        }
    
        public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {
            while (bloqueoEscritor || bloqueoLector) {
                wait();
            }
            nEscritores++;
            bloqueoEscritor = true;
        }
    
        public synchronized void terminaLeer(int idLector) {
            nLectores--;
            if (nLectores == 0) {
                bloqueoLector = false;
                notifyAll();
            }
        }
    
        public synchronized void terminaEscribir(int idEscritor) {
            nEscritores--;
            bloqueoEscritor = false;
            lecturas = 0;
            notifyAll();
        }
    }
    ```

En los dos últimos ejercicios, no es necesario reescribir por completo la clase `GestorLE`. Es suficiente indicar donde se incluyen las nuevas líneas de código, o el número de líneas que haya que borrar.