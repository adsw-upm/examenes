{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cat\u00e1logo de Ejercicios","text":"<p>Bienvenido al cat\u00e1logo.</p>"},{"location":"tags/","title":"Tags","text":"<p> Listado de tags</p> <p>La siguiente p\u00e1gina muestra autom\u00e1ticamente todos los ejercicios agrupados por tag.</p> <p>[TAGS]</p>"},{"location":"exams/2012/ex01/","title":"Ejercicio 1 \u2014 Ordenaci\u00f3n por \u00edndices (3 puntos)","text":"","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex01/#enunciado","title":"Enunciado","text":"<p>Se pide escribir un algoritmo:</p> <pre><code>int[] ordena(long[] datos)\n</code></pre> <p>que devuelva un array de \u00edndices indicando en qu\u00e9 posici\u00f3n ir\u00eda cada dato al ordenar en orden ascendente.</p>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex01/#a-implementacion-iterativa-15-puntos","title":"a) Implementaci\u00f3n iterativa (1.5 puntos)","text":"Mostrar soluci\u00f3n <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex01/#b-complejidad-15-puntos","title":"b) Complejidad (1.5 puntos)","text":"Mostrar soluci\u00f3n <p>Hay dos bucles anidados. El n\u00famero total de comparaciones es:</p> <pre><code>(N-1) + (N-2) + ... + 1 = O(N^2)\n</code></pre>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex02/","title":"Ejercicio 2 \u2014 Monitor GestorPuente (3 puntos)","text":"","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex02/#enunciado","title":"Enunciado","text":"<p>Se requiere un monitor que controle el acceso a un puente de capacidad 1, con accesos norte y sur, y prioridad de ambulancias.</p>","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex02/#solucion","title":"Soluci\u00f3n","text":"Mostrar soluci\u00f3n <pre><code>public class GestorPuente {\n\n    private boolean hayCocheEnPuente = false;\n    private int nCochesNorte = 0;\n    private int nCochesSur  = 0;\n    private boolean hayAmbulancia = false;\n\n    public synchronized void entrarNorte() throws InterruptedException {\n        nCochesNorte++;\n        while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur) wait();\n        hayCocheEnPuente = true;\n        nCochesNorte--;\n    }\n\n    public synchronized void entrarSur() throws InterruptedException {\n        nCochesSur++;\n        while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte) wait();\n        hayCocheEnPuente = true;\n        nCochesSur--;\n    }\n\n    public synchronized void entrarAmbulancia() throws InterruptedException {\n        hayAmbulancia = true;\n        while (hayCocheEnPuente) wait();\n        hayCocheEnPuente = true;\n        hayAmbulancia = false;\n    }\n\n    public synchronized void salirPuente() {\n        hayCocheEnPuente = false;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex03/","title":"Ejercicio 3 \u2014 Aplicaci\u00f3n Android NotaMedia (4 puntos)","text":"","tags":["android","actividades"]},{"location":"exams/2012/ex03/#a-completar-androidmanifestxml-1-punto","title":"a) Completar AndroidManifest.xml (1 punto)","text":"Mostrar soluci\u00f3n <pre><code>&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\"&gt;\n\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\"&gt;\n\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\"/&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre>","tags":["android","actividades"]},{"location":"exams/2012/ex03/#b-implementar-notamediaactivity-2-puntos","title":"b) Implementar NotaMediaActivity (2 puntos)","text":"Mostrar soluci\u00f3n <pre><code>public class NotaMediaActivity extends Activity {\n\n    public static final String APROBADO = \"nota\";\n    public static final String VALOR = \"valor\";\n\n    private EditText editNotaFinal;\n    private EditText editTrabajoFinal;\n    private Button buttonGuardar;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.notamedia_final);\n        editNotaFinal = findViewById(R.id.editText_examen_final);\n        editTrabajoFinal = findViewById(R.id.editText_trabajo_final);\n        buttonGuardar = findViewById(R.id.button_calcular);\n        buttonGuardar.setOnClickListener(new ProcesaMedia());\n    }\n\n    private class ProcesaMedia implements View.OnClickListener {\n        @Override\n        public void onClick(View v) {\n            try {\n                float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n                float notaTrabajo = Float.parseFloat(editTrabajoFinal.getText().toString());\n\n                if (notaFinal &lt; 0 || notaFinal &gt; 10 || notaTrabajo &lt; 0 || notaTrabajo &gt; 10) {\n                    Toast.makeText(getApplication(),\n                            getString(R.string.error_numero),\n                            Toast.LENGTH_LONG).show();\n                    return;\n                }\n\n                float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n                DecimalFormat df = new DecimalFormat(\"0.0\");\n                String mediaString = df.format(media);\n\n                boolean aprobado = false;\n                String valor = \"\";\n\n                if (notaTrabajo &lt; 4 || notaFinal &lt; 4) {\n                    aprobado = false;\n                    if (notaTrabajo &lt; 4)\n                        valor += \" \" + getString(R.string.umbral_trabajo);\n                    if (notaFinal &lt; 4)\n                        valor += \" \" + getString(R.string.umbral_examen);\n                } else {\n                    valor = mediaString;\n                    aprobado = (media &gt;= 5);\n                }\n\n                Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n                intent.putExtra(APROBADO, aprobado);\n                intent.putExtra(VALOR, valor);\n                startActivity(intent);\n\n            } catch (NumberFormatException e) {\n                Toast.makeText(getApplication(),\n                        getString(R.string.error_numero),\n                        Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n}\n</code></pre>","tags":["android","actividades"]},{"location":"exams/2012/exam/","title":"Examen 2012 \u2014 Final","text":"<p>id: ex-2012-01 year: 2012 exam: final tags:   - ordenaci\u00f3n   - complejidad</p>"},{"location":"exams/2012/exam/#ejercicio-1-ordenacion-por-indices-3-puntos","title":"Ejercicio 1 \u2014 Ordenaci\u00f3n por \u00edndices (3 puntos)","text":""},{"location":"exams/2012/exam/#enunciado","title":"Enunciado","text":"<p>Se pide escribir un algoritmo:</p> <pre><code>int[] ordena(long[] datos)\n</code></pre> <p>que devuelva un array de \u00edndices indicando en qu\u00e9 posici\u00f3n ir\u00eda cada dato al ordenar en orden ascendente.</p>"},{"location":"exams/2012/exam/#a-implementacion-iterativa-15-puntos","title":"a) Implementaci\u00f3n iterativa (1.5 puntos)","text":"Mostrar soluci\u00f3n <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre>"},{"location":"exams/2012/exam/#b-complejidad-15-puntos","title":"b) Complejidad (1.5 puntos)","text":"Mostrar soluci\u00f3n <p>Hay dos bucles anidados. El n\u00famero total de comparaciones es:</p> <pre><code>(N-1) + (N-2) + ... + 1 = O(N^2)\n</code></pre> <p>id: ex-2012-02 year: 2012 exam: final tags:   - concurrencia   - monitores</p>"},{"location":"exams/2012/exam/#ejercicio-2-monitor-gestorpuente-3-puntos","title":"Ejercicio 2 \u2014 Monitor GestorPuente (3 puntos)","text":""},{"location":"exams/2012/exam/#enunciado_1","title":"Enunciado","text":"<p>Se requiere un monitor que controle el acceso a un puente de capacidad 1, con accesos norte y sur, y prioridad de ambulancias.</p>"},{"location":"exams/2012/exam/#solucion","title":"Soluci\u00f3n","text":"Mostrar soluci\u00f3n <pre><code>public class GestorPuente {\n\n    private boolean hayCocheEnPuente = false;\n    private int nCochesNorte = 0;\n    private int nCochesSur  = 0;\n    private boolean hayAmbulancia = false;\n\n    public synchronized void entrarNorte() throws InterruptedException {\n        nCochesNorte++;\n        while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur) wait();\n        hayCocheEnPuente = true;\n        nCochesNorte--;\n    }\n\n    public synchronized void entrarSur() throws InterruptedException {\n        nCochesSur++;\n        while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte) wait();\n        hayCocheEnPuente = true;\n        nCochesSur--;\n    }\n\n    public synchronized void entrarAmbulancia() throws InterruptedException {\n        hayAmbulancia = true;\n        while (hayCocheEnPuente) wait();\n        hayCocheEnPuente = true;\n        hayAmbulancia = false;\n    }\n\n    public synchronized void salirPuente() {\n        hayCocheEnPuente = false;\n        notifyAll();\n    }\n}\n</code></pre> <p>id: ex-2012-03 year: 2012 exam: final tags:   - android   - actividades</p>"},{"location":"exams/2012/exam/#ejercicio-3-aplicacion-android-notamedia-4-puntos","title":"Ejercicio 3 \u2014 Aplicaci\u00f3n Android NotaMedia (4 puntos)","text":""},{"location":"exams/2012/exam/#a-completar-androidmanifestxml-1-punto","title":"a) Completar AndroidManifest.xml (1 punto)","text":"Mostrar soluci\u00f3n <pre><code>&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\"&gt;\n\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\"&gt;\n\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\"/&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre>"},{"location":"exams/2012/exam/#b-implementar-notamediaactivity-2-puntos","title":"b) Implementar NotaMediaActivity (2 puntos)","text":"Mostrar soluci\u00f3n <pre><code>public class NotaMediaActivity extends Activity {\n\n    public static final String APROBADO = \"nota\";\n    public static final String VALOR = \"valor\";\n\n    private EditText editNotaFinal;\n    private EditText editTrabajoFinal;\n    private Button buttonGuardar;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.notamedia_final);\n        editNotaFinal = findViewById(R.id.editText_examen_final);\n        editTrabajoFinal = findViewById(R.id.editText_trabajo_final);\n        buttonGuardar = findViewById(R.id.button_calcular);\n        buttonGuardar.setOnClickListener(new ProcesaMedia());\n    }\n\n    private class ProcesaMedia implements View.OnClickListener {\n        @Override\n        public void onClick(View v) {\n            try {\n                float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n                float notaTrabajo = Float.parseFloat(editTrabajoFinal.getText().toString());\n\n                if (notaFinal &lt; 0 || notaFinal &gt; 10 || notaTrabajo &lt; 0 || notaTrabajo &gt; 10) {\n                    Toast.makeText(getApplication(),\n                            getString(R.string.error_numero),\n                            Toast.LENGTH_LONG).show();\n                    return;\n                }\n\n                float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n                DecimalFormat df = new DecimalFormat(\"0.0\");\n                String mediaString = df.format(media);\n\n                boolean aprobado = false;\n                String valor = \"\";\n\n                if (notaTrabajo &lt; 4 || notaFinal &lt; 4) {\n                    aprobado = false;\n                    if (notaTrabajo &lt; 4)\n                        valor += \" \" + getString(R.string.umbral_trabajo);\n                    if (notaFinal &lt; 4)\n                        valor += \" \" + getString(R.string.umbral_examen);\n                } else {\n                    valor = mediaString;\n                    aprobado = (media &gt;= 5);\n                }\n\n                Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n                intent.putExtra(APROBADO, aprobado);\n                intent.putExtra(VALOR, valor);\n                startActivity(intent);\n\n            } catch (NumberFormatException e) {\n                Toast.makeText(getApplication(),\n                        getString(R.string.error_numero),\n                        Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2012/p1/","title":"Examen 2012 \u2014 Parcial 1","text":"<p>id: ex-2012-01 year: 2012 exam: parcial 1 tags:   - complejidad</p> <p>A continuaci\u00f3n se describe el m\u00e9todo cuantasVeces de la clase P1. No programe la clase P1. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo cuantasVeces. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo cuantasVeces. . Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo cuantasVeces invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p> <p>id: ex-2012-02 year: 2012 exam: parcial 1 tags:   - complejidad</p> <p>Problema 2 (5 puntos) Dado el siguiente algoritmo de ordenaci\u00e1n:</p> <pre><code>public void sort(long[] datos) {\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n            datos[j] = datos[j-1];\n            j--;\n        }\n        datos[j] = x;\n    }\n}\n</code></pre> <ul> <li>(0.5 puntos) Indique el nombre del algoritmo </li> </ul> Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00e1n por inserci\u00f3n.</p> <ul> <li>(3 puntos) Indique qu\u00e9 cambios har\u00f1a en el c\u00e1digo, indicando el n\u00famero de l\u00f1nea, para conseguir que el m\u00e9todo   devolviera el n\u00famero de veces que compara dos elementos del array.</li> </ul> Mostrar soluci\u00f3n <p>La comparaci\u00e1n se efect\u00faa al comprobar la condici\u00e1n del bucle en la l\u00f1nea 5. El cuerpo del bucle se   ejecuta si j &gt; y adem\u00e1s x &lt; datos[j-1]. Por tanto, en este caso se ha efectuado una comparaci\u00e1n entre   x y un elemento del array. Sin embargo, si el bucle no se ejecuta puede ser por dos causas: </p> <p>1) Que j == 0, en cuyo caso no se   llega a efectuar la comparaci\u00e1n, ya que el operador &amp;&amp; no eval\u00faa el segundo t\u00e9rmino si el primero es   falso. </p> <p>2) Que j &gt;0 y x &gt;= datos[j-1]. En este caso s  se efect\u00faa la comparaci\u00e1n.</p> <p>Por tanto, para contar adecuadamente el n\u00famero de comparaciones hay que desdoblar la condici\u00e1n   del bucle, separando las dos condiciones. Una forma de hacerlo es la siguiente:</p> <p><pre><code>public int sort(long[] datos) {\nint numeroComparaciones = 0;\nfor (int i = 1; i &lt; datos.length; i++) {\nlong x = datos[i];\nint j = i;\nwhile (j &gt; 0) {\n++numeroComparaciones;\nif(x &lt; datos[j - 1]) {\ndatos[j] = datos[j-1];\nj--;\n} else {\nbreak;\n}\n}\ndatos[j] = x;\n}\nreturn numeroComparaciones;\n}\n</code></pre> Se han marcado de distinto color las l\u00f1neas modificadas: L\u00f1nea 1 sustituida por <pre><code>public int sort(long[] datos) {\nint numeroComparaciones = 0;\n</code></pre> Lineas 5-8 sustituidas por: <pre><code>while (j &gt; 0) {\n++ numeroComparaciones;\nif(x &lt; datos[j - 1]) {\ndatos[j] = datos[j-1];\nj--;\n} else {\nbreak;\n}\n}\n</code></pre></p> <p>Despu\u00e9s de la l\u00f1nea 10 se ha a\u00f1adido:</p> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00e1n alternativa con una variable auxiliar puede ser:</p> <pre><code>public int sort2(long[] datos) {\nint numeroComparaciones = 0;\nfor (int i = 1; i &lt; datos.length; i++) {\nlong x = datos[i];\nint j = i;\nboolean menor = true;\nwhile (j &gt; 0 &amp;&amp; menor) {\n++numeroComparaciones;\nif(x &lt; datos[j - 1]) {\ndatos[j] = datos[j-1];\nj--;\n} else {\nmenor = false;\n}\n}\ndatos[j] = x;\n}\nreturn numeroComparaciones;\n}\n</code></pre> <ul> <li>(1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00e1n realizada en el apartado b), para el caso {3, 1, 2}.</li> </ul> Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es: <pre><code>public void test() {\nlong[] datos = {3, 1, 2};\nP2 algoritmo = new P2();\nassertEquals(3, algoritmo.sort(datos));\n}\n</code></pre></p>"},{"location":"exams/2012/p1_ex01/","title":"P1 ex01","text":"<p>A continuaci\u00f3n se describe el m\u00e9todo cuantasVeces de la clase P1. No programe la clase P1. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo cuantasVeces. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo cuantasVeces. . Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo cuantasVeces invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/","title":"P1 ex02","text":"<p>Problema 2 (5 puntos) Dado el siguiente algoritmo de ordenaci\u00e1n:</p> <pre><code>public void sort(long[] datos) {\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n            datos[j] = datos[j-1];\n            j--;\n        }\n        datos[j] = x;\n    }\n}\n</code></pre> <ul> <li>(0.5 puntos) Indique el nombre del algoritmo </li> </ul> Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00e1n por inserci\u00f3n.</p> <ul> <li>(3 puntos) Indique qu\u00e9 cambios har\u00f1a en el c\u00e1digo, indicando el n\u00famero de l\u00f1nea, para conseguir que el m\u00e9todo   devolviera el n\u00famero de veces que compara dos elementos del array.</li> </ul> Mostrar soluci\u00f3n <p>La comparaci\u00e1n se efect\u00faa al comprobar la condici\u00e1n del bucle en la l\u00f1nea 5. El cuerpo del bucle se   ejecuta si j &gt; y adem\u00e1s x &lt; datos[j-1]. Por tanto, en este caso se ha efectuado una comparaci\u00e1n entre   x y un elemento del array. Sin embargo, si el bucle no se ejecuta puede ser por dos causas: </p> <p>1) Que j == 0, en cuyo caso no se   llega a efectuar la comparaci\u00e1n, ya que el operador &amp;&amp; no eval\u00faa el segundo t\u00e9rmino si el primero es   falso. </p> <p>2) Que j &gt;0 y x &gt;= datos[j-1]. En este caso s  se efect\u00faa la comparaci\u00e1n.</p> <p>Por tanto, para contar adecuadamente el n\u00famero de comparaciones hay que desdoblar la condici\u00e1n   del bucle, separando las dos condiciones. Una forma de hacerlo es la siguiente:</p> <p><pre><code>public int sort(long[] datos) {\nint numeroComparaciones = 0;\nfor (int i = 1; i &lt; datos.length; i++) {\nlong x = datos[i];\nint j = i;\nwhile (j &gt; 0) {\n++numeroComparaciones;\nif(x &lt; datos[j - 1]) {\ndatos[j] = datos[j-1];\nj--;\n} else {\nbreak;\n}\n}\ndatos[j] = x;\n}\nreturn numeroComparaciones;\n}\n</code></pre> Se han marcado de distinto color las l\u00f1neas modificadas: L\u00f1nea 1 sustituida por <pre><code>public int sort(long[] datos) {\nint numeroComparaciones = 0;\n</code></pre> Lineas 5-8 sustituidas por: <pre><code>while (j &gt; 0) {\n++ numeroComparaciones;\nif(x &lt; datos[j - 1]) {\ndatos[j] = datos[j-1];\nj--;\n} else {\nbreak;\n}\n}\n</code></pre></p> <p>Despu\u00e9s de la l\u00f1nea 10 se ha a\u00f1adido:</p> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00e1n alternativa con una variable auxiliar puede ser:</p> <pre><code>public int sort2(long[] datos) {\nint numeroComparaciones = 0;\nfor (int i = 1; i &lt; datos.length; i++) {\nlong x = datos[i];\nint j = i;\nboolean menor = true;\nwhile (j &gt; 0 &amp;&amp; menor) {\n++numeroComparaciones;\nif(x &lt; datos[j - 1]) {\ndatos[j] = datos[j-1];\nj--;\n} else {\nmenor = false;\n}\n}\ndatos[j] = x;\n}\nreturn numeroComparaciones;\n}\n</code></pre> <ul> <li>(1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00e1n realizada en el apartado b), para el caso {3, 1, 2}.</li> </ul> Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es: <pre><code>public void test() {\nlong[] datos = {3, 1, 2};\nP2 algoritmo = new P2();\nassertEquals(3, algoritmo.sort(datos));\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2012/p2/","title":"Examen 2012 \u2014 Parcial 2","text":"<p>id: ex-2012-02 year: 2012 exam: parcial 2 tags:   - complejidad</p> <p>Problema 1 (2 puntos) Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads). <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre></p> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase Swap1 pueden utilizar simult\u00e1neamente la variable aux al invocar el m\u00e9todo swap. Por tanto, swap deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a aux.</p> <p>Por el contrario, en Swap2 la variable aux es local al m\u00e9todo swap, y cada hebra que lo invoca usa su propia copia de aux. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p> <p>id: ex-2012-02 year: 2012 exam: parcial 2 tags:   - complejidad</p>"},{"location":"exams/2012/p2_ex01/","title":"P2 ex01","text":"<p>Problema 1 (2 puntos) Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads). <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre></p> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase Swap1 pueden utilizar simult\u00e1neamente la variable aux al invocar el m\u00e9todo swap. Por tanto, swap deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a aux.</p> <p>Por el contrario, en Swap2 la variable aux es local al m\u00e9todo swap, y cada hebra que lo invoca usa su propia copia de aux. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p>","tags":["complejidad"]},{"location":"exams/2021/exam/","title":"Ejercicio X \u2014 T\u00edtulo breve","text":"","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#enunciado","title":"Enunciado","text":"<p>Escribe aqu\u00ed el enunciado completo del ejercicio.</p> <p>Puedes incluir c\u00f3digo:</p> <p><pre><code>for (int i = 0; i &lt; n; i++) {\n    // ...\n}\n</code></pre> O diagramas, pseudoc\u00f3digo, tablas, etc.</p>","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#solucion","title":"Soluci\u00f3n","text":"Mostrar soluci\u00f3n","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#razonamiento","title":"Razonamiento","text":"<p>Explica los pasos o la deducci\u00f3n necesaria. Puedes subdividir la explicaci\u00f3n en apartados.</p>","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#solucion-final","title":"Soluci\u00f3n final","text":"<p>Indica directamente la respuesta, demostraci\u00f3n o c\u00f3digo.</p> <pre><code>def solve():\n    return ...\n</code></pre>","tags":["complejidad","ordenaci\u00f3n"]}]}