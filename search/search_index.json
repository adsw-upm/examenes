{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cat\u00e1logo de Ejercicios","text":"<p>Bienvenido al cat\u00e1logo.</p>"},{"location":"tags/","title":"Tags","text":"<p> Listado de tags</p> <p>La siguiente p\u00e1gina muestra autom\u00e1ticamente todos los ejercicios agrupados por tag.</p>"},{"location":"tags/#_1","title":"???","text":"<p>3 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2015-03 2015 parcial 1 ex-2015-02 2015 parcial 1 recuperacion ex-2016-02 2016 parcial 1 recuperacion"},{"location":"tags/#actividades","title":"Actividades","text":"<p>1 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-03 2012 final"},{"location":"tags/#android","title":"Android","text":"<p>13 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-03 2012 extraordinario ex-2012-03 2012 final ex-2013-04 2013 extraordinario ex-2013-03 2013 extraordinario ex-2013-02 2013 parcial 2 ex-2014-04 2014 extraordinario ex-2014-03 2014 extraordinario ex-2014-02 2014 parcial 2 ex-2014-01 2014 parcial 2 ex-2015-04 2015 extraordinario ex-2015-05 2015 extraordinario ex-2015-02 2015 parcial 2 ex-2015-01 2015 parcial 2"},{"location":"tags/#complejidad","title":"Complejidad","text":"<p>20 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-01 2012 final ex-2012-01 2012 parcial 1 ex-2012-02 2012 parcial 1 ex-2012-02 2012 parcial 2 ex-2012-02 2012 parcial 2 ex-2012-02 2012 parcial 2 ex-2013-01 2013 extraordinario ex-2013-01 2013 parcial 1 ex-2013-01 2013 parcial 1 recuperacion ex-2014-01 2014 extraordinario ex-2014-01 2014 parcial 1 ex-2014-01 2014 parcial 1 recuperacion ex-2015-01 2015 extraordinario ex-2015-01 2015 parcial 1 ex-2015-01 2015 parcial 1 recuperacion ex-2016-03 2016 parcial 1 ex-2016-01 2016 parcial 1 ex-2016-02 2016 parcial 1 ex-2016-01 2016 parcial 1 recuperacion ex-2024-01 2024 ordinaria"},{"location":"tags/#concurrencia","title":"Concurrencia","text":"<p>1 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-02 2012 final"},{"location":"tags/#monitores","title":"Monitores","text":"<p>12 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-02 2012 final ex-2013-02 2013 extraordinario ex-2013-02 2013 parcial 1 ex-2013-02 2013 parcial 1 recuperacion ex-2014-02 2014 extraordinario ex-2014-02 2014 parcial 1 ex-2014-02 2014 parcial 1 recuperacion ex-2015-03 2015 extraordinario ex-2015-02 2015 extraordinario ex-2015-02 2015 parcial 1 ex-2015-02 2015 parcial 1 recuperacion ex-2016-03 2016 parcial 1 recuperacion"},{"location":"tags/#ordenacion","title":"Ordenaci\u00f3n","text":"<p>2 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-01 2012 final ex-2024-01 2024 ordinaria"},{"location":"exams/2012/ex01/","title":"Ex01","text":"","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex01/#a-15-puntos","title":"A. (1.5 puntos)","text":"<p>Se pide escribir un algoritmo de ordenaci\u00f3n con la siguiente interfaz</p> <p><pre><code>int[] ordena(long[] datos)\n</code></pre> de tal forma que los datos de entrada no se modifican y el m\u00e9todo devuelve un array que contiene en qu\u00e9 posici\u00f3n deber\u00eda ir del dato correspondiente para estar en orden ascendente. Por ejemplo: <pre><code>datos:   [8, 42, 46, 24, 29, 7]\nindices: [1,  4,  5,  2,  3, 0]\n</code></pre> que se lee como que</p> <ul> <li>datos[0] se ordenar\u00eda en la posici\u00f3n 1</li> <li>datos[1] se ordenar\u00eda en la posici\u00f3n 4</li> <li>datos[2] se ordenar\u00eda en la posici\u00f3n 5</li> <li>etc.</li> </ul> <p>NOTA: Si hubiera 2 datos de igual valor, da igual cual de ellos va antes o despu\u00e9s. Elija lo que le sea m\u00e1s c\u00f3modo.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre></p>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex01/#b-15-puntos","title":"B. (1.5 puntos)","text":"<p>Estime la complejidad del  algoritmo  del  punto anterior,  contando  el  n\u00famero  de  comparaciones entre datos (enteros <code>long</code>) que hay que hacer en el caso peor.</p> Mostrar soluci\u00f3n <p>Hay 2 bucles, uno dentro del otro. El bucle exterior se hace \\(N\\) veces. En el bucle interior, la primera vez se hacen \\(N-1\\) comparaciones; la segunda vez, \\(N-2\\); la tercera \\(N-3\\), etc.  En total \\((N-1) + (N-2) + ... + 1 \\leftarrow \\mathcal{O}(N^2)\\)</p>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex02/","title":"Ex02","text":"","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex02/#a-3-puntos","title":"A. (3 puntos)","text":"<p>Sea un puente con capacidad para un veh\u00edculo y dos accesos: norte y sur. En caso de que haya veh\u00edculos intentando entrar por los dos accesos, debe entrar un veh\u00edculo por el extremo en el que haya m\u00e1s esperando (si el n\u00famero de veh\u00edculos esperando en cada extremo es el mismo, no es necesario imponer un orden). En el caso de que intente entrar una ambulancia, tendr\u00e1 prioridad sobre el resto de veh\u00edculos. No es necesario considerar el caso en que dos ambulancias intenten acceder simult\u00e1neamente al puente.  Se  pide  desarrollar  una  clase  monitor  GestorPuente  que  gestione  el  acceso  al  puente,  seg\u00fan  la especificaci\u00f3n  previa.  Los  m\u00e9todos  de  esta  clase  no  retornan  valores.  El  esqueleto  de  la  clase  es  el siguiente:</p> <pre><code>public class GestorPuente {\n    ... void entrarNorte () { ...}\n    ... void entrarSur () { ...}\n    ... void entrarAmbulancia () { ...}\n    ... void salirPuente(){...}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>package es.upm.dit.adsw.puenteTurnoEspera;\n/**\n* @author Alejandro Alonso\n* Monitor que gestiona la entrada a un puente de coches\n* por sus dos extremos (norte y sur). Dentro el puente s\u00f3lo puede\n* haber un coche. Si hay coches esperando en sus dos extremos, entra\n* uno por el extremos con m\u00e1s coches esperando. Si intenta entrar una\n* ambulancia, tendr\u00e1 prioridad. No pueden intentar dos ambulancias\n* simultaneamente.\n*/\npublic class GestorPuente { // monitor\n/**\n* Indica si hay un coche dentro del puente\n*/\nprivate boolean hayCocheEnPuente = false;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Norte\n*/\nprivate int nCochesNorte = 0;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Sur\n*/\nprivate int nCochesSur = 0;\n/**\n    Indica si hay una ambulancia esperando.\n\n*/\nprivate boolean hayAmbulancia = false;\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el norte.\n*  El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n*  coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarNorte() throws InterruptedException {\n    nCochesNorte++;\n    !!while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur)\n        wait();\n    hayCocheEnPuente = true;\n    nCochesNorte--;\n}\n\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el sur.\n* El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n* coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarSur() throws InterruptedException {\n    nCochesSur++;\n    while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte)\n    wait();\n    hayCocheEnPuente = true;\n    nCochesSur--;\n}\n/**\n* M\u00e9todo que ejecutan las ambulancias\n*/\npublic synchronized void entrarAmbulancia() throws InterruptedException {\n    hayAmbulancia = true;\n    while (hayCocheEnPuente) wait();\n    hayCocheEnPuente = true;\n    hayAmbulancia = false;\n}\n\n/**\n* M\u00e9todo que invoca un coche que est\u00e1 en el puente al salir de \u00e9l.\n*/\npublic synchronized void salirPuente() {\n    hayCocheEnPuente = false;\n    notifyAll();\n}\n}\n</code></pre></p>","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex03/","title":"Ex03","text":"<p>Tenemos una aplicaci\u00f3n de Android que calcula la nota de ADSW como se muestra a continuaci\u00f3n.</p> <p>Como hemos visto, la aplicaci\u00f3n consta de dos pantallas, un formulario inicial (<code>NotaMediaActivity</code>) y  una pantalla que muestra  una foto y  el resultado (<code>ResultadoActivity</code>). Ambas clases est\u00e1n en el paquete <code>es.upm.dit.adsw</code>.</p> <p>El c\u00e1lculo de  la nota media se realiza de la siguiente forma:</p> <ul> <li>S\u00f3lo se hace media si ambas notas  son mayores o iguales a 4. </li> <li>La nota es 0.6 * nota de de examen + 0.4 * nota de trabajo</li> </ul>","tags":["android","actividades"]},{"location":"exams/2012/ex03/#a-1-punto","title":"A. (1 punto)","text":"<p>Complete el c\u00f3digo del fichero de manifiesto del listado 1 para que la aplicaci\u00f3n muestre la pantalla inicial (formulario) y pueda pasar a la segunda de resultado con la media.</p>","tags":["android","actividades"]},{"location":"exams/2012/ex03/#b-2-puntos","title":"B. (2 puntos)","text":"<p>Programe la actividad <code>NotaMediaActivity</code>. Debe tener en cuenta:</p> <ul> <li>Si el usuario no rellena un campo o introduce un valor no num\u00e9rico, debe mostrar un mensaje indic\u00e1ndole que debe introducir valores num\u00e9ricos (use un Toast).</li> <li>La actividad ResultadoActivity espera recibir una intenci\u00f3n con dos par\u00e1metros extra: <ul> <li>un primer par\u00e1metro de tipo boolean denominado \u201caprobado\u201d (true si cumple umbrales y media &gt; = 5; false en caso contrario)</li> <li>un segundo par\u00e1metro de tipo String denominado valor (contiene un mensaje indicando qu\u00e9 umbral no se ha superado si no se puede hacer la media, o bien el valor de la nota media).</li> </ul> </li> <li>Los listados 2 y 3 le proporcionan informaci\u00f3n del layout de NotaMediaActivity y las cadenas string.xml de la aplicaci\u00f3n.</li> </ul> <p>Listado 1. C\u00f3digo de AndroidManifest.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"COMPLETAR POR EL ALUMMNO\" &lt;!-- COMPLETAR --&gt;\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n     &gt;\n       &lt;!-- COMPLETAR POR EL ALUMNO --&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>Listado 2.  C\u00f3digo de layout/ notamedia_final.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;TableLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" \n    android:background=\"@drawable/notebook\"\n    android:paddingLeft=\"40dp\"\n    android:paddingRight=\"5dp\" &gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_examen\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_examen_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n            &lt;requestFocus /&gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_trabajo\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_trabajo_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow\n        android:gravity=\"center\"&gt;\n        &lt;Button\n            android:id=\"@+id/button_calcular\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/calcular\" /&gt;\n    &lt;/TableRow&gt;\n&lt;/TableLayout&gt;\n</code></pre></p> <p>Listado 3. C\u00f3digo de values/strings.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;NotaMediaADSW&lt;/string&gt;\n    &lt;string name=\"nota_trabajo\"&gt;Nota trabajo final&lt;/string&gt;\n    &lt;string name=\"nota_examen\"&gt;Nota examen final&lt;/string&gt;\n    &lt;string name=\"nota_media\"&gt;Nota media&lt;/string&gt;\n    &lt;string name=\"calcular\"&gt;Calcular&lt;/string&gt;\n    &lt;string name=\"error_numero\"&gt;Los campos deben ser num\u00e9ricos&lt;/string&gt;\n    &lt;string name=\"umbral_trabajo\"&gt;No has superado el umbral de 4.0 en la pr\u00e1ctica&lt;/string&gt;\n    &lt;string name=\"umbral_examen\"&gt;No has superado el umbral de 4.0 en el examen&lt;/string&gt;        \n     &lt;string name=\"enhorabuena\"&gt;Enhorabuena, que pases un buen verano.&lt;/string&gt;\n    &lt;string name=\"julio\"&gt;Hay otra oportunidad en julio. &lt;/string&gt;\n    &lt;string name=\"nota\"&gt;La nota es &lt;/string&gt;\n    &lt;string name=\"problema_nota\"&gt;Hay un problema para mostrar la nota&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre></p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n    &gt;\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\" &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <pre><code>public class NotaMediaActivity extends Activity {\npublic static final String APROBADO = \"nota\";\npublic static final String VALOR = \"valor\";\nprivate static final String TAG = NotaMediaActivity.class.getSimpleName();\nprivate EditText editNotaFinal;\nprivate EditText editTrabajoFinal;\nprivate Button buttonGuardar;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    Log.d(TAG, \"onCreate\");\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.notamedia_final);\n    editNotaFinal = (EditText) findViewById(R.id.editText_examen_final);\n    editTrabajoFinal = (EditText) findViewById(R.id.editText_trabajo_final);\n    buttonGuardar = (Button) findViewById(R.id.button_calcular);\n    buttonGuardar.setOnClickListener(new ProcesaMedia());\n}\n\nprivate class ProcesaMedia implements OnClickListener {\n    @Override\n    public void onClick(View v) {\n    try {\n        float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n        float notaTrabajo =\n            Float.parseFloat(editTrabajoFinal.getText().toString());\n        if ((notaFinal &lt; 0) || (notaFinal &gt; 10) || (notaTrabajo &lt; 0)\n            || (notaTrabajo &gt; 10)) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n        return;\n        }\n        float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String mediaString = df.format(media);\n        boolean aprobado = false;\n        String valor = \"\";\n        if ((notaTrabajo &lt; 4) || (notaFinal &lt; 4)) {\n        aprobado = false;\n        if (notaTrabajo &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_trabajo);\n        }\n        if (notaFinal &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_examen);\n        }\n        } else {\n        valor = mediaString;\n        aprobado = (media &gt;= 5);\n        }\n        Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n        intent.putExtra(APROBADO, aprobado);\n        intent.putExtra(VALOR, valor);\n        Log.d(TAG, \"Nota \" + aprobado + \" \" + valor);\n        startActivity(intent);\n    } catch (NumberFormatException e) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n    }\n    }\n}\n}\n</code></pre>","tags":["android","actividades"]},{"location":"exams/2012/exam/","title":"Examen 2012 \u2014 Final","text":""},{"location":"exams/2012/exam/#ejercicio-1","title":"Ejercicio 1","text":""},{"location":"exams/2012/exam/#a-15-puntos","title":"A. (1.5 puntos)","text":"<p>Se pide escribir un algoritmo de ordenaci\u00f3n con la siguiente interfaz</p> <p><pre><code>int[] ordena(long[] datos)\n</code></pre> de tal forma que los datos de entrada no se modifican y el m\u00e9todo devuelve un array que contiene en qu\u00e9 posici\u00f3n deber\u00eda ir del dato correspondiente para estar en orden ascendente. Por ejemplo: <pre><code>datos:   [8, 42, 46, 24, 29, 7]\nindices: [1,  4,  5,  2,  3, 0]\n</code></pre> que se lee como que</p> <ul> <li>datos[0] se ordenar\u00eda en la posici\u00f3n 1</li> <li>datos[1] se ordenar\u00eda en la posici\u00f3n 4</li> <li>datos[2] se ordenar\u00eda en la posici\u00f3n 5</li> <li>etc.</li> </ul> <p>NOTA: Si hubiera 2 datos de igual valor, da igual cual de ellos va antes o despu\u00e9s. Elija lo que le sea m\u00e1s c\u00f3modo.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre></p>"},{"location":"exams/2012/exam/#b-15-puntos","title":"B. (1.5 puntos)","text":"<p>Estime la complejidad del  algoritmo  del  punto anterior,  contando  el  n\u00famero  de  comparaciones entre datos (enteros <code>long</code>) que hay que hacer en el caso peor.</p> Mostrar soluci\u00f3n <p>Hay 2 bucles, uno dentro del otro. El bucle exterior se hace \\(N\\) veces. En el bucle interior, la primera vez se hacen \\(N-1\\) comparaciones; la segunda vez, \\(N-2\\); la tercera \\(N-3\\), etc.  En total \\((N-1) + (N-2) + ... + 1 \\leftarrow \\mathcal{O}(N^2)\\)</p>"},{"location":"exams/2012/exam/#ejercicio-2","title":"Ejercicio 2","text":""},{"location":"exams/2012/exam/#a-3-puntos","title":"A. (3 puntos)","text":"<p>Sea un puente con capacidad para un veh\u00edculo y dos accesos: norte y sur. En caso de que haya veh\u00edculos intentando entrar por los dos accesos, debe entrar un veh\u00edculo por el extremo en el que haya m\u00e1s esperando (si el n\u00famero de veh\u00edculos esperando en cada extremo es el mismo, no es necesario imponer un orden). En el caso de que intente entrar una ambulancia, tendr\u00e1 prioridad sobre el resto de veh\u00edculos. No es necesario considerar el caso en que dos ambulancias intenten acceder simult\u00e1neamente al puente.  Se  pide  desarrollar  una  clase  monitor  GestorPuente  que  gestione  el  acceso  al  puente,  seg\u00fan  la especificaci\u00f3n  previa.  Los  m\u00e9todos  de  esta  clase  no  retornan  valores.  El  esqueleto  de  la  clase  es  el siguiente:</p> <pre><code>public class GestorPuente {\n    ... void entrarNorte () { ...}\n    ... void entrarSur () { ...}\n    ... void entrarAmbulancia () { ...}\n    ... void salirPuente(){...}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>package es.upm.dit.adsw.puenteTurnoEspera;\n/**\n* @author Alejandro Alonso\n* Monitor que gestiona la entrada a un puente de coches\n* por sus dos extremos (norte y sur). Dentro el puente s\u00f3lo puede\n* haber un coche. Si hay coches esperando en sus dos extremos, entra\n* uno por el extremos con m\u00e1s coches esperando. Si intenta entrar una\n* ambulancia, tendr\u00e1 prioridad. No pueden intentar dos ambulancias\n* simultaneamente.\n*/\npublic class GestorPuente { // monitor\n/**\n* Indica si hay un coche dentro del puente\n*/\nprivate boolean hayCocheEnPuente = false;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Norte\n*/\nprivate int nCochesNorte = 0;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Sur\n*/\nprivate int nCochesSur = 0;\n/**\n    Indica si hay una ambulancia esperando.\n\n*/\nprivate boolean hayAmbulancia = false;\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el norte.\n*  El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n*  coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarNorte() throws InterruptedException {\n    nCochesNorte++;\n    !!while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur)\n        wait();\n    hayCocheEnPuente = true;\n    nCochesNorte--;\n}\n\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el sur.\n* El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n* coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarSur() throws InterruptedException {\n    nCochesSur++;\n    while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte)\n    wait();\n    hayCocheEnPuente = true;\n    nCochesSur--;\n}\n/**\n* M\u00e9todo que ejecutan las ambulancias\n*/\npublic synchronized void entrarAmbulancia() throws InterruptedException {\n    hayAmbulancia = true;\n    while (hayCocheEnPuente) wait();\n    hayCocheEnPuente = true;\n    hayAmbulancia = false;\n}\n\n/**\n* M\u00e9todo que invoca un coche que est\u00e1 en el puente al salir de \u00e9l.\n*/\npublic synchronized void salirPuente() {\n    hayCocheEnPuente = false;\n    notifyAll();\n}\n}\n</code></pre></p>"},{"location":"exams/2012/exam/#ejercicio-3","title":"Ejercicio 3","text":"<p>Tenemos una aplicaci\u00f3n de Android que calcula la nota de ADSW como se muestra a continuaci\u00f3n.</p> <p>Como hemos visto, la aplicaci\u00f3n consta de dos pantallas, un formulario inicial (<code>NotaMediaActivity</code>) y  una pantalla que muestra  una foto y  el resultado (<code>ResultadoActivity</code>). Ambas clases est\u00e1n en el paquete <code>es.upm.dit.adsw</code>.</p> <p>El c\u00e1lculo de  la nota media se realiza de la siguiente forma:</p> <ul> <li>S\u00f3lo se hace media si ambas notas  son mayores o iguales a 4. </li> <li>La nota es 0.6 * nota de de examen + 0.4 * nota de trabajo</li> </ul>"},{"location":"exams/2012/exam/#a-1-punto","title":"A. (1 punto)","text":"<p>Complete el c\u00f3digo del fichero de manifiesto del listado 1 para que la aplicaci\u00f3n muestre la pantalla inicial (formulario) y pueda pasar a la segunda de resultado con la media.</p>"},{"location":"exams/2012/exam/#b-2-puntos","title":"B. (2 puntos)","text":"<p>Programe la actividad <code>NotaMediaActivity</code>. Debe tener en cuenta:</p> <ul> <li>Si el usuario no rellena un campo o introduce un valor no num\u00e9rico, debe mostrar un mensaje indic\u00e1ndole que debe introducir valores num\u00e9ricos (use un Toast).</li> <li>La actividad ResultadoActivity espera recibir una intenci\u00f3n con dos par\u00e1metros extra: <ul> <li>un primer par\u00e1metro de tipo boolean denominado \u201caprobado\u201d (true si cumple umbrales y media &gt; = 5; false en caso contrario)</li> <li>un segundo par\u00e1metro de tipo String denominado valor (contiene un mensaje indicando qu\u00e9 umbral no se ha superado si no se puede hacer la media, o bien el valor de la nota media).</li> </ul> </li> <li>Los listados 2 y 3 le proporcionan informaci\u00f3n del layout de NotaMediaActivity y las cadenas string.xml de la aplicaci\u00f3n.</li> </ul> <p>Listado 1. C\u00f3digo de AndroidManifest.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"COMPLETAR POR EL ALUMMNO\" &lt;!-- COMPLETAR --&gt;\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n     &gt;\n       &lt;!-- COMPLETAR POR EL ALUMNO --&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>Listado 2.  C\u00f3digo de layout/ notamedia_final.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;TableLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" \n    android:background=\"@drawable/notebook\"\n    android:paddingLeft=\"40dp\"\n    android:paddingRight=\"5dp\" &gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_examen\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_examen_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n            &lt;requestFocus /&gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_trabajo\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_trabajo_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow\n        android:gravity=\"center\"&gt;\n        &lt;Button\n            android:id=\"@+id/button_calcular\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/calcular\" /&gt;\n    &lt;/TableRow&gt;\n&lt;/TableLayout&gt;\n</code></pre></p> <p>Listado 3. C\u00f3digo de values/strings.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;NotaMediaADSW&lt;/string&gt;\n    &lt;string name=\"nota_trabajo\"&gt;Nota trabajo final&lt;/string&gt;\n    &lt;string name=\"nota_examen\"&gt;Nota examen final&lt;/string&gt;\n    &lt;string name=\"nota_media\"&gt;Nota media&lt;/string&gt;\n    &lt;string name=\"calcular\"&gt;Calcular&lt;/string&gt;\n    &lt;string name=\"error_numero\"&gt;Los campos deben ser num\u00e9ricos&lt;/string&gt;\n    &lt;string name=\"umbral_trabajo\"&gt;No has superado el umbral de 4.0 en la pr\u00e1ctica&lt;/string&gt;\n    &lt;string name=\"umbral_examen\"&gt;No has superado el umbral de 4.0 en el examen&lt;/string&gt;        \n     &lt;string name=\"enhorabuena\"&gt;Enhorabuena, que pases un buen verano.&lt;/string&gt;\n    &lt;string name=\"julio\"&gt;Hay otra oportunidad en julio. &lt;/string&gt;\n    &lt;string name=\"nota\"&gt;La nota es &lt;/string&gt;\n    &lt;string name=\"problema_nota\"&gt;Hay un problema para mostrar la nota&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre></p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n    &gt;\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\" &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <pre><code>public class NotaMediaActivity extends Activity {\npublic static final String APROBADO = \"nota\";\npublic static final String VALOR = \"valor\";\nprivate static final String TAG = NotaMediaActivity.class.getSimpleName();\nprivate EditText editNotaFinal;\nprivate EditText editTrabajoFinal;\nprivate Button buttonGuardar;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    Log.d(TAG, \"onCreate\");\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.notamedia_final);\n    editNotaFinal = (EditText) findViewById(R.id.editText_examen_final);\n    editTrabajoFinal = (EditText) findViewById(R.id.editText_trabajo_final);\n    buttonGuardar = (Button) findViewById(R.id.button_calcular);\n    buttonGuardar.setOnClickListener(new ProcesaMedia());\n}\n\nprivate class ProcesaMedia implements OnClickListener {\n    @Override\n    public void onClick(View v) {\n    try {\n        float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n        float notaTrabajo =\n            Float.parseFloat(editTrabajoFinal.getText().toString());\n        if ((notaFinal &lt; 0) || (notaFinal &gt; 10) || (notaTrabajo &lt; 0)\n            || (notaTrabajo &gt; 10)) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n        return;\n        }\n        float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String mediaString = df.format(media);\n        boolean aprobado = false;\n        String valor = \"\";\n        if ((notaTrabajo &lt; 4) || (notaFinal &lt; 4)) {\n        aprobado = false;\n        if (notaTrabajo &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_trabajo);\n        }\n        if (notaFinal &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_examen);\n        }\n        } else {\n        valor = mediaString;\n        aprobado = (media &gt;= 5);\n        }\n        Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n        intent.putExtra(APROBADO, aprobado);\n        intent.putExtra(VALOR, valor);\n        Log.d(TAG, \"Nota \" + aprobado + \" \" + valor);\n        startActivity(intent);\n    } catch (NumberFormatException e) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n    }\n    }\n}\n}\n</code></pre>"},{"location":"exams/2012/extra/","title":"Examen 2012 \u2014 Extraordinario","text":""},{"location":"exams/2012/extra/#ejercicio-1","title":"Ejercicio 1","text":"<p>Se pide escribir un algoritmo para extraer la mediana de los valores de un array. Si un array de \\(N\\) datos est\u00e1 ordenado, la mediana es el valor del medio, \\(\\text{array}[N/2]\\).</p> <p>El objetivo es preparar un m\u00e9todo:</p> <pre><code>public long mediana(long[] datos)\n</code></pre> <p>que devuelve la mediana del array que se le pasa.</p> <p>Debe partir del algoritmo de quicksort y modificarlo de forma que, cuando se separan los datos en dos partes, solo se siga procesando la parte que contiene la mediana, sin ordenar la otra.</p> <p>Se pide:</p> <ol> <li>escribir el algoritmo de forma recursiva.</li> <li>escribirlo de forma iterativa.</li> <li>calcular la complejidad razonando el por qu\u00e9.</li> </ol> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\n````\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana1(long[] datos, int a, int z) {\n        long pivote = datos[(a + z) / 2];\n        int inf = a;\n        int sup = z;\n        while (inf &lt; sup) {\n            while (datos[inf] &lt; pivote)\n                inf++;\n            while (pivote &lt; datos[sup - 1])\n                sup--;\n            if (inf &lt; sup) {\n                long tmp = datos[inf];\n                datos[inf] = datos[sup - 1];\n                datos[sup - 1] = tmp;\n                inf++;\n                sup--;\n            }\n        }\n        int mitad = datos.length / 2;\n        if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n            mediana1(datos, a, sup);\n        if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n            mediana1(datos, inf, z);\n    }\n\n    private void mediana2(long[] datos, int a, int z) {\n        while (a &lt; z) {\n            long pivote = datos[(a + z) / 2];\n            int inf = a;\n            int sup = z;\n            while (inf &lt; sup) {\n                while (datos[inf] &lt; pivote)\n                    inf++;\n                while (pivote &lt; datos[sup - 1])\n                    sup--;\n                if (inf &lt; sup) {\n                    long tmp = datos[inf];\n                    datos[inf] = datos[sup - 1];\n                    datos[sup - 1] = tmp;\n                    inf++;\n                    sup--;\n                }\n            }\n            int mitad = datos.length / 2;\n            if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n                z = sup;\n            else if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n                a = inf;\n            else\n                return;\n        }\n    }\n}\n</code></pre> <p>Complejidad:</p> <ul> <li> <p>Caso peor: el comportamiento es equivalente a quicksort cuando siempre se elige un pivote p\u00e9simo. La partici\u00f3n genera tama\u00f1os \\(1\\) y \\(n-1\\), por lo que el coste es:   $\\(n + (n-1) + (n-2) + \\dots + 1 = O(n^2)\\)$</p> </li> <li> <p>Caso medio: cada paso divide el array aproximadamente por la mitad, y solo se sigue por la parte donde est\u00e1 la mediana:   $\\(n + \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} + \\dots = 2n = O(n)\\)$</p> </li> </ul> <p>Por tanto: - Caso peor: \\(O(n^2)\\) - Caso medio: \\(O(n)\\) ````</p>"},{"location":"exams/2012/extra/#ejercicio-2","title":"Ejercicio 2","text":""},{"location":"exams/2012/extra/#ejercicio-3","title":"Ejercicio 3","text":""},{"location":"exams/2012/extra01/","title":"Extra01","text":"<p>Se pide escribir un algoritmo para extraer la mediana de los valores de un array. Si un array de \\(N\\) datos est\u00e1 ordenado, la mediana es el valor del medio, \\(\\text{array}[N/2]\\).</p> <p>El objetivo es preparar un m\u00e9todo:</p> <pre><code>public long mediana(long[] datos)\n</code></pre> <p>que devuelve la mediana del array que se le pasa.</p> <p>Debe partir del algoritmo de quicksort y modificarlo de forma que, cuando se separan los datos en dos partes, solo se siga procesando la parte que contiene la mediana, sin ordenar la otra.</p> <p>Se pide:</p> <ol> <li>escribir el algoritmo de forma recursiva.</li> <li>escribirlo de forma iterativa.</li> <li>calcular la complejidad razonando el por qu\u00e9.</li> </ol> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\n````\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana1(long[] datos, int a, int z) {\n        long pivote = datos[(a + z) / 2];\n        int inf = a;\n        int sup = z;\n        while (inf &lt; sup) {\n            while (datos[inf] &lt; pivote)\n                inf++;\n            while (pivote &lt; datos[sup - 1])\n                sup--;\n            if (inf &lt; sup) {\n                long tmp = datos[inf];\n                datos[inf] = datos[sup - 1];\n                datos[sup - 1] = tmp;\n                inf++;\n                sup--;\n            }\n        }\n        int mitad = datos.length / 2;\n        if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n            mediana1(datos, a, sup);\n        if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n            mediana1(datos, inf, z);\n    }\n\n    private void mediana2(long[] datos, int a, int z) {\n        while (a &lt; z) {\n            long pivote = datos[(a + z) / 2];\n            int inf = a;\n            int sup = z;\n            while (inf &lt; sup) {\n                while (datos[inf] &lt; pivote)\n                    inf++;\n                while (pivote &lt; datos[sup - 1])\n                    sup--;\n                if (inf &lt; sup) {\n                    long tmp = datos[inf];\n                    datos[inf] = datos[sup - 1];\n                    datos[sup - 1] = tmp;\n                    inf++;\n                    sup--;\n                }\n            }\n            int mitad = datos.length / 2;\n            if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n                z = sup;\n            else if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n                a = inf;\n            else\n                return;\n        }\n    }\n}\n</code></pre> <p>Complejidad:</p> <ul> <li> <p>Caso peor: el comportamiento es equivalente a quicksort cuando siempre se elige un pivote p\u00e9simo. La partici\u00f3n genera tama\u00f1os \\(1\\) y \\(n-1\\), por lo que el coste es:   $\\(n + (n-1) + (n-2) + \\dots + 1 = O(n^2)\\)$</p> </li> <li> <p>Caso medio: cada paso divide el array aproximadamente por la mitad, y solo se sigue por la parte donde est\u00e1 la mediana:   $\\(n + \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} + \\dots = 2n = O(n)\\)$</p> </li> </ul> <p>Por tanto: - Caso peor: \\(O(n^2)\\) - Caso medio: \\(O(n)\\) ````</p>","tags":["android"]},{"location":"exams/2012/p1/","title":"Examen 2012 \u2014 Parcial 1","text":""},{"location":"exams/2012/p1/#problema-1","title":"Problema 1","text":"<p>A continuaci\u00f3n se describe el m\u00e9todo cuantasVeces de la clase P1. No programe la clase P1. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo cuantasVeces. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo cuantasVeces. . Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo cuantasVeces invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p>"},{"location":"exams/2012/p1/#problema-2","title":"Problema 2","text":""},{"location":"exams/2012/p1/#problema-2-5-puntos","title":"Problema 2 (5 puntos)","text":"<p>Dado el siguiente algoritmo de ordenaci\u00f3n:</p> <pre><code>public void sort(long[] datos) {\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n            datos[j] = datos[j - 1];\n            j--;\n        }\n        datos[j] = x;\n    }\n}\n</code></pre>"},{"location":"exams/2012/p1/#05-puntos-indique-el-nombre-del-algoritmo","title":"(0.5 puntos) Indique el nombre del algoritmo","text":"Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00f3n por inserci\u00f3n.</p>"},{"location":"exams/2012/p1/#3-puntos-indique-que-cambios-haria-en-el-codigo-indicando-el-numero-de-linea-para-conseguir-que-el-metodo-devolviera-el-numero-de-veces-que-compara-dos-elementos-del-array","title":"(3 puntos) Indique qu\u00e9 cambios har\u00eda en el c\u00f3digo, indicando el n\u00famero de l\u00ednea, para conseguir que el m\u00e9todo devolviera el n\u00famero de veces que compara dos elementos del array.","text":"Mostrar soluci\u00f3n <p>La comparaci\u00f3n se efect\u00faa al comprobar la condici\u00f3n del bucle en la l\u00ednea <code>5</code>. El cuerpo del bucle se ejecuta si <code>j &gt; 0</code> y adem\u00e1s <code>x &lt; datos[j - 1]</code>. Por tanto, en ese caso se ha efectuado una comparaci\u00f3n entre <code>x</code> y un elemento del array.</p> <p>Sin embargo, si el bucle no se ejecuta puede ser por dos causas:</p> <ol> <li><code>j == 0</code>, en cuyo caso no se llega a efectuar la comparaci\u00f3n, ya que el operador <code>&amp;&amp;</code> no eval\u00faa el segundo t\u00e9rmino.  </li> <li><code>j &gt; 0</code> y <code>x &gt;= datos[j - 1]</code>, en cuyo caso s\u00ed se efect\u00faa la comparaci\u00f3n.</li> </ol> <p>Para contar correctamente las comparaciones, hay que desdoblar la condici\u00f3n del bucle. Una forma de hacerlo es:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                break;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <p>L\u00edneas modificadas:</p> <ul> <li>L\u00ednea 1 sustituida por:</li> </ul> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n</code></pre> <ul> <li>L\u00edneas 5\u20138 sustituidas por:</li> </ul> <pre><code>while (j &gt; 0) {\n    ++numeroComparaciones;\n    if (x &lt; datos[j - 1]) {\n        datos[j] = datos[j - 1];\n        j--;\n    } else {\n        break;\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s de la l\u00ednea 10 se a\u00f1ade:</li> </ul> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00f3n alternativa con una variable auxiliar:</p> <pre><code>public int sort2(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        boolean menor = true;\n        while (j &gt; 0 &amp;&amp; menor) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                menor = false;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre>"},{"location":"exams/2012/p1/#15-puntos-programe-una-prueba-en-junit3-de-la-modificacion-realizada-en-el-apartado-b-para-el-caso-3-1-2","title":"(1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00f3n realizada en el apartado b), para el caso <code>{3, 1, 2}</code>.","text":"Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es:</p> <pre><code>public void test() {\n    long[] datos = {3, 1, 2};\n    P2 algoritmo = new P2();\n    assertEquals(3, algoritmo.sort(datos));\n}\n</code></pre>"},{"location":"exams/2012/p1_ex01/","title":"P1 ex01","text":"<p>A continuaci\u00f3n se describe el m\u00e9todo cuantasVeces de la clase P1. No programe la clase P1. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo cuantasVeces. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo cuantasVeces. . Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo cuantasVeces invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/","title":"Problema 2 (5 puntos)","text":"<p>Dado el siguiente algoritmo de ordenaci\u00f3n:</p> <pre><code>public void sort(long[] datos) {\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n            datos[j] = datos[j - 1];\n            j--;\n        }\n        datos[j] = x;\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/#05-puntos-indique-el-nombre-del-algoritmo","title":"(0.5 puntos) Indique el nombre del algoritmo","text":"Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00f3n por inserci\u00f3n.</p>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/#3-puntos-indique-que-cambios-haria-en-el-codigo-indicando-el-numero-de-linea-para-conseguir-que-el-metodo-devolviera-el-numero-de-veces-que-compara-dos-elementos-del-array","title":"(3 puntos) Indique qu\u00e9 cambios har\u00eda en el c\u00f3digo, indicando el n\u00famero de l\u00ednea, para conseguir que el m\u00e9todo devolviera el n\u00famero de veces que compara dos elementos del array.","text":"Mostrar soluci\u00f3n <p>La comparaci\u00f3n se efect\u00faa al comprobar la condici\u00f3n del bucle en la l\u00ednea <code>5</code>. El cuerpo del bucle se ejecuta si <code>j &gt; 0</code> y adem\u00e1s <code>x &lt; datos[j - 1]</code>. Por tanto, en ese caso se ha efectuado una comparaci\u00f3n entre <code>x</code> y un elemento del array.</p> <p>Sin embargo, si el bucle no se ejecuta puede ser por dos causas:</p> <ol> <li><code>j == 0</code>, en cuyo caso no se llega a efectuar la comparaci\u00f3n, ya que el operador <code>&amp;&amp;</code> no eval\u00faa el segundo t\u00e9rmino.  </li> <li><code>j &gt; 0</code> y <code>x &gt;= datos[j - 1]</code>, en cuyo caso s\u00ed se efect\u00faa la comparaci\u00f3n.</li> </ol> <p>Para contar correctamente las comparaciones, hay que desdoblar la condici\u00f3n del bucle. Una forma de hacerlo es:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                break;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <p>L\u00edneas modificadas:</p> <ul> <li>L\u00ednea 1 sustituida por:</li> </ul> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n</code></pre> <ul> <li>L\u00edneas 5\u20138 sustituidas por:</li> </ul> <pre><code>while (j &gt; 0) {\n    ++numeroComparaciones;\n    if (x &lt; datos[j - 1]) {\n        datos[j] = datos[j - 1];\n        j--;\n    } else {\n        break;\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s de la l\u00ednea 10 se a\u00f1ade:</li> </ul> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00f3n alternativa con una variable auxiliar:</p> <pre><code>public int sort2(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        boolean menor = true;\n        while (j &gt; 0 &amp;&amp; menor) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                menor = false;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/#15-puntos-programe-una-prueba-en-junit3-de-la-modificacion-realizada-en-el-apartado-b-para-el-caso-3-1-2","title":"(1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00f3n realizada en el apartado b), para el caso <code>{3, 1, 2}</code>.","text":"Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es:</p> <pre><code>public void test() {\n    long[] datos = {3, 1, 2};\n    P2 algoritmo = new P2();\n    assertEquals(3, algoritmo.sort(datos));\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p2/","title":"Examen 2012 \u2014 Parcial 2","text":""},{"location":"exams/2012/p2/#problema-1","title":"Problema 1","text":""},{"location":"exams/2012/p2/#a-2-puntos","title":"A. (2 puntos)","text":"<p>Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads). <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre></p> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase Swap1 pueden utilizar simult\u00e1neamente la variable aux al invocar el m\u00e9todo swap. Por tanto, swap deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a aux.</p> <p>Por el contrario, en Swap2 la variable aux es local al m\u00e9todo swap, y cada hebra que lo invoca usa su propia copia de aux. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p>"},{"location":"exams/2012/p2/#problema-2","title":"Problema 2","text":""},{"location":"exams/2012/p2/#a-4-puntos","title":"A. (4 puntos)","text":"<p>Escriba una clase con un contador interno, que se incrementa cada vez que se invoca el m\u00e9todo <code>siguiente()</code>. La clase debe poderse utilizar en un programa concurrente. Adem\u00e1s, la clase proporciona otros dos m\u00e9todos, <code>esperarPar()</code> y <code>esperarImpar()</code>, que hacen que la hebra (thread) que los invoca se quede bloqueada hasta que el valor del contador sea par o impar, respectivamente.</p> <p>Se supone que el intervalo entre dos invocaciones consecutivas de <code>siguiente()</code> es suficiente para que todas las hebras que estuvieran bloqueadas puedan continuar.</p> <p>El esquema de la clase es el siguiente:</p> <pre><code>public class Secuenciador  {\n    private int numero = 0;\n\n    public int siguiente() {...}\n    // devuelve 1 la primera vez que se invoca, 2 la segunda, etc.\n\n    public void esperarPar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea par\n\n    public void esperarImpar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea impar\n}\n</code></pre> Mostrar soluci\u00f3n <p>Los m\u00e9todos deben ser todos sincronizados. Adem\u00e1s, se deben incluir esperas condicionales en <code>esperarPar</code> y <code>esperarImpar</code>. Como el \u00fanico m\u00e9todo que modifica el valor del contador es <code>siguiente</code>, el aviso (<code>notifyAll</code>) para que las hebras bloqueadas vuelvan a comprobar la condici\u00f3n debe estar en este m\u00e9todo.</p> <p>Una posible implementaci\u00f3n es:</p> <pre><code>public class Secuenciador {\n    private int numero = 0;\n\n    public synchronized int siguiente() {\n        numero++;\n        notifyAll();\n        return numero;\n    }\n\n    public synchronized void esperarPar() {\n        while (numero % 2 != 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n\n    public synchronized void esperarImpar() {\n        while (numero % 2 == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2012/p2/#problema-3","title":"Problema 3","text":""},{"location":"exams/2012/p2/#a-4-puntos_1","title":"A. (4 puntos)","text":"<p>Modifique la clase <code>Monitor.java</code> de la pr\u00e1ctica 1 donde se han definido una serie de celdas como zona exclusiva en la que s\u00f3lo puede haber una pieza dentro (o un marciano, o un jugador). Por ejemplo,</p> <p></p> <p>Suponga que las celdas tienen un m\u00e9todo:</p> <pre><code>public boolean isZonaExclusiva()\n</code></pre> <p>El comportamiento de las piezas del juego es as\u00ed:</p> <ul> <li> <p>Cuando un jugador intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, debe buscar otra celda.</p> </li> <li> <p>Cuando un marciano intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, espera a que se libere.</p> </li> <li> <p>Tanto marcianos como jugador, cuando salen de la zona exclusiva hacia una celda que no lo es, liberan a los marcianos que pudieran estar esperando.</p> </li> </ul> <p>Sugerencia: se recomienda disponer de un campo</p> <pre><code>private Object ocupado;\n</code></pre> <p>que se inicia a <code>null</code> y sirve para indicar qu\u00e9 objeto (jugador o marciano) est\u00e1 dentro de la zona. Sirve para comprobar si hay alguien dentro:</p> <pre><code>private boolean estaZonaOcupada() { return ocupado != null; }\n</code></pre> <p>y para saber si salen:</p> <pre><code>private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n    return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n}\n\nprivate boolean estoySaliendo(Marciano marciano, Celda celda2) {\n    return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.pract1;\npublic class MonitorExtendido extends Monitor {\n\n    private final Laberinto laberinto;\n    private Object ocupado;\n\n    public MonitorExtendido(Laberinto laberinto) {\n        super(laberinto);\n        this.laberinto = laberinto;\n    }\n\n    public synchronized void mueveJugador(Jugador jugador, Celda celda2)\n            throws JugadorComido {\n\n        if (celda2.isZonaExclusiva()) {\n            if (estaZonaOcupada() &amp;&amp; ocupado != jugador)\n                return;\n            else\n                ocupado = jugador;\n        }\n\n        if (estoySaliendo(jugador, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            throw new JugadorComido();\n        }\n\n        jugador.setCelda(celda2);\n\n        if (celda2.getTipo() == Tipo.LLAVE) {\n            laberinto.limpiaCepos();\n            notifyAll();\n        }\n    }\n\n    public synchronized void mueveMarciano(Marciano marciano, Celda celda2)\n            throws JugadorComido, InterruptedException {\n\n        if (celda2.isZonaExclusiva()) {\n            while (estaZonaOcupada() &amp;&amp; ocupado != marciano)\n                wait();\n            ocupado = marciano;\n        }\n\n        if (estoySaliendo(marciano, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            return;\n        }\n\n        if (celda2.getEstado() == Estado.JUGADOR) {\n            throw new JugadorComido();\n        }\n\n        marciano.setCelda(celda2);\n\n        while (celda2.getTipo() == Tipo.CEPO) {\n            wait();\n        }\n    }\n\n    private boolean estaZonaOcupada() {\n        return ocupado != null;\n    }\n\n    private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n        return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n    }\n\n    private boolean estoySaliendo(Marciano marciano, Celda celda2) {\n        return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n    }\n}\n</code></pre></p>"},{"location":"exams/2012/p2_ex01/","title":"P2 ex01","text":"","tags":["complejidad"]},{"location":"exams/2012/p2_ex01/#a-2-puntos","title":"A. (2 puntos)","text":"<p>Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads). <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre></p> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase Swap1 pueden utilizar simult\u00e1neamente la variable aux al invocar el m\u00e9todo swap. Por tanto, swap deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a aux.</p> <p>Por el contrario, en Swap2 la variable aux es local al m\u00e9todo swap, y cada hebra que lo invoca usa su propia copia de aux. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p>","tags":["complejidad"]},{"location":"exams/2012/p2_ex02/","title":"P2 ex02","text":"","tags":["complejidad"]},{"location":"exams/2012/p2_ex02/#a-4-puntos","title":"A. (4 puntos)","text":"<p>Escriba una clase con un contador interno, que se incrementa cada vez que se invoca el m\u00e9todo <code>siguiente()</code>. La clase debe poderse utilizar en un programa concurrente. Adem\u00e1s, la clase proporciona otros dos m\u00e9todos, <code>esperarPar()</code> y <code>esperarImpar()</code>, que hacen que la hebra (thread) que los invoca se quede bloqueada hasta que el valor del contador sea par o impar, respectivamente.</p> <p>Se supone que el intervalo entre dos invocaciones consecutivas de <code>siguiente()</code> es suficiente para que todas las hebras que estuvieran bloqueadas puedan continuar.</p> <p>El esquema de la clase es el siguiente:</p> <pre><code>public class Secuenciador  {\n    private int numero = 0;\n\n    public int siguiente() {...}\n    // devuelve 1 la primera vez que se invoca, 2 la segunda, etc.\n\n    public void esperarPar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea par\n\n    public void esperarImpar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea impar\n}\n</code></pre> Mostrar soluci\u00f3n <p>Los m\u00e9todos deben ser todos sincronizados. Adem\u00e1s, se deben incluir esperas condicionales en <code>esperarPar</code> y <code>esperarImpar</code>. Como el \u00fanico m\u00e9todo que modifica el valor del contador es <code>siguiente</code>, el aviso (<code>notifyAll</code>) para que las hebras bloqueadas vuelvan a comprobar la condici\u00f3n debe estar en este m\u00e9todo.</p> <p>Una posible implementaci\u00f3n es:</p> <pre><code>public class Secuenciador {\n    private int numero = 0;\n\n    public synchronized int siguiente() {\n        numero++;\n        notifyAll();\n        return numero;\n    }\n\n    public synchronized void esperarPar() {\n        while (numero % 2 != 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n\n    public synchronized void esperarImpar() {\n        while (numero % 2 == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p2_ex03/","title":"P2 ex03","text":"","tags":["complejidad"]},{"location":"exams/2012/p2_ex03/#a-4-puntos","title":"A. (4 puntos)","text":"<p>Modifique la clase <code>Monitor.java</code> de la pr\u00e1ctica 1 donde se han definido una serie de celdas como zona exclusiva en la que s\u00f3lo puede haber una pieza dentro (o un marciano, o un jugador). Por ejemplo,</p> <p></p> <p>Suponga que las celdas tienen un m\u00e9todo:</p> <pre><code>public boolean isZonaExclusiva()\n</code></pre> <p>El comportamiento de las piezas del juego es as\u00ed:</p> <ul> <li> <p>Cuando un jugador intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, debe buscar otra celda.</p> </li> <li> <p>Cuando un marciano intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, espera a que se libere.</p> </li> <li> <p>Tanto marcianos como jugador, cuando salen de la zona exclusiva hacia una celda que no lo es, liberan a los marcianos que pudieran estar esperando.</p> </li> </ul> <p>Sugerencia: se recomienda disponer de un campo</p> <pre><code>private Object ocupado;\n</code></pre> <p>que se inicia a <code>null</code> y sirve para indicar qu\u00e9 objeto (jugador o marciano) est\u00e1 dentro de la zona. Sirve para comprobar si hay alguien dentro:</p> <pre><code>private boolean estaZonaOcupada() { return ocupado != null; }\n</code></pre> <p>y para saber si salen:</p> <pre><code>private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n    return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n}\n\nprivate boolean estoySaliendo(Marciano marciano, Celda celda2) {\n    return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.pract1;\npublic class MonitorExtendido extends Monitor {\n\n    private final Laberinto laberinto;\n    private Object ocupado;\n\n    public MonitorExtendido(Laberinto laberinto) {\n        super(laberinto);\n        this.laberinto = laberinto;\n    }\n\n    public synchronized void mueveJugador(Jugador jugador, Celda celda2)\n            throws JugadorComido {\n\n        if (celda2.isZonaExclusiva()) {\n            if (estaZonaOcupada() &amp;&amp; ocupado != jugador)\n                return;\n            else\n                ocupado = jugador;\n        }\n\n        if (estoySaliendo(jugador, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            throw new JugadorComido();\n        }\n\n        jugador.setCelda(celda2);\n\n        if (celda2.getTipo() == Tipo.LLAVE) {\n            laberinto.limpiaCepos();\n            notifyAll();\n        }\n    }\n\n    public synchronized void mueveMarciano(Marciano marciano, Celda celda2)\n            throws JugadorComido, InterruptedException {\n\n        if (celda2.isZonaExclusiva()) {\n            while (estaZonaOcupada() &amp;&amp; ocupado != marciano)\n                wait();\n            ocupado = marciano;\n        }\n\n        if (estoySaliendo(marciano, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            return;\n        }\n\n        if (celda2.getEstado() == Estado.JUGADOR) {\n            throw new JugadorComido();\n        }\n\n        marciano.setCelda(celda2);\n\n        while (celda2.getTipo() == Tipo.CEPO) {\n            wait();\n        }\n    }\n\n    private boolean estaZonaOcupada() {\n        return ocupado != null;\n    }\n\n    private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n        return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n    }\n\n    private boolean estoySaliendo(Marciano marciano, Celda celda2) {\n        return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n    }\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2013/extra/","title":"Examen 2013 \u2014 Extraordinario","text":""},{"location":"exams/2013/extra/#ejercicio-1","title":"Ejercicio 1","text":"<p>La siguiente clase implementa un conjunto de enteros ordenados mediante un \u00e1rbol binario. El \u00e1rbol no contiene datos duplicados. <pre><code>public class Arbol {\n    private class Nodo {\n        int valor;\n        Nodo izq, der;\n    }\n\n    private Nodo raiz;\n    private int n; // n\u00famero de datos almacenados en el \u00e1rbol\n    ...\n    public int cuenta(int x) {...} // n\u00famero de valores &lt;= x\n    ...\n}\n</code></pre> - (a) (1,5 puntos) Escriba el m\u00e9todo <code>int cuenta(int x)</code> de forma que devuelva el n\u00famero de valores menores o iguales que <code>x</code> en el \u00e1rbol.</p> <p>Ejemplo:</p> <p>Si el \u00e1rbol contiene los valores (1,3,4,6,10,14), obtendremos  - cuenta(1) = 1  - cuenta(6) = 4  - cuenta(9) = 4</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo, utilizando un m\u00e9todo auxiliar recursivo, es la siguiente:</p> <p><pre><code>public int cuenta(int x) {\n    return cuenta(raiz, x);\n}\n\nprivate int cuenta(Nodo nodo, int x) {\n    if (nodo == null) {\n        return 0;\n    }\n\n    if (nodo.valor == x) { \n        // suma 1 y sigue buscando por la izquierda\n        return 1 + cuenta(nodo.izq, x);\n    } else if (nodo.valor &lt; x) { \n        // suma 1 y sigue buscando por los dos lados\n        return 1 + cuenta(nodo.izq, x) + cuenta(nodo.der, x);\n    } else { \n        // no suma y sigue buscando por la izquierda\n        return cuenta(nodo.izq, x);\n    }\n}\n</code></pre> El algoritmo usa la propiedad del \u00e1rbol binario de b\u00fasqueda de que todos los nodos que est\u00e1n en el sub\u00e1rbol izquierdo de uno dado tienen un valor menor que \u00e9ste. Por tanto, si se encuentra el valor <code>x</code> ya no hay que seguir buscando por su derecha. Si el valor del nodo es menor que <code>x</code>, puede haber nodos menores tanto a la izquierda como a la derecha. Por \u00faltimo, si el valor del nodo es mayor que <code>x</code>, basta con seguir contando por la izquierda, ya que los nodos que haya a la derecha ser\u00e1n tambi\u00e9n mayores que <code>x</code>.</p> <ul> <li>(b) (1,5 puntos) Calcule la complejidad del algoritmo, justificando el resultado ne</li> </ul> Mostrar soluci\u00f3n <p>Para la complejidad, observamos que se van recorriendo todos los nodos del \u00e1rbol, excepto cuando se encuentra un valor mayor que x, en cuyo caso se descarta el sub\u00e1rbol derecho.</p> <p>M\u00e1s en detalle, el m\u00e9todo cuenta tiene cuatro casos posibles. Si calculamos el n\u00famero de operaciones que se hacen cada vez que se ejecuta, tenemos - Sumas:     1) nodo == null:! T(n) = 0     2) nodo.valor == x! T(n) = 1 + T(n/2)     3) nodo.valor &lt; x! T(n) = 2 + 2T(n/2)     4) nodo.valor &gt; x! T(n) = T(n/2) - Llamadas recursivas:     1) nodo == null:! T(n) = 0     2) nodo.valor == x! T(n) = 1 + T(n/2)     3) nodo.valor &lt; x! T(n) = 1 + 2T(n/2)     4) nodo.valor &gt; x! T(n) = T(n/2) Suponiendo que el caso 3 es el m\u00e1s frecuente,     T(n) \u2248 1 + 2T(n/2) que es lineal, O(n).</p>"},{"location":"exams/2013/extra/#ejercicio-2","title":"Ejercicio 2","text":"<ul> <li>(a) (3 puntos) Escriba un monitor en Java que controle el acceso a un parking de coches. El parking tiene un n\u00famero de plazas N y dispone de dos accesos, Este y Oeste.</li> </ul> <p>Si el parking no est\u00e1 lleno, se admiten entradas por ambos accesos libremente. Si el parking est\u00e1 lleno, los coches deben esperar a que haya plazas disponibles. Cuando queda una plaza libre, el monitor debe alternar los accesos de entrada entre Este y Oeste. Cuando un coche abandona el parking, se considera irrelevante el acceso que usa para salir.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es el siguiente:</p> <pre><code>class Monitor {\n    ...\n    Monitor(int numPlazas) { ... }\n    ...\n    entraCochePorEste(...) { ... }\n    ...\n    entraCochePorOeste(...) { ... }\n    ...\n    saleCoche(...) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n correcta es: <pre><code>public class Monitor {\n\n    private int numPlazas, numCoches;\n    private boolean turnoEste, turnoOeste;\n    private int esperaEnEste, esperaEnOeste;\n\n    public Monitor(int numPlazas) {\n        this.numPlazas = numPlazas;\n        numCoches = 0;\n        turnoEste = turnoOeste = true;\n        esperaEnEste = esperaEnOeste = 0;\n    }\n\n    public synchronized void entraCochePorEste() throws InterruptedException {\n        esperaEnEste++;\n        while ((numCoches &gt;= numPlazas) || (turnoOeste &amp;&amp; (esperaEnOeste &gt; 0))) {\n            wait();\n        }\n        esperaEnEste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = false;\n            turnoOeste = true;\n        }\n    }\n\n    public synchronized void entraCochePorOeste() throws InterruptedException {\n        esperaEnOeste++;\n        while ((numCoches &gt;= numPlazas) || (turnoEste &amp;&amp; (esperaEnEste &gt; 0))) {\n            wait();\n        }\n        esperaEnOeste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = true;\n            turnoOeste = false;\n        }\n    }\n\n    public synchronized void saleCoche() {\n        numCoches--;\n        notifyAll();\n    }\n}\n</code></pre></p>"},{"location":"exams/2013/extra/#ejercicio-3","title":"Ejercicio 3","text":"<ul> <li>(a) (4 puntos) Se desea programar una aplicaci\u00f3n compuesta por tres actividades: <code>MainActivity</code> (actividad inicial), <code>ActivityA</code>, y <code>ActivityB</code>. La tarea de <code>MainActivity</code> consiste en mostrar una lista con dos opciones al usuario: lanzar y terminar.</li> </ul> <p>Si el usuario pulsa lanzar, se lanza la actividad <code>ActivityA</code>, que devuelve como resultado un c\u00f3digo que indica si la actividad ha terminado con \u00e9xito o no (<code>RESULT_OK</code> o <code>RESULT_CANCELED</code>). Si el resultado es <code>RESULT_OK</code>, se lanza la actividad <code>ActivityB</code>, sin esperar a que devuelva ning\u00fan resultado.</p> <p>Mire la soluci\u00f3n que se proporciona a continuaci\u00f3n e indique si es correcta o no. En caso de tener fallos, indique qu\u00e9 fallos hay y c\u00f3mo se corrigen.</p> <pre><code>public class MainActivity extends Activity {\n\n    public static final int LANZA_A = 0;\n    public static final int LANZA_B = 1;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        String[] acciones = {\"lanzar\", \"terminar\"};\n        setListAdapter(new ArrayAdapter&lt;String&gt;(\n                this,\n                android.R.layout.simple_list_item_1,\n                acciones));\n    }\n\n    private void lanza() {\n        Intent lanzaA = new Intent(this, ActivityA.class);\n        if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {\n            Intent lanzaB = new Intent(this, ActivityB.class);\n            startActivityForResult(lanzaB, LANZA_B);\n        }\n    }\n\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        super.onListItemClick(l, v, position, id);\n        switch (position) {\n            case 0: {\n                lanza();\n                break;\n            }\n            case 1: {\n                finish();\n                break;\n            }\n            default: { }\n        }\n    }\n\n    public static void main(String[] args) {\n        onCreate(this);\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Se indican los cambios sobre el c\u00f3digo original ```java public class MainActivity extends ~~Activity~~ ListActivity {     public static final int LANZA_A = 0;     public static final int LANZA_B = 1;</p> <pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    String[] acciones = {\"lanzar\", \"terminar\"};\n    setListAdapter(new ArrayAdapter&lt;String&gt;(\n            this,\n            android.R.layout.simple_list_item_1,\n            acciones));\n}\n\nprivate void lanza() {\n    Intent lanzaA = new Intent(this, ActivityA.class);\n    startActivityForResult(lanzaA, LANZA_A);\n    ~~if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {~~\n        ~~Intent lanzaB = new Intent(this, ActivityB.class);~~\n        ~~startActivityForResult(lanzaB, LANZA_B);~~\n    ~~}~~\n}\n\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == LANZA_A) {\n        if (resultCode == RESULT_OK) {\n            Intent lanzaB = new Intent(this, ActivityB.class);\n            startActivity(lanzaB);\n        }\n    }\n}\n\n@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    switch (position) {\n        case 0: {lanza(); break;}\n        case 1: {finish(); break;}\n        default: { }\n        }\n    }\n\n    ~~public static void main(String[] args) {~~    // Las actividades en Android siguen un ciclo de vida,\n        ~~onCreate(this);~~                         // no tienen main\n    ~~}~~\n}\n</code></pre>"},{"location":"exams/2013/extra/#ejercicio-4","title":"Ejercicio 4","text":"<p>Se desea modificar la aplicaci\u00f3n <code>Teleconote</code> de manera que la pantalla con la lista de notas (controlada por la actividad <code>ListaNotasActivity</code>) se comporte de forma que, al pinchar en una nota, si est\u00e1 cifrada, se descifre sin pedir ninguna contrase\u00f1a. Si la nota no est\u00e1 cifrada, se deja como est\u00e1.</p> <p>Obs\u00e9rvese que no hay que mostrar el contenido de la nota, s\u00f3lo descifrarla en caso necesario desde <code>ListaNotasActivity</code>.</p> <p>Puede suponer que la clase que contiene la tarea as\u00edncrona, que program\u00f3 en <code>DetalleNotaActivity</code>, est\u00e1 refactorizada como una clase de paquete, de la siguiente forma:</p> <pre><code>public class Cifrar extends AsyncTask&lt;?,?,?&gt; {\n    protected void onPreExecute() {...}\n\n    @Override\n    protected ... doInBackground(...) {...}\n\n    protected void onProgressUpdate(...) {...}\n\n    protected void onPostExecute(...) {...}\n}\n</code></pre> <p>La tarea recibe varias cadenas (el t\u00edtulo y contenido de la nota, as\u00ed como su id), comunica el n\u00famero de caracteres cifrados o descifrados, y devuelve el objeto nota con los campos <code>titulo</code> y <code>contenido</code> descifrados.</p> <ul> <li>(a) (3 puntos) Indique qu\u00e9 signatura deber\u00eda tener la clase <code>Cifrar</code>.</li> </ul> Mostrar soluci\u00f3n <p>La signatura correcta de la clase <code>Cifrar</code> es:</p> <pre><code>Cifrar&lt;String, Integer, Nota&gt;\n</code></pre> <ul> <li>(b) (7 puntos) Indique los cambios necesarios para que se ejecute la tarea de descifrado con esta modificaci\u00f3n. Tenga en cuenta que los cambios deben almacenarse en la base de datos, y que debe actualizarse la pantalla de <code>ListaNotasActivity</code>.</li> </ul> <p>NOTA: Lim\u00edtese a hacer los cambios necesarios. No es necesario volver a escribir el c\u00f3digo de <code>Cifrar</code> ni las partes de <code>ListaNotasActivity</code> que no haya que modificar.</p> Mostrar soluci\u00f3n <p>A continuaci\u00f3n se muestran \u00fanicamente los cambios necesarios para ejecutar la tarea de descifrado desde <code>ListaNotasActivity</code>. Los cambios relevantes se destacan conceptualmente.  <pre><code>@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = notasCursor;\n    c.moveToPosition(position);\n\n    Nota nota = getNota(c);\n    if ((nota != null) &amp;&amp; (nota.isCifrado())) {\n        new Cifrar().execute(\n            nota.getContenido(),\n            nota.getTitulo(),\n            nota.getCategoria(),\n            id + \"\"\n        );\n    }\n    startActivityForResult(intent, MODIFICA_NOTA);\n}\n</code></pre></p> <pre><code>private class Cifrar extends AsyncTask&lt;String, Integer, Nota&gt; {\n\n    private final String CLAVE = new String(\"miclave\");\n    private long id = -1;\n\n    // Se puede acceder a la UI\n    @Override\n    protected void onPreExecute() {\n    }\n\n    // M\u00e9todo de descifrado (no se modifica)\n    private String descifra(String texto, String clave) {\n        // C\u00f3digo existente que almacena el texto\n        // descifrado en un buffer\n        ...\n        publishProgress(i);\n        return buffer.toString();\n    }\n\n    // Ejecuci\u00f3n en segundo plano\n    @Override\n    protected Nota doInBackground(String... params) {\n        Log.i(TAG, \"doInBackground\");\n\n        String titulo = params[0];\n        String contenido = params[1];\n        String categoria = params[2];\n\n        if ((titulo == null) || (contenido == null) || (categoria == null))\n            return null;\n\n        try {\n            id = Long.parseLong(params[3]);\n        } catch (NumberFormatException e) {\n            return null;\n        }\n\n        String tituloDescifrado = descifra(titulo, CLAVE);\n        String contenidoDescifrado = descifra(contenido, CLAVE);\n\n        Nota miNota = new Nota(\n            tituloDescifrado,\n            contenidoDescifrado,\n            categoria,\n            false\n        );\n        return miNota;\n    }\n\n    // Actualizaciones de progreso en la UI\n    @Override\n    protected void onProgressUpdate(Integer... value) {\n        super.onProgressUpdate(value);\n        Log.i(TAG, \"onProgressUpdate\");\n        texto.append(\"\nEjecut\u00e1ndose...\" + value[0]);\n        // Mostrar progreso por pantalla\n    }\n\n    // Al finalizar, se actualiza la BBDD y la lista\n    @Override\n    protected void onPostExecute(Nota miNota) {\n        Log.i(TAG, \"onPostExecute, nota Cifrada\");\n        notaDbAdaptador.actualizaNota(id, miNota);\n        cursorAdapter.notifyDataSetChanged();\n        actualizaLista();\n    }\n}\n</code></pre>"},{"location":"exams/2013/extra01/","title":"Extra01","text":"<p>La siguiente clase implementa un conjunto de enteros ordenados mediante un \u00e1rbol binario. El \u00e1rbol no contiene datos duplicados. <pre><code>public class Arbol {\n    private class Nodo {\n        int valor;\n        Nodo izq, der;\n    }\n\n    private Nodo raiz;\n    private int n; // n\u00famero de datos almacenados en el \u00e1rbol\n    ...\n    public int cuenta(int x) {...} // n\u00famero de valores &lt;= x\n    ...\n}\n</code></pre> - (a) (1,5 puntos) Escriba el m\u00e9todo <code>int cuenta(int x)</code> de forma que devuelva el n\u00famero de valores menores o iguales que <code>x</code> en el \u00e1rbol.</p> <p>Ejemplo:</p> <p>Si el \u00e1rbol contiene los valores (1,3,4,6,10,14), obtendremos  - cuenta(1) = 1  - cuenta(6) = 4  - cuenta(9) = 4</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo, utilizando un m\u00e9todo auxiliar recursivo, es la siguiente:</p> <p><pre><code>public int cuenta(int x) {\n    return cuenta(raiz, x);\n}\n\nprivate int cuenta(Nodo nodo, int x) {\n    if (nodo == null) {\n        return 0;\n    }\n\n    if (nodo.valor == x) { \n        // suma 1 y sigue buscando por la izquierda\n        return 1 + cuenta(nodo.izq, x);\n    } else if (nodo.valor &lt; x) { \n        // suma 1 y sigue buscando por los dos lados\n        return 1 + cuenta(nodo.izq, x) + cuenta(nodo.der, x);\n    } else { \n        // no suma y sigue buscando por la izquierda\n        return cuenta(nodo.izq, x);\n    }\n}\n</code></pre> El algoritmo usa la propiedad del \u00e1rbol binario de b\u00fasqueda de que todos los nodos que est\u00e1n en el sub\u00e1rbol izquierdo de uno dado tienen un valor menor que \u00e9ste. Por tanto, si se encuentra el valor <code>x</code> ya no hay que seguir buscando por su derecha. Si el valor del nodo es menor que <code>x</code>, puede haber nodos menores tanto a la izquierda como a la derecha. Por \u00faltimo, si el valor del nodo es mayor que <code>x</code>, basta con seguir contando por la izquierda, ya que los nodos que haya a la derecha ser\u00e1n tambi\u00e9n mayores que <code>x</code>.</p> <ul> <li>(b) (1,5 puntos) Calcule la complejidad del algoritmo, justificando el resultado ne</li> </ul> Mostrar soluci\u00f3n <p>Para la complejidad, observamos que se van recorriendo todos los nodos del \u00e1rbol, excepto cuando se encuentra un valor mayor que x, en cuyo caso se descarta el sub\u00e1rbol derecho.</p> <p>M\u00e1s en detalle, el m\u00e9todo cuenta tiene cuatro casos posibles. Si calculamos el n\u00famero de operaciones que se hacen cada vez que se ejecuta, tenemos - Sumas:     1) nodo == null:! T(n) = 0     2) nodo.valor == x! T(n) = 1 + T(n/2)     3) nodo.valor &lt; x! T(n) = 2 + 2T(n/2)     4) nodo.valor &gt; x! T(n) = T(n/2) - Llamadas recursivas:     1) nodo == null:! T(n) = 0     2) nodo.valor == x! T(n) = 1 + T(n/2)     3) nodo.valor &lt; x! T(n) = 1 + 2T(n/2)     4) nodo.valor &gt; x! T(n) = T(n/2) Suponiendo que el caso 3 es el m\u00e1s frecuente,     T(n) \u2248 1 + 2T(n/2) que es lineal, O(n).</p>","tags":["complejidad"]},{"location":"exams/2013/extra02/","title":"Extra02","text":"<ul> <li>(a) (3 puntos) Escriba un monitor en Java que controle el acceso a un parking de coches. El parking tiene un n\u00famero de plazas N y dispone de dos accesos, Este y Oeste.</li> </ul> <p>Si el parking no est\u00e1 lleno, se admiten entradas por ambos accesos libremente. Si el parking est\u00e1 lleno, los coches deben esperar a que haya plazas disponibles. Cuando queda una plaza libre, el monitor debe alternar los accesos de entrada entre Este y Oeste. Cuando un coche abandona el parking, se considera irrelevante el acceso que usa para salir.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es el siguiente:</p> <pre><code>class Monitor {\n    ...\n    Monitor(int numPlazas) { ... }\n    ...\n    entraCochePorEste(...) { ... }\n    ...\n    entraCochePorOeste(...) { ... }\n    ...\n    saleCoche(...) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n correcta es: <pre><code>public class Monitor {\n\n    private int numPlazas, numCoches;\n    private boolean turnoEste, turnoOeste;\n    private int esperaEnEste, esperaEnOeste;\n\n    public Monitor(int numPlazas) {\n        this.numPlazas = numPlazas;\n        numCoches = 0;\n        turnoEste = turnoOeste = true;\n        esperaEnEste = esperaEnOeste = 0;\n    }\n\n    public synchronized void entraCochePorEste() throws InterruptedException {\n        esperaEnEste++;\n        while ((numCoches &gt;= numPlazas) || (turnoOeste &amp;&amp; (esperaEnOeste &gt; 0))) {\n            wait();\n        }\n        esperaEnEste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = false;\n            turnoOeste = true;\n        }\n    }\n\n    public synchronized void entraCochePorOeste() throws InterruptedException {\n        esperaEnOeste++;\n        while ((numCoches &gt;= numPlazas) || (turnoEste &amp;&amp; (esperaEnEste &gt; 0))) {\n            wait();\n        }\n        esperaEnOeste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = true;\n            turnoOeste = false;\n        }\n    }\n\n    public synchronized void saleCoche() {\n        numCoches--;\n        notifyAll();\n    }\n}\n</code></pre></p>","tags":["monitores"]},{"location":"exams/2013/extra03/","title":"Extra03","text":"<ul> <li>(a) (4 puntos) Se desea programar una aplicaci\u00f3n compuesta por tres actividades: <code>MainActivity</code> (actividad inicial), <code>ActivityA</code>, y <code>ActivityB</code>. La tarea de <code>MainActivity</code> consiste en mostrar una lista con dos opciones al usuario: lanzar y terminar.</li> </ul> <p>Si el usuario pulsa lanzar, se lanza la actividad <code>ActivityA</code>, que devuelve como resultado un c\u00f3digo que indica si la actividad ha terminado con \u00e9xito o no (<code>RESULT_OK</code> o <code>RESULT_CANCELED</code>). Si el resultado es <code>RESULT_OK</code>, se lanza la actividad <code>ActivityB</code>, sin esperar a que devuelva ning\u00fan resultado.</p> <p>Mire la soluci\u00f3n que se proporciona a continuaci\u00f3n e indique si es correcta o no. En caso de tener fallos, indique qu\u00e9 fallos hay y c\u00f3mo se corrigen.</p> <pre><code>public class MainActivity extends Activity {\n\n    public static final int LANZA_A = 0;\n    public static final int LANZA_B = 1;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        String[] acciones = {\"lanzar\", \"terminar\"};\n        setListAdapter(new ArrayAdapter&lt;String&gt;(\n                this,\n                android.R.layout.simple_list_item_1,\n                acciones));\n    }\n\n    private void lanza() {\n        Intent lanzaA = new Intent(this, ActivityA.class);\n        if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {\n            Intent lanzaB = new Intent(this, ActivityB.class);\n            startActivityForResult(lanzaB, LANZA_B);\n        }\n    }\n\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        super.onListItemClick(l, v, position, id);\n        switch (position) {\n            case 0: {\n                lanza();\n                break;\n            }\n            case 1: {\n                finish();\n                break;\n            }\n            default: { }\n        }\n    }\n\n    public static void main(String[] args) {\n        onCreate(this);\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Se indican los cambios sobre el c\u00f3digo original ```java public class MainActivity extends ~~Activity~~ ListActivity {     public static final int LANZA_A = 0;     public static final int LANZA_B = 1;</p> <pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    String[] acciones = {\"lanzar\", \"terminar\"};\n    setListAdapter(new ArrayAdapter&lt;String&gt;(\n            this,\n            android.R.layout.simple_list_item_1,\n            acciones));\n}\n\nprivate void lanza() {\n    Intent lanzaA = new Intent(this, ActivityA.class);\n    startActivityForResult(lanzaA, LANZA_A);\n    ~~if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {~~\n        ~~Intent lanzaB = new Intent(this, ActivityB.class);~~\n        ~~startActivityForResult(lanzaB, LANZA_B);~~\n    ~~}~~\n}\n\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == LANZA_A) {\n        if (resultCode == RESULT_OK) {\n            Intent lanzaB = new Intent(this, ActivityB.class);\n            startActivity(lanzaB);\n        }\n    }\n}\n\n@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    switch (position) {\n        case 0: {lanza(); break;}\n        case 1: {finish(); break;}\n        default: { }\n        }\n    }\n\n    ~~public static void main(String[] args) {~~    // Las actividades en Android siguen un ciclo de vida,\n        ~~onCreate(this);~~                         // no tienen main\n    ~~}~~\n}\n</code></pre>","tags":["android"]},{"location":"exams/2013/extra04/","title":"Extra04","text":"<p>Se desea modificar la aplicaci\u00f3n <code>Teleconote</code> de manera que la pantalla con la lista de notas (controlada por la actividad <code>ListaNotasActivity</code>) se comporte de forma que, al pinchar en una nota, si est\u00e1 cifrada, se descifre sin pedir ninguna contrase\u00f1a. Si la nota no est\u00e1 cifrada, se deja como est\u00e1.</p> <p>Obs\u00e9rvese que no hay que mostrar el contenido de la nota, s\u00f3lo descifrarla en caso necesario desde <code>ListaNotasActivity</code>.</p> <p>Puede suponer que la clase que contiene la tarea as\u00edncrona, que program\u00f3 en <code>DetalleNotaActivity</code>, est\u00e1 refactorizada como una clase de paquete, de la siguiente forma:</p> <pre><code>public class Cifrar extends AsyncTask&lt;?,?,?&gt; {\n    protected void onPreExecute() {...}\n\n    @Override\n    protected ... doInBackground(...) {...}\n\n    protected void onProgressUpdate(...) {...}\n\n    protected void onPostExecute(...) {...}\n}\n</code></pre> <p>La tarea recibe varias cadenas (el t\u00edtulo y contenido de la nota, as\u00ed como su id), comunica el n\u00famero de caracteres cifrados o descifrados, y devuelve el objeto nota con los campos <code>titulo</code> y <code>contenido</code> descifrados.</p> <ul> <li>(a) (3 puntos) Indique qu\u00e9 signatura deber\u00eda tener la clase <code>Cifrar</code>.</li> </ul> Mostrar soluci\u00f3n <p>La signatura correcta de la clase <code>Cifrar</code> es:</p> <pre><code>Cifrar&lt;String, Integer, Nota&gt;\n</code></pre> <ul> <li>(b) (7 puntos) Indique los cambios necesarios para que se ejecute la tarea de descifrado con esta modificaci\u00f3n. Tenga en cuenta que los cambios deben almacenarse en la base de datos, y que debe actualizarse la pantalla de <code>ListaNotasActivity</code>.</li> </ul> <p>NOTA: Lim\u00edtese a hacer los cambios necesarios. No es necesario volver a escribir el c\u00f3digo de <code>Cifrar</code> ni las partes de <code>ListaNotasActivity</code> que no haya que modificar.</p> Mostrar soluci\u00f3n <p>A continuaci\u00f3n se muestran \u00fanicamente los cambios necesarios para ejecutar la tarea de descifrado desde <code>ListaNotasActivity</code>. Los cambios relevantes se destacan conceptualmente.  <pre><code>@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = notasCursor;\n    c.moveToPosition(position);\n\n    Nota nota = getNota(c);\n    if ((nota != null) &amp;&amp; (nota.isCifrado())) {\n        new Cifrar().execute(\n            nota.getContenido(),\n            nota.getTitulo(),\n            nota.getCategoria(),\n            id + \"\"\n        );\n    }\n    startActivityForResult(intent, MODIFICA_NOTA);\n}\n</code></pre></p> <pre><code>private class Cifrar extends AsyncTask&lt;String, Integer, Nota&gt; {\n\n    private final String CLAVE = new String(\"miclave\");\n    private long id = -1;\n\n    // Se puede acceder a la UI\n    @Override\n    protected void onPreExecute() {\n    }\n\n    // M\u00e9todo de descifrado (no se modifica)\n    private String descifra(String texto, String clave) {\n        // C\u00f3digo existente que almacena el texto\n        // descifrado en un buffer\n        ...\n        publishProgress(i);\n        return buffer.toString();\n    }\n\n    // Ejecuci\u00f3n en segundo plano\n    @Override\n    protected Nota doInBackground(String... params) {\n        Log.i(TAG, \"doInBackground\");\n\n        String titulo = params[0];\n        String contenido = params[1];\n        String categoria = params[2];\n\n        if ((titulo == null) || (contenido == null) || (categoria == null))\n            return null;\n\n        try {\n            id = Long.parseLong(params[3]);\n        } catch (NumberFormatException e) {\n            return null;\n        }\n\n        String tituloDescifrado = descifra(titulo, CLAVE);\n        String contenidoDescifrado = descifra(contenido, CLAVE);\n\n        Nota miNota = new Nota(\n            tituloDescifrado,\n            contenidoDescifrado,\n            categoria,\n            false\n        );\n        return miNota;\n    }\n\n    // Actualizaciones de progreso en la UI\n    @Override\n    protected void onProgressUpdate(Integer... value) {\n        super.onProgressUpdate(value);\n        Log.i(TAG, \"onProgressUpdate\");\n        texto.append(\"\nEjecut\u00e1ndose...\" + value[0]);\n        // Mostrar progreso por pantalla\n    }\n\n    // Al finalizar, se actualiza la BBDD y la lista\n    @Override\n    protected void onPostExecute(Nota miNota) {\n        Log.i(TAG, \"onPostExecute, nota Cifrada\");\n        notaDbAdaptador.actualizaNota(id, miNota);\n        cursorAdapter.notifyDataSetChanged();\n        actualizaLista();\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2013/p1/","title":"Examen 2013 \u2014 Parcial 1","text":""},{"location":"exams/2013/p1/#problema-1","title":"Problema 1","text":"<p>Tenemos arrays de datos que est\u00e1n ordenados en orden ascendente, pero con los datos desplazados una distancia \\( h \\ge 0 \\). Por ejemplo:</p> h array 0 [1, 3, 5, 7, 11, 13] 1 [13, 1, 3, 5, 7, 11] 2 [11, 13, 1, 3, 5, 7] 3 [7, 11, 13, 1, 3, 5] \u2026 \u2026 <p>Supondremos que todos los datos del array son distintos.</p> <ul> <li>(a) (1,5 puntos) Dados un array y el desplazamiento \\( h \\), desarrolle un algoritmo de complejidad O(1) que devuelva el n\u00famero mayor conociendo el array y el desplazamiento: <pre><code>int getMayor1(int[] array, int h)\n</code></pre> Demuestre que el algoritmo es efectivamente de complejidad O(1).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor1(int[] array, int h) {\n    return array[(array.length - 1 + h) % array.length];\n}\n</code></pre> El algoritmo es de complejidad O(1) porque el n\u00famero de pasos del algoritmo es independiente de n.</p> <ul> <li>(b) (1,5 puntos) Desarrolle un algoritmo de complejidad O(n) que devuelva el n\u00famero mayor conociendo el array, pero sin saber el desplazamiento: <pre><code>int getMayor2(int[] array)\n</code></pre> Demuestre que el algoritmo es de complejidad O(n)</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor2(int[] array) {\n    int mayor = Integer.MIN_VALUE;\n    for (int num : array) {\n        if (mayor &lt; num)\n            mayor = num;\n    }\n    return mayor;\n}\n</code></pre> El algoritmo es de complejidad O(n) porque es un bucle que se ejecuta n veces.</p> <ul> <li>(c) (2 puntos) Desarrolle un algoritmo de complejidad O(log n) que devuelva el n\u00famero mayor conociendo el array, pero sin conocer el desplazamiento: <pre><code>int getMayor3(int[] array)\n</code></pre></li> </ul> <p>Pista:</p> <p>Hay que usar el algoritmo del apartado a) probando con diferentes valores de h. Para un valor de h: - Sabemos que es el correcto si el n\u00famero siguiente es menor que <code>array[h]</code>. - Sabemos si hay que aumentar o disminuir h comparando <code>array[h]</code> con <code>array[0]</code>.</p> Mostrar soluci\u00f3n <p>La siguiente soluci\u00f3n utiliza un m\u00e9todo auxiliar, <code>busca</code>:</p> <p><pre><code>private static int getMayor3(int[] array) {\n    return busca(array, 0, array.length);\n    }\n\n    private static int busca(int[] array, int a, int z) {\n        if (a &gt;= z)\n            return array[a];\n        int h = (a + z) / 2;\n        int num = array[h];\n        int num_1 = array[(h + 1) % array.length];\n        if (num &gt; num_1)\n            return num;\n        if (array[0] &lt; num)\n            return busca(array, h + 1, z);\n        else\n            return busca(array, a, h);\n    }\n</code></pre> El algoritmo es de complejidad O(log n) porque es un esquema de divisi\u00f3n sucesiva. M\u00e1s desarrollado: - Al principio, h puede estar entre O y N-1 - Tras 1 paso, h puede estar entre (O y N/2) o entre (N/2 y N); es decir, hemos reducido las opciones a la mitad (N/2) - Tras k pasos, el rango es N/2<sup>k</sup>; de forma que el rango se reduce a 1 (h encontrado) cuando 1 &lt;= N/2<sup>k</sup> -&gt; k=log(N)1 &lt;= N / 2^k  \u279c  k = log\u2082(N) \u2282 O(log N)</p>"},{"location":"exams/2013/p1/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) Sean tres hebras (threads), T1, T2 y T3, que utilizan tres recursos, R1, R2 y R3.</li> </ul> <p>La hebra T1 s\u00f3lo necesita el recurso R1.  </p> <p>La hebra T2 necesita los recursos R2 y R3.  </p> <p>Por \u00faltimo, la hebra T3 requiere los tres recursos, R1, R2 y R3.</p> <p>Escriba un monitor que controle el acceso de las hebras a los recursos. Cada hebra solicita los recursos que necesita invocando un m\u00e9todo del monitor. Cuando una hebra termina de usar los recursos que necesita, lo indica para que otras hebras puedan usarlos. El monitor ha de asegurar que ning\u00fan recurso es utilizado por m\u00e1s de una hebra a la vez.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es:</p> <pre><code>class Monitor {\n    \u2026\n    \u2026 requiereR1 (\u2026) { \u2026 }\n    \u2026 requiereR2_R3 (\u2026) { \u2026 }\n    \u2026 requiereR1_R2_R3 ( \u2026) { \u2026}\n    \u2026 liberaR1(\u2026) { \u2026 }\n    \u2026 liberaR2_R3 (\u2026) { \u2026 }\n    \u2026 liberaR1_R2_R3 ( \u2026) { \u2026}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n ser\u00eda:</p> <pre><code>public class Monitor {\n    private boolean ocupadoR1 = false;\n    private boolean ocupadoR2 = false;\n    private boolean ocupadoR3 = false;\n\n    public synchronized void requiereR1 () \n               throws InterruptedException {\n        while (ocupadoR1) wait();\n        ocupadoR1 = true;\n    }\n\n    public synchronized void requiereR2_R3() \n               throws InterruptedException {\n        while (ocupadoR2 || ocupadoR3) wait();\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void requiereR1_R2_R3 () \n                   throws InterruptedException { \n        while (ocupadoR1 || ocupadoR2 || ocupadoR3) wait();\n        ocupadoR1 = true;\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void liberaR1() {\n        ocupadoR1 = false;\n        notifyAll();\n    }\n\n    public synchronized void libreraR2_R3 () {\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll();\n    }\n\n    public synchronized void liberaR1_R2_R3 () {\n        ocupadoR1 = false;\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll(); \n    }\n}\n</code></pre>"},{"location":"exams/2013/p1_ex01/","title":"P1 ex01","text":"<p>Tenemos arrays de datos que est\u00e1n ordenados en orden ascendente, pero con los datos desplazados una distancia \\( h \\ge 0 \\). Por ejemplo:</p> h array 0 [1, 3, 5, 7, 11, 13] 1 [13, 1, 3, 5, 7, 11] 2 [11, 13, 1, 3, 5, 7] 3 [7, 11, 13, 1, 3, 5] \u2026 \u2026 <p>Supondremos que todos los datos del array son distintos.</p> <ul> <li>(a) (1,5 puntos) Dados un array y el desplazamiento \\( h \\), desarrolle un algoritmo de complejidad O(1) que devuelva el n\u00famero mayor conociendo el array y el desplazamiento: <pre><code>int getMayor1(int[] array, int h)\n</code></pre> Demuestre que el algoritmo es efectivamente de complejidad O(1).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor1(int[] array, int h) {\n    return array[(array.length - 1 + h) % array.length];\n}\n</code></pre> El algoritmo es de complejidad O(1) porque el n\u00famero de pasos del algoritmo es independiente de n.</p> <ul> <li>(b) (1,5 puntos) Desarrolle un algoritmo de complejidad O(n) que devuelva el n\u00famero mayor conociendo el array, pero sin saber el desplazamiento: <pre><code>int getMayor2(int[] array)\n</code></pre> Demuestre que el algoritmo es de complejidad O(n)</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor2(int[] array) {\n    int mayor = Integer.MIN_VALUE;\n    for (int num : array) {\n        if (mayor &lt; num)\n            mayor = num;\n    }\n    return mayor;\n}\n</code></pre> El algoritmo es de complejidad O(n) porque es un bucle que se ejecuta n veces.</p> <ul> <li>(c) (2 puntos) Desarrolle un algoritmo de complejidad O(log n) que devuelva el n\u00famero mayor conociendo el array, pero sin conocer el desplazamiento: <pre><code>int getMayor3(int[] array)\n</code></pre></li> </ul> <p>Pista:</p> <p>Hay que usar el algoritmo del apartado a) probando con diferentes valores de h. Para un valor de h: - Sabemos que es el correcto si el n\u00famero siguiente es menor que <code>array[h]</code>. - Sabemos si hay que aumentar o disminuir h comparando <code>array[h]</code> con <code>array[0]</code>.</p> Mostrar soluci\u00f3n <p>La siguiente soluci\u00f3n utiliza un m\u00e9todo auxiliar, <code>busca</code>:</p> <p><pre><code>private static int getMayor3(int[] array) {\n    return busca(array, 0, array.length);\n    }\n\n    private static int busca(int[] array, int a, int z) {\n        if (a &gt;= z)\n            return array[a];\n        int h = (a + z) / 2;\n        int num = array[h];\n        int num_1 = array[(h + 1) % array.length];\n        if (num &gt; num_1)\n            return num;\n        if (array[0] &lt; num)\n            return busca(array, h + 1, z);\n        else\n            return busca(array, a, h);\n    }\n</code></pre> El algoritmo es de complejidad O(log n) porque es un esquema de divisi\u00f3n sucesiva. M\u00e1s desarrollado: - Al principio, h puede estar entre O y N-1 - Tras 1 paso, h puede estar entre (O y N/2) o entre (N/2 y N); es decir, hemos reducido las opciones a la mitad (N/2) - Tras k pasos, el rango es N/2<sup>k</sup>; de forma que el rango se reduce a 1 (h encontrado) cuando 1 &lt;= N/2<sup>k</sup> -&gt; k=log(N)1 &lt;= N / 2^k  \u279c  k = log\u2082(N) \u2282 O(log N)</p>","tags":["complejidad"]},{"location":"exams/2013/p1_ex02/","title":"P1 ex02","text":"<ul> <li>(a) (5 puntos) Sean tres hebras (threads), T1, T2 y T3, que utilizan tres recursos, R1, R2 y R3.</li> </ul> <p>La hebra T1 s\u00f3lo necesita el recurso R1.  </p> <p>La hebra T2 necesita los recursos R2 y R3.  </p> <p>Por \u00faltimo, la hebra T3 requiere los tres recursos, R1, R2 y R3.</p> <p>Escriba un monitor que controle el acceso de las hebras a los recursos. Cada hebra solicita los recursos que necesita invocando un m\u00e9todo del monitor. Cuando una hebra termina de usar los recursos que necesita, lo indica para que otras hebras puedan usarlos. El monitor ha de asegurar que ning\u00fan recurso es utilizado por m\u00e1s de una hebra a la vez.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es:</p> <pre><code>class Monitor {\n    \u2026\n    \u2026 requiereR1 (\u2026) { \u2026 }\n    \u2026 requiereR2_R3 (\u2026) { \u2026 }\n    \u2026 requiereR1_R2_R3 ( \u2026) { \u2026}\n    \u2026 liberaR1(\u2026) { \u2026 }\n    \u2026 liberaR2_R3 (\u2026) { \u2026 }\n    \u2026 liberaR1_R2_R3 ( \u2026) { \u2026}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n ser\u00eda:</p> <pre><code>public class Monitor {\n    private boolean ocupadoR1 = false;\n    private boolean ocupadoR2 = false;\n    private boolean ocupadoR3 = false;\n\n    public synchronized void requiereR1 () \n               throws InterruptedException {\n        while (ocupadoR1) wait();\n        ocupadoR1 = true;\n    }\n\n    public synchronized void requiereR2_R3() \n               throws InterruptedException {\n        while (ocupadoR2 || ocupadoR3) wait();\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void requiereR1_R2_R3 () \n                   throws InterruptedException { \n        while (ocupadoR1 || ocupadoR2 || ocupadoR3) wait();\n        ocupadoR1 = true;\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void liberaR1() {\n        ocupadoR1 = false;\n        notifyAll();\n    }\n\n    public synchronized void libreraR2_R3 () {\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll();\n    }\n\n    public synchronized void liberaR1_R2_R3 () {\n        ocupadoR1 = false;\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll(); \n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2013/p1r/","title":"Examen 2013 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2013/p1r/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o N\u00d7N, desarrolle un algoritmo de orden O(N\u00b2) para averiguar si un valor K est\u00e1 presente o no en la matriz. Razone el orden de complejidad del algoritmo desarrollado.</li> </ul> <p>Ejemplo <pre><code>84   32  -13   33   13\n7    82   93   89  -23\n31  -24  -28   57  -93\n86  -71  -44   75  -12\n-10 -18   53   24   78\n</code></pre> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre></p> Mostrar soluci\u00f3n <p><pre><code>boolean busca1(int[][] matriz, int m) {\n    for (int x = 0; x &lt; matriz.length; x++) {\n        for (int y = 0; y &lt; matriz[x].length; y++) {\n            if (matriz[x][y] == m)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre> En cuanto a la complejidad, es un bucle que hace N vueltas, y en cada una hay otro bucle anidado que hace otras N vueltas. Por tanto, en total es de O(N\u00b2).</p> <ul> <li>(b) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o N\u00d7N que est\u00e1 ordenada de forma que:</li> </ul> <p>[ \\forall i, j:; matriz[i][j] \\le matriz[i+1][j] ;\\wedge; matriz[i][j] \\le matriz[i][j+1] ]</p> <p>(se cumple que cada elemento es menor o igual que el de abajo y el de la derecha).</p> <p>Se propone el siguiente algoritmo de b\u00fasqueda de un dato <code>m</code>:</p> <pre><code>private static boolean busca2(int[][] matriz, int m) {\n    int xa = 0;\n    int xz = matriz.length;\n    int ya = 0;\n    int yz = matriz[0].length;\n    return busca2(matriz, xa, xz, ya, yz, m);\n}\n\nprivate static boolean busca2(int[][] matriz,\n        int xa, int xz, int ya, int yz, int m) {\n\n    if (xa &gt;= xz || ya &gt;= yz)\n        return false;\n\n    int xm = (xa + xz) / 2;\n    int ym = (ya + yz) / 2;\n    int ref = matriz[xm][ym];\n\n    if (ref == m)\n        return true;\n\n    if (ref &lt; m)\n        return busca2(matriz, xm + 1, xz, ya, yz, m)\n            || busca2(matriz, xa, xz, ym + 1, yz, m);\n    else\n        return busca2(matriz, xa, xm, ya, yz, m)\n            || busca2(matriz, xa, xz, ya, ym, m);\n}\n</code></pre> <p>Se pide calcular la complejidad temporal del algoritmo, razonando el resultado.</p> <p>Ejemplo:</p> <pre><code>-93  -71  -28  -18    7\n-44  -24  -13   13   33\n-23  -12   24   53   78\n-10   31   57   82   86\n 32   75   84   89   93\n</code></pre> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre> Mostrar soluci\u00f3n <p>Un problema de tama\u00f1o  [ X = N^2 ] se parte en 2 subproblemas de tama\u00f1o (X/2). Esto hace k veces, siendo [ \\frac{X}{2^k} = 1 ;\\Rightarrow; k = \\log_2(X) ]</p> <p>En la primera ronda hay 1 comparaci\u00f3n * En la segunda ronda 2 comparaciones * En la tercera ronda 4 comparaciones * (\\dots) * En la k-\u00e9sima ronda, (2^k) comparaciones</p> <p>El n\u00famero total de comparaciones es la suma [ 1 + 2 + 2^2 + 2^3 + \\dots + 2^k ]</p> <p>Sustituyendo  [ 2 \\cdot 2^{\\log_2(X)} = 2X ]</p> <p>Como [ X = N^2 ] la soluci\u00f3n al problema cuesta [ 2N^2 ] comparaciones, siendo de la familia O(N^2)</p>"},{"location":"exams/2013/p1r/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) Desarrolle un monitor en Java que gestione el despegue de aviones y avionetas en un aeropuerto como se especifica a continuaci\u00f3n:</li> </ul> <p>Los aviones, al despegar, generan turbulencias, por lo que entre dos despegues consecutivos debe transcurrir un intervalo m\u00ednimo de tiempo:</p> <ul> <li>3 minutos despu\u00e9s del despegue de un avi\u00f3n.</li> <li>2 minutos despu\u00e9s del despegue de una avioneta.</li> </ul> <p>Adem\u00e1s se debe impedir que despeguen consecutivamente dos avionetas si hay aviones esperando. No hay restricciones de este tipo respecto a los aviones (pueden despegar consecutivamente).</p> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorDespegue {\n    ...\n\n    // Lo invoca un avi\u00f3n cuando quiere despegar\n    ... despegarAvion() {...}\n\n    // Lo invoca una avioneta cuando quiere despegar\n    ... despegarAvioneta() {...}\n\n    // Lo invoca el temporizador para indicar que\n    // ha transcurrido el intervalo m\u00ednimo desde\n    // el despegue anterior\n    ... autorizarDespegue() {...}\n    ...\n}\n</code></pre> <p>Para gestionar el intervalo de tiempo entre despegues, se dispone de una clase <code>Temporizador</code>, cuya interfaz se muestra a continuaci\u00f3n. El m\u00e9todo <code>iniciarTemporizador</code> arranca un temporizador que deja pasar un cierto tiempo. Cuando el tiempo expira, se invoca el m\u00e9todo <code>autorizarDespegue</code> del objeto <code>GestorDespegue</code> que se pasa en el constructor. No es necesario desarrollar esta clase.</p> <pre><code>public class Temporizador {\n    public Temporizador(GestorDespegue gestor) { ... }\n    public void iniciarTemporizador(int minutos) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n posible al problema del monitor de gesti\u00f3n de despegues es la siguiente:</p> <pre><code>public class GestorDespegue {\n\n    private boolean pistaOcupada = true;\n    private int nAvionesEsperando = 0;\n\n    private final int tiempoAvion = 3;\n    private final int tiempoAvioneta = 2;\n\n    private boolean anteriorAvioneta = false;\n\n    private Temporizador unTemporizador = new Temporizador(this);\n\n    // Invocado por un avi\u00f3n cuando quiere despegar\n    public synchronized void despegarAvion() throws InterruptedException {\n        nAvionesEsperando++;\n        while (pistaOcupada)\n            wait();\n\n        nAvionesEsperando--;\n        anteriorAvioneta = false;\n\n        unTemporizador.iniciarTemporizador(tiempoAvion);\n        pistaOcupada = true;\n    }\n\n    // Invocado por una avioneta cuando quiere despegar\n    public synchronized void despegarAvioneta() throws InterruptedException {\n        while (pistaOcupada || (nAvionesEsperando &gt; 0 &amp;&amp; anteriorAvioneta))\n            wait();\n\n        anteriorAvioneta = true;\n        unTemporizador.iniciarTemporizador(tiempoAvioneta);\n        pistaOcupada = true;\n    }\n\n    // Invocado por el temporizador cuando finaliza el intervalo m\u00ednimo\n    public synchronized void finTemporizador() throws InterruptedException {\n        pistaOcupada = false;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2013/p1r_ex01/","title":"P1r ex01","text":"<ul> <li>(a) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o N\u00d7N, desarrolle un algoritmo de orden O(N\u00b2) para averiguar si un valor K est\u00e1 presente o no en la matriz. Razone el orden de complejidad del algoritmo desarrollado.</li> </ul> <p>Ejemplo <pre><code>84   32  -13   33   13\n7    82   93   89  -23\n31  -24  -28   57  -93\n86  -71  -44   75  -12\n-10 -18   53   24   78\n</code></pre> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre></p> Mostrar soluci\u00f3n <p><pre><code>boolean busca1(int[][] matriz, int m) {\n    for (int x = 0; x &lt; matriz.length; x++) {\n        for (int y = 0; y &lt; matriz[x].length; y++) {\n            if (matriz[x][y] == m)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre> En cuanto a la complejidad, es un bucle que hace N vueltas, y en cada una hay otro bucle anidado que hace otras N vueltas. Por tanto, en total es de O(N\u00b2).</p> <ul> <li>(b) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o N\u00d7N que est\u00e1 ordenada de forma que:</li> </ul> <p>[ \\forall i, j:; matriz[i][j] \\le matriz[i+1][j] ;\\wedge; matriz[i][j] \\le matriz[i][j+1] ]</p> <p>(se cumple que cada elemento es menor o igual que el de abajo y el de la derecha).</p> <p>Se propone el siguiente algoritmo de b\u00fasqueda de un dato <code>m</code>:</p> <pre><code>private static boolean busca2(int[][] matriz, int m) {\n    int xa = 0;\n    int xz = matriz.length;\n    int ya = 0;\n    int yz = matriz[0].length;\n    return busca2(matriz, xa, xz, ya, yz, m);\n}\n\nprivate static boolean busca2(int[][] matriz,\n        int xa, int xz, int ya, int yz, int m) {\n\n    if (xa &gt;= xz || ya &gt;= yz)\n        return false;\n\n    int xm = (xa + xz) / 2;\n    int ym = (ya + yz) / 2;\n    int ref = matriz[xm][ym];\n\n    if (ref == m)\n        return true;\n\n    if (ref &lt; m)\n        return busca2(matriz, xm + 1, xz, ya, yz, m)\n            || busca2(matriz, xa, xz, ym + 1, yz, m);\n    else\n        return busca2(matriz, xa, xm, ya, yz, m)\n            || busca2(matriz, xa, xz, ya, ym, m);\n}\n</code></pre> <p>Se pide calcular la complejidad temporal del algoritmo, razonando el resultado.</p> <p>Ejemplo:</p> <pre><code>-93  -71  -28  -18    7\n-44  -24  -13   13   33\n-23  -12   24   53   78\n-10   31   57   82   86\n 32   75   84   89   93\n</code></pre> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre> Mostrar soluci\u00f3n <p>Un problema de tama\u00f1o  [ X = N^2 ] se parte en 2 subproblemas de tama\u00f1o (X/2). Esto hace k veces, siendo [ \\frac{X}{2^k} = 1 ;\\Rightarrow; k = \\log_2(X) ]</p> <p>En la primera ronda hay 1 comparaci\u00f3n * En la segunda ronda 2 comparaciones * En la tercera ronda 4 comparaciones * (\\dots) * En la k-\u00e9sima ronda, (2^k) comparaciones</p> <p>El n\u00famero total de comparaciones es la suma [ 1 + 2 + 2^2 + 2^3 + \\dots + 2^k ]</p> <p>Sustituyendo  [ 2 \\cdot 2^{\\log_2(X)} = 2X ]</p> <p>Como [ X = N^2 ] la soluci\u00f3n al problema cuesta [ 2N^2 ] comparaciones, siendo de la familia O(N^2)</p>","tags":["complejidad"]},{"location":"exams/2013/p1r_ex02/","title":"P1r ex02","text":"<ul> <li>(a) (5 puntos) Desarrolle un monitor en Java que gestione el despegue de aviones y avionetas en un aeropuerto como se especifica a continuaci\u00f3n:</li> </ul> <p>Los aviones, al despegar, generan turbulencias, por lo que entre dos despegues consecutivos debe transcurrir un intervalo m\u00ednimo de tiempo:</p> <ul> <li>3 minutos despu\u00e9s del despegue de un avi\u00f3n.</li> <li>2 minutos despu\u00e9s del despegue de una avioneta.</li> </ul> <p>Adem\u00e1s se debe impedir que despeguen consecutivamente dos avionetas si hay aviones esperando. No hay restricciones de este tipo respecto a los aviones (pueden despegar consecutivamente).</p> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorDespegue {\n    ...\n\n    // Lo invoca un avi\u00f3n cuando quiere despegar\n    ... despegarAvion() {...}\n\n    // Lo invoca una avioneta cuando quiere despegar\n    ... despegarAvioneta() {...}\n\n    // Lo invoca el temporizador para indicar que\n    // ha transcurrido el intervalo m\u00ednimo desde\n    // el despegue anterior\n    ... autorizarDespegue() {...}\n    ...\n}\n</code></pre> <p>Para gestionar el intervalo de tiempo entre despegues, se dispone de una clase <code>Temporizador</code>, cuya interfaz se muestra a continuaci\u00f3n. El m\u00e9todo <code>iniciarTemporizador</code> arranca un temporizador que deja pasar un cierto tiempo. Cuando el tiempo expira, se invoca el m\u00e9todo <code>autorizarDespegue</code> del objeto <code>GestorDespegue</code> que se pasa en el constructor. No es necesario desarrollar esta clase.</p> <pre><code>public class Temporizador {\n    public Temporizador(GestorDespegue gestor) { ... }\n    public void iniciarTemporizador(int minutos) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n posible al problema del monitor de gesti\u00f3n de despegues es la siguiente:</p> <pre><code>public class GestorDespegue {\n\n    private boolean pistaOcupada = true;\n    private int nAvionesEsperando = 0;\n\n    private final int tiempoAvion = 3;\n    private final int tiempoAvioneta = 2;\n\n    private boolean anteriorAvioneta = false;\n\n    private Temporizador unTemporizador = new Temporizador(this);\n\n    // Invocado por un avi\u00f3n cuando quiere despegar\n    public synchronized void despegarAvion() throws InterruptedException {\n        nAvionesEsperando++;\n        while (pistaOcupada)\n            wait();\n\n        nAvionesEsperando--;\n        anteriorAvioneta = false;\n\n        unTemporizador.iniciarTemporizador(tiempoAvion);\n        pistaOcupada = true;\n    }\n\n    // Invocado por una avioneta cuando quiere despegar\n    public synchronized void despegarAvioneta() throws InterruptedException {\n        while (pistaOcupada || (nAvionesEsperando &gt; 0 &amp;&amp; anteriorAvioneta))\n            wait();\n\n        anteriorAvioneta = true;\n        unTemporizador.iniciarTemporizador(tiempoAvioneta);\n        pistaOcupada = true;\n    }\n\n    // Invocado por el temporizador cuando finaliza el intervalo m\u00ednimo\n    public synchronized void finTemporizador() throws InterruptedException {\n        pistaOcupada = false;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2013/p2/","title":"Examen 2013 \u2014 Parcial 2","text":""},{"location":"exams/2013/p2/#problema-1","title":"Problema 1","text":"<p>Se desea desarrollar una aplicaci\u00f3n que facilite la selecci\u00f3n de un vino, ofreci\u00e9ndonos informaci\u00f3n de los vinos m\u00e1s populares. La pantalla inicial muestra una lista de vinos, y est\u00e1 gestionada por una actividad denominada <code>ListaVinosActivity</code>.  Al pinchar en el nombre de un vino se muestra otra pantalla con los detalles correspondientes. Esta pantalla est\u00e1 gestionada por la actividad <code>DetalleVinoActivity</code>.</p> <p></p> <p>Se proporcionan las clases Vino y Bodega (ver al final). </p> <p>Se pide: - (a) (5 puntos) Programe <code>ListaVinosActivity</code>. Suponga que dispone de la plantilla (layout) correspondiente en un fichero lista_vinos.xml, y utilice los nombres que necesite como crea oportuno. Utilice un <code>ArrayAdapter</code> para mostrar los elementos de la lista.</p> <p>Cuando se pulse en un elemento de la lista (el nombre de un vino), la actividad <code>ListaVinosActivity</code> debe lanzar la actividad <code>DetalleVinoActivity</code> pas\u00e1ndole el nombre del vino en la clave NOMBRE, y sin esperar un resultado de vuelta de dicha actividad.</p> <p>La actividad debe mostrar una traza (Log) de tipo informativo (i)  con el n\u00famero de vinos cargados, y una traza de tipo depuraci\u00f3n (d) con la opci\u00f3n que ha pulsado, como se muestra a continuaci\u00f3n.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public class ListaVinosActivity extends ListActivity {\n   public static final String NOMBRE = \"nombre\";\n   private static final String TAG = ListaVinosActivity.class.getSimpleName();\n   private Bodega bodega;\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.lista_vinos);\n      bodega = Bodega.getBodega();\n      List&lt;Vino&gt; lista = bodega.getListaVinos(); \n      Log.i(TAG, \"Cargando \" + lista.size() + \" vinos\"); \n      setListAdapter(new ArrayAdapter&lt;Vino&gt;(this,\n                       android.R.layout.simple_list_item_1, lista));\n   }\n   @Override\n   protected void onListItemClick(ListView l, View v, int position, long id) { \n      super.onListItemClick(l, v, position, id);\n      Intent intent = new Intent(this, DetalleVinoActivity.class);\n      Vino vino = bodega.getListaVinos().get(position);\n      Log.d(TAG, \"Pulsado en \" + vino);\n      intent.putExtra(NOMBRE, vino.getNombre());\n      startActivity(intent);\n   }\n}\n</code></pre> <ul> <li> <p>(b) (5 puntos) Programe <code>DetalleVinoActivity</code>. Suponga que la plantilla detalle_vino.xml muestra los campos de un  objeto <code>Vino</code> en los siguientes componentes: </p> <ul> <li> <ol> <li>foto en un <code>ImageView</code> (R.id.foto),</li> </ol> </li> <li> <ol> <li>nombre, denominaci\u00f3n y descripci\u00f3n en tres <code>EditText</code> (R.id.nombre, R.id.denominacion, R.id.descripcion).</li> </ol> </li> </ul> </li> </ul> <p>La actividad recibe en la intenci\u00f3n el nombre del vino en la clave NOMBRE. Debe crear un objeto <code>Bodega</code> y recuperar el objeto <code>Vino</code> correspondiente al nombre recibido. A continuaci\u00f3n, rellene los campos de la pantalla con los valores del vino. Puede suponer que todos los campos de un objeto <code>Vino</code> tienen un valor correcto.</p> Mostrar soluci\u00f3n <pre><code>public class DetalleVinoActivity extends Activity {\n   private EditText nombre;\n   private EditText denominacion;\n   private EditText descripcion;\n   private ImageView foto;\n   private static final String TAG = DetalleVinoActivity.class.getSimpleName();\n\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.detalle_vino);\n      Intent intent = getIntent();\n      String nombreVino = intent.getStringExtra(ListaVinosActivity.NOMBRE);\n      Bodega bodega = Bodega.getBodega();\n      Vino vino = bodega.getVino(nombreVino);\n      nombre = (EditText) findViewById(R.id.nombre); \n      nombre.setText(vino.getNombre());\n      denominacion = (EditText) findViewById(R.id.denominacion);\n      denominacion.setText(vino.getDenominacion().toString());\n      descripcion = (EditText) findViewById(R.id.descripcion);\n      descripcion.setText(vino.getDescripcion());\n      foto = (ImageView) findViewById(R.id.foto); \n      foto.setImageResource(vino.getFoto());\n   }\n}\n</code></pre> <p>Clases auxiliares: <pre><code>public class Vino {\n    enum Denominacion { RIOJA, RIBERA, PENEDES; }\n    private String nombre;\n    private Denominacion denominacion;\n    private int foto;\n    private String descripcion;\n    // suponga que tiene m\u00e9todos m\u00e9todos get/put para todos los campos\n    // suponga que tiene un m\u00e9todo toString() que imprime el nombre del vino\n}\n\npublic class Bodega {\n    public Vino getVino(String nombre) {... }\n    public List&lt;Vino&gt; getListaVinos() {...}\n    public static Bodega getBodega(){...}\n}\n\n// ejemplo de uso de las clases anteriores\n\npublic class Ejemplo {\n\n    public static void main(String [] args) {\n        Bodega bodega = Bodega.getBodega(); // creo la bodega\n        List&lt;Vino&gt; vinos = bodega.getListaVinos(); // lista de vinos\n        Vino vino = vinos.get(0); // obtener vino  recorriendo lista\n        // vino dado el nombre del vino\n        Vino valdehermoso = bodega.getVino(\"Valdehermoso\"); \n    }\n}\n</code></pre></p>"},{"location":"exams/2013/p2_ex01/","title":"P2 ex01","text":"<p>Se desea desarrollar una aplicaci\u00f3n que facilite la selecci\u00f3n de un vino, ofreci\u00e9ndonos informaci\u00f3n de los vinos m\u00e1s populares. La pantalla inicial muestra una lista de vinos, y est\u00e1 gestionada por una actividad denominada <code>ListaVinosActivity</code>.  Al pinchar en el nombre de un vino se muestra otra pantalla con los detalles correspondientes. Esta pantalla est\u00e1 gestionada por la actividad <code>DetalleVinoActivity</code>.</p> <p></p> <p>Se proporcionan las clases Vino y Bodega (ver al final). </p> <p>Se pide: - (a) (5 puntos) Programe <code>ListaVinosActivity</code>. Suponga que dispone de la plantilla (layout) correspondiente en un fichero lista_vinos.xml, y utilice los nombres que necesite como crea oportuno. Utilice un <code>ArrayAdapter</code> para mostrar los elementos de la lista.</p> <p>Cuando se pulse en un elemento de la lista (el nombre de un vino), la actividad <code>ListaVinosActivity</code> debe lanzar la actividad <code>DetalleVinoActivity</code> pas\u00e1ndole el nombre del vino en la clave NOMBRE, y sin esperar un resultado de vuelta de dicha actividad.</p> <p>La actividad debe mostrar una traza (Log) de tipo informativo (i)  con el n\u00famero de vinos cargados, y una traza de tipo depuraci\u00f3n (d) con la opci\u00f3n que ha pulsado, como se muestra a continuaci\u00f3n.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public class ListaVinosActivity extends ListActivity {\n   public static final String NOMBRE = \"nombre\";\n   private static final String TAG = ListaVinosActivity.class.getSimpleName();\n   private Bodega bodega;\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.lista_vinos);\n      bodega = Bodega.getBodega();\n      List&lt;Vino&gt; lista = bodega.getListaVinos(); \n      Log.i(TAG, \"Cargando \" + lista.size() + \" vinos\"); \n      setListAdapter(new ArrayAdapter&lt;Vino&gt;(this,\n                       android.R.layout.simple_list_item_1, lista));\n   }\n   @Override\n   protected void onListItemClick(ListView l, View v, int position, long id) { \n      super.onListItemClick(l, v, position, id);\n      Intent intent = new Intent(this, DetalleVinoActivity.class);\n      Vino vino = bodega.getListaVinos().get(position);\n      Log.d(TAG, \"Pulsado en \" + vino);\n      intent.putExtra(NOMBRE, vino.getNombre());\n      startActivity(intent);\n   }\n}\n</code></pre> <ul> <li> <p>(b) (5 puntos) Programe <code>DetalleVinoActivity</code>. Suponga que la plantilla detalle_vino.xml muestra los campos de un  objeto <code>Vino</code> en los siguientes componentes: </p> <ul> <li> <ol> <li>foto en un <code>ImageView</code> (R.id.foto),</li> </ol> </li> <li> <ol> <li>nombre, denominaci\u00f3n y descripci\u00f3n en tres <code>EditText</code> (R.id.nombre, R.id.denominacion, R.id.descripcion).</li> </ol> </li> </ul> </li> </ul> <p>La actividad recibe en la intenci\u00f3n el nombre del vino en la clave NOMBRE. Debe crear un objeto <code>Bodega</code> y recuperar el objeto <code>Vino</code> correspondiente al nombre recibido. A continuaci\u00f3n, rellene los campos de la pantalla con los valores del vino. Puede suponer que todos los campos de un objeto <code>Vino</code> tienen un valor correcto.</p> Mostrar soluci\u00f3n <pre><code>public class DetalleVinoActivity extends Activity {\n   private EditText nombre;\n   private EditText denominacion;\n   private EditText descripcion;\n   private ImageView foto;\n   private static final String TAG = DetalleVinoActivity.class.getSimpleName();\n\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.detalle_vino);\n      Intent intent = getIntent();\n      String nombreVino = intent.getStringExtra(ListaVinosActivity.NOMBRE);\n      Bodega bodega = Bodega.getBodega();\n      Vino vino = bodega.getVino(nombreVino);\n      nombre = (EditText) findViewById(R.id.nombre); \n      nombre.setText(vino.getNombre());\n      denominacion = (EditText) findViewById(R.id.denominacion);\n      denominacion.setText(vino.getDenominacion().toString());\n      descripcion = (EditText) findViewById(R.id.descripcion);\n      descripcion.setText(vino.getDescripcion());\n      foto = (ImageView) findViewById(R.id.foto); \n      foto.setImageResource(vino.getFoto());\n   }\n}\n</code></pre> <p>Clases auxiliares: <pre><code>public class Vino {\n    enum Denominacion { RIOJA, RIBERA, PENEDES; }\n    private String nombre;\n    private Denominacion denominacion;\n    private int foto;\n    private String descripcion;\n    // suponga que tiene m\u00e9todos m\u00e9todos get/put para todos los campos\n    // suponga que tiene un m\u00e9todo toString() que imprime el nombre del vino\n}\n\npublic class Bodega {\n    public Vino getVino(String nombre) {... }\n    public List&lt;Vino&gt; getListaVinos() {...}\n    public static Bodega getBodega(){...}\n}\n\n// ejemplo de uso de las clases anteriores\n\npublic class Ejemplo {\n\n    public static void main(String [] args) {\n        Bodega bodega = Bodega.getBodega(); // creo la bodega\n        List&lt;Vino&gt; vinos = bodega.getListaVinos(); // lista de vinos\n        Vino vino = vinos.get(0); // obtener vino  recorriendo lista\n        // vino dado el nombre del vino\n        Vino valdehermoso = bodega.getVino(\"Valdehermoso\"); \n    }\n}\n</code></pre></p>","tags":["android"]},{"location":"exams/2014/extra/","title":"Examen 2014 \u2014 Extraordinario","text":""},{"location":"exams/2014/extra/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (2,5 puntos) En una matriz de valores enteros de dos dimensiones, se dice que un elemento es un pico si es mayor o igual que sus cuatro vecinos en vertical y horizontal (o sus tres vecinos, en el caso de que se encuentre en el borde de la matriz, o sus dos vecinos si est\u00e1 en una esquina).</li> </ul> <p>Para encontrar un pico en una matriz de N filas por M columnas (se puede demostrar que siempre existe al menos uno) se puede utilizar el siguiente algoritmo:     1. Si M es igual a 1, encontrar el mayor valor de esa columna, y devolverlo como resultado.     2. En otro caso, encontrar el mayor valor en la columna central de la matriz.     3. Si ese valor es mayor o igual que sus vecinos derecho e izquierdo (si existen), devolverlo como resultado.     4. En otro caso, si ese valor es menor que su vecino izquierdo (si existe), continuar el mismo algoritmo con la mitad izquierda de la matriz. Y si no es as\u00ed, continuar el mismo algoritmo con la mitad derecha de la matriz (quitando la columna central en ambos casos).</p> <p>Se pide indicar razonadamente cu\u00e1l es la complejidad del algoritmo descrito, en t\u00e9rminos de N y M.</p> Mostrar soluci\u00f3n <p>La b\u00fasqueda del mayor valor en una columna de N enteros tiene complejidad N, ya que todos los valores de la columna han de ser comprobados, y las operaciones a realizar con cada uno de ellos son de complejidad constante. </p> <p>Por otra parte, en el peor caso habr\u00e1 que hacer esa b\u00fasqueda tantas veces como se puedan dividir iterativamente en dos partes iguales las M columnas, para llegar al final a una sola. Es decir, logaritmo en base dos de M veces. Por tanto, la complejidad total del algoritmo es N*log(M).</p>"},{"location":"exams/2014/extra/#problema-2","title":"Problema 2","text":"<p>Un sistema de gesti\u00f3n de un almac\u00e9n de piezas est\u00e1 compuesto por un conjunto de productores y de consumidores, que se modelan mediante hebras. Las hebras productoras a\u00f1aden piezas, mientras que las consumidoras las solicitan y retiran.</p> <p>Se pide dise\u00f1ar un monitor GestorPiezas que gestione las interacciones de estas hebras, cuya interfaz est\u00e1 formada por los siguientes m\u00e9todos:     \u2026 void solicitarPiezas (int cantidadPiezas): este m\u00e9todo lo invocan las hebras consumidoras cuando quieren solicitar una cantidad de piezas determinada. Si hay piezas suficientes, se le proporcionan inmediatamente (se actualiza el n\u00famero de piezas almacenadas). Si no las hay, se bloquea la hebra hasta que haya suficientes. En este caso, hay que bloquear al resto de hebras consumidoras hasta que se satisfaga la petici\u00f3n pendiente.</p> <pre><code>\u2026 void agregarPiezas (int cantidadPiezas): este m\u00e9todo lo invocan las hebras productoras para a\u00f1adir piezas al almac\u00e9n. La cantidad de piezas que se pueden almacenar es ilimitada.\n</code></pre> <p>Nota: el n\u00famero de piezas debe ser positivo en todos los casos.</p> Mostrar soluci\u00f3n <pre><code>public class GestorAlmacen {\n    private int cantidadAlmacen = 0;\n    private boolean peticionPendiente = false;\n\n    public synchronized void solicitarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        while (peticionPendiente) wait();\n        peticionPendiente = true;\n        while (cantidadAlmacen &lt; cantidadPiezas) wait();\n        cantidadAlmacen = cantidadAlmacen - cantidadPiezas;\n        peticionPendiente = false;\n        notifyAll();\n    }\n\n    public synchronized void agregarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        cantidadAlmacen = cantidadAlmacen + cantidadPiezas;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2014/extra/#problema-3","title":"Problema 3","text":"<p>Sobre el proyecto del pacman, deseamos mover funcionalidad del men\u00fa a botones:</p> <p></p> <p>Se pide:</p> <ul> <li>(a) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para poner botones? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>a) Hay que a\u00f1adir una fila de botones en res / layout / main.xml</p> <pre><code>&lt;LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:gravity=\"center\" &gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_reset\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"RESET\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_fantasma\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"fantasma\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_depredador\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"depredador\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>b) Hay que asociar la funcionalidad a cada bot\u00f3n en MainActivity.java</p> <pre><code>public void clic(View view) {\n    Escenario escenario = Escenario.getInstance();\n    switch(view.getId()) {\n        case R.id.boton_reset:\n            escenario.restart();\n            return;\n        case R.id.boton_fantasma:\n            escenario.addMovil(this, R.id.fantasma00);\n            return;\n        case R.id.boton_depredador:\n            escenario.addMovil(this, R.id.depredador);\n            return;\n    }\n}\n</code></pre> <p>Si se van a eliminar las entradas del men\u00fa, hay que revisar los R.id que desaparecen, ajustando los identificadores que se usan en cada parte del c\u00f3digo.</p> <p>NOTA: Hay otras formas de hacerlo:</p> <p>\u2022 En el layout: identificando cada bot\u00f3n por un onClick() espec\u00edfico</p> <p>\u2022 En java, en onCreate(): localizando los botones y asoci\u00e1ndoles la funcionalidad. Por ejemplo</p> <pre><code>Button bv = (Button) findViewById(R.id.boton_reset);\nbv.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Escenario escenario = Escenario.getInstance();\n        escenario.restart();\n    }\n});\n</code></pre> <p>\u2022 En java, hacemos que la clase MainActivity implemente OnClickListener y escribimos el m\u00e9todo onClick() en la clase principal y la asociamos a cada bot\u00f3n</p> <pre><code>public class MainActivity extends \u2026 implements OnClickListener {\n\n    // en onCreate():\n    Button botonReset = (Button)rootView.findViewById(R.id.boton_reset);\n    botonReset.setOnClickListener(this);\n\n    // en la clase MainActivity:\n    public void onClick(View view) {\n        Escenario escenario = Escenario.getInstance();\n        switch (view.getId()) {\n            case R.id.boton_reset:\n                escenario.restart();\n                return;\n            case R.id.boton_fantasma:\n                escenario.addMovil(this, R.id.fantasma00);\n                return;\n            case R.id.boton_depredador:\n                escenario.addMovil(this, R.id.depredador);\n                return;\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para eliminar entradas del men\u00fa? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>a) Hay que eliminar las entradas de res / menu / main.xml</p> <pre><code>~~&lt;item~~\n    ~~android:id=\"@+id/button_reset\"~~\n    ~~android:icon=\"@drawable/fantasma_rojo\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/button_reset\"/&gt;~~\n\n~~&lt;item~~\n    ~~android:id=\"@+id/fantasma00\"~~\n    ~~android:icon=\"@drawable/fantasma_rojo\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/fantasma00\"/&gt;~~\n\n~~&lt;item~~\n    ~~android:id=\"@+id/depredador\"~~\n    ~~android:icon=\"@drawable/anibal\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/depredador\"/&gt;~~\n</code></pre> <p>b) Hay que eliminar la funcionalidad de la clase MainActivity</p> <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    Escenario escenario = Escenario.getInstance();\n    switch (item.getItemId()) {\n        ~~case R.id.button_reset:~~\n            ~~escenario.restart();~~\n            ~~return true;~~\n    ~~}~~\n    ~~if (escenario.addMovil(this, item.getItemId()))~~\n        ~~return true;~~\n    return super.onOptionsItemSelected(item);\n}\n</code></pre> <p>OJO: hemos eliminado la facilidad de a\u00f1adir nuevos fantasmas sin m\u00e1s que a\u00f1adirlos en la especificaci\u00f3n xml del men\u00fa.</p> <ul> <li>(c) (0,5 puntos) \u00bfPodemos mantener ambos? Es decir, la misma funcionalidad accesible por men\u00fa y por bot\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed. Se pueden a\u00f1adir los botones y dejar el c\u00f3digo para el men\u00fa. La misma funci\u00f3n se puede realizar de 2 formas: por bot\u00f3n y por men\u00fa.</p> <p>La respuesta debe ser razonada, incluyendo c\u00f3digo java y especificaciones en XML, aunque no es necesario que la sintaxis de java y xml sea perfectamente correcta.</p>"},{"location":"exams/2014/extra/#problema-4","title":"Problema 4","text":"<ul> <li>(a) (0,8 puntos) Una aplicaci\u00f3n Android llamada APP est\u00e1 ejecut\u00e1ndose y dispone del foco (interact\u00faa con el usuario). Supongamos que se recibe una llamada telef\u00f3nica, el usuario la atiende y luego cuelga. \u00bfCu\u00e1les son los m\u00e9todos del ciclo de vida de APP llamados?</li> </ul> Mostrar soluci\u00f3n <p>La secuencia m\u00e1s com\u00fan es:</p> <pre><code>onPause()\nonStop()\nonRestart()\nonStart()\nonResume()\n</code></pre> <p>pero tambi\u00e9n puede ocurrir la siguiente secuencia:</p> <pre><code>onPause()\nonStop()\nonDestroy()\nonCreate()\nonStart()\nonResume()\n</code></pre> <p>Tambi\u00e9n podr\u00eda ocurrir que la llamada entrante no llegue a retirar toda la actividad de la pantalla sino que quede en el fondo. En ese caso la secuencia ser\u00eda:</p> <pre><code>onPause()\nonResume()\n</code></pre> <p>Todas las soluciones anteriores se consideran v\u00e1lidas.</p> <ul> <li>(b) (0,7 puntos) Describir brevemente qu\u00e9 es y para qu\u00e9 se usa un <code>SimpleCursorAdapter</code>.</li> </ul> Mostrar soluci\u00f3n <p>Es un mecanismo que sirve para conectar el cursor con el que se accede a las filas que resultan de una consulta en una base datos con una <code>ListView</code> definida en el layout de una actividad. Se usa para mostrar los resultados de una consulta en una pantalla</p> <ul> <li>(c) (1 punto) En la actividad principal de una aplicaci\u00f3n hay un bot\u00f3n que tiene asociado un m\u00e9todo <code>onClick</code> que lanza la ejecuci\u00f3n de una tarea as\u00edncrona para cargar un fichero remoto. Indicar qu\u00e9 m\u00e9todos hay que programar en la clase que implementa la <code>AsyncTask</code>, en qu\u00e9 hebra (thread) se ejecuta cada uno de ellos, y describa sucintamente qu\u00e9 hacen.</li> </ul> Mostrar soluci\u00f3n <p>Suponiendo que la cabecera de la clase es:</p> <pre><code>class MyClass extends AsyncTask&lt;Params, Progress, Result&gt;\n</code></pre> <p>los m\u00e9todos que hay que programar son:</p> <pre><code>void onPreExecute()\n</code></pre> <p>Se ejecuta en la UIThread, cuando se llama a execute(). Sirve para iniciar la tarea antes de empezar a ejecutar doInbackground.</p> <pre><code>Result doInBackground(Params\u2026)\n</code></pre> <p>Se ejecuta en la hebra auxiliar. Es equivalente a run() en las threads normales. Params son los par\u00e1metros que se le pasan al arrancar la tarea.</p> <pre><code>void onProgressUpdate (Progress\u2026)\n</code></pre> <p>Se ejecuta en la UIThread cada vez que se llama a publishProgress(Progress\u2026) desde el cuerpo de doInBackground.</p> <pre><code>void onPostExecute (Result)\n</code></pre> <p>Se ejecuta en la UIThread cuando termina doInBackground (con return Result).</p>"},{"location":"exams/2014/extra01/","title":"Extra01","text":"<ul> <li>(a) (2,5 puntos) En una matriz de valores enteros de dos dimensiones, se dice que un elemento es un pico si es mayor o igual que sus cuatro vecinos en vertical y horizontal (o sus tres vecinos, en el caso de que se encuentre en el borde de la matriz, o sus dos vecinos si est\u00e1 en una esquina).</li> </ul> <p>Para encontrar un pico en una matriz de N filas por M columnas (se puede demostrar que siempre existe al menos uno) se puede utilizar el siguiente algoritmo:     1. Si M es igual a 1, encontrar el mayor valor de esa columna, y devolverlo como resultado.     2. En otro caso, encontrar el mayor valor en la columna central de la matriz.     3. Si ese valor es mayor o igual que sus vecinos derecho e izquierdo (si existen), devolverlo como resultado.     4. En otro caso, si ese valor es menor que su vecino izquierdo (si existe), continuar el mismo algoritmo con la mitad izquierda de la matriz. Y si no es as\u00ed, continuar el mismo algoritmo con la mitad derecha de la matriz (quitando la columna central en ambos casos).</p> <p>Se pide indicar razonadamente cu\u00e1l es la complejidad del algoritmo descrito, en t\u00e9rminos de N y M.</p> Mostrar soluci\u00f3n <p>La b\u00fasqueda del mayor valor en una columna de N enteros tiene complejidad N, ya que todos los valores de la columna han de ser comprobados, y las operaciones a realizar con cada uno de ellos son de complejidad constante. </p> <p>Por otra parte, en el peor caso habr\u00e1 que hacer esa b\u00fasqueda tantas veces como se puedan dividir iterativamente en dos partes iguales las M columnas, para llegar al final a una sola. Es decir, logaritmo en base dos de M veces. Por tanto, la complejidad total del algoritmo es N*log(M).</p>","tags":["complejidad"]},{"location":"exams/2014/extra02/","title":"Extra02","text":"<p>Un sistema de gesti\u00f3n de un almac\u00e9n de piezas est\u00e1 compuesto por un conjunto de productores y de consumidores, que se modelan mediante hebras. Las hebras productoras a\u00f1aden piezas, mientras que las consumidoras las solicitan y retiran.</p> <p>Se pide dise\u00f1ar un monitor GestorPiezas que gestione las interacciones de estas hebras, cuya interfaz est\u00e1 formada por los siguientes m\u00e9todos:     \u2026 void solicitarPiezas (int cantidadPiezas): este m\u00e9todo lo invocan las hebras consumidoras cuando quieren solicitar una cantidad de piezas determinada. Si hay piezas suficientes, se le proporcionan inmediatamente (se actualiza el n\u00famero de piezas almacenadas). Si no las hay, se bloquea la hebra hasta que haya suficientes. En este caso, hay que bloquear al resto de hebras consumidoras hasta que se satisfaga la petici\u00f3n pendiente.</p> <pre><code>\u2026 void agregarPiezas (int cantidadPiezas): este m\u00e9todo lo invocan las hebras productoras para a\u00f1adir piezas al almac\u00e9n. La cantidad de piezas que se pueden almacenar es ilimitada.\n</code></pre> <p>Nota: el n\u00famero de piezas debe ser positivo en todos los casos.</p> Mostrar soluci\u00f3n <pre><code>public class GestorAlmacen {\n    private int cantidadAlmacen = 0;\n    private boolean peticionPendiente = false;\n\n    public synchronized void solicitarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        while (peticionPendiente) wait();\n        peticionPendiente = true;\n        while (cantidadAlmacen &lt; cantidadPiezas) wait();\n        cantidadAlmacen = cantidadAlmacen - cantidadPiezas;\n        peticionPendiente = false;\n        notifyAll();\n    }\n\n    public synchronized void agregarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        cantidadAlmacen = cantidadAlmacen + cantidadPiezas;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2014/extra03/","title":"Extra03","text":"<p>Sobre el proyecto del pacman, deseamos mover funcionalidad del men\u00fa a botones:</p> <p></p> <p>Se pide:</p> <ul> <li>(a) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para poner botones? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>a) Hay que a\u00f1adir una fila de botones en res / layout / main.xml</p> <pre><code>&lt;LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:gravity=\"center\" &gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_reset\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"RESET\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_fantasma\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"fantasma\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_depredador\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"depredador\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>b) Hay que asociar la funcionalidad a cada bot\u00f3n en MainActivity.java</p> <pre><code>public void clic(View view) {\n    Escenario escenario = Escenario.getInstance();\n    switch(view.getId()) {\n        case R.id.boton_reset:\n            escenario.restart();\n            return;\n        case R.id.boton_fantasma:\n            escenario.addMovil(this, R.id.fantasma00);\n            return;\n        case R.id.boton_depredador:\n            escenario.addMovil(this, R.id.depredador);\n            return;\n    }\n}\n</code></pre> <p>Si se van a eliminar las entradas del men\u00fa, hay que revisar los R.id que desaparecen, ajustando los identificadores que se usan en cada parte del c\u00f3digo.</p> <p>NOTA: Hay otras formas de hacerlo:</p> <p>\u2022 En el layout: identificando cada bot\u00f3n por un onClick() espec\u00edfico</p> <p>\u2022 En java, en onCreate(): localizando los botones y asoci\u00e1ndoles la funcionalidad. Por ejemplo</p> <pre><code>Button bv = (Button) findViewById(R.id.boton_reset);\nbv.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Escenario escenario = Escenario.getInstance();\n        escenario.restart();\n    }\n});\n</code></pre> <p>\u2022 En java, hacemos que la clase MainActivity implemente OnClickListener y escribimos el m\u00e9todo onClick() en la clase principal y la asociamos a cada bot\u00f3n</p> <pre><code>public class MainActivity extends \u2026 implements OnClickListener {\n\n    // en onCreate():\n    Button botonReset = (Button)rootView.findViewById(R.id.boton_reset);\n    botonReset.setOnClickListener(this);\n\n    // en la clase MainActivity:\n    public void onClick(View view) {\n        Escenario escenario = Escenario.getInstance();\n        switch (view.getId()) {\n            case R.id.boton_reset:\n                escenario.restart();\n                return;\n            case R.id.boton_fantasma:\n                escenario.addMovil(this, R.id.fantasma00);\n                return;\n            case R.id.boton_depredador:\n                escenario.addMovil(this, R.id.depredador);\n                return;\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para eliminar entradas del men\u00fa? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>a) Hay que eliminar las entradas de res / menu / main.xml</p> <pre><code>~~&lt;item~~\n    ~~android:id=\"@+id/button_reset\"~~\n    ~~android:icon=\"@drawable/fantasma_rojo\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/button_reset\"/&gt;~~\n\n~~&lt;item~~\n    ~~android:id=\"@+id/fantasma00\"~~\n    ~~android:icon=\"@drawable/fantasma_rojo\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/fantasma00\"/&gt;~~\n\n~~&lt;item~~\n    ~~android:id=\"@+id/depredador\"~~\n    ~~android:icon=\"@drawable/anibal\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/depredador\"/&gt;~~\n</code></pre> <p>b) Hay que eliminar la funcionalidad de la clase MainActivity</p> <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    Escenario escenario = Escenario.getInstance();\n    switch (item.getItemId()) {\n        ~~case R.id.button_reset:~~\n            ~~escenario.restart();~~\n            ~~return true;~~\n    ~~}~~\n    ~~if (escenario.addMovil(this, item.getItemId()))~~\n        ~~return true;~~\n    return super.onOptionsItemSelected(item);\n}\n</code></pre> <p>OJO: hemos eliminado la facilidad de a\u00f1adir nuevos fantasmas sin m\u00e1s que a\u00f1adirlos en la especificaci\u00f3n xml del men\u00fa.</p> <ul> <li>(c) (0,5 puntos) \u00bfPodemos mantener ambos? Es decir, la misma funcionalidad accesible por men\u00fa y por bot\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed. Se pueden a\u00f1adir los botones y dejar el c\u00f3digo para el men\u00fa. La misma funci\u00f3n se puede realizar de 2 formas: por bot\u00f3n y por men\u00fa.</p> <p>La respuesta debe ser razonada, incluyendo c\u00f3digo java y especificaciones en XML, aunque no es necesario que la sintaxis de java y xml sea perfectamente correcta.</p>","tags":["android"]},{"location":"exams/2014/extra04/","title":"Extra04","text":"<ul> <li>(a) (0,8 puntos) Una aplicaci\u00f3n Android llamada APP est\u00e1 ejecut\u00e1ndose y dispone del foco (interact\u00faa con el usuario). Supongamos que se recibe una llamada telef\u00f3nica, el usuario la atiende y luego cuelga. \u00bfCu\u00e1les son los m\u00e9todos del ciclo de vida de APP llamados?</li> </ul> Mostrar soluci\u00f3n <p>La secuencia m\u00e1s com\u00fan es:</p> <pre><code>onPause()\nonStop()\nonRestart()\nonStart()\nonResume()\n</code></pre> <p>pero tambi\u00e9n puede ocurrir la siguiente secuencia:</p> <pre><code>onPause()\nonStop()\nonDestroy()\nonCreate()\nonStart()\nonResume()\n</code></pre> <p>Tambi\u00e9n podr\u00eda ocurrir que la llamada entrante no llegue a retirar toda la actividad de la pantalla sino que quede en el fondo. En ese caso la secuencia ser\u00eda:</p> <pre><code>onPause()\nonResume()\n</code></pre> <p>Todas las soluciones anteriores se consideran v\u00e1lidas.</p> <ul> <li>(b) (0,7 puntos) Describir brevemente qu\u00e9 es y para qu\u00e9 se usa un <code>SimpleCursorAdapter</code>.</li> </ul> Mostrar soluci\u00f3n <p>Es un mecanismo que sirve para conectar el cursor con el que se accede a las filas que resultan de una consulta en una base datos con una <code>ListView</code> definida en el layout de una actividad. Se usa para mostrar los resultados de una consulta en una pantalla</p> <ul> <li>(c) (1 punto) En la actividad principal de una aplicaci\u00f3n hay un bot\u00f3n que tiene asociado un m\u00e9todo <code>onClick</code> que lanza la ejecuci\u00f3n de una tarea as\u00edncrona para cargar un fichero remoto. Indicar qu\u00e9 m\u00e9todos hay que programar en la clase que implementa la <code>AsyncTask</code>, en qu\u00e9 hebra (thread) se ejecuta cada uno de ellos, y describa sucintamente qu\u00e9 hacen.</li> </ul> Mostrar soluci\u00f3n <p>Suponiendo que la cabecera de la clase es:</p> <pre><code>class MyClass extends AsyncTask&lt;Params, Progress, Result&gt;\n</code></pre> <p>los m\u00e9todos que hay que programar son:</p> <pre><code>void onPreExecute()\n</code></pre> <p>Se ejecuta en la UIThread, cuando se llama a execute(). Sirve para iniciar la tarea antes de empezar a ejecutar doInbackground.</p> <pre><code>Result doInBackground(Params\u2026)\n</code></pre> <p>Se ejecuta en la hebra auxiliar. Es equivalente a run() en las threads normales. Params son los par\u00e1metros que se le pasan al arrancar la tarea.</p> <pre><code>void onProgressUpdate (Progress\u2026)\n</code></pre> <p>Se ejecuta en la UIThread cada vez que se llama a publishProgress(Progress\u2026) desde el cuerpo de doInBackground.</p> <pre><code>void onPostExecute (Result)\n</code></pre> <p>Se ejecuta en la UIThread cuando termina doInBackground (con return Result).</p>","tags":["android"]},{"location":"exams/2014/p1/","title":"Examen 2014 \u2014 Parcial 1","text":""},{"location":"exams/2014/p1/#problema-1","title":"Problema 1","text":"<p>Se necesita comprobar la bondad de los algoritmos de construcci\u00f3n de laberintos que se puedan desarrollar para la pr\u00e1ctica del Pacman. El objetivo es poder construir un laberinto conexo, esto es, un terreno en el que todas las casillas est\u00e9n conectadas, bien directamente o bien a trav\u00e9s de otras que las interconecten. De esta forma, no habr\u00e1 zonas del laberinto aisladas.</p> <p>Para ello, se pide desarrollar una clase auxiliar, llamada <code>Conectividad</code>, que averig\u00fce si un terreno es conexo o no. La especificaci\u00f3n de la clase es la siguiente:</p> <pre><code>package es.upm.dit.adsw.pacman2;\n\npublic class Conectividad {\n    private final Terreno terreno;\n\n    /**\n     * @param terreno\n     */\n    public Conectividad(Terreno terreno) {\n        this.terreno = terreno;\n    }\n\n    /**\n     * Determina si el terreno es conexo\n     * @return true si el terreno es conexo, false en caso contrario\n     */\n    public boolean esConexo() { ... }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Implementaci\u00f3n del m\u00e9todo <code>esConexo()</code>. Este m\u00e9todo ha de comprobar que desde cualquier casilla del terreno se puede alcanzar cualquier otra casilla.</li> </ul> <p>Sugerencia: Se propone el siguiente algoritmo para determinar si un terreno tiene casillas conexas.</p> <p>Se define un conjunto de casillas visitadas (ya analizadas alguna vez) y una lista de casillas pendientes (a\u00fan no analizadas).</p> <p>Se elige una casilla inicial, por ejemplo (0,0), y se a\u00f1ade a la lista de pendientes.</p> <p>Mientras haya casillas pendientes:   1. Se saca una casilla de la lista de pendientes.   2. Se a\u00f1ade la casilla al conjunto de visitadas.   3. Para cada direcci\u00f3n:      * Si existe una casilla adyacente accesible (no separada por una pared)      * Y no ha sido visitada, se a\u00f1ade a la lista de pendientes.</p> <p>Cuando ya no hay casillas pendientes:   * O bien se han visitado todas las casillas   * O existen zonas aisladas que no se han podido alcanzar</p> <p>Si el tama\u00f1o del conjunto de visitadas coincide con el n\u00famero total de casillas (N^2), entonces el terreno es conexo.</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo <code>esConexo()</code> es la siguiente:</p> <pre><code>public boolean esConexo() {\n    Set&lt;Casilla&gt; visitadas = new HashSet&lt;Casilla&gt;();\n    List&lt;Casilla&gt; pendientes = new ArrayList&lt;Casilla&gt;();\n\n    Casilla origen = terreno.getCasilla(0, 0);\n    pendientes.add(origen);\n\n    while (!pendientes.isEmpty()) {\n        Casilla c = pendientes.remove(0);\n        visitadas.add(c);\n\n        for (Direccion d : Direccion.values()) {\n            if (!c.hayPared(d)) {\n                Casilla v = terreno.getCasilla(c, d);\n                if (v != null &amp;&amp; !visitadas.contains(v)) {\n                    pendientes.add(v);\n                }\n            }\n        }\n    }\n\n    int N = terreno.getN();\n    return visitadas.size() == N * N;\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Complejidad temporal del algoritmo. (0,5 puntos) Determine la complejidad temporal del algoritmo programado en el apartado anterior. (1 punto) Justifique su respuesta. Se considera m\u00e1s importante el razonamiento sobre la complejidad que el c\u00e1lculo correcto.</li> </ul> Mostrar soluci\u00f3n <p>Dado que el algoritmo recorre, en el peor de los casos, todas las casillas del terreno, la complejidad b\u00e1sica ser\u00e1:</p> <p>[ O(N^2) \\times (\\text{complejidad de las operaciones}) ]</p> <p>Las operaciones b\u00e1sicas (comparaciones, asignaciones, accesos simples) tienen complejidad O(1).</p> <p>El acceso a las estructuras de datos depende de su implementaci\u00f3n. En el caso de<code>HashSet</code> las operaciones de inserci\u00f3n, borrado y b\u00fasqueda tienen complejidad O(1) de forma habitual. En el caso de <code>ArrayList</code>n la operaci\u00f3n <code>remove(0)</code> implica desplazar todos los elementos restantes, por lo que su complejidad es O(N).</p> <p>Por lo tanto, para el primer caso tenemos que el algoritmo es O(N\u00b2) y para el segundo O(N\u00b3).</p>"},{"location":"exams/2014/p1/#problema-2","title":"Problema 2","text":"<p>Sea un cruce de calles por el que circulan coches de oeste a este y de norte a sur. Para regular el tr\u00e1fico hay dos sem\u00e1foros, uno en la entrada oeste y otro en la entrada norte, y dos sensores, que se activan cuando llega un coche a cada una de las entradas. Tambi\u00e9n hay sensores que indican la salida del cruce.</p> <p>Se desea desarrollar un monitor en Java que simule la gesti\u00f3n de los sem\u00e1foros con las siguientes forma:</p> <ul> <li> <p>Los coches se modelan como hebras (threads) que invocan un m\u00e9todo <code>llegaNorte()</code> o <code>llegaOeste()</code> cuando llegan al cruce.</p> </li> <li> <p>Si el sem\u00e1foro correspondiente est\u00e1 en verde, el coche pasa inmediatamente.</p> </li> <li> <p>Si el sem\u00e1foro est\u00e1 en rojo, el coche espera hasta que se ponga en verde.</p> </li> <li> <p>Los coches tardan un cierto tiempo en atravesar el cruce. Al salir invocan el m\u00e9todo <code>sale()</code> del monitor.</p> </li> <li> <p>Una hebra de control llama peri\u00f3dicamente al m\u00e9todo <code>cambiaSem\u00e1foros()</code> para cambiar la configuraci\u00f3n de los sem\u00e1foros.</p> </li> </ul> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorCruce {\n    ...\n\n    // Lo invoca un coche que llega por el norte\n    llegaNorte() { ... }\n\n    // Lo invoca un coche que llega por el oeste\n    llegaOeste() { ... }\n\n    // Lo invoca un coche que sale del cruce\n    sale() { ... }\n\n    // Lo invoca la hebra de control\n    cambiaSem\u00e1foros() { ... }\n...\n}\n</code></pre> <ul> <li>(a) Se pide (5 puntos)  Desarrollar el c\u00f3digo completo del monitor , justificando la respuesta. Se valorar\u00e1 especialmente el razonamiento sobre el dise\u00f1o del monitor.</li> </ul> Mostrar soluci\u00f3n <p>En el sistema existen dos tipos de hebras que representan, respectivamente, el comportamiento de los coches y el control de los sem\u00e1foros. Estas hebras invocan los m\u00e9todos del monitor para actualizar el estado del cruce y sincronizarse.</p> <p>El monitor almacena el estado del cruce mediante atributos privados. En este caso se identifican los siguientes:</p> <ul> <li>Estado de los sem\u00e1foros: puede representarse mediante un valor booleano. Basta con una sola variable, ya que cuando un sem\u00e1foro est\u00e1 en verde, el otro est\u00e1 en rojo.</li> <li>N\u00famero de coches en el cruce: se representa mediante un booleano, ya que solo se permite un coche a la vez.</li> </ul> <p>N\u00f3tese que no es necesario representar el n\u00famero de coches que esperan, ni el tiempo que transcurre entre la entrada y la un salida de un coche. Este \u00faltimo aspecto se debe modelar en la clase que representa elcomportamiento de los coches. Tampoco hay que modelar aqu\u00ed el tiempo que transcurre entre los cambios de los sem\u00e1foros, que corresponde a la hebra de control.</p> <p>En cuanto a la implementaci\u00f3n del gestor, debe realizarse como un monitor, por lo que todos los atributos dedatos deber ser privados, y todos los m\u00e9todos p\u00fablicos (excepto los constructores) deben estar sincronizados.</p> <p>Una posible implementaci\u00f3n es la siguiente:</p> <pre><code>public class GestorCruce {\n\n    // true indica sem\u00e1foro norte en verde (oeste en rojo)\n    private boolean norteVerde = true;\n\n    // Indica si hay un coche pasando por el cruce\n    private boolean cochePasando = false;\n\n    // Invocado por un coche que llega desde el norte\n    public synchronized void entraNorte() throws InterruptedException {\n        while (!norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que llega desde el oeste\n    public synchronized void entraOeste() throws InterruptedException {\n        while (norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que sale del cruce\n    public synchronized void sale() {\n        cochePasando = false;\n        notifyAll();\n    }\n\n    // Invocado por la hebra de control de los sem\u00e1foros\n    public synchronized void cambiaSemaforos() {\n        norteVerde = !norteVerde;\n        notifyAll();\n    }\n}\n</code></pre> <p>Obs\u00e9rvese que si cambian los sem\u00e1foros cuando hay un coche en el cruce, no puede entrar ning\u00fan otro coche en la nueva orientaci\u00f3n hasta que el coche que est\u00e1 en el cruce salga, ya que <code>cochePasando</code> ser\u00e1 <code>true</code>.</p> <p>Los m\u00e9todos <code>entraNorte</code> y <code>entraOeste</code> propagan <code>IntrruptedException</code>. Una alternativa ser\u00eda maneja la interrupci\u00f3n en estos m\u00e9todos con un bloque try-catch.</p>"},{"location":"exams/2014/p1_ex01/","title":"P1 ex01","text":"<p>Se necesita comprobar la bondad de los algoritmos de construcci\u00f3n de laberintos que se puedan desarrollar para la pr\u00e1ctica del Pacman. El objetivo es poder construir un laberinto conexo, esto es, un terreno en el que todas las casillas est\u00e9n conectadas, bien directamente o bien a trav\u00e9s de otras que las interconecten. De esta forma, no habr\u00e1 zonas del laberinto aisladas.</p> <p>Para ello, se pide desarrollar una clase auxiliar, llamada <code>Conectividad</code>, que averig\u00fce si un terreno es conexo o no. La especificaci\u00f3n de la clase es la siguiente:</p> <pre><code>package es.upm.dit.adsw.pacman2;\n\npublic class Conectividad {\n    private final Terreno terreno;\n\n    /**\n     * @param terreno\n     */\n    public Conectividad(Terreno terreno) {\n        this.terreno = terreno;\n    }\n\n    /**\n     * Determina si el terreno es conexo\n     * @return true si el terreno es conexo, false en caso contrario\n     */\n    public boolean esConexo() { ... }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Implementaci\u00f3n del m\u00e9todo <code>esConexo()</code>. Este m\u00e9todo ha de comprobar que desde cualquier casilla del terreno se puede alcanzar cualquier otra casilla.</li> </ul> <p>Sugerencia: Se propone el siguiente algoritmo para determinar si un terreno tiene casillas conexas.</p> <p>Se define un conjunto de casillas visitadas (ya analizadas alguna vez) y una lista de casillas pendientes (a\u00fan no analizadas).</p> <p>Se elige una casilla inicial, por ejemplo (0,0), y se a\u00f1ade a la lista de pendientes.</p> <p>Mientras haya casillas pendientes:   1. Se saca una casilla de la lista de pendientes.   2. Se a\u00f1ade la casilla al conjunto de visitadas.   3. Para cada direcci\u00f3n:      * Si existe una casilla adyacente accesible (no separada por una pared)      * Y no ha sido visitada, se a\u00f1ade a la lista de pendientes.</p> <p>Cuando ya no hay casillas pendientes:   * O bien se han visitado todas las casillas   * O existen zonas aisladas que no se han podido alcanzar</p> <p>Si el tama\u00f1o del conjunto de visitadas coincide con el n\u00famero total de casillas (N^2), entonces el terreno es conexo.</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo <code>esConexo()</code> es la siguiente:</p> <pre><code>public boolean esConexo() {\n    Set&lt;Casilla&gt; visitadas = new HashSet&lt;Casilla&gt;();\n    List&lt;Casilla&gt; pendientes = new ArrayList&lt;Casilla&gt;();\n\n    Casilla origen = terreno.getCasilla(0, 0);\n    pendientes.add(origen);\n\n    while (!pendientes.isEmpty()) {\n        Casilla c = pendientes.remove(0);\n        visitadas.add(c);\n\n        for (Direccion d : Direccion.values()) {\n            if (!c.hayPared(d)) {\n                Casilla v = terreno.getCasilla(c, d);\n                if (v != null &amp;&amp; !visitadas.contains(v)) {\n                    pendientes.add(v);\n                }\n            }\n        }\n    }\n\n    int N = terreno.getN();\n    return visitadas.size() == N * N;\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Complejidad temporal del algoritmo. (0,5 puntos) Determine la complejidad temporal del algoritmo programado en el apartado anterior. (1 punto) Justifique su respuesta. Se considera m\u00e1s importante el razonamiento sobre la complejidad que el c\u00e1lculo correcto.</li> </ul> Mostrar soluci\u00f3n <p>Dado que el algoritmo recorre, en el peor de los casos, todas las casillas del terreno, la complejidad b\u00e1sica ser\u00e1:</p> <p>[ O(N^2) \\times (\\text{complejidad de las operaciones}) ]</p> <p>Las operaciones b\u00e1sicas (comparaciones, asignaciones, accesos simples) tienen complejidad O(1).</p> <p>El acceso a las estructuras de datos depende de su implementaci\u00f3n. En el caso de<code>HashSet</code> las operaciones de inserci\u00f3n, borrado y b\u00fasqueda tienen complejidad O(1) de forma habitual. En el caso de <code>ArrayList</code>n la operaci\u00f3n <code>remove(0)</code> implica desplazar todos los elementos restantes, por lo que su complejidad es O(N).</p> <p>Por lo tanto, para el primer caso tenemos que el algoritmo es O(N\u00b2) y para el segundo O(N\u00b3).</p>","tags":["complejidad"]},{"location":"exams/2014/p1_ex02/","title":"P1 ex02","text":"<p>Sea un cruce de calles por el que circulan coches de oeste a este y de norte a sur. Para regular el tr\u00e1fico hay dos sem\u00e1foros, uno en la entrada oeste y otro en la entrada norte, y dos sensores, que se activan cuando llega un coche a cada una de las entradas. Tambi\u00e9n hay sensores que indican la salida del cruce.</p> <p>Se desea desarrollar un monitor en Java que simule la gesti\u00f3n de los sem\u00e1foros con las siguientes forma:</p> <ul> <li> <p>Los coches se modelan como hebras (threads) que invocan un m\u00e9todo <code>llegaNorte()</code> o <code>llegaOeste()</code> cuando llegan al cruce.</p> </li> <li> <p>Si el sem\u00e1foro correspondiente est\u00e1 en verde, el coche pasa inmediatamente.</p> </li> <li> <p>Si el sem\u00e1foro est\u00e1 en rojo, el coche espera hasta que se ponga en verde.</p> </li> <li> <p>Los coches tardan un cierto tiempo en atravesar el cruce. Al salir invocan el m\u00e9todo <code>sale()</code> del monitor.</p> </li> <li> <p>Una hebra de control llama peri\u00f3dicamente al m\u00e9todo <code>cambiaSem\u00e1foros()</code> para cambiar la configuraci\u00f3n de los sem\u00e1foros.</p> </li> </ul> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorCruce {\n    ...\n\n    // Lo invoca un coche que llega por el norte\n    llegaNorte() { ... }\n\n    // Lo invoca un coche que llega por el oeste\n    llegaOeste() { ... }\n\n    // Lo invoca un coche que sale del cruce\n    sale() { ... }\n\n    // Lo invoca la hebra de control\n    cambiaSem\u00e1foros() { ... }\n...\n}\n</code></pre> <ul> <li>(a) Se pide (5 puntos)  Desarrollar el c\u00f3digo completo del monitor , justificando la respuesta. Se valorar\u00e1 especialmente el razonamiento sobre el dise\u00f1o del monitor.</li> </ul> Mostrar soluci\u00f3n <p>En el sistema existen dos tipos de hebras que representan, respectivamente, el comportamiento de los coches y el control de los sem\u00e1foros. Estas hebras invocan los m\u00e9todos del monitor para actualizar el estado del cruce y sincronizarse.</p> <p>El monitor almacena el estado del cruce mediante atributos privados. En este caso se identifican los siguientes:</p> <ul> <li>Estado de los sem\u00e1foros: puede representarse mediante un valor booleano. Basta con una sola variable, ya que cuando un sem\u00e1foro est\u00e1 en verde, el otro est\u00e1 en rojo.</li> <li>N\u00famero de coches en el cruce: se representa mediante un booleano, ya que solo se permite un coche a la vez.</li> </ul> <p>N\u00f3tese que no es necesario representar el n\u00famero de coches que esperan, ni el tiempo que transcurre entre la entrada y la un salida de un coche. Este \u00faltimo aspecto se debe modelar en la clase que representa elcomportamiento de los coches. Tampoco hay que modelar aqu\u00ed el tiempo que transcurre entre los cambios de los sem\u00e1foros, que corresponde a la hebra de control.</p> <p>En cuanto a la implementaci\u00f3n del gestor, debe realizarse como un monitor, por lo que todos los atributos dedatos deber ser privados, y todos los m\u00e9todos p\u00fablicos (excepto los constructores) deben estar sincronizados.</p> <p>Una posible implementaci\u00f3n es la siguiente:</p> <pre><code>public class GestorCruce {\n\n    // true indica sem\u00e1foro norte en verde (oeste en rojo)\n    private boolean norteVerde = true;\n\n    // Indica si hay un coche pasando por el cruce\n    private boolean cochePasando = false;\n\n    // Invocado por un coche que llega desde el norte\n    public synchronized void entraNorte() throws InterruptedException {\n        while (!norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que llega desde el oeste\n    public synchronized void entraOeste() throws InterruptedException {\n        while (norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que sale del cruce\n    public synchronized void sale() {\n        cochePasando = false;\n        notifyAll();\n    }\n\n    // Invocado por la hebra de control de los sem\u00e1foros\n    public synchronized void cambiaSemaforos() {\n        norteVerde = !norteVerde;\n        notifyAll();\n    }\n}\n</code></pre> <p>Obs\u00e9rvese que si cambian los sem\u00e1foros cuando hay un coche en el cruce, no puede entrar ning\u00fan otro coche en la nueva orientaci\u00f3n hasta que el coche que est\u00e1 en el cruce salga, ya que <code>cochePasando</code> ser\u00e1 <code>true</code>.</p> <p>Los m\u00e9todos <code>entraNorte</code> y <code>entraOeste</code> propagan <code>IntrruptedException</code>. Una alternativa ser\u00eda maneja la interrupci\u00f3n en estos m\u00e9todos con un bloque try-catch.</p>","tags":["monitores"]},{"location":"exams/2014/p1r/","title":"Examen 2014 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2014/p1r/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (5 puntos) Se llama mont\u00f3n (heap) a un array de valores enteros en el que, representado como un \u00e1rbol binario, todo nodo es mayor o igual que culaquiera de sus dos hijos (si existen):</li> </ul> <p>Se ve que para todo nodo representado en la posici\u00f3n <code>i</code> de un array su hijo izquierdo se encuentra en la posici\u00f3n <code>2\u00b7i + 1</code> y su hijo derecho se encuentra en la posici\u00f3n <code>2\u00b7i + 2</code>.</p> <p>As\u00ed pues, para ordenar de mayor a menor un conjunto de valores enteros, basta con colocarlos primero como un mont\u00f3n, y despu\u00e9s ir extrayendo sucesivamente el primer valor del array (la ra\u00edz principal), y a continuaci\u00f3n recuperar el mont\u00f3n de los elementos restantes, hasta que no quede ning\u00fan elemento.</p> <p>Para recuperar el mont\u00f3n de los restantes elementos cuando se extrae el primer elemento de la tabla, basta con colocar en su lugar el \u00faltimo, y a continuaci\u00f3n hacer descender \u00e9ste en el \u00e1rbol iterativamente, si resulta necesario, hasta el nivel donde no sea menor que ninguno de sus dos (posibles) descendientes. Detr\u00e1s se puede ver el c\u00f3digo de esta operaci\u00f3n, aunque no resulta necesario en absoluto consultarlo, si se ha entendido correctamente este p\u00e1rrafo.</p> <p>Sabiendo que la operaci\u00f3n de construir un mont\u00f3n a partir de un array de enteros cualquiera tiene una complejidad del orden de n \u2217 log(n), se pide encontrar y justificar la complejidad del algoritmo completo de ordenaci\u00f3n descrito</p> <pre><code>private static int[] montonOrdenado(int[] monton) {\n    int[] resultado = new int[monton.length];\n\n    for (int j = 0; j &lt; monton.length; j++) {\n        resultado[j] = monton[0];\n\n        int ultimoIndice = monton.length - 1 - j;\n        monton[0] = monton[ultimoIndice];\n        --ultimoIndice;\n\n        int i = 0;\n        while (true) {\n            int indiceHijoIzquierdo = 2 * i + 1;\n            int indiceHijoDerecho = 2 * i + 2;\n\n            // No hay hijos\n            if (indiceHijoIzquierdo &gt; ultimoIndice)\n                break;\n\n            // Solo hay hijo izquierdo\n            if (indiceHijoDerecho &gt; ultimoIndice) {\n                if (monton[i] &lt; monton[indiceHijoIzquierdo])\n                    intercambia(monton, i, indiceHijoIzquierdo);\n                break;\n            }\n\n            // Ambos hijos son menores o iguales\n            if ((monton[i] &gt;= monton[indiceHijoIzquierdo])\n                    &amp;&amp; (monton[i] &gt;= monton[indiceHijoDerecho]))\n                break;\n\n            // Uno de los hijos es mayor\n            if (monton[indiceHijoDerecho] &lt; monton[indiceHijoIzquierdo]) {\n                intercambia(monton, i, indiceHijoIzquierdo);\n                i = indiceHijoIzquierdo;\n            } else {\n                intercambia(monton, i, indiceHijoDerecho);\n                i = indiceHijoDerecho;\n            }\n        }\n    }\n    return resultado;\n}\n\nprivate static void intercambia(int[] array, int i, int j) {\n    int t = array[i];\n    array[i] = array[j];\n    array[j] = t;\n}\n</code></pre> Mostrar soluci\u00f3n <p>En la extracci\u00f3n de los valores en orden (descendente) del array, para cada uno de ellos hay que hacer descender en el \u00e1rbol la nueva raiz, hasta que encuentre un lugar apropiado para que se siga cumpliendo la condici\u00f3n de heap. Y como el \u00e1rbol est\u00e1 siempre equilibrado, este descenso ser\u00e1, como mucho, de longitud log(n).</p> <p>Como, por otra parte, esta operaci\u00f3n ha de realizarse para cada uno de los valores del array, la complejidad de la extracci\u00f3n ordenada de los n valores ser\u00e1 de orden n\u00b7log(n). Con lo que se tiene una complejidad para el algoritmo de ordenaci\u00f3n completo (creaci\u00f3n del heap original m\u00e1s extracci\u00f3n ordenada de todos sus valores) de orden n\u00b7log(n) + n\u00b7log(n). Expresi\u00f3n que, seg\u00fan las reglas de combinaci\u00f3n de \u00f3rdenes de complejidad, equivale simplemente a n\u00b7log(n).</p>"},{"location":"exams/2014/p1r/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) En un museo se exhibe un cortometraje de corta duraci\u00f3n repetidamente, con un breve descanso entre proyecciones. La capacidad de la sala es de 50 personas. En el descanso, se vac\u00eda la sala y pueden entrar los visitantes que lo deseen, sin sobrepasar la capacidad de la sala. Una vez comenzada la proyecci\u00f3n, no se permite el acceso a nuevos visitantes, que quedan esperando al siguiente descanso.</li> </ul> <p>Escriba una clase Monitor que controle el acceso a la sala. Cada visitante es modelado como una hebra, que invoca el m\u00e9todo <code>accederASala()</code> del Monitor cuando desea ver la proyecci\u00f3n. Adem\u00e1s hay otra hebra, Proyector, que peri\u00f3dicamente invoca el m\u00e9todo <code>comienzaProyecci\u00f3n()</code> y, tras la finalizaci\u00f3n de la proyecci\u00f3n, invoca el m\u00e9todo <code>terminaProyecci\u00f3n()</code>.</p> <p>El monitor debe permitir acceso a la Sala a las hebras <code>Visitante</code> siempre que: - No se sobrepase la capacidad de la sala - No haya comenzado la proyecci\u00f3n</p> <p>Cuando la proyecci\u00f3n termine, se debe permitir que los visitantes que estaban esperando accedan a la sala. Se entiende que TODOS los asistentes a una proyecci\u00f3n salen de la sala al terminar la proyecci\u00f3n.</p> <p>SE PIDE EXCLUSIVAMENTE EL C\u00d3DIGO DEL MONITOR. NO ESCRIBA EL C\u00d3DIGO DE VISITANTE.</p> <p>A continuaci\u00f3n se incluye el c\u00f3digo del Proyector.</p> <pre><code>public class Proyector extends Thread\n{\n    private final Monitor monitor;\n    private final int duracionProyeccion = 15000;\n    private final int duracionDescanso = 5000;\n\n    Proyector (Monitor monitor) {\n        this.monitor = monitor;\n        this.start();\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                sleep(duracionDescanso);\n                monitor.comienzaProyeccion();\n                sleep(duracionProyeccion);\n                monitor.terminaProyeccion();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>```java</p> <p>private int N= 10; private int numVisitantes; private boolean proyectando;</p> <p>Monitor() {     numVisitantes= 0;     proyectando= false; }</p> <p>public synchronized void comienzaProyeccion() {     proyectando= true; }</p> <p>public synchronized void terminaProyeccion() {     proyectando= false;     numVisitantes= 0;     notifyAll(); }</p> <p>public synchronized void accederASala() {     while ( proyectando || numVisitantes &gt;= N)     {         try {             wait();         } catch (InterruptedException e) {         }     }     numVisitantes++; } ```</p>"},{"location":"exams/2014/p1r_ex01/","title":"P1r ex01","text":"<ul> <li>(a) (5 puntos) Se llama mont\u00f3n (heap) a un array de valores enteros en el que, representado como un \u00e1rbol binario, todo nodo es mayor o igual que culaquiera de sus dos hijos (si existen):</li> </ul> <p>Se ve que para todo nodo representado en la posici\u00f3n <code>i</code> de un array su hijo izquierdo se encuentra en la posici\u00f3n <code>2\u00b7i + 1</code> y su hijo derecho se encuentra en la posici\u00f3n <code>2\u00b7i + 2</code>.</p> <p>As\u00ed pues, para ordenar de mayor a menor un conjunto de valores enteros, basta con colocarlos primero como un mont\u00f3n, y despu\u00e9s ir extrayendo sucesivamente el primer valor del array (la ra\u00edz principal), y a continuaci\u00f3n recuperar el mont\u00f3n de los elementos restantes, hasta que no quede ning\u00fan elemento.</p> <p>Para recuperar el mont\u00f3n de los restantes elementos cuando se extrae el primer elemento de la tabla, basta con colocar en su lugar el \u00faltimo, y a continuaci\u00f3n hacer descender \u00e9ste en el \u00e1rbol iterativamente, si resulta necesario, hasta el nivel donde no sea menor que ninguno de sus dos (posibles) descendientes. Detr\u00e1s se puede ver el c\u00f3digo de esta operaci\u00f3n, aunque no resulta necesario en absoluto consultarlo, si se ha entendido correctamente este p\u00e1rrafo.</p> <p>Sabiendo que la operaci\u00f3n de construir un mont\u00f3n a partir de un array de enteros cualquiera tiene una complejidad del orden de n \u2217 log(n), se pide encontrar y justificar la complejidad del algoritmo completo de ordenaci\u00f3n descrito</p> <pre><code>private static int[] montonOrdenado(int[] monton) {\n    int[] resultado = new int[monton.length];\n\n    for (int j = 0; j &lt; monton.length; j++) {\n        resultado[j] = monton[0];\n\n        int ultimoIndice = monton.length - 1 - j;\n        monton[0] = monton[ultimoIndice];\n        --ultimoIndice;\n\n        int i = 0;\n        while (true) {\n            int indiceHijoIzquierdo = 2 * i + 1;\n            int indiceHijoDerecho = 2 * i + 2;\n\n            // No hay hijos\n            if (indiceHijoIzquierdo &gt; ultimoIndice)\n                break;\n\n            // Solo hay hijo izquierdo\n            if (indiceHijoDerecho &gt; ultimoIndice) {\n                if (monton[i] &lt; monton[indiceHijoIzquierdo])\n                    intercambia(monton, i, indiceHijoIzquierdo);\n                break;\n            }\n\n            // Ambos hijos son menores o iguales\n            if ((monton[i] &gt;= monton[indiceHijoIzquierdo])\n                    &amp;&amp; (monton[i] &gt;= monton[indiceHijoDerecho]))\n                break;\n\n            // Uno de los hijos es mayor\n            if (monton[indiceHijoDerecho] &lt; monton[indiceHijoIzquierdo]) {\n                intercambia(monton, i, indiceHijoIzquierdo);\n                i = indiceHijoIzquierdo;\n            } else {\n                intercambia(monton, i, indiceHijoDerecho);\n                i = indiceHijoDerecho;\n            }\n        }\n    }\n    return resultado;\n}\n\nprivate static void intercambia(int[] array, int i, int j) {\n    int t = array[i];\n    array[i] = array[j];\n    array[j] = t;\n}\n</code></pre> Mostrar soluci\u00f3n <p>En la extracci\u00f3n de los valores en orden (descendente) del array, para cada uno de ellos hay que hacer descender en el \u00e1rbol la nueva raiz, hasta que encuentre un lugar apropiado para que se siga cumpliendo la condici\u00f3n de heap. Y como el \u00e1rbol est\u00e1 siempre equilibrado, este descenso ser\u00e1, como mucho, de longitud log(n).</p> <p>Como, por otra parte, esta operaci\u00f3n ha de realizarse para cada uno de los valores del array, la complejidad de la extracci\u00f3n ordenada de los n valores ser\u00e1 de orden n\u00b7log(n). Con lo que se tiene una complejidad para el algoritmo de ordenaci\u00f3n completo (creaci\u00f3n del heap original m\u00e1s extracci\u00f3n ordenada de todos sus valores) de orden n\u00b7log(n) + n\u00b7log(n). Expresi\u00f3n que, seg\u00fan las reglas de combinaci\u00f3n de \u00f3rdenes de complejidad, equivale simplemente a n\u00b7log(n).</p>","tags":["complejidad"]},{"location":"exams/2014/p1r_ex02/","title":"P1r ex02","text":"<ul> <li>(a) (5 puntos) En un museo se exhibe un cortometraje de corta duraci\u00f3n repetidamente, con un breve descanso entre proyecciones. La capacidad de la sala es de 50 personas. En el descanso, se vac\u00eda la sala y pueden entrar los visitantes que lo deseen, sin sobrepasar la capacidad de la sala. Una vez comenzada la proyecci\u00f3n, no se permite el acceso a nuevos visitantes, que quedan esperando al siguiente descanso.</li> </ul> <p>Escriba una clase Monitor que controle el acceso a la sala. Cada visitante es modelado como una hebra, que invoca el m\u00e9todo <code>accederASala()</code> del Monitor cuando desea ver la proyecci\u00f3n. Adem\u00e1s hay otra hebra, Proyector, que peri\u00f3dicamente invoca el m\u00e9todo <code>comienzaProyecci\u00f3n()</code> y, tras la finalizaci\u00f3n de la proyecci\u00f3n, invoca el m\u00e9todo <code>terminaProyecci\u00f3n()</code>.</p> <p>El monitor debe permitir acceso a la Sala a las hebras <code>Visitante</code> siempre que: - No se sobrepase la capacidad de la sala - No haya comenzado la proyecci\u00f3n</p> <p>Cuando la proyecci\u00f3n termine, se debe permitir que los visitantes que estaban esperando accedan a la sala. Se entiende que TODOS los asistentes a una proyecci\u00f3n salen de la sala al terminar la proyecci\u00f3n.</p> <p>SE PIDE EXCLUSIVAMENTE EL C\u00d3DIGO DEL MONITOR. NO ESCRIBA EL C\u00d3DIGO DE VISITANTE.</p> <p>A continuaci\u00f3n se incluye el c\u00f3digo del Proyector.</p> <pre><code>public class Proyector extends Thread\n{\n    private final Monitor monitor;\n    private final int duracionProyeccion = 15000;\n    private final int duracionDescanso = 5000;\n\n    Proyector (Monitor monitor) {\n        this.monitor = monitor;\n        this.start();\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                sleep(duracionDescanso);\n                monitor.comienzaProyeccion();\n                sleep(duracionProyeccion);\n                monitor.terminaProyeccion();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>```java</p> <p>private int N= 10; private int numVisitantes; private boolean proyectando;</p> <p>Monitor() {     numVisitantes= 0;     proyectando= false; }</p> <p>public synchronized void comienzaProyeccion() {     proyectando= true; }</p> <p>public synchronized void terminaProyeccion() {     proyectando= false;     numVisitantes= 0;     notifyAll(); }</p> <p>public synchronized void accederASala() {     while ( proyectando || numVisitantes &gt;= N)     {         try {             wait();         } catch (InterruptedException e) {         }     }     numVisitantes++; } ```</p>","tags":["monitores"]},{"location":"exams/2014/p2/","title":"Examen 2014 \u2014 Parcial 2","text":""},{"location":"exams/2014/p2/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (5 puntos) En la pr\u00e1ctica 2 (Pacman en Android) deseamos a\u00f1adir una nueva funcionalidad: que los jugadores ganen puntos. Consideraremos que cada escenario tiene s\u00f3lo un jugador. El jugador ganar\u00e1 1 punto cada vez que se mueva y avance una casilla.</li> </ul> <p>Adem\u00e1s, deseamos que al guardar una partida en la base de datos se almacene la puntuaci\u00f3n, y que se recupere cuando se carga la partida. Al cargar una partida almacenada, se desea que DbLoadActivity muestre una lista de las partidas guardadas, mostrando en cada fila el nombre de la partida y los puntos obtenidos.</p> <p>Se pide: indique qu\u00e9 clases de la pr\u00e1ctica debe modificar y c\u00f3mo. Incluya exclusivamente las modificaciones realizadas. No hace falta que escriba completas las cabeceras de los m\u00e9todos. En caso de que tenga varias alternativas, justifique y discuta su respuesta. </p> <p>Nota. En MyDbAdapter, basta con que indique las modificaciones necesarias para crear la tabla e insertar una nueva partida.</p> mostrar soluci\u00f3n <p>Debemos a\u00f1adir un campo puntos. Se puede a\u00f1adir en Escenario o en Jugador.</p> <ol> <li>Jugador</li> </ol> <pre><code>private int puntos;\n...\npublic int getPuntos() { return puntos; }\npublic void setPuntos(int puntos) { this.puntos = puntos; }\npublic void incrementa(int puntos) { this.puntos += puntos; }\n\nprivate Jugador() { ...\n    puntos = 0;\n}\n</code></pre> <ol> <li>Terreno, m\u00e9todo move</li> </ol> <pre><code>public synchronized Casilla move(Movil movil, Direccion direccion) {\n    origen.setMovil(null);\n    destino.setMovil(movil);\n    movil.setCasilla(destino);\n    jugador.incrementa(1);\n    ...\n}\n</code></pre> <ol> <li>MyDbAdapter</li> </ol> <p>3.1. En DatabaseHelper, debemos cambiar el String para crear la tabla, a\u00f1adiendo una columna:</p> <pre><code>CREATE TABLE TABLE_FOTOS (id INTEGER PRIMARY KEY AUTOINCREMENT,\nname TEXT, moviles TEXT, casillas TEXT, date TEXT, puntos INT);\n</code></pre> <p>3.2. inserfFoto()</p> <pre><code>public static final String COL_PUNTOS = \"puntos\";\n\npublic long insertFoto(String name) {\n    Escenario escenario = Escenario.getInstance();\n    Jugador jugador = escenario.getTerreno().getJugador();\n    ContentValues values = new ContentValues();\n    values.put(COL_NAME, name);\n    values.put(COL_MOVILES, DbUtils.getStringMoviles(terreno));\n    values.put(COL_CASILLAS, DbUtils.getStringCasillas(terreno));\n    values.put(COL_DATE, prepareDate());\n    values.put(COL_PUNTOS, escenario.getPuntos());\n    return db.insert(TABLE_FOTOS, null, values);\n}\n</code></pre> <ol> <li>DbLoadActivity</li> </ol> <pre><code>public class DbLoadActivity extends ListActivity {\n    private static final String TAG = \u201cDbLoadActivity\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) { ...\n        String[] columns = { MyDbAdapter.COL_NAME, MyDbAdapter.COL_PUNTOS};\n        ...\n    }\n\n    protected void onListItemClick(ListView listView,\n        View view, int position, long id) {\n        ...\n        Jugador jugador = escenario.getTerreno().getJugador();\n        jugador.setPuntos(cursor.getInt(cursor.getColumnIndex(\n            MyDbAdapter.COL_PUNTOS));\n    }\n    ...\n}\n</code></pre>"},{"location":"exams/2014/p2/#problema-2","title":"Problema 2","text":"<p>Conteste a las siguientes preguntas:</p> <ul> <li>(a) (1,5 puntos) En un layout existe un widget de tipo EditText con id \u201ctelefono\u201d. Escribir el c\u00f3digo que extrae lo tecleado por el usuario en el widget y genera una traza con el contenido.</li> </ul> Mostrar soluci\u00f3n <pre><code>EditText telefono = (EditText) findViewById(R.id.telefono);\nString numero = telefono.getText().toString();\nLog.i.(TAG, \u201cTel\u00e9fono: \u201c + numero);\n</code></pre> <ul> <li>(b) (1,5 puntos) Estando en una actividad se desea pasar a otra actividad llamada PantallaActivity. Escribir el c\u00f3digo necesario para lanzar esta actividad pas\u00e1ndole un par\u00e1metro entero llamado \u201cn\u201d.</li> </ul> Mostrar soluci\u00f3n <pre><code>Intent intent = new Intent(this, PantallaActivity.class);\nintent.putExtra(\"n\", n);\nstartActivity(intent);\n</code></pre> <ul> <li>(c) (2 puntos) Necesitamos enviar un mensaje (String M) a una larga lista de destinatarios cuyas direcciones de email tenemos en una lista de direcciones <code>List&lt;Email&gt;</code>. Tenemos un m\u00e9todo para enviar un correo:</li> </ul> <pre><code>boolean send(Email direccion, String mensaje)\n</code></pre> <p>Como este m\u00e9todo puede ser lento, usaremos una AsyncTask para el env\u00edo a la lista. Suponga que llamamos al m\u00e9todo execute() pas\u00e1ndole como par\u00e1metro la String M. Escriba la cabecera y cuerpo del m\u00e9todo de la AsyncTask que se ejecuta en otra hebra (thread) de forma que ocurra lo siguiente:     - cada vez que termina el env\u00edo de un mensaje, se lanza un Toast en la UI-thread con un mensaje que pone el email y el boolean que ha devuelto el m\u00e9todo send()     - el resultado final es el tiempo transcurrido en la hebra as\u00edncrona en milisegundos (un entero largo)</p> Mostrar soluci\u00f3n <pre><code>class Correo extends AsyncTask&lt;String,String, Long&gt; {\n    List&lt;Email&gt; direcciones ...;\n\n    protected void onPreExecute() {...} // se ejecuta en la UIThread\n\n    // se ejecuta en una nueva hebra, diferente de la UI Thread\n    @Override\n    protected Long doInBackground(final String... params) {\n        Long t0 = System.currentTimeMillis();\n        String mensaje = params[0];\n        for (Email direccion : direcciones) {\n            boolean enviado = send(direccion, mensaje);\n            String resultado = direccion + \": \u201c + enviado;\n            publishProgress(resultado);\n        }\n        Long t1 = System.currentTimeMillis();\n        return t1 - t0;\n    }\n\n    protected void onProgressUpdate(String... message) {...} // en la UIThread\n    protected void onPostExecute(Long result) {...} // en la UIThread\n}\n</code></pre> <p>S\u00f3lo se da el c\u00f3digo del m\u00e9todo doInBackground, dado que los otros m\u00e9todos se ejecutan en la UIThread. En particular, los Toast que se mencionan en el enunciado se lanzan desde los m\u00e9todos     onProgressUpdate y onPostExecute, que se ejecutan en la hebra principal (UIThread).</p>"},{"location":"exams/2014/p2_ex01/","title":"P2 ex01","text":"<ul> <li>(a) (5 puntos) En la pr\u00e1ctica 2 (Pacman en Android) deseamos a\u00f1adir una nueva funcionalidad: que los jugadores ganen puntos. Consideraremos que cada escenario tiene s\u00f3lo un jugador. El jugador ganar\u00e1 1 punto cada vez que se mueva y avance una casilla.</li> </ul> <p>Adem\u00e1s, deseamos que al guardar una partida en la base de datos se almacene la puntuaci\u00f3n, y que se recupere cuando se carga la partida. Al cargar una partida almacenada, se desea que DbLoadActivity muestre una lista de las partidas guardadas, mostrando en cada fila el nombre de la partida y los puntos obtenidos.</p> <p>Se pide: indique qu\u00e9 clases de la pr\u00e1ctica debe modificar y c\u00f3mo. Incluya exclusivamente las modificaciones realizadas. No hace falta que escriba completas las cabeceras de los m\u00e9todos. En caso de que tenga varias alternativas, justifique y discuta su respuesta. </p> <p>Nota. En MyDbAdapter, basta con que indique las modificaciones necesarias para crear la tabla e insertar una nueva partida.</p> mostrar soluci\u00f3n <p>Debemos a\u00f1adir un campo puntos. Se puede a\u00f1adir en Escenario o en Jugador.</p> <ol> <li>Jugador</li> </ol> <pre><code>private int puntos;\n...\npublic int getPuntos() { return puntos; }\npublic void setPuntos(int puntos) { this.puntos = puntos; }\npublic void incrementa(int puntos) { this.puntos += puntos; }\n\nprivate Jugador() { ...\n    puntos = 0;\n}\n</code></pre> <ol> <li>Terreno, m\u00e9todo move</li> </ol> <pre><code>public synchronized Casilla move(Movil movil, Direccion direccion) {\n    origen.setMovil(null);\n    destino.setMovil(movil);\n    movil.setCasilla(destino);\n    jugador.incrementa(1);\n    ...\n}\n</code></pre> <ol> <li>MyDbAdapter</li> </ol> <p>3.1. En DatabaseHelper, debemos cambiar el String para crear la tabla, a\u00f1adiendo una columna:</p> <pre><code>CREATE TABLE TABLE_FOTOS (id INTEGER PRIMARY KEY AUTOINCREMENT,\nname TEXT, moviles TEXT, casillas TEXT, date TEXT, puntos INT);\n</code></pre> <p>3.2. inserfFoto()</p> <pre><code>public static final String COL_PUNTOS = \"puntos\";\n\npublic long insertFoto(String name) {\n    Escenario escenario = Escenario.getInstance();\n    Jugador jugador = escenario.getTerreno().getJugador();\n    ContentValues values = new ContentValues();\n    values.put(COL_NAME, name);\n    values.put(COL_MOVILES, DbUtils.getStringMoviles(terreno));\n    values.put(COL_CASILLAS, DbUtils.getStringCasillas(terreno));\n    values.put(COL_DATE, prepareDate());\n    values.put(COL_PUNTOS, escenario.getPuntos());\n    return db.insert(TABLE_FOTOS, null, values);\n}\n</code></pre> <ol> <li>DbLoadActivity</li> </ol> <pre><code>public class DbLoadActivity extends ListActivity {\n    private static final String TAG = \u201cDbLoadActivity\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) { ...\n        String[] columns = { MyDbAdapter.COL_NAME, MyDbAdapter.COL_PUNTOS};\n        ...\n    }\n\n    protected void onListItemClick(ListView listView,\n        View view, int position, long id) {\n        ...\n        Jugador jugador = escenario.getTerreno().getJugador();\n        jugador.setPuntos(cursor.getInt(cursor.getColumnIndex(\n            MyDbAdapter.COL_PUNTOS));\n    }\n    ...\n}\n</code></pre>","tags":["android"]},{"location":"exams/2014/p2_ex02/","title":"P2 ex02","text":"<p>Conteste a las siguientes preguntas:</p> <ul> <li>(a) (1,5 puntos) En un layout existe un widget de tipo EditText con id \u201ctelefono\u201d. Escribir el c\u00f3digo que extrae lo tecleado por el usuario en el widget y genera una traza con el contenido.</li> </ul> Mostrar soluci\u00f3n <pre><code>EditText telefono = (EditText) findViewById(R.id.telefono);\nString numero = telefono.getText().toString();\nLog.i.(TAG, \u201cTel\u00e9fono: \u201c + numero);\n</code></pre> <ul> <li>(b) (1,5 puntos) Estando en una actividad se desea pasar a otra actividad llamada PantallaActivity. Escribir el c\u00f3digo necesario para lanzar esta actividad pas\u00e1ndole un par\u00e1metro entero llamado \u201cn\u201d.</li> </ul> Mostrar soluci\u00f3n <pre><code>Intent intent = new Intent(this, PantallaActivity.class);\nintent.putExtra(\"n\", n);\nstartActivity(intent);\n</code></pre> <ul> <li>(c) (2 puntos) Necesitamos enviar un mensaje (String M) a una larga lista de destinatarios cuyas direcciones de email tenemos en una lista de direcciones <code>List&lt;Email&gt;</code>. Tenemos un m\u00e9todo para enviar un correo:</li> </ul> <pre><code>boolean send(Email direccion, String mensaje)\n</code></pre> <p>Como este m\u00e9todo puede ser lento, usaremos una AsyncTask para el env\u00edo a la lista. Suponga que llamamos al m\u00e9todo execute() pas\u00e1ndole como par\u00e1metro la String M. Escriba la cabecera y cuerpo del m\u00e9todo de la AsyncTask que se ejecuta en otra hebra (thread) de forma que ocurra lo siguiente:     - cada vez que termina el env\u00edo de un mensaje, se lanza un Toast en la UI-thread con un mensaje que pone el email y el boolean que ha devuelto el m\u00e9todo send()     - el resultado final es el tiempo transcurrido en la hebra as\u00edncrona en milisegundos (un entero largo)</p> Mostrar soluci\u00f3n <pre><code>class Correo extends AsyncTask&lt;String,String, Long&gt; {\n    List&lt;Email&gt; direcciones ...;\n\n    protected void onPreExecute() {...} // se ejecuta en la UIThread\n\n    // se ejecuta en una nueva hebra, diferente de la UI Thread\n    @Override\n    protected Long doInBackground(final String... params) {\n        Long t0 = System.currentTimeMillis();\n        String mensaje = params[0];\n        for (Email direccion : direcciones) {\n            boolean enviado = send(direccion, mensaje);\n            String resultado = direccion + \": \u201c + enviado;\n            publishProgress(resultado);\n        }\n        Long t1 = System.currentTimeMillis();\n        return t1 - t0;\n    }\n\n    protected void onProgressUpdate(String... message) {...} // en la UIThread\n    protected void onPostExecute(Long result) {...} // en la UIThread\n}\n</code></pre> <p>S\u00f3lo se da el c\u00f3digo del m\u00e9todo doInBackground, dado que los otros m\u00e9todos se ejecutan en la UIThread. En particular, los Toast que se mencionan en el enunciado se lanzan desde los m\u00e9todos     onProgressUpdate y onPostExecute, que se ejecutan en la hebra principal (UIThread).</p>","tags":["android"]},{"location":"exams/2015/extra/","title":"Examen 2015 \u2014 Extraordinario","text":""},{"location":"exams/2015/extra/#problema-1","title":"Problema 1","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n es [0, 2, 6, 9, 11, 15] (la soluci\u00f3n no es necesariamente \u00fanica).</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>int[] lis(int[] x) {\n    int n = x.length;\n    int[] p = new int[n];\n    int[] m = new int[n + 1];\n    int le = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        int lo = 1;\n        int hi = le;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi + 1) / 2;\n            if (x[m[mid]] &lt; x[i])\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        int newLe = lo;\n        p[i] = m[newLe - 1];\n        m[newLe] = i;\n        if (newLe &gt; le)\n            le = newLe;\n    }\n\n    int[] s = new int[le];\n    int k = m[le];\n    for (int i = le - 1; i &gt;= 0; i--) {\n        s[i] = x[k];\n        k = p[k];\n    }\n    return s;\n}\n</code></pre></p> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n de tama\u00f1o N de la secuencia de entrada, razonando la soluci\u00f3n. NOTA: A efectos del examen se valorar\u00e1 m\u00e1s el razonamiento que el resultado final.</li> </ul> Mostrar soluci\u00f3n <p>Al principio hay un doble bucle anidado, siendo el bucle externo de complejidad lineal, mientras que el bucle interno es en principio de complejidad logar\u00edtmica, ya que hace b\u00fasqueda dicot\u00f3mica en un intervalo de tama\u00f1o no mayor que n.  Visto en m\u00e1s detalle, el bucle interno empieza con un intervalo de una unidad y aumenta su tama\u00f1o como mucho en una unidad m\u00e1s en cada vuelta al bucle externo (algunas vueltas se incrementa en una unidad y algunas vueltas no se incrementa).  As\u00ed pues, su tiempo de ejecuci\u00f3n estar\u00e1 acotado por una constante que multiplica a (log 1 + log 2 ... log n), lo cual es igual a log(12...n), es decir, log(n!). Cantidad que puede acotarse tambi\u00e9n por log(n^n), es decir, nlog(n) (aplicando la f\u00f3rmula de Stirling se obtiene un valor mas aproximado, (nlog n - n), pero del mismo orden de complejidad). Es decir, el bucle doble tiene complejidad lineal logar\u00edtmica. Y a continuaci\u00f3n del bucle doble anidado hay un bucle simple que es de complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser lineal logar\u00edtmica. En t\u00e9rminos formales: </p> <p>C(for.while) = O(log 1 + log 2 ... log n) = O(log(12...n)) = O(log(n!)) = O(n*log n)</p> <p>C(lis) =</p> <p>= C(for.while) + C(for)</p> <p>= O(n*log n) + O(n)</p> <p>= O(n*log n)</p>"},{"location":"exams/2015/extra/#problema-2","title":"Problema 2","text":"<p>Un sistema est\u00e1 compuesto por un conjunto de hebras que deben acceder a un recurso compartido con exclusi\u00f3n mutua. Estas hebras se dividen en dos grupos: H1 y H2. Las hebras del grupo H2 acceden al recurso con prioridad respecto a las del grupo H1. Es decir, las hebras H1 no pueden acceder al recurso si hay alguna hebra H2 esperando. Adem\u00e1s, las hebras del grupo H1 deben acceder al recurso en el mismo orden en el que lo han solicitado.</p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor GestorRecurso que gestione el acceso al recurso, de acuerdo a las caracter\u00edsticas descritas. El monitor deber\u00e1 tener tres operaciones:<ul> <li>\u2026 solicitarRecursoH1(): Este m\u00e9todo lo invocan las hebras del grupo H1 para solicitar acceso al recurso.</li> <li>\u2026 solicitarRecursoH2(): Este m\u00e9todo lo invocan las hebras del grupo H2 para solicitar acceso al recurso.</li> <li>\u2026 liberarRecurso(): Este m\u00e9todo lo invocan las hebras de los dos grupos para liberar el recurso.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorRecurso {\n    private int turno = 0;\n    private int ultimoSolicitar = 0;\n    private int nH2Esperando = 0;\n    private boolean recursoOcupado = false;\n\n    public synchronized void SolicitarRecursoH1() throws InterruptedException {\n        int miTurno = ultimoSolicitar;\n        ultimoSolicitar++;\n        while (miTurno &gt; turno || nH2Esperando &gt; 0 || recursoOcupado) {\n            wait();\n        }\n        turno++;\n        recursoOcupado = true;\n    }\n\n    public synchronized void SolicitarRecursoH2() throws InterruptedException {\n        nH2Esperando++;\n        while (recursoOcupado) {\n            wait();\n        }\n        recursoOcupado = true;\n        nH2Esperando--;\n    }\n\n    public synchronized void LiberarRecurso() {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2015/extra/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (2 puntos) En el pacman presentado como proyecto 1, queremos modificar el comportamiento del Fantasma00 de forma que evite acercarse a los Depredadores. Los Depredadores no saben nada del asco que suscitan. Suponga que nos facilitan un m\u00e9todo en Terreno que nos dice si hay un depredador a menos de 3 casillas de distancia de la que pasamos como argumento:</li> </ul> <p>public synchronized boolean hayDepredador(Casilla casilla)</p> <pre><code>- \u00bfPodemos hacerlo en el m\u00e9todo run() de Fantasma00?Razone si s\u00ed o si no.\n- \u00bfPodemos hacerlo en el m\u00e9todo puedoMoverme() de Fantasma00? Razone si s\u00ed o si no.\n- Si cree que se puede hacer de ambas maneras, indique ventajas e inconvenientes de una y otra opci\u00f3n\n</code></pre> Mostrar soluci\u00f3n <ul> <li>S\u00ed se puede en run().</li> <li>Se puede optimizar el movimiento huyendo del depredador (moviendo en direcci\u00f3n opuesta).</li> <li>Se ejecuta fuera de la zona cr\u00edtica y el depredador y dem\u00e1s fantasmas se pueden mover mientras estamos eligiendo a d\u00f3nde ir.</li> <li>S\u00ed se puede en puedoMoverme().</li> <li>S\u00f3lo podemos hacer que el fantasma espere, sin moverse.</li> <li>se ejecuta dentro de la zona cr\u00edtica de forma que el depredador y todos los fantasmas est\u00e1n quietos mientras tomamos la decisi\u00f3n.</li> </ul>"},{"location":"exams/2015/extra/#problema-4","title":"Problema 4","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione los gastos de un usuario. Cada vez que se realiza un gasto, el usuario puede introducir la cantidad gastada (\u201cImporte\u201d, campo num\u00e9rico real) y en qu\u00e9 se lo ha gastado (\u201cConcepto\u201d, de tipo texto). Estos registros se guardar\u00e1n en una base de datos sqlite, con una \u00fanica tabla. La aplicaci\u00f3n mostrar\u00e1 los registros existentes mediante una ListActivity. </p> <p>La aplicaci\u00f3n dispone de un men\u00fa con dos opciones, \u201cA\u00f1adir\u201d y \u201cAcerca de\u201d. La especificaci\u00f3n del men\u00fa es la siguiente:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;item\n        android:id=\"@+id/annadir\"\n        android:title=\"A\u00f1adir\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/ayuda\"\n        android:title=\"Acerca de\" /&gt;\n\n&lt;/menu&gt;\n</code></pre> <p>La sentencia SQL para crear la tabla en la base de datos es:</p> <pre><code>CREATE TABLE gastos (_id INTEGER PRIMARY KEY AUTOINCREMENT, Concepto TEXT NOT NULL, Importe REAL NOT NULL)\n</code></pre> <p>La aplicaci\u00f3n dispone de un adaptador de bases de datos, con la siguiente codificaci\u00f3n (parcial):</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba una sentencia SQL que devuelva todos los registros de la base de datos cuyo importe supere el valor de 50,00.</li> </ul> Mostrar soluci\u00f3n <pre><code>SELECT * FROM gastos WHERE Importe &gt; 50;\n</code></pre> <ul> <li> <p>(b) (1 punto) Sobreescriba el m\u00e9todo adecuado de ListActivity para implementar el siguiente comportamiento:</p> <ul> <li>1) la opci\u00f3n \u201cAcerca de\u201d muestra un Toast con el nombre del autor del c\u00f3digo (usted);</li> <li>2) la opci\u00f3n \u201cA\u00f1adir\u201d se lance otra actividad llamada \u201cAnadirGastoActivity\u201d que ya est\u00e1 implementada.</li> </ul> <p>Tenga en cuenta que \u201cAnadirGastoActivity\u201d devolver\u00e1 un Intent con los datos del usuario.</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n\n        case R.id.ayuda:\n            Toast.makeText(\n                    this,\n                    getString(R.string.msg_ayuda),\n                    Toast.LENGTH_SHORT\n            ).show();\n            return true;\n\n        case R.id.annadir: {\n            Intent miIntent = new Intent(\n                    this,\n                    AnadirGastoActivity.class\n            );\n            miIntent.putExtra(REQUEST_CODE, CREA_PRODUCTO);\n            startActivityForResult(miIntent, CREA_PRODUCTO);\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfQu\u00e9 m\u00e9todos relativos al ciclo de vida de las actividades ListActivity y AnadirGastoActivity se ejecutan desde que se selecciona la opci\u00f3n \u201cA\u00f1adir\u201d del men\u00fa hasta que se vuelve a mostrar la lista de gasto? Escriba s\u00f3lo el nombre del m\u00e9todo y la actividad a la que pertenece, y el orden adecuado.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Actividad onPause() ListActivity onCreate() AnadirGastoActivity onStart() AnadirGastoActivity onResume() AnadirGastoActivity onStop() AnadirGastoActivity onPause() AnadirGastoActivity onRestart() ListActivity onStart() ListActivity onResume() ListActivity onStop() AnadirGastoActivity <ul> <li>(d) (1 punto) Escriba un m\u00e9todo de la clase DatabaseHelper que a\u00f1ada un nuevo registro a la base de datos. La informaci\u00f3n del Concepto y del Importe se pasar\u00e1 como par\u00e1metros del m\u00e9todo.</li> </ul> Mostrar soluci\u00f3n <pre><code>public long creaProducto(String gasto, float importe) {\n    ContentValues valoresIniciales = new ContentValues();\n\n    valoresIniciales.put(\"Concepto\", gasto);\n    valoresIniciales.put(\"Importe\", importe);\n\n    return db.insert(DATABASE_TABLE, null, valoresIniciales);\n}\n</code></pre> <ul> <li>(e) (1 punto) Escriba una especificaci\u00f3n de layout adecuada que se pueda utilizar en la actividad \u201cAnadirGastoActivity\u201d. Adem\u00e1s de los campos de informaci\u00f3n, dispondr\u00e1 de un bot\u00f3n \u201cGuardar\u201d y otro \u201cCancelar\u201d (s\u00f3lo hay que poner los botones). </li> </ul> Mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent \"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content \"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Concepto \" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editConcepto\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"&gt;\n        &lt;/EditText&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cantidad \u201c /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editTextCantidad\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:inputType=\"numberDecimal\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout android:orientation=\"horizontal\"&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonGuardar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Guardar\" /&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonCancelar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cancelar\" /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>"},{"location":"exams/2015/extra/#problema-5","title":"Problema 5","text":"<ul> <li>(a) (2 puntos) El proyecto 2 se basa en una adaptaci\u00f3n del proyecto 1. Seleccione la respuesta o respuestas correctas en la hoja de respuestas. Las respuestas incorrectas restan.<ul> <li> <ol> <li>La clase Terreno se adapta al ciclo de vida de Android</li> <li>I. No ser\u00eda imprescindible realizar esta adaptaci\u00f3n; simplemente la aplicaci\u00f3n seguir\u00eda usando recursos cuando no est\u00e1 en primer plano.</li> <li>II. Si no hacemos la adaptaci\u00f3n, tendremos interbloqueos.</li> <li>III. Los m\u00f3viles se congelan en onPause() y se descongelan en onResume().</li> <li>IV. Los m\u00f3viles se resucitan en onCreate()</li> </ol> </li> <li> <ol> <li>Las clases que extienden Movil (p.ej. Jugador, Estatua, Depredador, \u2026)</li> <li>I. Deben implementar restart() porque es un m\u00e9todo abstracto en Movil</li> <li>II. Si adem\u00e1s implementan Runnable, deben crear en restart() una hebra (new Thread()) y llamar a start() en la hebra creada</li> <li>III. Si adem\u00e1 s implementan Runnable, deben crear en pause() una hebra (new Thread()) y llamar a pause() en la hebra creada</li> <li>IV. Siempre que extienden Movil deben implementar Runnable</li> </ol> </li> </ul> </li> </ul> Mostrar soluci\u00f3n <ul> <li> <p>En 1 la opci\u00f3n correcta es III.</p> </li> <li> <p>En 2 las opciones correctas son III y IV.</p> </li> </ul> <ul> <li>(b) (3 puntos) Deseamos simplificar el comportamiento que hemos implementado el proyecto 2 para mover con el dedo el jugador. El nuevo comportamiento consiste en que si pulsamos en la casilla donde est\u00e1 el jugador, lanza un popup. Si pulsamos en una casilla diferente, el jugador se mueve en la direcci\u00f3n en la que est\u00e1 dicha casilla respecto del jugador.</li> </ul> <p>Adem\u00e1s, queremos poner una traza de error si se pulsa fuera del tablero.</p> <p>Suponga que dispone del m\u00e9todo popup para lanzar el popup como en la pr\u00e1ctica, as\u00ed como el resto de m\u00e9todos de las clases.</p> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onTouch(View view, MotionEvent event) {\n    try {\n        Movil jugador = terreno.getJugador();\n        if (jugador == null) {\n            return false;\n        }\n\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            int x1 = (int) (event.getX() / lado1);\n            int y1 = terreno.getN() - 1 - (int) (event.getY() / lado1);\n\n            Casilla casilla = terreno.getCasilla(x1, y1);\n            Casilla casillaJugador = jugador.getCasilla();\n\n            if (casillaJugador.equals(casilla)) {\n                popup(casilla);\n            } else {\n                int dx = (int) (x1 - casillaJugador.getX());\n                int dy = (int) (y1 - casillaJugador.getY());\n                Direccion direccion = null;\n\n                if (dy &gt; 0)\n                    direccion = Direccion.NORTE;\n                else if (dy &lt; 0)\n                    direccion = Direccion.SUR;\n                else if (dx &gt; 0)\n                    direccion = Direccion.ESTE;\n                else if (dx &lt; 0)\n                    direccion = Direccion.OESTE;\n\n                if (direccion != null) {\n                    terreno.move(jugador, direccion);\n                }\n            }\n        }\n    } catch (Exception e) {\n        Log.e(TAG, \"Ha pulsado fuera del tablero\");\n    }\n    return false;\n}\n</code></pre>"},{"location":"exams/2015/extra_ex01/","title":"Extra ex01","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n es [0, 2, 6, 9, 11, 15] (la soluci\u00f3n no es necesariamente \u00fanica).</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>int[] lis(int[] x) {\n    int n = x.length;\n    int[] p = new int[n];\n    int[] m = new int[n + 1];\n    int le = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        int lo = 1;\n        int hi = le;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi + 1) / 2;\n            if (x[m[mid]] &lt; x[i])\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        int newLe = lo;\n        p[i] = m[newLe - 1];\n        m[newLe] = i;\n        if (newLe &gt; le)\n            le = newLe;\n    }\n\n    int[] s = new int[le];\n    int k = m[le];\n    for (int i = le - 1; i &gt;= 0; i--) {\n        s[i] = x[k];\n        k = p[k];\n    }\n    return s;\n}\n</code></pre></p> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n de tama\u00f1o N de la secuencia de entrada, razonando la soluci\u00f3n. NOTA: A efectos del examen se valorar\u00e1 m\u00e1s el razonamiento que el resultado final.</li> </ul> Mostrar soluci\u00f3n <p>Al principio hay un doble bucle anidado, siendo el bucle externo de complejidad lineal, mientras que el bucle interno es en principio de complejidad logar\u00edtmica, ya que hace b\u00fasqueda dicot\u00f3mica en un intervalo de tama\u00f1o no mayor que n.  Visto en m\u00e1s detalle, el bucle interno empieza con un intervalo de una unidad y aumenta su tama\u00f1o como mucho en una unidad m\u00e1s en cada vuelta al bucle externo (algunas vueltas se incrementa en una unidad y algunas vueltas no se incrementa).  As\u00ed pues, su tiempo de ejecuci\u00f3n estar\u00e1 acotado por una constante que multiplica a (log 1 + log 2 ... log n), lo cual es igual a log(12...n), es decir, log(n!). Cantidad que puede acotarse tambi\u00e9n por log(n^n), es decir, nlog(n) (aplicando la f\u00f3rmula de Stirling se obtiene un valor mas aproximado, (nlog n - n), pero del mismo orden de complejidad). Es decir, el bucle doble tiene complejidad lineal logar\u00edtmica. Y a continuaci\u00f3n del bucle doble anidado hay un bucle simple que es de complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser lineal logar\u00edtmica. En t\u00e9rminos formales: </p> <p>C(for.while) = O(log 1 + log 2 ... log n) = O(log(12...n)) = O(log(n!)) = O(n*log n)</p> <p>C(lis) =</p> <p>= C(for.while) + C(for)</p> <p>= O(n*log n) + O(n)</p> <p>= O(n*log n)</p>","tags":["complejidad"]},{"location":"exams/2015/extra_ex02/","title":"Extra ex02","text":"<p>Un sistema est\u00e1 compuesto por un conjunto de hebras que deben acceder a un recurso compartido con exclusi\u00f3n mutua. Estas hebras se dividen en dos grupos: H1 y H2. Las hebras del grupo H2 acceden al recurso con prioridad respecto a las del grupo H1. Es decir, las hebras H1 no pueden acceder al recurso si hay alguna hebra H2 esperando. Adem\u00e1s, las hebras del grupo H1 deben acceder al recurso en el mismo orden en el que lo han solicitado.</p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor GestorRecurso que gestione el acceso al recurso, de acuerdo a las caracter\u00edsticas descritas. El monitor deber\u00e1 tener tres operaciones:<ul> <li>\u2026 solicitarRecursoH1(): Este m\u00e9todo lo invocan las hebras del grupo H1 para solicitar acceso al recurso.</li> <li>\u2026 solicitarRecursoH2(): Este m\u00e9todo lo invocan las hebras del grupo H2 para solicitar acceso al recurso.</li> <li>\u2026 liberarRecurso(): Este m\u00e9todo lo invocan las hebras de los dos grupos para liberar el recurso.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorRecurso {\n    private int turno = 0;\n    private int ultimoSolicitar = 0;\n    private int nH2Esperando = 0;\n    private boolean recursoOcupado = false;\n\n    public synchronized void SolicitarRecursoH1() throws InterruptedException {\n        int miTurno = ultimoSolicitar;\n        ultimoSolicitar++;\n        while (miTurno &gt; turno || nH2Esperando &gt; 0 || recursoOcupado) {\n            wait();\n        }\n        turno++;\n        recursoOcupado = true;\n    }\n\n    public synchronized void SolicitarRecursoH2() throws InterruptedException {\n        nH2Esperando++;\n        while (recursoOcupado) {\n            wait();\n        }\n        recursoOcupado = true;\n        nH2Esperando--;\n    }\n\n    public synchronized void LiberarRecurso() {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2015/extra_ex03/","title":"Extra ex03","text":"<ul> <li>(a) (2 puntos) En el pacman presentado como proyecto 1, queremos modificar el comportamiento del Fantasma00 de forma que evite acercarse a los Depredadores. Los Depredadores no saben nada del asco que suscitan. Suponga que nos facilitan un m\u00e9todo en Terreno que nos dice si hay un depredador a menos de 3 casillas de distancia de la que pasamos como argumento:</li> </ul> <p>public synchronized boolean hayDepredador(Casilla casilla)</p> <pre><code>- \u00bfPodemos hacerlo en el m\u00e9todo run() de Fantasma00?Razone si s\u00ed o si no.\n- \u00bfPodemos hacerlo en el m\u00e9todo puedoMoverme() de Fantasma00? Razone si s\u00ed o si no.\n- Si cree que se puede hacer de ambas maneras, indique ventajas e inconvenientes de una y otra opci\u00f3n\n</code></pre> Mostrar soluci\u00f3n <ul> <li>S\u00ed se puede en run().</li> <li>Se puede optimizar el movimiento huyendo del depredador (moviendo en direcci\u00f3n opuesta).</li> <li>Se ejecuta fuera de la zona cr\u00edtica y el depredador y dem\u00e1s fantasmas se pueden mover mientras estamos eligiendo a d\u00f3nde ir.</li> <li>S\u00ed se puede en puedoMoverme().</li> <li>S\u00f3lo podemos hacer que el fantasma espere, sin moverse.</li> <li>se ejecuta dentro de la zona cr\u00edtica de forma que el depredador y todos los fantasmas est\u00e1n quietos mientras tomamos la decisi\u00f3n.</li> </ul>","tags":["monitores"]},{"location":"exams/2015/extra_ex04/","title":"Extra ex04","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione los gastos de un usuario. Cada vez que se realiza un gasto, el usuario puede introducir la cantidad gastada (\u201cImporte\u201d, campo num\u00e9rico real) y en qu\u00e9 se lo ha gastado (\u201cConcepto\u201d, de tipo texto). Estos registros se guardar\u00e1n en una base de datos sqlite, con una \u00fanica tabla. La aplicaci\u00f3n mostrar\u00e1 los registros existentes mediante una ListActivity. </p> <p>La aplicaci\u00f3n dispone de un men\u00fa con dos opciones, \u201cA\u00f1adir\u201d y \u201cAcerca de\u201d. La especificaci\u00f3n del men\u00fa es la siguiente:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;item\n        android:id=\"@+id/annadir\"\n        android:title=\"A\u00f1adir\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/ayuda\"\n        android:title=\"Acerca de\" /&gt;\n\n&lt;/menu&gt;\n</code></pre> <p>La sentencia SQL para crear la tabla en la base de datos es:</p> <pre><code>CREATE TABLE gastos (_id INTEGER PRIMARY KEY AUTOINCREMENT, Concepto TEXT NOT NULL, Importe REAL NOT NULL)\n</code></pre> <p>La aplicaci\u00f3n dispone de un adaptador de bases de datos, con la siguiente codificaci\u00f3n (parcial):</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba una sentencia SQL que devuelva todos los registros de la base de datos cuyo importe supere el valor de 50,00.</li> </ul> Mostrar soluci\u00f3n <pre><code>SELECT * FROM gastos WHERE Importe &gt; 50;\n</code></pre> <ul> <li> <p>(b) (1 punto) Sobreescriba el m\u00e9todo adecuado de ListActivity para implementar el siguiente comportamiento:</p> <ul> <li>1) la opci\u00f3n \u201cAcerca de\u201d muestra un Toast con el nombre del autor del c\u00f3digo (usted);</li> <li>2) la opci\u00f3n \u201cA\u00f1adir\u201d se lance otra actividad llamada \u201cAnadirGastoActivity\u201d que ya est\u00e1 implementada.</li> </ul> <p>Tenga en cuenta que \u201cAnadirGastoActivity\u201d devolver\u00e1 un Intent con los datos del usuario.</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n\n        case R.id.ayuda:\n            Toast.makeText(\n                    this,\n                    getString(R.string.msg_ayuda),\n                    Toast.LENGTH_SHORT\n            ).show();\n            return true;\n\n        case R.id.annadir: {\n            Intent miIntent = new Intent(\n                    this,\n                    AnadirGastoActivity.class\n            );\n            miIntent.putExtra(REQUEST_CODE, CREA_PRODUCTO);\n            startActivityForResult(miIntent, CREA_PRODUCTO);\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfQu\u00e9 m\u00e9todos relativos al ciclo de vida de las actividades ListActivity y AnadirGastoActivity se ejecutan desde que se selecciona la opci\u00f3n \u201cA\u00f1adir\u201d del men\u00fa hasta que se vuelve a mostrar la lista de gasto? Escriba s\u00f3lo el nombre del m\u00e9todo y la actividad a la que pertenece, y el orden adecuado.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Actividad onPause() ListActivity onCreate() AnadirGastoActivity onStart() AnadirGastoActivity onResume() AnadirGastoActivity onStop() AnadirGastoActivity onPause() AnadirGastoActivity onRestart() ListActivity onStart() ListActivity onResume() ListActivity onStop() AnadirGastoActivity <ul> <li>(d) (1 punto) Escriba un m\u00e9todo de la clase DatabaseHelper que a\u00f1ada un nuevo registro a la base de datos. La informaci\u00f3n del Concepto y del Importe se pasar\u00e1 como par\u00e1metros del m\u00e9todo.</li> </ul> Mostrar soluci\u00f3n <pre><code>public long creaProducto(String gasto, float importe) {\n    ContentValues valoresIniciales = new ContentValues();\n\n    valoresIniciales.put(\"Concepto\", gasto);\n    valoresIniciales.put(\"Importe\", importe);\n\n    return db.insert(DATABASE_TABLE, null, valoresIniciales);\n}\n</code></pre> <ul> <li>(e) (1 punto) Escriba una especificaci\u00f3n de layout adecuada que se pueda utilizar en la actividad \u201cAnadirGastoActivity\u201d. Adem\u00e1s de los campos de informaci\u00f3n, dispondr\u00e1 de un bot\u00f3n \u201cGuardar\u201d y otro \u201cCancelar\u201d (s\u00f3lo hay que poner los botones). </li> </ul> Mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent \"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content \"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Concepto \" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editConcepto\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"&gt;\n        &lt;/EditText&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cantidad \u201c /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editTextCantidad\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:inputType=\"numberDecimal\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout android:orientation=\"horizontal\"&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonGuardar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Guardar\" /&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonCancelar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cancelar\" /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>","tags":["android"]},{"location":"exams/2015/extra_ex05/","title":"Extra ex05","text":"<ul> <li>(a) (2 puntos) El proyecto 2 se basa en una adaptaci\u00f3n del proyecto 1. Seleccione la respuesta o respuestas correctas en la hoja de respuestas. Las respuestas incorrectas restan.<ul> <li> <ol> <li>La clase Terreno se adapta al ciclo de vida de Android</li> <li>I. No ser\u00eda imprescindible realizar esta adaptaci\u00f3n; simplemente la aplicaci\u00f3n seguir\u00eda usando recursos cuando no est\u00e1 en primer plano.</li> <li>II. Si no hacemos la adaptaci\u00f3n, tendremos interbloqueos.</li> <li>III. Los m\u00f3viles se congelan en onPause() y se descongelan en onResume().</li> <li>IV. Los m\u00f3viles se resucitan en onCreate()</li> </ol> </li> <li> <ol> <li>Las clases que extienden Movil (p.ej. Jugador, Estatua, Depredador, \u2026)</li> <li>I. Deben implementar restart() porque es un m\u00e9todo abstracto en Movil</li> <li>II. Si adem\u00e1s implementan Runnable, deben crear en restart() una hebra (new Thread()) y llamar a start() en la hebra creada</li> <li>III. Si adem\u00e1 s implementan Runnable, deben crear en pause() una hebra (new Thread()) y llamar a pause() en la hebra creada</li> <li>IV. Siempre que extienden Movil deben implementar Runnable</li> </ol> </li> </ul> </li> </ul> Mostrar soluci\u00f3n <ul> <li> <p>En 1 la opci\u00f3n correcta es III.</p> </li> <li> <p>En 2 las opciones correctas son III y IV.</p> </li> </ul> <ul> <li>(b) (3 puntos) Deseamos simplificar el comportamiento que hemos implementado el proyecto 2 para mover con el dedo el jugador. El nuevo comportamiento consiste en que si pulsamos en la casilla donde est\u00e1 el jugador, lanza un popup. Si pulsamos en una casilla diferente, el jugador se mueve en la direcci\u00f3n en la que est\u00e1 dicha casilla respecto del jugador.</li> </ul> <p>Adem\u00e1s, queremos poner una traza de error si se pulsa fuera del tablero.</p> <p>Suponga que dispone del m\u00e9todo popup para lanzar el popup como en la pr\u00e1ctica, as\u00ed como el resto de m\u00e9todos de las clases.</p> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onTouch(View view, MotionEvent event) {\n    try {\n        Movil jugador = terreno.getJugador();\n        if (jugador == null) {\n            return false;\n        }\n\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            int x1 = (int) (event.getX() / lado1);\n            int y1 = terreno.getN() - 1 - (int) (event.getY() / lado1);\n\n            Casilla casilla = terreno.getCasilla(x1, y1);\n            Casilla casillaJugador = jugador.getCasilla();\n\n            if (casillaJugador.equals(casilla)) {\n                popup(casilla);\n            } else {\n                int dx = (int) (x1 - casillaJugador.getX());\n                int dy = (int) (y1 - casillaJugador.getY());\n                Direccion direccion = null;\n\n                if (dy &gt; 0)\n                    direccion = Direccion.NORTE;\n                else if (dy &lt; 0)\n                    direccion = Direccion.SUR;\n                else if (dx &gt; 0)\n                    direccion = Direccion.ESTE;\n                else if (dx &lt; 0)\n                    direccion = Direccion.OESTE;\n\n                if (direccion != null) {\n                    terreno.move(jugador, direccion);\n                }\n            }\n        }\n    } catch (Exception e) {\n        Log.e(TAG, \"Ha pulsado fuera del tablero\");\n    }\n    return false;\n}\n</code></pre>","tags":["android"]},{"location":"exams/2015/p1/","title":"Examen 2015 \u2014 Parcial 1","text":""},{"location":"exams/2015/p1/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (5 puntos) Como medida de similitud (o diferencia) entre dos documentos dados, representados como ficheros de texto, compa\u00f1\u00edas como Google utilizan el concepto de \u201cdistancia\u201d (o su contrario, \u201cproximidad\u201d) entre dos documentos, seg\u00fan el algoritmo que se describe a continuaci\u00f3n. </li> </ul> <p>Se descomponen los dos ficheros de texto en palabras y, para cada uno de los dos ficheros, se construye un vector ordenado con tantos componentes como palabras diferentes hay entre los dos ficheros, siendo el valor de cada elemento el n\u00famero de veces que la palabra en cuesti\u00f3n se repite en el fichero de texto dado. En especial, si una determinada palabra existe en un fichero pero no en el otro, el valor correspondiente para el segundo vector,  es cero. Por ejemplo, </p> Palabra d1 d2 \u00e1rbol 5 7 barco 2 0 \u2026 \u2026 \u2026 zapatiesta 0 3 <p>La palabra \u2018\u00e1rbol\u2019 aparece 5 veces en el fichero 1 y 7 veces en el 2. La palabra \u2018barco\u2019 no aparece en el fichero 2. La palabra \u2018zapatiesta\u2019 no aparece en el fichero 1.</p> <p>A continuaci\u00f3n se realiza el producto escalar de los dos vectores que, una vez dividido por el producto del n\u00famero total de palabras que hay en cada uno de los dos textos, nos da como resultado la medida de proximidad entre los dos documentos dados. </p> <p>Suponiendo que los dos documentos a comparar tienen una longitud similar, digamos N caracteres, y que la longitud m\u00e1xima de una palabra en espa\u00f1ol es K, se pide dar la complejidad del algoritmo descrito en t\u00e9rminos de N, a base de justificar la complejidad de cada una de las partes de las que se compone (el algoritmo). </p> <p>NOTA: Si no puede justificar la complejidad del algoritmo de ordenaci\u00f3n, considere que es O(NlogN).</p> Mostrar soluci\u00f3n <p>La extracci\u00f3n de las palabras se realiza iterando dentro de un simple bucle a lo largo de cada uno de los dos textos, lo cual da una complejidad lineal, es decir, O(N). </p> <p>Cada vez que en el bucle anterior se encuentra una palabra, se consultan y actualizan dos HashMap, cuyas operaciones son en todo caso de orden constante, y se hacen un n\u00famero m\u00e1ximo de ellas finito (y peque\u00f1o) por cada palabra encontrada, por lo que la fase anterior no ve modificada su complejidad de O(N). </p> <p>A continuaci\u00f3n han de construirse los dos vectores ordenados a partir de los valores que est\u00e1n desordenados en los HashMap, lo cual nos dicen que tiene una complejidad de O(N*logN). </p> <p>Por \u00faltimo, el c\u00e1lculo del producto escalar es otro bucle simple, repetido tantas veces como palabras diferentes hay, de una multiplicaci\u00f3n (complejidad constante) m\u00e1s una suma (tambi\u00e9n complejidad constante), lo cual da una complejidad para el producto escalar de O(N). La divisi\u00f3n posterior, siendo una sola y de complejidad constante, no cambia la complejidad de esta fase.  </p> <p>Asi pues, la complejidad total ser\u00e1, sumando las de cada una de sus tres fases, </p> <p>O(N) + O(NlogN) + O(N), lo cual se reduce, simplemente, a O(NlogN).</p>"},{"location":"exams/2015/p1/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (4 puntos) Se pretende sincronizar la fabricaci\u00f3n en una l\u00ednea de ensamblado de mesas. Hay varios fabricantes de patas, que las depositan en una l\u00ednea con un l\u00edmite de capacidad MAX_NUM_PATAS. Cuando se llena, los fabricantes dejan de producir patas hasta que haya hueco libre. Hay varios fabricantes de tableros, que depositan en otra l\u00ednea de capacidad limitada MAX_NUM_TABLEROS. Por \u00faltimo, hay varios ensambladores de mesas: cada uno coge cuatro patas y un tablero y ensambla una mesa. </li> </ul> <p>Se trata de escribir en Java un monitor que sincronice estos tres sistemas, de forma que la producci\u00f3n se detenga cuando se alcanza la capacidad m\u00e1xima de almacenamiento (de patas o tableros independientemente) y sistema de ensamblaje no avance si le faltan piezas para hacer una nueva mesa. </p> <p>NO ESCRIBA NING\u00daN C\u00d3DIGO para los subsistemas de producci\u00f3n y ensamblaje. </p> <p>El sincronizador responde al siguiente esquema: <pre><code>class Sincronizador { \n    ...  \n    ... ponPata() {...}    // lo invoca el productor de patas por cada una \n    ... ponTablero() {...} // lo invoca el productor de tableros \n    ... cogePatasyTablero () {...}   // lo invoca el ensamblador de mesas \n    ... \n} \n</code></pre> Se pide: Desarrollar el c\u00f3digo completo del monitor sincronizador.</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.em;\n\npublic class Sincronizador {\n\n   private static final int NUM_MAX_PATAS    = 10;\n   private static final int NUM_MAX_TABLEROS = 4;\n   private int numPatas = 0;\n   private int numTableros = 0;\n\n   public synchronized void ponTablero() throws InterruptedException {\n      while (numTableros &gt;= NUM_MAX_TABLEROS)\n      {\n         wait();\n      }\n\n      numTableros++;\n\n      notifyAll();\n   }\n\n   public synchronized void ponPatas() throws InterruptedException {\n      while (numPatas &gt;= NUM_MAX_PATAS)\n      {\n         wait();\n      }\n\n      numPatas++;\n\n      notifyAll();\n   }\n\n   public synchronized void cogePatasyTablero() throws InterruptedException {\n      while (numTableros &lt; 1 || numPatas &lt; 4)\n      {\n         wait();\n      }\n\n      numTableros--;\n      numPatas -= 4;\n\n      notifyAll();\n   }\n\n}\n</code></pre></p>"},{"location":"exams/2015/p1/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (1 punto) Describa dos casos posibles de error significativamente diferentes para detectar errores de la clase Paredes del alumno en el borde del tablero (concretamente en la casilla (0, 0)) y progr\u00e1melos con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponiendo que partimos de la casilla c = (0,0), dos ejemplos de casos de error podr\u00edan ser: </p> <p>1) Poner una pared hacia el OESTE. La pared no se a\u00f1ade.  2) Obtener la posible pared hacia el SUR. El resultado debe ser null. </p> <p>Y los casos de prueba correspondientes podr\u00edan ser:</p> <pre><code>private Terreno terreno \u2026 \nprivate Paredes paredes \u2026\n\n@Test\npublic void Test001() {\n   Casilla c = terreno.getCasilla(0, 0);\n   int size = paredes.size();\n   paredes.add(c, Direccion.OESTE);\n   assertEquals(paredes.size(), size); // la pared no se ha a\u00f1adido\n}\n\n@Test\npublic void Test002() {\n   Casilla c = terreno.getCasilla(0, 0);\n   assertNull(paredes.get(c, Direccion.SUR));\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba el m\u00e9todo necesario para que un fantasma empiece movi\u00e9ndose hacia el NORTE hasta que choca con una pared; cuando choca intenta moverse al ESTE hasta que choca con una pared; y as\u00ed sucesivamente, rotando 90\u00ba a la derecha cada vez que choca. Si no puede desplazarse a ninguna de las casillas circundantes, deja pasar esta vez y espera al siguiente ciclo.</li> </ul> Mostar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>public class Fantasma01 {\n...\n\npublic void run() {\n    Direccion[] direcciones =\n        {Direccion.NORTE, Direccion.ESTE, Direccion.SUR, Direccion.OESTE};\n    int direccionActual = 0;\n\n    while (vivo) {\n        if (casilla != null) {\n            for (int i = 0; i &lt; 4; i++) {\n                if (!terreno.hayPared(casilla, direcciones[direccionActual])) {\n                    terreno.move(this, direcciones[direccionActual]);\n                    break;\n                }\n                direccionActual = (direccionActual + 1) % 4;\n            }\n            try {\n                Thread.sleep(DELAY);\n            } catch (InterruptedException ignored) {}\n        }\n    }\n}\n}\n</code></pre></p>"},{"location":"exams/2015/p1_ex01/","title":"P1 ex01","text":"<ul> <li>(a) (5 puntos) Como medida de similitud (o diferencia) entre dos documentos dados, representados como ficheros de texto, compa\u00f1\u00edas como Google utilizan el concepto de \u201cdistancia\u201d (o su contrario, \u201cproximidad\u201d) entre dos documentos, seg\u00fan el algoritmo que se describe a continuaci\u00f3n. </li> </ul> <p>Se descomponen los dos ficheros de texto en palabras y, para cada uno de los dos ficheros, se construye un vector ordenado con tantos componentes como palabras diferentes hay entre los dos ficheros, siendo el valor de cada elemento el n\u00famero de veces que la palabra en cuesti\u00f3n se repite en el fichero de texto dado. En especial, si una determinada palabra existe en un fichero pero no en el otro, el valor correspondiente para el segundo vector,  es cero. Por ejemplo, </p> Palabra d1 d2 \u00e1rbol 5 7 barco 2 0 \u2026 \u2026 \u2026 zapatiesta 0 3 <p>La palabra \u2018\u00e1rbol\u2019 aparece 5 veces en el fichero 1 y 7 veces en el 2. La palabra \u2018barco\u2019 no aparece en el fichero 2. La palabra \u2018zapatiesta\u2019 no aparece en el fichero 1.</p> <p>A continuaci\u00f3n se realiza el producto escalar de los dos vectores que, una vez dividido por el producto del n\u00famero total de palabras que hay en cada uno de los dos textos, nos da como resultado la medida de proximidad entre los dos documentos dados. </p> <p>Suponiendo que los dos documentos a comparar tienen una longitud similar, digamos N caracteres, y que la longitud m\u00e1xima de una palabra en espa\u00f1ol es K, se pide dar la complejidad del algoritmo descrito en t\u00e9rminos de N, a base de justificar la complejidad de cada una de las partes de las que se compone (el algoritmo). </p> <p>NOTA: Si no puede justificar la complejidad del algoritmo de ordenaci\u00f3n, considere que es O(NlogN).</p> Mostrar soluci\u00f3n <p>La extracci\u00f3n de las palabras se realiza iterando dentro de un simple bucle a lo largo de cada uno de los dos textos, lo cual da una complejidad lineal, es decir, O(N). </p> <p>Cada vez que en el bucle anterior se encuentra una palabra, se consultan y actualizan dos HashMap, cuyas operaciones son en todo caso de orden constante, y se hacen un n\u00famero m\u00e1ximo de ellas finito (y peque\u00f1o) por cada palabra encontrada, por lo que la fase anterior no ve modificada su complejidad de O(N). </p> <p>A continuaci\u00f3n han de construirse los dos vectores ordenados a partir de los valores que est\u00e1n desordenados en los HashMap, lo cual nos dicen que tiene una complejidad de O(N*logN). </p> <p>Por \u00faltimo, el c\u00e1lculo del producto escalar es otro bucle simple, repetido tantas veces como palabras diferentes hay, de una multiplicaci\u00f3n (complejidad constante) m\u00e1s una suma (tambi\u00e9n complejidad constante), lo cual da una complejidad para el producto escalar de O(N). La divisi\u00f3n posterior, siendo una sola y de complejidad constante, no cambia la complejidad de esta fase.  </p> <p>Asi pues, la complejidad total ser\u00e1, sumando las de cada una de sus tres fases, </p> <p>O(N) + O(NlogN) + O(N), lo cual se reduce, simplemente, a O(NlogN).</p>","tags":["complejidad"]},{"location":"exams/2015/p1_ex02/","title":"P1 ex02","text":"<ul> <li>(a) (4 puntos) Se pretende sincronizar la fabricaci\u00f3n en una l\u00ednea de ensamblado de mesas. Hay varios fabricantes de patas, que las depositan en una l\u00ednea con un l\u00edmite de capacidad MAX_NUM_PATAS. Cuando se llena, los fabricantes dejan de producir patas hasta que haya hueco libre. Hay varios fabricantes de tableros, que depositan en otra l\u00ednea de capacidad limitada MAX_NUM_TABLEROS. Por \u00faltimo, hay varios ensambladores de mesas: cada uno coge cuatro patas y un tablero y ensambla una mesa. </li> </ul> <p>Se trata de escribir en Java un monitor que sincronice estos tres sistemas, de forma que la producci\u00f3n se detenga cuando se alcanza la capacidad m\u00e1xima de almacenamiento (de patas o tableros independientemente) y sistema de ensamblaje no avance si le faltan piezas para hacer una nueva mesa. </p> <p>NO ESCRIBA NING\u00daN C\u00d3DIGO para los subsistemas de producci\u00f3n y ensamblaje. </p> <p>El sincronizador responde al siguiente esquema: <pre><code>class Sincronizador { \n    ...  \n    ... ponPata() {...}    // lo invoca el productor de patas por cada una \n    ... ponTablero() {...} // lo invoca el productor de tableros \n    ... cogePatasyTablero () {...}   // lo invoca el ensamblador de mesas \n    ... \n} \n</code></pre> Se pide: Desarrollar el c\u00f3digo completo del monitor sincronizador.</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.em;\n\npublic class Sincronizador {\n\n   private static final int NUM_MAX_PATAS    = 10;\n   private static final int NUM_MAX_TABLEROS = 4;\n   private int numPatas = 0;\n   private int numTableros = 0;\n\n   public synchronized void ponTablero() throws InterruptedException {\n      while (numTableros &gt;= NUM_MAX_TABLEROS)\n      {\n         wait();\n      }\n\n      numTableros++;\n\n      notifyAll();\n   }\n\n   public synchronized void ponPatas() throws InterruptedException {\n      while (numPatas &gt;= NUM_MAX_PATAS)\n      {\n         wait();\n      }\n\n      numPatas++;\n\n      notifyAll();\n   }\n\n   public synchronized void cogePatasyTablero() throws InterruptedException {\n      while (numTableros &lt; 1 || numPatas &lt; 4)\n      {\n         wait();\n      }\n\n      numTableros--;\n      numPatas -= 4;\n\n      notifyAll();\n   }\n\n}\n</code></pre></p>","tags":["monitores"]},{"location":"exams/2015/p1_ex03/","title":"P1 ex03","text":"<ul> <li>(a) (1 punto) Describa dos casos posibles de error significativamente diferentes para detectar errores de la clase Paredes del alumno en el borde del tablero (concretamente en la casilla (0, 0)) y progr\u00e1melos con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponiendo que partimos de la casilla c = (0,0), dos ejemplos de casos de error podr\u00edan ser: </p> <p>1) Poner una pared hacia el OESTE. La pared no se a\u00f1ade.  2) Obtener la posible pared hacia el SUR. El resultado debe ser null. </p> <p>Y los casos de prueba correspondientes podr\u00edan ser:</p> <pre><code>private Terreno terreno \u2026 \nprivate Paredes paredes \u2026\n\n@Test\npublic void Test001() {\n   Casilla c = terreno.getCasilla(0, 0);\n   int size = paredes.size();\n   paredes.add(c, Direccion.OESTE);\n   assertEquals(paredes.size(), size); // la pared no se ha a\u00f1adido\n}\n\n@Test\npublic void Test002() {\n   Casilla c = terreno.getCasilla(0, 0);\n   assertNull(paredes.get(c, Direccion.SUR));\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba el m\u00e9todo necesario para que un fantasma empiece movi\u00e9ndose hacia el NORTE hasta que choca con una pared; cuando choca intenta moverse al ESTE hasta que choca con una pared; y as\u00ed sucesivamente, rotando 90\u00ba a la derecha cada vez que choca. Si no puede desplazarse a ninguna de las casillas circundantes, deja pasar esta vez y espera al siguiente ciclo.</li> </ul> Mostar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>public class Fantasma01 {\n...\n\npublic void run() {\n    Direccion[] direcciones =\n        {Direccion.NORTE, Direccion.ESTE, Direccion.SUR, Direccion.OESTE};\n    int direccionActual = 0;\n\n    while (vivo) {\n        if (casilla != null) {\n            for (int i = 0; i &lt; 4; i++) {\n                if (!terreno.hayPared(casilla, direcciones[direccionActual])) {\n                    terreno.move(this, direcciones[direccionActual]);\n                    break;\n                }\n                direccionActual = (direccionActual + 1) % 4;\n            }\n            try {\n                Thread.sleep(DELAY);\n            } catch (InterruptedException ignored) {}\n        }\n    }\n}\n}\n</code></pre></p>","tags":["???"]},{"location":"exams/2015/p1r/","title":"Examen 2015 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2015/p1r/#problema-1","title":"Problema 1","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n (puede haber m\u00e1s de una) es:</p> <p>[0, 2, 6, 9, 11, 15]</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre></p> <pre><code>int[] getLIS(int[] x) {\n    int n = x.length;\n    int[] len = new int[n];\n    Arrays.fill(len, 1);\n    int[] pred = new int[n];\n    Arrays.fill(pred, -1);\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 0; j &lt; i; j++) {\n            if (x[j] &lt; x[i] &amp;&amp; len[i] &lt; len[j] + 1) {\n                len[i] = len[j] + 1;\n                pred[i] = j;\n            }\n        }\n    }\n    int bi = 0;\n    for (int i = 1; i &lt; n; i++) {\n        if (len[bi] &lt; len[i])\n            bi = i;\n    }\n    int cnt = len[bi];\n    int[] res = new int[cnt];\n    for (int i = bi; i != -1; i = pred[i])\n        res[--cnt] = x[i];\n    return res;\n}\n</code></pre> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n del tama\u00f1o N de la secuencia de entrada, razonando la soluci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>La iniciaci\u00f3n de los arrays \"len\" y \"pred\" es de complejidad lineal, pues se visitan todos sus elementos una sola vez, y su longitud es n.</p> <p>A continuaci\u00f3n hay un bucle doble anidado, cuyo cuerpo, de complejidad constante, se ejecuta 1 + 2 + 3 + ... + n-1 veces, es decir, un total de n/2*(n-1) veces. Por lo que su complejidad es cuadr\u00e1tica.</p> <p>Al final hay dos bucles simples con cuerpo de complejidad constante y n\u00famero de vueltas de orden n, que tienen pues complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser cuadr\u00e1tica. En t\u00e9rminos formales: C(for.for) = O(1+2+3+...+(n-1)) = O(n/2 * (n-1)) = O(n^2 / 2) - O(n/2) = O(n^2) C(LIS) = C(arrays.fill) + C(Arrays.fill) + C(for.for) + C(for) + C(for) = O(n) + O(n) + C(for.for) + O(n) + O(n/k) = O(n) + O(n) + O(n^2) + O(n) + O(n) = O(n^2).</p>"},{"location":"exams/2015/p1r/#problema-2","title":"Problema 2","text":"<p>Se tiene un sistema con dos hebras (H1 y H2) que acceden continuamente a un recurso compartido, que se debe usar con exclusi\u00f3n mutua. Para que el sistema funcione correctamente las hebras tienen que acceder seg\u00fan el siguiente patr\u00f3n, que se  debe repetir c\u00edclicamente: H1, H1, H2, H1, H2, como se ve en la figura siguiente:</p> <p></p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor (GestorCiclosAcceso) para sincronizar las hebras seg\u00fan el comportamiento descrito. El monitor debe proporcionar las siguientes operaciones:<ul> <li>... void accederH1(): Este m\u00e9todo lo invoca la hebra H1 para solicitar acceso al recurso compartido.</li> <li>... void accederH2(): Este m\u00e9todo lo invoca la hebra H2 para solicitar acceso al recurso compartido.</li> <li>... void liberar(): Este m\u00e9todo lo invocan las hebras para liberar el recurso compartido.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p><pre><code>public class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\npublic class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre> Otra posible implementaci\u00f3n, que utiliza m\u00e1quinas de estados, es la siguiente:</p> <pre><code>public class GestorCiclosAcceso2 {\n    // estado 0 - espera H1\n    // estado 1 - espera H1\n    // estado 2 - espera H2\n    // estado 3 - espera H1\n    // estado 4 - espera H2\n    private int state = 0;\n    private boolean busy = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (busy || !espera(1))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (busy || !espera(2))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        busy = false;\n        notifyAll();\n    }\n\n    private boolean espera(int i) {\n        switch (state) {\n            case 0:\n            case 1:\n            case 3:\n                return i == 1;\n            case 2:\n            case 4:\n                return i == 2;\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"exams/2015/p1r/#problema-3","title":"Problema 3","text":"<p>Dado el siguiente terreno de prueba y la situaci\u00f3n del jugador y el depredador que se muestra:</p> <p></p> <ul> <li>(a) (1 punto) Describa un caso posible de error para detectar errores del m\u00e9todo primerPaso de la clase Depredador del alumno y progr\u00e1melo con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponemos que la variable terreno se refiere al terreno creado con la configuraci\u00f3n de la figura, y que la variable depredador se refiere al depredador situado en el terreno anterior.</p> <p>El primer paso de la ruta m\u00e1s corta desde la casilla donde est\u00e1 el depredador (1,1) y la del jugador (3,2) es la casilla (1,0). Para comprobar que el funcionamiento del m\u00e9todo primerPaso() es correcto, pues, basta con probar la siguiente aserci\u00f3n</p> <p>assertEquals(terreno.getCasilla(1,0),</p> <p>depredador.primerPaso(terreno.getCasilla(1,1),terreno.getCasilla(3,2)))</p> <ul> <li>(b) (1 punto) Escriba un caso de prueba para comprobar si el n\u00famero de paredes en el terreno es igual a 10 (los bordes no cuentan), utilizando m\u00e9todos p\u00fablicos de las clases del proyecto.</li> </ul> Mostar soluci\u00f3n <p>Para comprobar el n\u00famero de paredes basta hacer     assertEquals(10, terreno.getparedes().size()</p>"},{"location":"exams/2015/p1r_ex01/","title":"P1r ex01","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n (puede haber m\u00e1s de una) es:</p> <p>[0, 2, 6, 9, 11, 15]</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre></p> <pre><code>int[] getLIS(int[] x) {\n    int n = x.length;\n    int[] len = new int[n];\n    Arrays.fill(len, 1);\n    int[] pred = new int[n];\n    Arrays.fill(pred, -1);\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 0; j &lt; i; j++) {\n            if (x[j] &lt; x[i] &amp;&amp; len[i] &lt; len[j] + 1) {\n                len[i] = len[j] + 1;\n                pred[i] = j;\n            }\n        }\n    }\n    int bi = 0;\n    for (int i = 1; i &lt; n; i++) {\n        if (len[bi] &lt; len[i])\n            bi = i;\n    }\n    int cnt = len[bi];\n    int[] res = new int[cnt];\n    for (int i = bi; i != -1; i = pred[i])\n        res[--cnt] = x[i];\n    return res;\n}\n</code></pre> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n del tama\u00f1o N de la secuencia de entrada, razonando la soluci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>La iniciaci\u00f3n de los arrays \"len\" y \"pred\" es de complejidad lineal, pues se visitan todos sus elementos una sola vez, y su longitud es n.</p> <p>A continuaci\u00f3n hay un bucle doble anidado, cuyo cuerpo, de complejidad constante, se ejecuta 1 + 2 + 3 + ... + n-1 veces, es decir, un total de n/2*(n-1) veces. Por lo que su complejidad es cuadr\u00e1tica.</p> <p>Al final hay dos bucles simples con cuerpo de complejidad constante y n\u00famero de vueltas de orden n, que tienen pues complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser cuadr\u00e1tica. En t\u00e9rminos formales: C(for.for) = O(1+2+3+...+(n-1)) = O(n/2 * (n-1)) = O(n^2 / 2) - O(n/2) = O(n^2) C(LIS) = C(arrays.fill) + C(Arrays.fill) + C(for.for) + C(for) + C(for) = O(n) + O(n) + C(for.for) + O(n) + O(n/k) = O(n) + O(n) + O(n^2) + O(n) + O(n) = O(n^2).</p>","tags":["complejidad"]},{"location":"exams/2015/p1r_ex02/","title":"P1r ex02","text":"<p>Se tiene un sistema con dos hebras (H1 y H2) que acceden continuamente a un recurso compartido, que se debe usar con exclusi\u00f3n mutua. Para que el sistema funcione correctamente las hebras tienen que acceder seg\u00fan el siguiente patr\u00f3n, que se  debe repetir c\u00edclicamente: H1, H1, H2, H1, H2, como se ve en la figura siguiente:</p> <p></p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor (GestorCiclosAcceso) para sincronizar las hebras seg\u00fan el comportamiento descrito. El monitor debe proporcionar las siguientes operaciones:<ul> <li>... void accederH1(): Este m\u00e9todo lo invoca la hebra H1 para solicitar acceso al recurso compartido.</li> <li>... void accederH2(): Este m\u00e9todo lo invoca la hebra H2 para solicitar acceso al recurso compartido.</li> <li>... void liberar(): Este m\u00e9todo lo invocan las hebras para liberar el recurso compartido.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p><pre><code>public class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\npublic class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre> Otra posible implementaci\u00f3n, que utiliza m\u00e1quinas de estados, es la siguiente:</p> <pre><code>public class GestorCiclosAcceso2 {\n    // estado 0 - espera H1\n    // estado 1 - espera H1\n    // estado 2 - espera H2\n    // estado 3 - espera H1\n    // estado 4 - espera H2\n    private int state = 0;\n    private boolean busy = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (busy || !espera(1))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (busy || !espera(2))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        busy = false;\n        notifyAll();\n    }\n\n    private boolean espera(int i) {\n        switch (state) {\n            case 0:\n            case 1:\n            case 3:\n                return i == 1;\n            case 2:\n            case 4:\n                return i == 2;\n        }\n        return false;\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2015/p1r_ex03/","title":"P1r ex03","text":"<p>Dado el siguiente terreno de prueba y la situaci\u00f3n del jugador y el depredador que se muestra:</p> <p></p> <ul> <li>(a) (1 punto) Describa un caso posible de error para detectar errores del m\u00e9todo primerPaso de la clase Depredador del alumno y progr\u00e1melo con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponemos que la variable terreno se refiere al terreno creado con la configuraci\u00f3n de la figura, y que la variable depredador se refiere al depredador situado en el terreno anterior.</p> <p>El primer paso de la ruta m\u00e1s corta desde la casilla donde est\u00e1 el depredador (1,1) y la del jugador (3,2) es la casilla (1,0). Para comprobar que el funcionamiento del m\u00e9todo primerPaso() es correcto, pues, basta con probar la siguiente aserci\u00f3n</p> <p>assertEquals(terreno.getCasilla(1,0),</p> <p>depredador.primerPaso(terreno.getCasilla(1,1),terreno.getCasilla(3,2)))</p> <ul> <li>(b) (1 punto) Escriba un caso de prueba para comprobar si el n\u00famero de paredes en el terreno es igual a 10 (los bordes no cuentan), utilizando m\u00e9todos p\u00fablicos de las clases del proyecto.</li> </ul> Mostar soluci\u00f3n <p>Para comprobar el n\u00famero de paredes basta hacer     assertEquals(10, terreno.getparedes().size()</p>","tags":["???"]},{"location":"exams/2015/p2/","title":"Examen 2015 \u2014 Parcial 2","text":""},{"location":"exams/2015/p2/#problema-1","title":"Problema 1","text":"<p>Se pretende desarrollar una aplicaci\u00f3n para Android de gesti\u00f3n de una colecci\u00f3n de libros. La informaci\u00f3n de los libros se almacena en una Base de Datos sqlite. Una ListActivity muestra informaci\u00f3n de los libros almacenados.</p> <p>De los libros se almacena la siguiente informaci\u00f3n: Autor, T\u00edtulo, A\u00f1o de publicaci\u00f3n. Los dos primeros campos ser\u00e1n textuales, el \u00faltimo ser\u00e1 un n\u00famero. La Bases de Datos constar\u00e1 de una \u00fanica tabla que contenga esta informaci\u00f3n.</p> <ul> <li>(a) (1 punto) Escriba la sentencia SQL correcta para la creaci\u00f3n de la Base de Datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>CREATE TABLE libros (_id INTEGER PRIMARY KEY AUTOINCREMENT, Autor TEXT NOT NULL, Titulo TEXT NOT NULL, A\u00f1o INTEGER NOT NULL)\n</code></pre> <p>Se decide programar un adaptador para manejar la base de datos. Parte de dicho adaptador es la siguiente:</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n\n    private class MySQLiteHelper extends SQLiteOpenHelper\n    {\n        @Override\n        public void onCreate(SQLiteDatabase db) { \u2026 }\n        \u2026\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un m\u00e9todo de la clase DatabaseHelper que devuelva un Cursor con la informaci\u00f3n de todos los libros. La cabecera del m\u00e9todo ser\u00e1: public Cursor selectAll() { \u2026 }. Si necesita atributos adicionales, decl\u00e1relos correctamente. No duplique las declaraciones de la pregunta anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public Cursor recuperaTodosLosLibros() {\n    return db.query(\"libros\", new String[] {\n        COL_ID, COL_AUTOR, COL_TITULO, COL_ANYO\n    }, null, null, null, null, null);\n}\n</code></pre> <p>Se pretende disponer de una actividad ListaLibrosActivity, que herede de ListActivity, seg\u00fan el siguiente esquema:</p> <pre><code>public class ListaLibrosActivity extends ListActivity {\n    private DatabaseHelper dbHelper;\n    private SimpleCursorAdapter cursorAdapter;\n    \u2026\n}\n</code></pre> <ul> <li>(c) (2 puntos) Se pretende que dicha actividad reaccione de forma que cuando el usuario pulse sobre un registro mostrado en el ListView, se lance otra actividad, llamada \u201cEditarLibroActivity\u201d, que ya est\u00e1 ya implementada. A la actividad \u201cEditarLibroActivity\u201d se le ha de pasar toda la informaci\u00f3n del libro seleccionado. Escriba el c\u00f3digo necesario para implementar este comportamiento. </li> </ul> Mostrar soluci\u00f3n <pre><code>public void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = productosCursor;\n    c.moveToPosition(position);\n    Intent intent = new Intent(this, EditarLibroActivity.class);\n    intent.putExtra(ProductoDbAdaptador.COL_ID, id);\n    intent.putExtra(Producto.AUTOR, c.getString(indiceAutor));\n    intent.putExtra(Producto.TITULO, c.getInt(indiceTitulo));\n    intent.putExtra(Producto.ANYO, c.getInt(indiceAnyo));\n    intent.putExtra(REQUEST_CODE, MODIFICA_PRODUCTO);\n    startActivityForResult(intent, MODIFICA_PRODUCTO);\n}\n</code></pre> <ul> <li>(d) (1 punto) Se desea guardar la base de datos de forma autom\u00e1tica, cuando la aplicaci\u00f3n sea interrumpida por otra ACTIVIDAD (por ejemplo, una llamada de tel\u00e9fono o pulsar el bot\u00f3n de aplicaciones). Cuando se vuelva a la aplicaci\u00f3n, se debe cargar la base de datos. \u00bfQu\u00e9 m\u00e9todos han de sobrecargarse relativos al ciclo de vida de la actividad principal? Ponga S\u00d3LO el nombre de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>sol a) onStart() \u2013 onStop() sol b) onResume() \u2013 onPause()</p>"},{"location":"exams/2015/p2/#problema-2","title":"Problema 2","text":"<p>En el Juego del Pacman para Android tenemos un tablero de 8x8:</p> <p></p> <ul> <li>(a) (1 punto) Indique las coordinadas (x,y) que debe pasar a juego.pon(terreno.getCasilla(x.y), 0) para poner un Patito (con identificador 0) en la casilla con un c\u00edrculo azul (objetivo) situada en el extremo superior derecho.</li> </ul> Mostrar soluci\u00f3n <p>X = 7, Y = 7</p> <ul> <li>(b) (1 punto) Suponga que tenemos un gestor de eventos t\u00e1ctiles onTouch(View v, MotionEvent event). Si pulsamos en el objetivo (c\u00edrculo azul situado en el extremo superior derecho), \u00bfqu\u00e9 valores nos dar\u00e1n x e y si se calculan como sigue? int x = (int) event.getX() / lado1; int y = (int) event.getY() / lado1</li> </ul> Mostrar soluci\u00f3n <p>X = 7, Y = 0</p> <p>Deseamos cambiar el comportamiento del gestor de eventos t\u00e1ctiles, de forma que el jugador ya no se mueva con el dedo. Queremos que al poner el dedo en una posici\u00f3n, aparezca un Patito si la casilla est\u00e1 vac\u00eda. El id de Patito registrado en Juego es 0. Adem\u00e1s, queremos que muestre:     - una traza informativa (info) al pulsar en la pantalla. Ej. \u201cPulso en (3, 4)\u201d     - una traza de depuraci\u00f3n (debug) cuando pone el patito. Ej. \u201cPatito puesto en (3, 4)\u201d     - una traza de depuraci\u00f3n si no coincide la posici\u00f3n al poner y quitar el dedo, porque ha realizado alg\u00fan movimiento. Ej. \u201cNo coinciden poner y quitar dedo\u201d     - una traza de advertencia (warn) si ya hay alg\u00fan m\u00f3vil en esa posici\u00f3n. \u201cPatito no puesto ya hay otro m\u00f3vil\u201d.</p> <ul> <li>(c) (3 puntos) Complete el c\u00f3digo del m\u00e9todo onTouch() que se da en la hoja de respuestas.</li> </ul> Mostrar soluci\u00f3n <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"exams/2015/p2_ex01/","title":"P2 ex01","text":"<p>Se pretende desarrollar una aplicaci\u00f3n para Android de gesti\u00f3n de una colecci\u00f3n de libros. La informaci\u00f3n de los libros se almacena en una Base de Datos sqlite. Una ListActivity muestra informaci\u00f3n de los libros almacenados.</p> <p>De los libros se almacena la siguiente informaci\u00f3n: Autor, T\u00edtulo, A\u00f1o de publicaci\u00f3n. Los dos primeros campos ser\u00e1n textuales, el \u00faltimo ser\u00e1 un n\u00famero. La Bases de Datos constar\u00e1 de una \u00fanica tabla que contenga esta informaci\u00f3n.</p> <ul> <li>(a) (1 punto) Escriba la sentencia SQL correcta para la creaci\u00f3n de la Base de Datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>CREATE TABLE libros (_id INTEGER PRIMARY KEY AUTOINCREMENT, Autor TEXT NOT NULL, Titulo TEXT NOT NULL, A\u00f1o INTEGER NOT NULL)\n</code></pre> <p>Se decide programar un adaptador para manejar la base de datos. Parte de dicho adaptador es la siguiente:</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n\n    private class MySQLiteHelper extends SQLiteOpenHelper\n    {\n        @Override\n        public void onCreate(SQLiteDatabase db) { \u2026 }\n        \u2026\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un m\u00e9todo de la clase DatabaseHelper que devuelva un Cursor con la informaci\u00f3n de todos los libros. La cabecera del m\u00e9todo ser\u00e1: public Cursor selectAll() { \u2026 }. Si necesita atributos adicionales, decl\u00e1relos correctamente. No duplique las declaraciones de la pregunta anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public Cursor recuperaTodosLosLibros() {\n    return db.query(\"libros\", new String[] {\n        COL_ID, COL_AUTOR, COL_TITULO, COL_ANYO\n    }, null, null, null, null, null);\n}\n</code></pre> <p>Se pretende disponer de una actividad ListaLibrosActivity, que herede de ListActivity, seg\u00fan el siguiente esquema:</p> <pre><code>public class ListaLibrosActivity extends ListActivity {\n    private DatabaseHelper dbHelper;\n    private SimpleCursorAdapter cursorAdapter;\n    \u2026\n}\n</code></pre> <ul> <li>(c) (2 puntos) Se pretende que dicha actividad reaccione de forma que cuando el usuario pulse sobre un registro mostrado en el ListView, se lance otra actividad, llamada \u201cEditarLibroActivity\u201d, que ya est\u00e1 ya implementada. A la actividad \u201cEditarLibroActivity\u201d se le ha de pasar toda la informaci\u00f3n del libro seleccionado. Escriba el c\u00f3digo necesario para implementar este comportamiento. </li> </ul> Mostrar soluci\u00f3n <pre><code>public void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = productosCursor;\n    c.moveToPosition(position);\n    Intent intent = new Intent(this, EditarLibroActivity.class);\n    intent.putExtra(ProductoDbAdaptador.COL_ID, id);\n    intent.putExtra(Producto.AUTOR, c.getString(indiceAutor));\n    intent.putExtra(Producto.TITULO, c.getInt(indiceTitulo));\n    intent.putExtra(Producto.ANYO, c.getInt(indiceAnyo));\n    intent.putExtra(REQUEST_CODE, MODIFICA_PRODUCTO);\n    startActivityForResult(intent, MODIFICA_PRODUCTO);\n}\n</code></pre> <ul> <li>(d) (1 punto) Se desea guardar la base de datos de forma autom\u00e1tica, cuando la aplicaci\u00f3n sea interrumpida por otra ACTIVIDAD (por ejemplo, una llamada de tel\u00e9fono o pulsar el bot\u00f3n de aplicaciones). Cuando se vuelva a la aplicaci\u00f3n, se debe cargar la base de datos. \u00bfQu\u00e9 m\u00e9todos han de sobrecargarse relativos al ciclo de vida de la actividad principal? Ponga S\u00d3LO el nombre de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>sol a) onStart() \u2013 onStop() sol b) onResume() \u2013 onPause()</p>","tags":["android"]},{"location":"exams/2015/p2_ex02/","title":"P2 ex02","text":"<p>En el Juego del Pacman para Android tenemos un tablero de 8x8:</p> <p></p> <ul> <li>(a) (1 punto) Indique las coordinadas (x,y) que debe pasar a juego.pon(terreno.getCasilla(x.y), 0) para poner un Patito (con identificador 0) en la casilla con un c\u00edrculo azul (objetivo) situada en el extremo superior derecho.</li> </ul> Mostrar soluci\u00f3n <p>X = 7, Y = 7</p> <ul> <li>(b) (1 punto) Suponga que tenemos un gestor de eventos t\u00e1ctiles onTouch(View v, MotionEvent event). Si pulsamos en el objetivo (c\u00edrculo azul situado en el extremo superior derecho), \u00bfqu\u00e9 valores nos dar\u00e1n x e y si se calculan como sigue? int x = (int) event.getX() / lado1; int y = (int) event.getY() / lado1</li> </ul> Mostrar soluci\u00f3n <p>X = 7, Y = 0</p> <p>Deseamos cambiar el comportamiento del gestor de eventos t\u00e1ctiles, de forma que el jugador ya no se mueva con el dedo. Queremos que al poner el dedo en una posici\u00f3n, aparezca un Patito si la casilla est\u00e1 vac\u00eda. El id de Patito registrado en Juego es 0. Adem\u00e1s, queremos que muestre:     - una traza informativa (info) al pulsar en la pantalla. Ej. \u201cPulso en (3, 4)\u201d     - una traza de depuraci\u00f3n (debug) cuando pone el patito. Ej. \u201cPatito puesto en (3, 4)\u201d     - una traza de depuraci\u00f3n si no coincide la posici\u00f3n al poner y quitar el dedo, porque ha realizado alg\u00fan movimiento. Ej. \u201cNo coinciden poner y quitar dedo\u201d     - una traza de advertencia (warn) si ya hay alg\u00fan m\u00f3vil en esa posici\u00f3n. \u201cPatito no puesto ya hay otro m\u00f3vil\u201d.</p> <ul> <li>(c) (3 puntos) Complete el c\u00f3digo del m\u00e9todo onTouch() que se da en la hoja de respuestas.</li> </ul> Mostrar soluci\u00f3n <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2016/extra/","title":"Examen 2016 \u2014 Extraordinario","text":""},{"location":"exams/2016/extra/#problema-1","title":"Problema 1","text":"<p>Queremos desplegar un conjunto de sensores de contaminaci\u00f3n en Madrid. Cada sensor S est\u00e1 en unas coordenadas (x, y) medidas en metros en una cuadr\u00edcula centrada en la Puerta del Sol, yendo el eje X de oeste a este y el eje Y de sur a norte.</p> <p>Los sensores son fr\u00e1giles y pueden fallar. Pero no queremos quedarnos sin datos, as\u00ed que se les facilita la capacidad de que puedan mandar sus mediciones a otro sensor, que debe estar a una distancia menor que d0 metros.</p> <pre><code>public class Sensor {\n    private final String id;\n    private final int x, y;\n\n    public Sensor(String id, int x, int y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distancia(Sensor b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Dada una lista con todos los sensores, escriba un m\u00e9todo que cargue un diccionario donde cada sensor est\u00e1 asociado a una lista con los sensores que est\u00e1n a su alcance (a menos de d0 metros). N\u00f3tese que si el sensor A est\u00e1 dentro del alcance de B, tambi\u00e9n est\u00e1 B dentro del alcance de A. Razone la complejidad de este m\u00e9todo: <pre><code>public class Red {\n    private Diccionario diccionario = new \u2026\n\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\u2026}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Soluci\u00f3n usando un diccionario de la biblioteca de Java</p> <pre><code>public class Red {\n    private Map&lt;Sensor, List&lt;Sensor&gt;&gt; diccionario = new HashMap&lt;&gt;();\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        for (int i = 0; i &lt; sensores.size(); i++) {\n            Sensor s1 = sensores.get(i);\n            List&lt;Sensor&gt; lista = new ArrayList&lt;&gt;();\n            for (int j = 0; j &lt; sensores.size(); j++) {\n                if (i == j)\n                    continue;\n                Sensor s2 = sensores.get(j);\n                if (s1.distancia(s2) &lt; d0)\n                    lista.add(s2);\n        }\n        diccionario.put(s1, lista);\n    }\n}\n</code></pre> <p>Para usar un diccionario como el del ejercicio 3, hay que cambiar CV y la implementaci\u00f3n de la misma manera:</p> <pre><code>class CVExamen {\n    final Sensor clave;\n    List&lt;Sensor&gt; valor;\n\n    CVExamen(Sensor clave, List&lt;Sensor&gt; valor) {\n        this.clave = clave;\n        this.valor = valor;\n    }\n}\n\npublic interface Diccionario {\n    void put(Sensor clave, List&lt;Sensor&gt; valor);\n    List&lt;Sensor&gt; get(Sensor clave);\n    List&lt;Sensor&gt; remove(Sensor clave);\n    int size();\n    void clear();\n}\n</code></pre> <p>Complejidad.</p> <p>Siendo N el n\u00famero de sensores, tenemos un bucle exterior que se hace N veces. Cada pasada por el bucle incluye: - bucle interior: N veces, de complejidad O(n). - diccionario.put(), donde lacomplejidad,  si el n\u00famero de ranuras es sensiblemente superior a N es O(1), si no es O(n).</p> <p>El total es, por tanto O(n) + \u2026 = O(n)</p> <p>Y la operaci\u00f3n total de carga N \u00d7 O(n) -&gt; O(n2)</p>"},{"location":"exams/2016/extra/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (3,5 puntos) Escriba un m\u00e9todo para crear un diccionario que, para cada sensor S, contenga el conjunto de sensores a los que mandar\u00e1 regularmente una copia de sus medidas. Sabiendo que los sensores de destino podr\u00edan verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se env\u00edan a los F sensores que a su vez tengan menos sensores a su alcance.</li> </ul> <pre><code>public Diccionario cercanos (int f) {\u2026}\n</code></pre> <p>NOTA: El algoritmo es como sigue:     - 1. para cada sensor S obtenemos la lista de nodos a distancia alcanzable (pregunta 1)     - 2. ordenamos la lista en funci\u00f3n del n\u00famero de sensores al alcance de cada sensor     - 3. nos quedamos con los F primeros sensores en una nueva lista     - 4. asociamos la nueva lista a S en el diccionario de resultado</p> <p>NOTAS:     - Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java.     - Como algoritmo de ordenaci\u00f3n, elija uno de los presentados en clase, adaptando el c\u00f3digo al caso.     - Puede usar m\u00e9todos auxiliares si lo cree oportuno. Privados, por supuesto.</p> <p>Razone la complejidad de su c\u00f3digo</p> Mostrar soluci\u00f3n <p>Probablemente, el n\u00famero de sensores dentro del alcance sea un n\u00famero peque\u00f1o. En ese caso la ordenaci\u00f3n se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenaci\u00f3n.</p> <p>En la soluci\u00f3n que sigue se recurre al algoritmo de inserci\u00f3n.</p> <p>Usando la biblioteca de Java:</p> <pre><code>public Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n    Map&lt;Sensor, List&lt;Sensor&gt;&gt; resultado = new HashMap&lt;&gt;();\n\n    for (Sensor sensor : diccionario.keySet()) {\n        List&lt;Sensor&gt; list1 = getListaOrdenadaSensores(sensor);\n        List&lt;Sensor&gt; list2 = new ArrayList&lt;&gt;();\n\n        int m = Math.min(f, list1.size());\n        for (int i = 0; i &lt; m; i++)\n            list2.add(list1.get(i));\n\n        resultado.put(sensor, list2);\n    }\n    return resultado;\n}\n\nprivate List&lt;Sensor&gt; getListaOrdenadaSensores(Sensor sensor) {\n    List&lt;Sensor&gt; list0 = diccionario.get(sensor);\n    List&lt;Sensor&gt; list1 = new ArrayList&lt;&gt;(list0);\n    sort(list1);\n    return list1;\n}\n\nprivate void sort(List&lt;Sensor&gt; list) {\n    // inserci\u00f3n\n    for (int i = 1; i &lt; list.size(); i++)\n        inserta(list, i, list.get(i));\n}\n\n// inserta sensor en datos, entre 0 y z-1\nprivate void inserta(List&lt;Sensor&gt; datos, int z, Sensor sensor) {\n    int j = z;\n    while (0 &lt; j &amp;&amp; compareTo(sensor, datos.get(j - 1)) &lt; 0)\n        j--;\n\n    if (j != z) {\n        datos.remove(sensor);\n        datos.add(j, sensor);\n    }\n}\n\nprivate int compareTo(Sensor s1, Sensor s2) {\n    int size1 = diccionario.get(s1).size();\n    int size2 = diccionario.get(s2).size();\n    return size2 - size1;\n}\n</code></pre> <p>Con respecto a la complejidad, hay que revisar N sensores.</p> <p>Para cada sensor hay que localizar su lista de sensores en el diccionario: get().</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>Cada lista, de X elementos, hay que ordenarla. Si usamos un algoritmo de inserci\u00f3n como el de arriba, por t\u00e9rmino medio ser\u00e1 la ordenaci\u00f3n de un array de x elementos: O(x2):     - 1. Podemos pensar que X sea constante, independientemente de N, en cuyo caso la ordenaci\u00f3n ser\u00e1 de tiempo constante, O(1).     - 2. Podemos pensar que X sea proporcional a N, en cuyo caso la ordenaci\u00f3n ser\u00e1 una proporci\u00f3n de N: O(n2)</p> <p>Nos quedamos con f elementos: O(1).</p> <p>Y hacemos una operaci\u00f3n put() en el diccionario se salida.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>En el caso 1, el total es N \u00d7 (O(1) + O(1) + O(1) + O(1)) -&gt; N \u00d7 O(1) -&gt; O(n)</p> <p>En el caso 2, el total es N \u00d7 (O(1) + O(n2) + O(1) + O(1)) -&gt; N \u00d7 O(n2) -&gt; O(n3)</p> <p>Resumiendo, si el n\u00famero de sensores dentro del alcance es independiente de N, la complejidad es O(n). Si el n\u00famero de sensores dentro del alcance es proporcional a N, la complejidad depende del algoritmo de ordenaci\u00f3n.</p>"},{"location":"exams/2016/extra/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (1 punto) Modifique la clase Sensor para que se pueda integrar en una hebra que comparta informaci\u00f3n con los sensores cercanos cada 30 s. Para ello se puede implementar la interfaz Runnable.</li> </ul> <pre><code>public class Sensor implements Runnable {\n    // ...\n    private Red red;\n    private int medida; // valor le\u00eddo por el sensor\n\n    public Sensor(String id, int x, int y, Red red) {\n        this.red = red;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // transmitir la lectura cada 30 segundos\n                red.transmitir(this, medida);\n                Thread.sleep(30000); // 30 s\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Para implementar la interfaz Runnable espreciso redefinir el m\u00e9todo run(): <pre><code>@Override\npublic void run() {\n    while (true) {\n        try {\n            sleep(30000);\n        } catch (InterruptedException ignored) {\n        }\n\n        for (Sensor s : red.cercanos(f).get(this)) {\n            red.enviar(s, medida);\n        }\n    }\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Escriba una l\u00ednea de c\u00f3digo java para arrancar una hebra que ejecute el c\u00f3digo concurrente de Sensor.</li> </ul> Mostrar soluci\u00f3n <p>Para arrancar una hebra que ejecute el m\u00e9todo run() anterior hay que crear la hebra a partir del Runnable y hacer start(): <pre><code>new Thread(new Sensor()).start();\n</code></pre> o alternativamente: <pre><code>Runnable sensor = new Sensor(\u2026);\nThread tread = new Thread(sensor);\nthread.start();\n</code></pre></p> <ul> <li>(c) (1 punto) En el puesto de mando y control, un servidor ejecuta un programa basado en la clase Red de las preguntas anteriores, y recibe peticiones de los operadores locales y de los muchos sensores distribuidos por Madrid. Modifique la clase Red para que pueda atender cargas, recargas y peticiones concurrentes sin problemas de concurrencia.</li> </ul> <p>NOTAS 1. Suponga que el valor medido por el sensor (medida) se actualiza autom\u00e1ticamente por alg\u00fan mecanismo que no es relevante para examen. 2. Suponga que la clase Red incluye el m\u00e9todo <pre><code>public void enviar (Sensor destino, int medida) {\u2026}\n</code></pre></p> Mostrar soluci\u00f3n <p>Para que la clase Red se pueda usar de forma segura desde varias hebras es preciso convertirla en un monitor. Como no tiene atributos p\u00fablicos basta para ello con sincronizar todos sus m\u00e9todos p\u00fablicos: <pre><code>public class Red {\n    private Diccionario diccionario = new DiccionarioImpl();\n\n    public synchronized void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        // ...\n    }\n\n    public synchronized Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n        // ...\n        return null;\n    }\n\n    public synchronized void enviar(Sensor destino, int medida) {\n        // ...\n    }\n}\n</code></pre></p>"},{"location":"exams/2016/p1/","title":"Examen 2016 \u2014 Parcial 1","text":""},{"location":"exams/2016/p1/#problema-1","title":"Problema 1","text":"<p>Queremos desplegar un conjunto de sensores de contaminaci\u00f3n en Madrid. Cada sensor S est\u00e1 en unas coordenadas (x, y) medidas en metros en una cuadr\u00edcula centrada en la Puerta del Sol, yendo el eje X de oeste a este y el eje Y de sur a norte.</p> <p>Los sensores son fr\u00e1giles y pueden fallar. Pero no queremos quedarnos sin datos, as\u00ed que se les facilita la capacidad de que puedan mandar sus mediciones a otro sensor, que debe estar a una distancia menor que d0 metros.</p> <pre><code>public class Sensor {\n    private final String id;\n    private final int x, y;\n\n    public Sensor(String id, int x, int y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distancia(Sensor b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Dada una lista con todos los sensores, escriba un m\u00e9todo que cargue un diccionario donde cada sensor est\u00e1 asociado a una lista con los sensores que est\u00e1n a su alcance (a menos de d0 metros). N\u00f3tese que si el sensor A est\u00e1 dentro del alcance de B, tambi\u00e9n est\u00e1 B dentro del alcance de A. Razone la complejidad de este m\u00e9todo: <pre><code>public class Red {\n    private Diccionario diccionario = new \u2026\n\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\u2026}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Soluci\u00f3n usando un diccionario de la biblioteca de Java</p> <pre><code>public class Red {\n    private Map&lt;Sensor, List&lt;Sensor&gt;&gt; diccionario = new HashMap&lt;&gt;();\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        for (int i = 0; i &lt; sensores.size(); i++) {\n            Sensor s1 = sensores.get(i);\n            List&lt;Sensor&gt; lista = new ArrayList&lt;&gt;();\n            for (int j = 0; j &lt; sensores.size(); j++) {\n                if (i == j)\n                    continue;\n                Sensor s2 = sensores.get(j);\n                if (s1.distancia(s2) &lt; d0)\n                    lista.add(s2);\n        }\n        diccionario.put(s1, lista);\n    }\n}\n</code></pre> <p>Para usar un diccionario como el del ejercicio 3, hay que cambiar CV y la implementaci\u00f3n de la misma manera:</p> <pre><code>class CVExamen {\n    final Sensor clave;\n    List&lt;Sensor&gt; valor;\n\n    CVExamen(Sensor clave, List&lt;Sensor&gt; valor) {\n        this.clave = clave;\n        this.valor = valor;\n    }\n}\n\npublic interface Diccionario {\n    void put(Sensor clave, List&lt;Sensor&gt; valor);\n    List&lt;Sensor&gt; get(Sensor clave);\n    List&lt;Sensor&gt; remove(Sensor clave);\n    int size();\n    void clear();\n}\n</code></pre> <p>Complejidad.</p> <p>Siendo N el n\u00famero de sensores, tenemos un bucle exterior que se hace N veces. Cada pasada por el bucle incluye: - bucle interior: N veces, de complejidad O(n). - diccionario.put(), donde lacomplejidad,  si el n\u00famero de ranuras es sensiblemente superior a N es O(1), si no es O(n).</p> <p>El total es, por tanto O(n) + \u2026 = O(n)</p> <p>Y la operaci\u00f3n total de carga N \u00d7 O(n) -&gt; O(n2)</p>"},{"location":"exams/2016/p1/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (3,5 puntos) Escriba un m\u00e9todo para crear un diccionario que, para cada sensor S, contenga el conjunto de sensores a los que mandar\u00e1 regularmente una copia de sus medidas. Sabiendo que los sensores de destino podr\u00edan verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se env\u00edan a los F sensores que a su vez tengan menos sensores a su alcance.</li> </ul> <pre><code>public Diccionario cercanos (int f) {\u2026}\n</code></pre> <p>NOTA: El algoritmo es como sigue:     - 1. para cada sensor S obtenemos la lista de nodos a distancia alcanzable (pregunta 1)     - 2. ordenamos la lista en funci\u00f3n del n\u00famero de sensores al alcance de cada sensor     - 3. nos quedamos con los F primeros sensores en una nueva lista     - 4. asociamos la nueva lista a S en el diccionario de resultado</p> <p>NOTAS:     - Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java.     - Como algoritmo de ordenaci\u00f3n, elija uno de los presentados en clase, adaptando el c\u00f3digo al caso.     - Puede usar m\u00e9todos auxiliares si lo cree oportuno. Privados, por supuesto.</p> <p>Razone la complejidad de su c\u00f3digo</p> Mostrar soluci\u00f3n <p>Probablemente, el n\u00famero de sensores dentro del alcance sea un n\u00famero peque\u00f1o. En ese caso la ordenaci\u00f3n se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenaci\u00f3n.</p> <p>En la soluci\u00f3n que sigue se recurre al algoritmo de inserci\u00f3n.</p> <p>Usando la biblioteca de Java:</p> <pre><code>public Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n    Map&lt;Sensor, List&lt;Sensor&gt;&gt; resultado = new HashMap&lt;&gt;();\n\n    for (Sensor sensor : diccionario.keySet()) {\n        List&lt;Sensor&gt; list1 = getListaOrdenadaSensores(sensor);\n        List&lt;Sensor&gt; list2 = new ArrayList&lt;&gt;();\n\n        int m = Math.min(f, list1.size());\n        for (int i = 0; i &lt; m; i++)\n            list2.add(list1.get(i));\n\n        resultado.put(sensor, list2);\n    }\n    return resultado;\n}\n\nprivate List&lt;Sensor&gt; getListaOrdenadaSensores(Sensor sensor) {\n    List&lt;Sensor&gt; list0 = diccionario.get(sensor);\n    List&lt;Sensor&gt; list1 = new ArrayList&lt;&gt;(list0);\n    sort(list1);\n    return list1;\n}\n\nprivate void sort(List&lt;Sensor&gt; list) {\n    // inserci\u00f3n\n    for (int i = 1; i &lt; list.size(); i++)\n        inserta(list, i, list.get(i));\n}\n\n// inserta sensor en datos, entre 0 y z-1\nprivate void inserta(List&lt;Sensor&gt; datos, int z, Sensor sensor) {\n    int j = z;\n    while (0 &lt; j &amp;&amp; compareTo(sensor, datos.get(j - 1)) &lt; 0)\n        j--;\n\n    if (j != z) {\n        datos.remove(sensor);\n        datos.add(j, sensor);\n    }\n}\n\nprivate int compareTo(Sensor s1, Sensor s2) {\n    int size1 = diccionario.get(s1).size();\n    int size2 = diccionario.get(s2).size();\n    return size2 - size1;\n}\n</code></pre> <p>Con respecto a la complejidad, hay que revisar N sensores.</p> <p>Para cada sensor hay que localizar su lista de sensores en el diccionario: get().</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>Cada lista, de X elementos, hay que ordenarla. Si usamos un algoritmo de inserci\u00f3n como el de arriba, por t\u00e9rmino medio ser\u00e1 la ordenaci\u00f3n de un array de x elementos: O(x2):     - 1. Podemos pensar que X sea constante, independientemente de N, en cuyo caso la ordenaci\u00f3n ser\u00e1 de tiempo constante, O(1).     - 2. Podemos pensar que X sea proporcional a N, en cuyo caso la ordenaci\u00f3n ser\u00e1 una proporci\u00f3n de N: O(n2)</p> <p>Nos quedamos con f elementos: O(1).</p> <p>Y hacemos una operaci\u00f3n put() en el diccionario se salida.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>En el caso 1, el total es N \u00d7 (O(1) + O(1) + O(1) + O(1)) -&gt; N \u00d7 O(1) -&gt; O(n)</p> <p>En el caso 2, el total es N \u00d7 (O(1) + O(n2) + O(1) + O(1)) -&gt; N \u00d7 O(n2) -&gt; O(n3)</p> <p>Resumiendo, si el n\u00famero de sensores dentro del alcance es independiente de N, la complejidad es O(n). Si el n\u00famero de sensores dentro del alcance es proporcional a N, la complejidad depende del algoritmo de ordenaci\u00f3n.</p>"},{"location":"exams/2016/p1/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (1 punto) Modifique la clase Sensor para que se pueda integrar en una hebra que comparta informaci\u00f3n con los sensores cercanos cada 30 s. Para ello se puede implementar la interfaz Runnable.</li> </ul> <pre><code>public class Sensor implements Runnable {\n    // ...\n    private Red red;\n    private int medida; // valor le\u00eddo por el sensor\n\n    public Sensor(String id, int x, int y, Red red) {\n        this.red = red;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // transmitir la lectura cada 30 segundos\n                red.transmitir(this, medida);\n                Thread.sleep(30000); // 30 s\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Para implementar la interfaz Runnable espreciso redefinir el m\u00e9todo run(): <pre><code>@Override\npublic void run() {\n    while (true) {\n        try {\n            sleep(30000);\n        } catch (InterruptedException ignored) {\n        }\n\n        for (Sensor s : red.cercanos(f).get(this)) {\n            red.enviar(s, medida);\n        }\n    }\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Escriba una l\u00ednea de c\u00f3digo java para arrancar una hebra que ejecute el c\u00f3digo concurrente de Sensor.</li> </ul> Mostrar soluci\u00f3n <p>Para arrancar una hebra que ejecute el m\u00e9todo run() anterior hay que crear la hebra a partir del Runnable y hacer start(): <pre><code>new Thread(new Sensor()).start();\n</code></pre> o alternativamente: <pre><code>Runnable sensor = new Sensor(\u2026);\nThread tread = new Thread(sensor);\nthread.start();\n</code></pre></p> <ul> <li>(c) (1 punto) En el puesto de mando y control, un servidor ejecuta un programa basado en la clase Red de las preguntas anteriores, y recibe peticiones de los operadores locales y de los muchos sensores distribuidos por Madrid. Modifique la clase Red para que pueda atender cargas, recargas y peticiones concurrentes sin problemas de concurrencia.</li> </ul> <p>NOTAS 1. Suponga que el valor medido por el sensor (medida) se actualiza autom\u00e1ticamente por alg\u00fan mecanismo que no es relevante para examen. 2. Suponga que la clase Red incluye el m\u00e9todo <pre><code>public void enviar (Sensor destino, int medida) {\u2026}\n</code></pre></p> Mostrar soluci\u00f3n <p>Para que la clase Red se pueda usar de forma segura desde varias hebras es preciso convertirla en un monitor. Como no tiene atributos p\u00fablicos basta para ello con sincronizar todos sus m\u00e9todos p\u00fablicos: <pre><code>public class Red {\n    private Diccionario diccionario = new DiccionarioImpl();\n\n    public synchronized void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        // ...\n    }\n\n    public synchronized Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n        // ...\n        return null;\n    }\n\n    public synchronized void enviar(Sensor destino, int medida) {\n        // ...\n    }\n}\n</code></pre></p>"},{"location":"exams/2016/p1_ex01/","title":"P1 ex01","text":"<p>Queremos desplegar un conjunto de sensores de contaminaci\u00f3n en Madrid. Cada sensor S est\u00e1 en unas coordenadas (x, y) medidas en metros en una cuadr\u00edcula centrada en la Puerta del Sol, yendo el eje X de oeste a este y el eje Y de sur a norte.</p> <p>Los sensores son fr\u00e1giles y pueden fallar. Pero no queremos quedarnos sin datos, as\u00ed que se les facilita la capacidad de que puedan mandar sus mediciones a otro sensor, que debe estar a una distancia menor que d0 metros.</p> <pre><code>public class Sensor {\n    private final String id;\n    private final int x, y;\n\n    public Sensor(String id, int x, int y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distancia(Sensor b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Dada una lista con todos los sensores, escriba un m\u00e9todo que cargue un diccionario donde cada sensor est\u00e1 asociado a una lista con los sensores que est\u00e1n a su alcance (a menos de d0 metros). N\u00f3tese que si el sensor A est\u00e1 dentro del alcance de B, tambi\u00e9n est\u00e1 B dentro del alcance de A. Razone la complejidad de este m\u00e9todo: <pre><code>public class Red {\n    private Diccionario diccionario = new \u2026\n\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\u2026}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Soluci\u00f3n usando un diccionario de la biblioteca de Java</p> <pre><code>public class Red {\n    private Map&lt;Sensor, List&lt;Sensor&gt;&gt; diccionario = new HashMap&lt;&gt;();\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        for (int i = 0; i &lt; sensores.size(); i++) {\n            Sensor s1 = sensores.get(i);\n            List&lt;Sensor&gt; lista = new ArrayList&lt;&gt;();\n            for (int j = 0; j &lt; sensores.size(); j++) {\n                if (i == j)\n                    continue;\n                Sensor s2 = sensores.get(j);\n                if (s1.distancia(s2) &lt; d0)\n                    lista.add(s2);\n        }\n        diccionario.put(s1, lista);\n    }\n}\n</code></pre> <p>Para usar un diccionario como el del ejercicio 3, hay que cambiar CV y la implementaci\u00f3n de la misma manera:</p> <pre><code>class CVExamen {\n    final Sensor clave;\n    List&lt;Sensor&gt; valor;\n\n    CVExamen(Sensor clave, List&lt;Sensor&gt; valor) {\n        this.clave = clave;\n        this.valor = valor;\n    }\n}\n\npublic interface Diccionario {\n    void put(Sensor clave, List&lt;Sensor&gt; valor);\n    List&lt;Sensor&gt; get(Sensor clave);\n    List&lt;Sensor&gt; remove(Sensor clave);\n    int size();\n    void clear();\n}\n</code></pre> <p>Complejidad.</p> <p>Siendo N el n\u00famero de sensores, tenemos un bucle exterior que se hace N veces. Cada pasada por el bucle incluye: - bucle interior: N veces, de complejidad O(n). - diccionario.put(), donde lacomplejidad,  si el n\u00famero de ranuras es sensiblemente superior a N es O(1), si no es O(n).</p> <p>El total es, por tanto O(n) + \u2026 = O(n)</p> <p>Y la operaci\u00f3n total de carga N \u00d7 O(n) -&gt; O(n2)</p>","tags":["complejidad"]},{"location":"exams/2016/p1_ex02/","title":"P1 ex02","text":"<ul> <li>(a) (3,5 puntos) Escriba un m\u00e9todo para crear un diccionario que, para cada sensor S, contenga el conjunto de sensores a los que mandar\u00e1 regularmente una copia de sus medidas. Sabiendo que los sensores de destino podr\u00edan verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se env\u00edan a los F sensores que a su vez tengan menos sensores a su alcance.</li> </ul> <pre><code>public Diccionario cercanos (int f) {\u2026}\n</code></pre> <p>NOTA: El algoritmo es como sigue:     - 1. para cada sensor S obtenemos la lista de nodos a distancia alcanzable (pregunta 1)     - 2. ordenamos la lista en funci\u00f3n del n\u00famero de sensores al alcance de cada sensor     - 3. nos quedamos con los F primeros sensores en una nueva lista     - 4. asociamos la nueva lista a S en el diccionario de resultado</p> <p>NOTAS:     - Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java.     - Como algoritmo de ordenaci\u00f3n, elija uno de los presentados en clase, adaptando el c\u00f3digo al caso.     - Puede usar m\u00e9todos auxiliares si lo cree oportuno. Privados, por supuesto.</p> <p>Razone la complejidad de su c\u00f3digo</p> Mostrar soluci\u00f3n <p>Probablemente, el n\u00famero de sensores dentro del alcance sea un n\u00famero peque\u00f1o. En ese caso la ordenaci\u00f3n se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenaci\u00f3n.</p> <p>En la soluci\u00f3n que sigue se recurre al algoritmo de inserci\u00f3n.</p> <p>Usando la biblioteca de Java:</p> <pre><code>public Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n    Map&lt;Sensor, List&lt;Sensor&gt;&gt; resultado = new HashMap&lt;&gt;();\n\n    for (Sensor sensor : diccionario.keySet()) {\n        List&lt;Sensor&gt; list1 = getListaOrdenadaSensores(sensor);\n        List&lt;Sensor&gt; list2 = new ArrayList&lt;&gt;();\n\n        int m = Math.min(f, list1.size());\n        for (int i = 0; i &lt; m; i++)\n            list2.add(list1.get(i));\n\n        resultado.put(sensor, list2);\n    }\n    return resultado;\n}\n\nprivate List&lt;Sensor&gt; getListaOrdenadaSensores(Sensor sensor) {\n    List&lt;Sensor&gt; list0 = diccionario.get(sensor);\n    List&lt;Sensor&gt; list1 = new ArrayList&lt;&gt;(list0);\n    sort(list1);\n    return list1;\n}\n\nprivate void sort(List&lt;Sensor&gt; list) {\n    // inserci\u00f3n\n    for (int i = 1; i &lt; list.size(); i++)\n        inserta(list, i, list.get(i));\n}\n\n// inserta sensor en datos, entre 0 y z-1\nprivate void inserta(List&lt;Sensor&gt; datos, int z, Sensor sensor) {\n    int j = z;\n    while (0 &lt; j &amp;&amp; compareTo(sensor, datos.get(j - 1)) &lt; 0)\n        j--;\n\n    if (j != z) {\n        datos.remove(sensor);\n        datos.add(j, sensor);\n    }\n}\n\nprivate int compareTo(Sensor s1, Sensor s2) {\n    int size1 = diccionario.get(s1).size();\n    int size2 = diccionario.get(s2).size();\n    return size2 - size1;\n}\n</code></pre> <p>Con respecto a la complejidad, hay que revisar N sensores.</p> <p>Para cada sensor hay que localizar su lista de sensores en el diccionario: get().</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>Cada lista, de X elementos, hay que ordenarla. Si usamos un algoritmo de inserci\u00f3n como el de arriba, por t\u00e9rmino medio ser\u00e1 la ordenaci\u00f3n de un array de x elementos: O(x2):     - 1. Podemos pensar que X sea constante, independientemente de N, en cuyo caso la ordenaci\u00f3n ser\u00e1 de tiempo constante, O(1).     - 2. Podemos pensar que X sea proporcional a N, en cuyo caso la ordenaci\u00f3n ser\u00e1 una proporci\u00f3n de N: O(n2)</p> <p>Nos quedamos con f elementos: O(1).</p> <p>Y hacemos una operaci\u00f3n put() en el diccionario se salida.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>En el caso 1, el total es N \u00d7 (O(1) + O(1) + O(1) + O(1)) -&gt; N \u00d7 O(1) -&gt; O(n)</p> <p>En el caso 2, el total es N \u00d7 (O(1) + O(n2) + O(1) + O(1)) -&gt; N \u00d7 O(n2) -&gt; O(n3)</p> <p>Resumiendo, si el n\u00famero de sensores dentro del alcance es independiente de N, la complejidad es O(n). Si el n\u00famero de sensores dentro del alcance es proporcional a N, la complejidad depende del algoritmo de ordenaci\u00f3n.</p>","tags":["complejidad"]},{"location":"exams/2016/p1_ex03/","title":"P1 ex03","text":"<ul> <li>(a) (1 punto) Modifique la clase Sensor para que se pueda integrar en una hebra que comparta informaci\u00f3n con los sensores cercanos cada 30 s. Para ello se puede implementar la interfaz Runnable.</li> </ul> <pre><code>public class Sensor implements Runnable {\n    // ...\n    private Red red;\n    private int medida; // valor le\u00eddo por el sensor\n\n    public Sensor(String id, int x, int y, Red red) {\n        this.red = red;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // transmitir la lectura cada 30 segundos\n                red.transmitir(this, medida);\n                Thread.sleep(30000); // 30 s\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Para implementar la interfaz Runnable espreciso redefinir el m\u00e9todo run(): <pre><code>@Override\npublic void run() {\n    while (true) {\n        try {\n            sleep(30000);\n        } catch (InterruptedException ignored) {\n        }\n\n        for (Sensor s : red.cercanos(f).get(this)) {\n            red.enviar(s, medida);\n        }\n    }\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Escriba una l\u00ednea de c\u00f3digo java para arrancar una hebra que ejecute el c\u00f3digo concurrente de Sensor.</li> </ul> Mostrar soluci\u00f3n <p>Para arrancar una hebra que ejecute el m\u00e9todo run() anterior hay que crear la hebra a partir del Runnable y hacer start(): <pre><code>new Thread(new Sensor()).start();\n</code></pre> o alternativamente: <pre><code>Runnable sensor = new Sensor(\u2026);\nThread tread = new Thread(sensor);\nthread.start();\n</code></pre></p> <ul> <li>(c) (1 punto) En el puesto de mando y control, un servidor ejecuta un programa basado en la clase Red de las preguntas anteriores, y recibe peticiones de los operadores locales y de los muchos sensores distribuidos por Madrid. Modifique la clase Red para que pueda atender cargas, recargas y peticiones concurrentes sin problemas de concurrencia.</li> </ul> <p>NOTAS 1. Suponga que el valor medido por el sensor (medida) se actualiza autom\u00e1ticamente por alg\u00fan mecanismo que no es relevante para examen. 2. Suponga que la clase Red incluye el m\u00e9todo <pre><code>public void enviar (Sensor destino, int medida) {\u2026}\n</code></pre></p> Mostrar soluci\u00f3n <p>Para que la clase Red se pueda usar de forma segura desde varias hebras es preciso convertirla en un monitor. Como no tiene atributos p\u00fablicos basta para ello con sincronizar todos sus m\u00e9todos p\u00fablicos: <pre><code>public class Red {\n    private Diccionario diccionario = new DiccionarioImpl();\n\n    public synchronized void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        // ...\n    }\n\n    public synchronized Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n        // ...\n        return null;\n    }\n\n    public synchronized void enviar(Sensor destino, int medida) {\n        // ...\n    }\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2016/p1r/","title":"Examen 2016 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2016/p1r/#problema-1","title":"Problema 1","text":"<p>Queremos desplegar un conjunto de sensores de contaminaci\u00f3n en Madrid. Cada sensor S est\u00e1 en unas coordenadas (x, y) medidas en metros en una cuadr\u00edcula centrada en la Puerta del Sol, yendo el eje X de oeste a este y el eje Y de sur a norte.</p> <p>Los sensores son fr\u00e1giles y pueden fallar. Pero no queremos quedarnos sin datos, as\u00ed que se les facilita la capacidad de que puedan mandar sus mediciones a otro sensor, que debe estar a una distancia menor que d0 metros.</p> <pre><code>public class Sensor {\n    private final String id;\n    private final int x, y;\n\n    public Sensor(String id, int x, int y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distancia(Sensor b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Dada una lista con todos los sensores, escriba un m\u00e9todo que cargue un diccionario donde cada sensor est\u00e1 asociado a una lista con los sensores que est\u00e1n a su alcance (a menos de d0 metros). N\u00f3tese que si el sensor A est\u00e1 dentro del alcance de B, tambi\u00e9n est\u00e1 B dentro del alcance de A. Razone la complejidad de este m\u00e9todo: <pre><code>public class Red {\n    private Diccionario diccionario = new \u2026\n\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\u2026}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Soluci\u00f3n usando un diccionario de la biblioteca de Java</p> <pre><code>public class Red {\n    private Map&lt;Sensor, List&lt;Sensor&gt;&gt; diccionario = new HashMap&lt;&gt;();\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        for (int i = 0; i &lt; sensores.size(); i++) {\n            Sensor s1 = sensores.get(i);\n            List&lt;Sensor&gt; lista = new ArrayList&lt;&gt;();\n            for (int j = 0; j &lt; sensores.size(); j++) {\n                if (i == j)\n                    continue;\n                Sensor s2 = sensores.get(j);\n                if (s1.distancia(s2) &lt; d0)\n                    lista.add(s2);\n        }\n        diccionario.put(s1, lista);\n    }\n}\n</code></pre> <p>Para usar un diccionario como el del ejercicio 3, hay que cambiar CV y la implementaci\u00f3n de la misma manera:</p> <pre><code>class CVExamen {\n    final Sensor clave;\n    List&lt;Sensor&gt; valor;\n\n    CVExamen(Sensor clave, List&lt;Sensor&gt; valor) {\n        this.clave = clave;\n        this.valor = valor;\n    }\n}\n\npublic interface Diccionario {\n    void put(Sensor clave, List&lt;Sensor&gt; valor);\n    List&lt;Sensor&gt; get(Sensor clave);\n    List&lt;Sensor&gt; remove(Sensor clave);\n    int size();\n    void clear();\n}\n</code></pre> <p>Complejidad.</p> <p>Siendo N el n\u00famero de sensores, tenemos un bucle exterior que se hace N veces. Cada pasada por el bucle incluye: - bucle interior: N veces, de complejidad O(n). - diccionario.put(), donde lacomplejidad,  si el n\u00famero de ranuras es sensiblemente superior a N es O(1), si no es O(n).</p> <p>El total es, por tanto O(n) + \u2026 = O(n)</p> <p>Y la operaci\u00f3n total de carga N \u00d7 O(n) -&gt; O(n2)</p>"},{"location":"exams/2016/p1r/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (3,5 puntos) Escriba un m\u00e9todo para crear un diccionario que, para cada sensor S, contenga el conjunto de sensores a los que mandar\u00e1 regularmente una copia de sus medidas. Sabiendo que los sensores de destino podr\u00edan verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se env\u00edan a los F sensores que a su vez tengan menos sensores a su alcance.</li> </ul> <pre><code>public Diccionario cercanos (int f) {\u2026}\n</code></pre> <p>NOTA: El algoritmo es como sigue:     - 1. para cada sensor S obtenemos la lista de nodos a distancia alcanzable (pregunta 1)     - 2. ordenamos la lista en funci\u00f3n del n\u00famero de sensores al alcance de cada sensor     - 3. nos quedamos con los F primeros sensores en una nueva lista     - 4. asociamos la nueva lista a S en el diccionario de resultado</p> <p>NOTAS:     - Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java.     - Como algoritmo de ordenaci\u00f3n, elija uno de los presentados en clase, adaptando el c\u00f3digo al caso.     - Puede usar m\u00e9todos auxiliares si lo cree oportuno. Privados, por supuesto.</p> <p>Razone la complejidad de su c\u00f3digo</p> Mostrar soluci\u00f3n <p>Probablemente, el n\u00famero de sensores dentro del alcance sea un n\u00famero peque\u00f1o. En ese caso la ordenaci\u00f3n se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenaci\u00f3n.</p> <p>En la soluci\u00f3n que sigue se recurre al algoritmo de inserci\u00f3n.</p> <p>Usando la biblioteca de Java:</p> <pre><code>public Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n    Map&lt;Sensor, List&lt;Sensor&gt;&gt; resultado = new HashMap&lt;&gt;();\n\n    for (Sensor sensor : diccionario.keySet()) {\n        List&lt;Sensor&gt; list1 = getListaOrdenadaSensores(sensor);\n        List&lt;Sensor&gt; list2 = new ArrayList&lt;&gt;();\n\n        int m = Math.min(f, list1.size());\n        for (int i = 0; i &lt; m; i++)\n            list2.add(list1.get(i));\n\n        resultado.put(sensor, list2);\n    }\n    return resultado;\n}\n\nprivate List&lt;Sensor&gt; getListaOrdenadaSensores(Sensor sensor) {\n    List&lt;Sensor&gt; list0 = diccionario.get(sensor);\n    List&lt;Sensor&gt; list1 = new ArrayList&lt;&gt;(list0);\n    sort(list1);\n    return list1;\n}\n\nprivate void sort(List&lt;Sensor&gt; list) {\n    // inserci\u00f3n\n    for (int i = 1; i &lt; list.size(); i++)\n        inserta(list, i, list.get(i));\n}\n\n// inserta sensor en datos, entre 0 y z-1\nprivate void inserta(List&lt;Sensor&gt; datos, int z, Sensor sensor) {\n    int j = z;\n    while (0 &lt; j &amp;&amp; compareTo(sensor, datos.get(j - 1)) &lt; 0)\n        j--;\n\n    if (j != z) {\n        datos.remove(sensor);\n        datos.add(j, sensor);\n    }\n}\n\nprivate int compareTo(Sensor s1, Sensor s2) {\n    int size1 = diccionario.get(s1).size();\n    int size2 = diccionario.get(s2).size();\n    return size2 - size1;\n}\n</code></pre> <p>Con respecto a la complejidad, hay que revisar N sensores.</p> <p>Para cada sensor hay que localizar su lista de sensores en el diccionario: get().</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>Cada lista, de X elementos, hay que ordenarla. Si usamos un algoritmo de inserci\u00f3n como el de arriba, por t\u00e9rmino medio ser\u00e1 la ordenaci\u00f3n de un array de x elementos: O(x2):     - 1. Podemos pensar que X sea constante, independientemente de N, en cuyo caso la ordenaci\u00f3n ser\u00e1 de tiempo constante, O(1).     - 2. Podemos pensar que X sea proporcional a N, en cuyo caso la ordenaci\u00f3n ser\u00e1 una proporci\u00f3n de N: O(n2)</p> <p>Nos quedamos con f elementos: O(1).</p> <p>Y hacemos una operaci\u00f3n put() en el diccionario se salida.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>En el caso 1, el total es N \u00d7 (O(1) + O(1) + O(1) + O(1)) -&gt; N \u00d7 O(1) -&gt; O(n)</p> <p>En el caso 2, el total es N \u00d7 (O(1) + O(n2) + O(1) + O(1)) -&gt; N \u00d7 O(n2) -&gt; O(n3)</p> <p>Resumiendo, si el n\u00famero de sensores dentro del alcance es independiente de N, la complejidad es O(n). Si el n\u00famero de sensores dentro del alcance es proporcional a N, la complejidad depende del algoritmo de ordenaci\u00f3n.</p>"},{"location":"exams/2016/p1r/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (1 punto) Modifique la clase Sensor para que se pueda integrar en una hebra que comparta informaci\u00f3n con los sensores cercanos cada 30 s. Para ello se puede implementar la interfaz Runnable.</li> </ul> <pre><code>public class Sensor implements Runnable {\n    // ...\n    private Red red;\n    private int medida; // valor le\u00eddo por el sensor\n\n    public Sensor(String id, int x, int y, Red red) {\n        this.red = red;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // transmitir la lectura cada 30 segundos\n                red.transmitir(this, medida);\n                Thread.sleep(30000); // 30 s\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Para implementar la interfaz Runnable espreciso redefinir el m\u00e9todo run(): <pre><code>@Override\npublic void run() {\n    while (true) {\n        try {\n            sleep(30000);\n        } catch (InterruptedException ignored) {\n        }\n\n        for (Sensor s : red.cercanos(f).get(this)) {\n            red.enviar(s, medida);\n        }\n    }\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Escriba una l\u00ednea de c\u00f3digo java para arrancar una hebra que ejecute el c\u00f3digo concurrente de Sensor.</li> </ul> Mostrar soluci\u00f3n <p>Para arrancar una hebra que ejecute el m\u00e9todo run() anterior hay que crear la hebra a partir del Runnable y hacer start(): <pre><code>new Thread(new Sensor()).start();\n</code></pre> o alternativamente: <pre><code>Runnable sensor = new Sensor(\u2026);\nThread tread = new Thread(sensor);\nthread.start();\n</code></pre></p> <ul> <li>(c) (1 punto) En el puesto de mando y control, un servidor ejecuta un programa basado en la clase Red de las preguntas anteriores, y recibe peticiones de los operadores locales y de los muchos sensores distribuidos por Madrid. Modifique la clase Red para que pueda atender cargas, recargas y peticiones concurrentes sin problemas de concurrencia.</li> </ul> <p>NOTAS 1. Suponga que el valor medido por el sensor (medida) se actualiza autom\u00e1ticamente por alg\u00fan mecanismo que no es relevante para examen. 2. Suponga que la clase Red incluye el m\u00e9todo <pre><code>public void enviar (Sensor destino, int medida) {\u2026}\n</code></pre></p> Mostrar soluci\u00f3n <p>Para que la clase Red se pueda usar de forma segura desde varias hebras es preciso convertirla en un monitor. Como no tiene atributos p\u00fablicos basta para ello con sincronizar todos sus m\u00e9todos p\u00fablicos: <pre><code>public class Red {\n    private Diccionario diccionario = new DiccionarioImpl();\n\n    public synchronized void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        // ...\n    }\n\n    public synchronized Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n        // ...\n        return null;\n    }\n\n    public synchronized void enviar(Sensor destino, int medida) {\n        // ...\n    }\n}\n</code></pre></p>"},{"location":"exams/2016/p1r_ex01/","title":"P1r ex01","text":"<p>Se quiere desarrollar un algoritmo que, dado un array de enteros, calcule cu\u00e1l es el n\u00famero que se repite m\u00e1s veces. As\u00ed, si el array contiene {2, 4, 3, 4, 2, 6, 1, 4, 4}, el algoritmo devuelve 4. Si hay empate, devuelve el primer valor. Se pide:</p> <ul> <li>(a) (1 punto) Escribir un m\u00e9todo en Java que compute el algoritmo descrito. Si el array est\u00e1 vac\u00edo o es nulo, se lanzar\u00e1 una excepci\u00f3n. La cabecera del m\u00e9todo debe ser:</li> </ul> <pre><code>int mayoria (int []v) throws exception\n</code></pre> Mostrar soluci\u00f3n <p>Hay varias posibles soluciones:</p> <ol> <li>hacer un histograma, eligiendo el valor mayor seg\u00fan se cuenta</li> <li>ordenar el array y contar repeticiones sucesivas</li> </ol> <p>Se incluye la soluci\u00f3n 1, almacenando el histograma en un Map. Una posible soluci\u00f3n es: <pre><code>public static int mayoria(int[] v) throws Exception {\n    if (v == null || v.length == 0)\n        throw new IllegalArgumentException(\"mayoria: invalid argument\");\n\n    Map&lt;Integer, Integer&gt; histograma = new HashMap&lt;Integer, Integer&gt;();\n    int masRep = v[0];        // candidato inicial\n    int repeticiones = 1;    // aparece una vez\n\n    for (int i = 0; i &lt; v.length; i++) {\n        Integer veces = histograma.get(v[i]);\n        veces = (veces == null) ? 1 : veces + 1;\n        histograma.put(v[i], veces);\n\n        if (veces &gt; repeticiones) {\n            repeticiones = veces;\n            masRep = v[i];\n        }\n    }\n    return masRep;\n}\n</code></pre></p> <p>Se desea calcular la complejidad del m\u00e9todo del apartado anterior. Se pide:</p> <ul> <li>(b) (1 punto) \u00bfCu\u00e1l es la ecuaci\u00f3n de recurrencia?</li> </ul> Mostrar soluci\u00f3n <p>T(n) = T(n-1) +c si n &gt; 1</p> <p>T(0) = d</p> <p>(c) (1 punto) Determinar su complejidad.</p> Mostrar soluci\u00f3n <p>Se puede resolver la ecuaci\u00f3n de (b) o razonar de la siguiente forma:</p> <p>Las instrucciones sencillas (if, asignaciones, acceso al array) son constantes O(1).</p> <p>El acceso al Map (get y put) podemos considerarlo tambi\u00e9n constante en condiciones adecuadas de carga.</p> <p>S\u00f3lo el bucle for depende de n, procesando cada elemento una \u00fanica vez, ergo es de complejidad O(n).</p> <p>Como O(1) \u2286 O(n), el resultado es que el algoritmo es de complejidad O(n).</p> <p>Comentarios adicionales: - no puede existir un algoritmo mejor que O(n) porque al menos hay que ver cada elemento una vez. - se puede tener un algoritmo O(n2) si con un for vamos viendo cada elemento, y para cada elemento contamos el n\u00famero de repeticiones recorriendo el array (for dentro de for). - el O(n log n) se obtiene en varias circunstancias:     - suponiendo un algoritmo de ordenaci\u00f3n de esa complejidad.     - usando un \u00e1rbol binario de b\u00fasqueda para almacenar el histograma.</p>","tags":["complejidad"]},{"location":"exams/2016/p1r_ex02/","title":"P1r ex02","text":"<p>Una aplicaci\u00f3n m\u00f3vil registra la actividad de un senderista. Cuando empieza una caminata, la aplicaci\u00f3n guarda la fecha (de comienzo del paseo) y una lista de coordenadas en el plano (x, y), obtenidas cada segundo. Cuando el senderista termina su actividad, la aplicaci\u00f3n manda a un servidor la siguiente informaci\u00f3n: nombre completo del senderista (String), fecha de comienzo de la actividad (Date) y la lista de coordenadas recorridas.</p> <p>El servidor, escrito en Java, guarda para cada senderista, todas las rutas que haya recorrido. Para ello, dispone de un diccionario donde la clave es el nombre del senderista y el valor es una lista de todas las rutas recorridas por dicho senderista.</p> <p>Se dispone de las siguientes declaraciones:</p> <pre><code>public class Coordenada {\n    private double x, y;\n    // constructor, getters y setters al uso\n\n    public double distancia(Coordenada b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n\npublic class Servidor {\n    private Diccionario rutas = new /* implementaci\u00f3n */;\n\n    public void anadir(String senderista, Ruta ruta) {\n        // ...\n    }\n\n    public String campeon() {\n        // ...\n        return null;\n    }\n}\n\npublic class Ruta {\n    private Date fechaComienzo;\n    private List&lt;Coordenada&gt; puntos;\n    // constructor, getters y setters al uso\n\n    public double longitud() {\n        // ...\n        return 0.0;\n    }\n}\n</code></pre> <ul> <li>(a) (1 punto) Codificar el m\u00e9todo a\u00f1adir.</li> </ul> Mostrar soluci\u00f3n <p>Como se usa un diccionario, es necesario que tengamos una lista de senderistas registrados. Por ello queda: <pre><code>// rutas de cada senderista\nprivate Diccionario rutasPorSenderista = new DiccionarioHashMap(1000);\n// tambi\u00e9n vale:\n// private Map&lt;String, List&lt;Ruta&gt;&gt; rutasPorSenderista = new HashMap&lt;&gt;();\n\n// senderistas registrados, puede evitarse a\u00f1adiendo keySet() a Diccionario\nprivate List&lt;String&gt; lsenderistas = new ArrayList&lt;String&gt;();\n\npublic void anadir(String senderista, Ruta ruta) {\n    List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n\n    if (lr == null) { // senderista no registrado\n        lsenderistas.add(senderista);\n        lr = new ArrayList&lt;Ruta&gt;();\n    }\n\n    lr.add(ruta);\n    rutasPorSenderista.put(senderista, lr);\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Codificar un m\u00e9todo de la clase Ruta que calcule la longitud total del recorrido (m\u00e9todo longitud de la clase Ruta).</li> </ul> Mostrar soluci\u00f3n <pre><code>public double longitud() {\n    double total = 0;\n\n    if (puntos == null || puntos.size() &lt; 2) { // \u00bfno hay puntos?\n        return 0;\n    }\n\n    Coordenada ant = puntos.get(0);\n    for (int i = 1; i &lt; puntos.size(); i++) {\n        Coordenada sig = puntos.get(i);\n        total += ant.distancia(sig);\n        ant = sig;\n    }\n\n    return total;\n}\n</code></pre> <ul> <li>(c) (2 puntos) Codificar un m\u00e9todo de la clase Servidor que determine qu\u00e9 senderista ha recorrido m\u00e1s distancia en total, sumando todas sus rutas (m\u00e9todo campeon de la clase Servidor). En caso de empate, puede devolver cualquiera.</li> </ul> Mostrar soluci\u00f3n <p>campe\u00f3n usa un m\u00e9todo auxiliar para averiguar la la suma de longitudes de las rutas de un usuario: <pre><code>public String campeon() {\n    String champ = null;\n    double maxLong = -1;\n\n    // tambi\u00e9n:\n    // for (String senderista : rutasPorSenderista.keySet())\n    for (String senderista : lsenderistas) {\n        List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n        double mayorCamino = sumaTotal(lr);\n\n        if (mayorCamino &gt; maxLong) {\n            maxLong = mayorCamino;\n            champ = senderista;\n        }\n    }\n    return champ;\n}\n\nprivate double sumaTotal(List&lt;Ruta&gt; lr) {\n    double suma = 0;\n    for (Ruta r : lr)\n        suma += r.longitud();\n    return suma;\n}\n</code></pre></p>","tags":["???"]},{"location":"exams/2016/p1r_ex03/","title":"P1r ex03","text":"<p>Sea un un sistema de gesti\u00f3n de turnos en un supermercado. Los usuarios, con el tel\u00e9fono inteligente, piden n\u00famero al gestor de turnos, y pueden preguntar en cualquier momento por el turno actual. Los dependientes, con unos botones que hay en los mostradores, hacen avanzar el turno actual.</p> <p>Hay un gestor central que coordina las peticiones y avances para que no haya duplicidades ni se pierda ning\u00fan turno. Su esquema es:</p> <pre><code>class Gestor {\n    // devuelve turnos correlativos 1, 2, 3, ...\n    public int getTurno() { \u2026 }\n\n    // avanza el turno al n\u00famero siguiente\n    public void avanzaTurno() { \u2026 }\n\n    // dice en qu\u00e9 turno estamos\n    public int getActual() { \u2026 }\n}\n</code></pre> <ul> <li>(a) (1,5 puntos) Complete la clase Gestor, teniendo en cuenta que debe poder recibir llamadas concurrentes de clientes y dependientes.</li> </ul> Mostrar soluci\u00f3n <p>public class Gestor {     private int turno = 0;     private int actual = 0;</p> <pre><code>// devuelve turnos correlativos 1, 2, 3, ...\npublic synchronized int getTurno() {\n    turno++;\n    return turno;\n}\n\n// avanza el turno al n\u00famero siguiente\npublic synchronized void avanzaTurno() {\n    if (actual &lt;= turno)\n        actual++;\n}\n\n// dice en qu\u00e9 turno estamos\npublic synchronized int getActual() {\n    return actual;\n}\n</code></pre> <p>}</p> <ul> <li>(b) (1,5 puntos) Escriba el c\u00f3digo de una clase Cliente que defina una hebra (thread) que efect\u00fae las siguientes operaciones:      \u2013 Pide turno     \u2013 Cada 10 s consulta el turno actual     \u2013 Si faltan menos de 5 turnos hace BIP()     \u2013 Si le toca el turno hace BIP(); BIP();     \u2013 Si se ha pasado el turno termina la ejecuci\u00f3n de la hebra</li> </ul> <p>NOTAS: 1. Suponga que el m\u00e9todo BIP() est\u00e1 disponible directamente en la plataforma de ejecuci\u00f3n 2. El m\u00e9todo avanzaTurno no debe incrementar el n\u00famero de turno m\u00e1s all\u00e1 del \u00faltimo n\u00famero emitido. Por ejemplo, si el \u00faltimo n\u00famero devuelto por getTurno es el 41, el m\u00e9todo avanzaTurno puede llegar a 42, pero no puede avanzar a 43. 3. Los m\u00e9todos de Gestor devuelven el control inmediatamente, sin esperas.</p> Mostrar soluci\u00f3n <p>public class Cliente extends Thread {     private Gestor gestor;</p> <pre><code>public Cliente(int id, Gestor gestor) {\n    this.gestor = gestor;\n}\n\n@Override\npublic void run() {\n    int turno = gestor.getTurno();\n    int actual;\n\n    do {\n        actual = gestor.getActual();\n\n        if (turno - actual &lt; 5)\n            BIP();\n\n        if (actual == turno) {\n            BIP();\n            break;\n        }\n\n        try {\n            sleep(10000);\n        } catch (InterruptedException ignored) {\n        }\n\n    } while (turno &gt; actual);\n}\n</code></pre> <p>}</p>","tags":["monitores"]},{"location":"exams/2021/exam/","title":"Ejercicio X \u2014 T\u00edtulo breve","text":"","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#enunciado","title":"Enunciado","text":"<p>Escribe aqu\u00ed el enunciado completo del ejercicio.</p> <p>Puedes incluir c\u00f3digo:</p> <p><pre><code>for (int i = 0; i &lt; n; i++) {\n    // ...\n}\n</code></pre> O diagramas, pseudoc\u00f3digo, tablas, etc.</p>","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#solucion","title":"Soluci\u00f3n","text":"Mostrar soluci\u00f3n","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#razonamiento","title":"Razonamiento","text":"<p>Explica los pasos o la deducci\u00f3n necesaria. Puedes subdividir la explicaci\u00f3n en apartados.</p>","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#solucion-final","title":"Soluci\u00f3n final","text":"<p>Indica directamente la respuesta, demostraci\u00f3n o c\u00f3digo.</p> <pre><code>def solve():\n    return ...\n</code></pre>","tags":["complejidad","ordenaci\u00f3n"]}]}