{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cat\u00e1logo de Ejercicios","text":"<p>Bienvenido al cat\u00e1logo.</p>"},{"location":"tags/","title":"Macro Rendering Error","text":"<p>File: <code>tags.md</code></p> <p>TypeError: '&lt;' not supported between instances of 'str' and 'int'</p> <pre><code>Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/site-packages/mkdocs_macros/plugin.py\", line 703, in render\n    return md_template.render(**page_variables)\n           ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\n  File \"/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/site-packages/jinja2/environment.py\", line 1295, in render\n    self.environment.handle_exception()\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^\n  File \"/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/site-packages/jinja2/environment.py\", line 942, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 7, in top-level template code\n  File \"/home/runner/work/examenes/examenes/main.py\", line 131, in generate_tags_list\n    exercises.sort(key=lambda x: (x['year'], x['exam']))\n    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '&lt;' not supported between instances of 'str' and 'int'\n</code></pre>"},{"location":"exams/2012/ex01/","title":"Ex01","text":"","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex01/#a-15-puntos","title":"A. (1.5 puntos)","text":"<p>Se pide escribir un algoritmo de ordenaci\u00f3n con la siguiente interfaz</p> <p><pre><code>int[] ordena(long[] datos)\n</code></pre> de tal forma que los datos de entrada no se modifican y el m\u00e9todo devuelve un array que contiene en qu\u00e9 posici\u00f3n deber\u00eda ir del dato correspondiente para estar en orden ascendente. Por ejemplo: <pre><code>datos:   [8, 42, 46, 24, 29, 7]\nindices: [1,  4,  5,  2,  3, 0]\n</code></pre> que se lee como que</p> <ul> <li>datos[0] se ordenar\u00eda en la posici\u00f3n 1</li> <li>datos[1] se ordenar\u00eda en la posici\u00f3n 4</li> <li>datos[2] se ordenar\u00eda en la posici\u00f3n 5</li> <li>etc.</li> </ul> <p>NOTA: Si hubiera 2 datos de igual valor, da igual cual de ellos va antes o despu\u00e9s. Elija lo que le sea m\u00e1s c\u00f3modo.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre></p>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex01/#b-15-puntos","title":"B. (1.5 puntos)","text":"<p>Estime la complejidad del  algoritmo  del  punto anterior,  contando  el  n\u00famero  de  comparaciones entre datos (enteros <code>long</code>) que hay que hacer en el caso peor.</p> Mostrar soluci\u00f3n <p>Hay 2 bucles, uno dentro del otro. El bucle exterior se hace \\(N\\) veces. En el bucle interior, la primera vez se hacen \\(N-1\\) comparaciones; la segunda vez, \\(N-2\\); la tercera \\(N-3\\), etc.  En total \\((N-1) + (N-2) + ... + 1 \\leftarrow \\mathcal{O}(N^2)\\)</p>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex02/","title":"Ex02","text":"","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex02/#a-3-puntos","title":"A. (3 puntos)","text":"<p>Sea un puente con capacidad para un veh\u00edculo y dos accesos: norte y sur. En caso de que haya veh\u00edculos intentando entrar por los dos accesos, debe entrar un veh\u00edculo por el extremo en el que haya m\u00e1s esperando (si el n\u00famero de veh\u00edculos esperando en cada extremo es el mismo, no es necesario imponer un orden). En el caso de que intente entrar una ambulancia, tendr\u00e1 prioridad sobre el resto de veh\u00edculos. No es necesario considerar el caso en que dos ambulancias intenten acceder simult\u00e1neamente al puente.  Se  pide  desarrollar  una  clase  monitor  GestorPuente  que  gestione  el  acceso  al  puente,  seg\u00fan  la especificaci\u00f3n  previa.  Los  m\u00e9todos  de  esta  clase  no  retornan  valores.  El  esqueleto  de  la  clase  es  el siguiente:</p> <pre><code>public class GestorPuente {\n    ... void entrarNorte () { ...}\n    ... void entrarSur () { ...}\n    ... void entrarAmbulancia () { ...}\n    ... void salirPuente(){...}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>package es.upm.dit.adsw.puenteTurnoEspera;\n/**\n* @author Alejandro Alonso\n* Monitor que gestiona la entrada a un puente de coches\n* por sus dos extremos (norte y sur). Dentro el puente s\u00f3lo puede\n* haber un coche. Si hay coches esperando en sus dos extremos, entra\n* uno por el extremos con m\u00e1s coches esperando. Si intenta entrar una\n* ambulancia, tendr\u00e1 prioridad. No pueden intentar dos ambulancias\n* simultaneamente.\n*/\npublic class GestorPuente { // monitor\n/**\n* Indica si hay un coche dentro del puente\n*/\nprivate boolean hayCocheEnPuente = false;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Norte\n*/\nprivate int nCochesNorte = 0;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Sur\n*/\nprivate int nCochesSur = 0;\n/**\n    Indica si hay una ambulancia esperando.\n\n*/\nprivate boolean hayAmbulancia = false;\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el norte.\n*  El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n*  coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarNorte() throws InterruptedException {\n    nCochesNorte++;\n    !!while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur)\n        wait();\n    hayCocheEnPuente = true;\n    nCochesNorte--;\n}\n\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el sur.\n* El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n* coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarSur() throws InterruptedException {\n    nCochesSur++;\n    while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte)\n    wait();\n    hayCocheEnPuente = true;\n    nCochesSur--;\n}\n/**\n* M\u00e9todo que ejecutan las ambulancias\n*/\npublic synchronized void entrarAmbulancia() throws InterruptedException {\n    hayAmbulancia = true;\n    while (hayCocheEnPuente) wait();\n    hayCocheEnPuente = true;\n    hayAmbulancia = false;\n}\n\n/**\n* M\u00e9todo que invoca un coche que est\u00e1 en el puente al salir de \u00e9l.\n*/\npublic synchronized void salirPuente() {\n    hayCocheEnPuente = false;\n    notifyAll();\n}\n}\n</code></pre></p>","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex03/","title":"Ex03","text":"<p>Tenemos una aplicaci\u00f3n de Android que calcula la nota de ADSW como se muestra a continuaci\u00f3n.</p> <p>Como hemos visto, la aplicaci\u00f3n consta de dos pantallas, un formulario inicial (<code>NotaMediaActivity</code>) y  una pantalla que muestra  una foto y  el resultado (<code>ResultadoActivity</code>). Ambas clases est\u00e1n en el paquete <code>es.upm.dit.adsw</code>.</p> <p>El c\u00e1lculo de  la nota media se realiza de la siguiente forma:</p> <ul> <li>S\u00f3lo se hace media si ambas notas  son mayores o iguales a 4. </li> <li>La nota es 0.6 * nota de de examen + 0.4 * nota de trabajo</li> </ul>","tags":["android","actividades"]},{"location":"exams/2012/ex03/#a-1-punto","title":"A. (1 punto)","text":"<p>Complete el c\u00f3digo del fichero de manifiesto del listado 1 para que la aplicaci\u00f3n muestre la pantalla inicial (formulario) y pueda pasar a la segunda de resultado con la media.</p>","tags":["android","actividades"]},{"location":"exams/2012/ex03/#b-2-puntos","title":"B. (2 puntos)","text":"<p>Programe la actividad <code>NotaMediaActivity</code>. Debe tener en cuenta:</p> <ul> <li>Si el usuario no rellena un campo o introduce un valor no num\u00e9rico, debe mostrar un mensaje indic\u00e1ndole que debe introducir valores num\u00e9ricos (use un Toast).</li> <li>La actividad ResultadoActivity espera recibir una intenci\u00f3n con dos par\u00e1metros extra: <ul> <li>un primer par\u00e1metro de tipo boolean denominado \u201caprobado\u201d (true si cumple umbrales y media &gt; = 5; false en caso contrario)</li> <li>un segundo par\u00e1metro de tipo String denominado valor (contiene un mensaje indicando qu\u00e9 umbral no se ha superado si no se puede hacer la media, o bien el valor de la nota media).</li> </ul> </li> <li>Los listados 2 y 3 le proporcionan informaci\u00f3n del layout de NotaMediaActivity y las cadenas string.xml de la aplicaci\u00f3n.</li> </ul> <p>Listado 1. C\u00f3digo de AndroidManifest.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"COMPLETAR POR EL ALUMMNO\" &lt;!-- COMPLETAR --&gt;\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n     &gt;\n       &lt;!-- COMPLETAR POR EL ALUMNO --&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>Listado 2.  C\u00f3digo de layout/ notamedia_final.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;TableLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" \n    android:background=\"@drawable/notebook\"\n    android:paddingLeft=\"40dp\"\n    android:paddingRight=\"5dp\" &gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_examen\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_examen_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n            &lt;requestFocus /&gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_trabajo\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_trabajo_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow\n        android:gravity=\"center\"&gt;\n        &lt;Button\n            android:id=\"@+id/button_calcular\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/calcular\" /&gt;\n    &lt;/TableRow&gt;\n&lt;/TableLayout&gt;\n</code></pre></p> <p>Listado 3. C\u00f3digo de values/strings.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;NotaMediaADSW&lt;/string&gt;\n    &lt;string name=\"nota_trabajo\"&gt;Nota trabajo final&lt;/string&gt;\n    &lt;string name=\"nota_examen\"&gt;Nota examen final&lt;/string&gt;\n    &lt;string name=\"nota_media\"&gt;Nota media&lt;/string&gt;\n    &lt;string name=\"calcular\"&gt;Calcular&lt;/string&gt;\n    &lt;string name=\"error_numero\"&gt;Los campos deben ser num\u00e9ricos&lt;/string&gt;\n    &lt;string name=\"umbral_trabajo\"&gt;No has superado el umbral de 4.0 en la pr\u00e1ctica&lt;/string&gt;\n    &lt;string name=\"umbral_examen\"&gt;No has superado el umbral de 4.0 en el examen&lt;/string&gt;        \n     &lt;string name=\"enhorabuena\"&gt;Enhorabuena, que pases un buen verano.&lt;/string&gt;\n    &lt;string name=\"julio\"&gt;Hay otra oportunidad en julio. &lt;/string&gt;\n    &lt;string name=\"nota\"&gt;La nota es &lt;/string&gt;\n    &lt;string name=\"problema_nota\"&gt;Hay un problema para mostrar la nota&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre></p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n    &gt;\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\" &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <pre><code>public class NotaMediaActivity extends Activity {\npublic static final String APROBADO = \"nota\";\npublic static final String VALOR = \"valor\";\nprivate static final String TAG = NotaMediaActivity.class.getSimpleName();\nprivate EditText editNotaFinal;\nprivate EditText editTrabajoFinal;\nprivate Button buttonGuardar;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    Log.d(TAG, \"onCreate\");\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.notamedia_final);\n    editNotaFinal = (EditText) findViewById(R.id.editText_examen_final);\n    editTrabajoFinal = (EditText) findViewById(R.id.editText_trabajo_final);\n    buttonGuardar = (Button) findViewById(R.id.button_calcular);\n    buttonGuardar.setOnClickListener(new ProcesaMedia());\n}\n\nprivate class ProcesaMedia implements OnClickListener {\n    @Override\n    public void onClick(View v) {\n    try {\n        float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n        float notaTrabajo =\n            Float.parseFloat(editTrabajoFinal.getText().toString());\n        if ((notaFinal &lt; 0) || (notaFinal &gt; 10) || (notaTrabajo &lt; 0)\n            || (notaTrabajo &gt; 10)) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n        return;\n        }\n        float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String mediaString = df.format(media);\n        boolean aprobado = false;\n        String valor = \"\";\n        if ((notaTrabajo &lt; 4) || (notaFinal &lt; 4)) {\n        aprobado = false;\n        if (notaTrabajo &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_trabajo);\n        }\n        if (notaFinal &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_examen);\n        }\n        } else {\n        valor = mediaString;\n        aprobado = (media &gt;= 5);\n        }\n        Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n        intent.putExtra(APROBADO, aprobado);\n        intent.putExtra(VALOR, valor);\n        Log.d(TAG, \"Nota \" + aprobado + \" \" + valor);\n        startActivity(intent);\n    } catch (NumberFormatException e) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n    }\n    }\n}\n}\n</code></pre>","tags":["android","actividades"]},{"location":"exams/2012/exam/","title":"Examen 2012 \u2014 Final","text":""},{"location":"exams/2012/exam/#ejercicio-1","title":"Ejercicio 1","text":""},{"location":"exams/2012/exam/#a-15-puntos","title":"A. (1.5 puntos)","text":"<p>Se pide escribir un algoritmo de ordenaci\u00f3n con la siguiente interfaz</p> <p><pre><code>int[] ordena(long[] datos)\n</code></pre> de tal forma que los datos de entrada no se modifican y el m\u00e9todo devuelve un array que contiene en qu\u00e9 posici\u00f3n deber\u00eda ir del dato correspondiente para estar en orden ascendente. Por ejemplo: <pre><code>datos:   [8, 42, 46, 24, 29, 7]\nindices: [1,  4,  5,  2,  3, 0]\n</code></pre> que se lee como que</p> <ul> <li>datos[0] se ordenar\u00eda en la posici\u00f3n 1</li> <li>datos[1] se ordenar\u00eda en la posici\u00f3n 4</li> <li>datos[2] se ordenar\u00eda en la posici\u00f3n 5</li> <li>etc.</li> </ul> <p>NOTA: Si hubiera 2 datos de igual valor, da igual cual de ellos va antes o despu\u00e9s. Elija lo que le sea m\u00e1s c\u00f3modo.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre></p>"},{"location":"exams/2012/exam/#b-15-puntos","title":"B. (1.5 puntos)","text":"<p>Estime la complejidad del  algoritmo  del  punto anterior,  contando  el  n\u00famero  de  comparaciones entre datos (enteros <code>long</code>) que hay que hacer en el caso peor.</p> Mostrar soluci\u00f3n <p>Hay 2 bucles, uno dentro del otro. El bucle exterior se hace \\(N\\) veces. En el bucle interior, la primera vez se hacen \\(N-1\\) comparaciones; la segunda vez, \\(N-2\\); la tercera \\(N-3\\), etc.  En total \\((N-1) + (N-2) + ... + 1 \\leftarrow \\mathcal{O}(N^2)\\)</p>"},{"location":"exams/2012/exam/#ejercicio-2","title":"Ejercicio 2","text":""},{"location":"exams/2012/exam/#a-3-puntos","title":"A. (3 puntos)","text":"<p>Sea un puente con capacidad para un veh\u00edculo y dos accesos: norte y sur. En caso de que haya veh\u00edculos intentando entrar por los dos accesos, debe entrar un veh\u00edculo por el extremo en el que haya m\u00e1s esperando (si el n\u00famero de veh\u00edculos esperando en cada extremo es el mismo, no es necesario imponer un orden). En el caso de que intente entrar una ambulancia, tendr\u00e1 prioridad sobre el resto de veh\u00edculos. No es necesario considerar el caso en que dos ambulancias intenten acceder simult\u00e1neamente al puente.  Se  pide  desarrollar  una  clase  monitor  GestorPuente  que  gestione  el  acceso  al  puente,  seg\u00fan  la especificaci\u00f3n  previa.  Los  m\u00e9todos  de  esta  clase  no  retornan  valores.  El  esqueleto  de  la  clase  es  el siguiente:</p> <pre><code>public class GestorPuente {\n    ... void entrarNorte () { ...}\n    ... void entrarSur () { ...}\n    ... void entrarAmbulancia () { ...}\n    ... void salirPuente(){...}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>package es.upm.dit.adsw.puenteTurnoEspera;\n/**\n* @author Alejandro Alonso\n* Monitor que gestiona la entrada a un puente de coches\n* por sus dos extremos (norte y sur). Dentro el puente s\u00f3lo puede\n* haber un coche. Si hay coches esperando en sus dos extremos, entra\n* uno por el extremos con m\u00e1s coches esperando. Si intenta entrar una\n* ambulancia, tendr\u00e1 prioridad. No pueden intentar dos ambulancias\n* simultaneamente.\n*/\npublic class GestorPuente { // monitor\n/**\n* Indica si hay un coche dentro del puente\n*/\nprivate boolean hayCocheEnPuente = false;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Norte\n*/\nprivate int nCochesNorte = 0;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Sur\n*/\nprivate int nCochesSur = 0;\n/**\n    Indica si hay una ambulancia esperando.\n\n*/\nprivate boolean hayAmbulancia = false;\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el norte.\n*  El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n*  coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarNorte() throws InterruptedException {\n    nCochesNorte++;\n    !!while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur)\n        wait();\n    hayCocheEnPuente = true;\n    nCochesNorte--;\n}\n\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el sur.\n* El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n* coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarSur() throws InterruptedException {\n    nCochesSur++;\n    while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte)\n    wait();\n    hayCocheEnPuente = true;\n    nCochesSur--;\n}\n/**\n* M\u00e9todo que ejecutan las ambulancias\n*/\npublic synchronized void entrarAmbulancia() throws InterruptedException {\n    hayAmbulancia = true;\n    while (hayCocheEnPuente) wait();\n    hayCocheEnPuente = true;\n    hayAmbulancia = false;\n}\n\n/**\n* M\u00e9todo que invoca un coche que est\u00e1 en el puente al salir de \u00e9l.\n*/\npublic synchronized void salirPuente() {\n    hayCocheEnPuente = false;\n    notifyAll();\n}\n}\n</code></pre></p>"},{"location":"exams/2012/exam/#ejercicio-3","title":"Ejercicio 3","text":"<p>Tenemos una aplicaci\u00f3n de Android que calcula la nota de ADSW como se muestra a continuaci\u00f3n.</p> <p>Como hemos visto, la aplicaci\u00f3n consta de dos pantallas, un formulario inicial (<code>NotaMediaActivity</code>) y  una pantalla que muestra  una foto y  el resultado (<code>ResultadoActivity</code>). Ambas clases est\u00e1n en el paquete <code>es.upm.dit.adsw</code>.</p> <p>El c\u00e1lculo de  la nota media se realiza de la siguiente forma:</p> <ul> <li>S\u00f3lo se hace media si ambas notas  son mayores o iguales a 4. </li> <li>La nota es 0.6 * nota de de examen + 0.4 * nota de trabajo</li> </ul>"},{"location":"exams/2012/exam/#a-1-punto","title":"A. (1 punto)","text":"<p>Complete el c\u00f3digo del fichero de manifiesto del listado 1 para que la aplicaci\u00f3n muestre la pantalla inicial (formulario) y pueda pasar a la segunda de resultado con la media.</p>"},{"location":"exams/2012/exam/#b-2-puntos","title":"B. (2 puntos)","text":"<p>Programe la actividad <code>NotaMediaActivity</code>. Debe tener en cuenta:</p> <ul> <li>Si el usuario no rellena un campo o introduce un valor no num\u00e9rico, debe mostrar un mensaje indic\u00e1ndole que debe introducir valores num\u00e9ricos (use un Toast).</li> <li>La actividad ResultadoActivity espera recibir una intenci\u00f3n con dos par\u00e1metros extra: <ul> <li>un primer par\u00e1metro de tipo boolean denominado \u201caprobado\u201d (true si cumple umbrales y media &gt; = 5; false en caso contrario)</li> <li>un segundo par\u00e1metro de tipo String denominado valor (contiene un mensaje indicando qu\u00e9 umbral no se ha superado si no se puede hacer la media, o bien el valor de la nota media).</li> </ul> </li> <li>Los listados 2 y 3 le proporcionan informaci\u00f3n del layout de NotaMediaActivity y las cadenas string.xml de la aplicaci\u00f3n.</li> </ul> <p>Listado 1. C\u00f3digo de AndroidManifest.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"COMPLETAR POR EL ALUMMNO\" &lt;!-- COMPLETAR --&gt;\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n     &gt;\n       &lt;!-- COMPLETAR POR EL ALUMNO --&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>Listado 2.  C\u00f3digo de layout/ notamedia_final.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;TableLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" \n    android:background=\"@drawable/notebook\"\n    android:paddingLeft=\"40dp\"\n    android:paddingRight=\"5dp\" &gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_examen\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_examen_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n            &lt;requestFocus /&gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_trabajo\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_trabajo_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow\n        android:gravity=\"center\"&gt;\n        &lt;Button\n            android:id=\"@+id/button_calcular\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/calcular\" /&gt;\n    &lt;/TableRow&gt;\n&lt;/TableLayout&gt;\n</code></pre></p> <p>Listado 3. C\u00f3digo de values/strings.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;NotaMediaADSW&lt;/string&gt;\n    &lt;string name=\"nota_trabajo\"&gt;Nota trabajo final&lt;/string&gt;\n    &lt;string name=\"nota_examen\"&gt;Nota examen final&lt;/string&gt;\n    &lt;string name=\"nota_media\"&gt;Nota media&lt;/string&gt;\n    &lt;string name=\"calcular\"&gt;Calcular&lt;/string&gt;\n    &lt;string name=\"error_numero\"&gt;Los campos deben ser num\u00e9ricos&lt;/string&gt;\n    &lt;string name=\"umbral_trabajo\"&gt;No has superado el umbral de 4.0 en la pr\u00e1ctica&lt;/string&gt;\n    &lt;string name=\"umbral_examen\"&gt;No has superado el umbral de 4.0 en el examen&lt;/string&gt;        \n     &lt;string name=\"enhorabuena\"&gt;Enhorabuena, que pases un buen verano.&lt;/string&gt;\n    &lt;string name=\"julio\"&gt;Hay otra oportunidad en julio. &lt;/string&gt;\n    &lt;string name=\"nota\"&gt;La nota es &lt;/string&gt;\n    &lt;string name=\"problema_nota\"&gt;Hay un problema para mostrar la nota&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre></p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n    &gt;\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\" &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <pre><code>public class NotaMediaActivity extends Activity {\npublic static final String APROBADO = \"nota\";\npublic static final String VALOR = \"valor\";\nprivate static final String TAG = NotaMediaActivity.class.getSimpleName();\nprivate EditText editNotaFinal;\nprivate EditText editTrabajoFinal;\nprivate Button buttonGuardar;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    Log.d(TAG, \"onCreate\");\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.notamedia_final);\n    editNotaFinal = (EditText) findViewById(R.id.editText_examen_final);\n    editTrabajoFinal = (EditText) findViewById(R.id.editText_trabajo_final);\n    buttonGuardar = (Button) findViewById(R.id.button_calcular);\n    buttonGuardar.setOnClickListener(new ProcesaMedia());\n}\n\nprivate class ProcesaMedia implements OnClickListener {\n    @Override\n    public void onClick(View v) {\n    try {\n        float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n        float notaTrabajo =\n            Float.parseFloat(editTrabajoFinal.getText().toString());\n        if ((notaFinal &lt; 0) || (notaFinal &gt; 10) || (notaTrabajo &lt; 0)\n            || (notaTrabajo &gt; 10)) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n        return;\n        }\n        float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String mediaString = df.format(media);\n        boolean aprobado = false;\n        String valor = \"\";\n        if ((notaTrabajo &lt; 4) || (notaFinal &lt; 4)) {\n        aprobado = false;\n        if (notaTrabajo &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_trabajo);\n        }\n        if (notaFinal &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_examen);\n        }\n        } else {\n        valor = mediaString;\n        aprobado = (media &gt;= 5);\n        }\n        Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n        intent.putExtra(APROBADO, aprobado);\n        intent.putExtra(VALOR, valor);\n        Log.d(TAG, \"Nota \" + aprobado + \" \" + valor);\n        startActivity(intent);\n    } catch (NumberFormatException e) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n    }\n    }\n}\n}\n</code></pre>"},{"location":"exams/2012/extra/","title":"Examen 2012 \u2014 Extraordinario","text":""},{"location":"exams/2012/extra/#ejercicio-1","title":"Ejercicio 1","text":"<p>Se pide escribir un algoritmo para extraer la mediana de los valores de un array. Si un array de \\(N\\) datos est\u00e1 ordenado, la mediana es el valor del medio, \\(\\text{array}[N/2]\\).</p> <p>El objetivo es preparar un m\u00e9todo:</p> <pre><code>public long mediana(long[] datos)\n</code></pre> <p>que devuelve la mediana del array que se le pasa.</p> <p>Debe partir del algoritmo de quicksort y modificarlo de forma que, cuando se separan los datos en dos partes, solo se siga procesando la parte que contiene la mediana, sin ordenar la otra.</p> <p>Se pide:</p> <ol> <li>escribir el algoritmo de forma recursiva.</li> <li>escribirlo de forma iterativa.</li> <li>calcular la complejidad razonando el por qu\u00e9.</li> </ol> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\n````\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana1(long[] datos, int a, int z) {\n        long pivote = datos[(a + z) / 2];\n        int inf = a;\n        int sup = z;\n        while (inf &lt; sup) {\n            while (datos[inf] &lt; pivote)\n                inf++;\n            while (pivote &lt; datos[sup - 1])\n                sup--;\n            if (inf &lt; sup) {\n                long tmp = datos[inf];\n                datos[inf] = datos[sup - 1];\n                datos[sup - 1] = tmp;\n                inf++;\n                sup--;\n            }\n        }\n        int mitad = datos.length / 2;\n        if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n            mediana1(datos, a, sup);\n        if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n            mediana1(datos, inf, z);\n    }\n\n    private void mediana2(long[] datos, int a, int z) {\n        while (a &lt; z) {\n            long pivote = datos[(a + z) / 2];\n            int inf = a;\n            int sup = z;\n            while (inf &lt; sup) {\n                while (datos[inf] &lt; pivote)\n                    inf++;\n                while (pivote &lt; datos[sup - 1])\n                    sup--;\n                if (inf &lt; sup) {\n                    long tmp = datos[inf];\n                    datos[inf] = datos[sup - 1];\n                    datos[sup - 1] = tmp;\n                    inf++;\n                    sup--;\n                }\n            }\n            int mitad = datos.length / 2;\n            if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n                z = sup;\n            else if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n                a = inf;\n            else\n                return;\n        }\n    }\n}\n</code></pre> <p>Complejidad:</p> <ul> <li> <p>Caso peor: el comportamiento es equivalente a quicksort cuando siempre se elige un pivote p\u00e9simo. La partici\u00f3n genera tama\u00f1os \\(1\\) y \\(n-1\\), por lo que el coste es:   $\\(n + (n-1) + (n-2) + \\dots + 1 = O(n^2)\\)$</p> </li> <li> <p>Caso medio: cada paso divide el array aproximadamente por la mitad, y solo se sigue por la parte donde est\u00e1 la mediana:   $\\(n + \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} + \\dots = 2n = O(n)\\)$</p> </li> </ul> <p>Por tanto: - Caso peor: \\(O(n^2)\\) - Caso medio: \\(O(n)\\) ````</p>"},{"location":"exams/2012/extra/#ejercicio-2","title":"Ejercicio 2","text":""},{"location":"exams/2012/extra/#ejercicio-3","title":"Ejercicio 3","text":""},{"location":"exams/2012/extra01/","title":"Extra01","text":"<p>Se pide escribir un algoritmo para extraer la mediana de los valores de un array. Si un array de \\(N\\) datos est\u00e1 ordenado, la mediana es el valor del medio, \\(\\text{array}[N/2]\\).</p> <p>El objetivo es preparar un m\u00e9todo:</p> <pre><code>public long mediana(long[] datos)\n</code></pre> <p>que devuelve la mediana del array que se le pasa.</p> <p>Debe partir del algoritmo de quicksort y modificarlo de forma que, cuando se separan los datos en dos partes, solo se siga procesando la parte que contiene la mediana, sin ordenar la otra.</p> <p>Se pide:</p> <ol> <li>escribir el algoritmo de forma recursiva.</li> <li>escribirlo de forma iterativa.</li> <li>calcular la complejidad razonando el por qu\u00e9.</li> </ol> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\n````\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana1(long[] datos, int a, int z) {\n        long pivote = datos[(a + z) / 2];\n        int inf = a;\n        int sup = z;\n        while (inf &lt; sup) {\n            while (datos[inf] &lt; pivote)\n                inf++;\n            while (pivote &lt; datos[sup - 1])\n                sup--;\n            if (inf &lt; sup) {\n                long tmp = datos[inf];\n                datos[inf] = datos[sup - 1];\n                datos[sup - 1] = tmp;\n                inf++;\n                sup--;\n            }\n        }\n        int mitad = datos.length / 2;\n        if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n            mediana1(datos, a, sup);\n        if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n            mediana1(datos, inf, z);\n    }\n\n    private void mediana2(long[] datos, int a, int z) {\n        while (a &lt; z) {\n            long pivote = datos[(a + z) / 2];\n            int inf = a;\n            int sup = z;\n            while (inf &lt; sup) {\n                while (datos[inf] &lt; pivote)\n                    inf++;\n                while (pivote &lt; datos[sup - 1])\n                    sup--;\n                if (inf &lt; sup) {\n                    long tmp = datos[inf];\n                    datos[inf] = datos[sup - 1];\n                    datos[sup - 1] = tmp;\n                    inf++;\n                    sup--;\n                }\n            }\n            int mitad = datos.length / 2;\n            if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n                z = sup;\n            else if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n                a = inf;\n            else\n                return;\n        }\n    }\n}\n</code></pre> <p>Complejidad:</p> <ul> <li> <p>Caso peor: el comportamiento es equivalente a quicksort cuando siempre se elige un pivote p\u00e9simo. La partici\u00f3n genera tama\u00f1os \\(1\\) y \\(n-1\\), por lo que el coste es:   $\\(n + (n-1) + (n-2) + \\dots + 1 = O(n^2)\\)$</p> </li> <li> <p>Caso medio: cada paso divide el array aproximadamente por la mitad, y solo se sigue por la parte donde est\u00e1 la mediana:   $\\(n + \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} + \\dots = 2n = O(n)\\)$</p> </li> </ul> <p>Por tanto: - Caso peor: \\(O(n^2)\\) - Caso medio: \\(O(n)\\) ````</p>","tags":["android"]},{"location":"exams/2012/p1/","title":"Examen 2012 \u2014 Parcial 1","text":""},{"location":"exams/2012/p1/#problema-1","title":"Problema 1","text":"<p>A continuaci\u00f3n se describe el m\u00e9todo cuantasVeces de la clase P1. No programe la clase P1. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo cuantasVeces. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo cuantasVeces. . Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo cuantasVeces invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p>"},{"location":"exams/2012/p1/#problema-2","title":"Problema 2","text":""},{"location":"exams/2012/p1/#problema-2-5-puntos","title":"Problema 2 (5 puntos)","text":"<p>Dado el siguiente algoritmo de ordenaci\u00f3n:</p> <pre><code>public void sort(long[] datos) {\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n            datos[j] = datos[j - 1];\n            j--;\n        }\n        datos[j] = x;\n    }\n}\n</code></pre>"},{"location":"exams/2012/p1/#05-puntos-indique-el-nombre-del-algoritmo","title":"(0.5 puntos) Indique el nombre del algoritmo","text":"Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00f3n por inserci\u00f3n.</p>"},{"location":"exams/2012/p1/#3-puntos-indique-que-cambios-haria-en-el-codigo-indicando-el-numero-de-linea-para-conseguir-que-el-metodo-devolviera-el-numero-de-veces-que-compara-dos-elementos-del-array","title":"(3 puntos) Indique qu\u00e9 cambios har\u00eda en el c\u00f3digo, indicando el n\u00famero de l\u00ednea, para conseguir que el m\u00e9todo devolviera el n\u00famero de veces que compara dos elementos del array.","text":"Mostrar soluci\u00f3n <p>La comparaci\u00f3n se efect\u00faa al comprobar la condici\u00f3n del bucle en la l\u00ednea <code>5</code>. El cuerpo del bucle se ejecuta si <code>j &gt; 0</code> y adem\u00e1s <code>x &lt; datos[j - 1]</code>. Por tanto, en ese caso se ha efectuado una comparaci\u00f3n entre <code>x</code> y un elemento del array.</p> <p>Sin embargo, si el bucle no se ejecuta puede ser por dos causas:</p> <ol> <li><code>j == 0</code>, en cuyo caso no se llega a efectuar la comparaci\u00f3n, ya que el operador <code>&amp;&amp;</code> no eval\u00faa el segundo t\u00e9rmino.  </li> <li><code>j &gt; 0</code> y <code>x &gt;= datos[j - 1]</code>, en cuyo caso s\u00ed se efect\u00faa la comparaci\u00f3n.</li> </ol> <p>Para contar correctamente las comparaciones, hay que desdoblar la condici\u00f3n del bucle. Una forma de hacerlo es:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                break;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <p>L\u00edneas modificadas:</p> <ul> <li>L\u00ednea 1 sustituida por:</li> </ul> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n</code></pre> <ul> <li>L\u00edneas 5\u20138 sustituidas por:</li> </ul> <pre><code>while (j &gt; 0) {\n    ++numeroComparaciones;\n    if (x &lt; datos[j - 1]) {\n        datos[j] = datos[j - 1];\n        j--;\n    } else {\n        break;\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s de la l\u00ednea 10 se a\u00f1ade:</li> </ul> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00f3n alternativa con una variable auxiliar:</p> <pre><code>public int sort2(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        boolean menor = true;\n        while (j &gt; 0 &amp;&amp; menor) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                menor = false;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre>"},{"location":"exams/2012/p1/#15-puntos-programe-una-prueba-en-junit3-de-la-modificacion-realizada-en-el-apartado-b-para-el-caso-3-1-2","title":"(1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00f3n realizada en el apartado b), para el caso <code>{3, 1, 2}</code>.","text":"Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es:</p> <pre><code>public void test() {\n    long[] datos = {3, 1, 2};\n    P2 algoritmo = new P2();\n    assertEquals(3, algoritmo.sort(datos));\n}\n</code></pre>"},{"location":"exams/2012/p1_ex01/","title":"P1 ex01","text":"<p>A continuaci\u00f3n se describe el m\u00e9todo cuantasVeces de la clase P1. No programe la clase P1. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo cuantasVeces. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo cuantasVeces. . Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo cuantasVeces invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/","title":"Problema 2 (5 puntos)","text":"<p>Dado el siguiente algoritmo de ordenaci\u00f3n:</p> <pre><code>public void sort(long[] datos) {\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n            datos[j] = datos[j - 1];\n            j--;\n        }\n        datos[j] = x;\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/#05-puntos-indique-el-nombre-del-algoritmo","title":"(0.5 puntos) Indique el nombre del algoritmo","text":"Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00f3n por inserci\u00f3n.</p>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/#3-puntos-indique-que-cambios-haria-en-el-codigo-indicando-el-numero-de-linea-para-conseguir-que-el-metodo-devolviera-el-numero-de-veces-que-compara-dos-elementos-del-array","title":"(3 puntos) Indique qu\u00e9 cambios har\u00eda en el c\u00f3digo, indicando el n\u00famero de l\u00ednea, para conseguir que el m\u00e9todo devolviera el n\u00famero de veces que compara dos elementos del array.","text":"Mostrar soluci\u00f3n <p>La comparaci\u00f3n se efect\u00faa al comprobar la condici\u00f3n del bucle en la l\u00ednea <code>5</code>. El cuerpo del bucle se ejecuta si <code>j &gt; 0</code> y adem\u00e1s <code>x &lt; datos[j - 1]</code>. Por tanto, en ese caso se ha efectuado una comparaci\u00f3n entre <code>x</code> y un elemento del array.</p> <p>Sin embargo, si el bucle no se ejecuta puede ser por dos causas:</p> <ol> <li><code>j == 0</code>, en cuyo caso no se llega a efectuar la comparaci\u00f3n, ya que el operador <code>&amp;&amp;</code> no eval\u00faa el segundo t\u00e9rmino.  </li> <li><code>j &gt; 0</code> y <code>x &gt;= datos[j - 1]</code>, en cuyo caso s\u00ed se efect\u00faa la comparaci\u00f3n.</li> </ol> <p>Para contar correctamente las comparaciones, hay que desdoblar la condici\u00f3n del bucle. Una forma de hacerlo es:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                break;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <p>L\u00edneas modificadas:</p> <ul> <li>L\u00ednea 1 sustituida por:</li> </ul> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n</code></pre> <ul> <li>L\u00edneas 5\u20138 sustituidas por:</li> </ul> <pre><code>while (j &gt; 0) {\n    ++numeroComparaciones;\n    if (x &lt; datos[j - 1]) {\n        datos[j] = datos[j - 1];\n        j--;\n    } else {\n        break;\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s de la l\u00ednea 10 se a\u00f1ade:</li> </ul> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00f3n alternativa con una variable auxiliar:</p> <pre><code>public int sort2(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        boolean menor = true;\n        while (j &gt; 0 &amp;&amp; menor) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                menor = false;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/#15-puntos-programe-una-prueba-en-junit3-de-la-modificacion-realizada-en-el-apartado-b-para-el-caso-3-1-2","title":"(1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00f3n realizada en el apartado b), para el caso <code>{3, 1, 2}</code>.","text":"Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es:</p> <pre><code>public void test() {\n    long[] datos = {3, 1, 2};\n    P2 algoritmo = new P2();\n    assertEquals(3, algoritmo.sort(datos));\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p2/","title":"Examen 2012 \u2014 Parcial 2","text":""},{"location":"exams/2012/p2/#problema-1","title":"Problema 1","text":""},{"location":"exams/2012/p2/#a-2-puntos","title":"A. (2 puntos)","text":"<p>Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads). <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre></p> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase Swap1 pueden utilizar simult\u00e1neamente la variable aux al invocar el m\u00e9todo swap. Por tanto, swap deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a aux.</p> <p>Por el contrario, en Swap2 la variable aux es local al m\u00e9todo swap, y cada hebra que lo invoca usa su propia copia de aux. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p>"},{"location":"exams/2012/p2/#problema-2","title":"Problema 2","text":""},{"location":"exams/2012/p2/#a-4-puntos","title":"A. (4 puntos)","text":"<p>Escriba una clase con un contador interno, que se incrementa cada vez que se invoca el m\u00e9todo <code>siguiente()</code>. La clase debe poderse utilizar en un programa concurrente. Adem\u00e1s, la clase proporciona otros dos m\u00e9todos, <code>esperarPar()</code> y <code>esperarImpar()</code>, que hacen que la hebra (thread) que los invoca se quede bloqueada hasta que el valor del contador sea par o impar, respectivamente.</p> <p>Se supone que el intervalo entre dos invocaciones consecutivas de <code>siguiente()</code> es suficiente para que todas las hebras que estuvieran bloqueadas puedan continuar.</p> <p>El esquema de la clase es el siguiente:</p> <pre><code>public class Secuenciador  {\n    private int numero = 0;\n\n    public int siguiente() {...}\n    // devuelve 1 la primera vez que se invoca, 2 la segunda, etc.\n\n    public void esperarPar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea par\n\n    public void esperarImpar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea impar\n}\n</code></pre> Mostrar soluci\u00f3n <p>Los m\u00e9todos deben ser todos sincronizados. Adem\u00e1s, se deben incluir esperas condicionales en <code>esperarPar</code> y <code>esperarImpar</code>. Como el \u00fanico m\u00e9todo que modifica el valor del contador es <code>siguiente</code>, el aviso (<code>notifyAll</code>) para que las hebras bloqueadas vuelvan a comprobar la condici\u00f3n debe estar en este m\u00e9todo.</p> <p>Una posible implementaci\u00f3n es:</p> <pre><code>public class Secuenciador {\n    private int numero = 0;\n\n    public synchronized int siguiente() {\n        numero++;\n        notifyAll();\n        return numero;\n    }\n\n    public synchronized void esperarPar() {\n        while (numero % 2 != 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n\n    public synchronized void esperarImpar() {\n        while (numero % 2 == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2012/p2/#problema-3","title":"Problema 3","text":""},{"location":"exams/2012/p2/#a-4-puntos_1","title":"A. (4 puntos)","text":"<p>Modifique la clase <code>Monitor.java</code> de la pr\u00e1ctica 1 donde se han definido una serie de celdas como zona exclusiva en la que s\u00f3lo puede haber una pieza dentro (o un marciano, o un jugador). Por ejemplo,</p> <p></p> <p>Suponga que las celdas tienen un m\u00e9todo:</p> <pre><code>public boolean isZonaExclusiva()\n</code></pre> <p>El comportamiento de las piezas del juego es as\u00ed:</p> <ul> <li> <p>Cuando un jugador intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, debe buscar otra celda.</p> </li> <li> <p>Cuando un marciano intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, espera a que se libere.</p> </li> <li> <p>Tanto marcianos como jugador, cuando salen de la zona exclusiva hacia una celda que no lo es, liberan a los marcianos que pudieran estar esperando.</p> </li> </ul> <p>Sugerencia: se recomienda disponer de un campo</p> <pre><code>private Object ocupado;\n</code></pre> <p>que se inicia a <code>null</code> y sirve para indicar qu\u00e9 objeto (jugador o marciano) est\u00e1 dentro de la zona. Sirve para comprobar si hay alguien dentro:</p> <pre><code>private boolean estaZonaOcupada() { return ocupado != null; }\n</code></pre> <p>y para saber si salen:</p> <pre><code>private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n    return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n}\n\nprivate boolean estoySaliendo(Marciano marciano, Celda celda2) {\n    return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.pract1;\npublic class MonitorExtendido extends Monitor {\n\n    private final Laberinto laberinto;\n    private Object ocupado;\n\n    public MonitorExtendido(Laberinto laberinto) {\n        super(laberinto);\n        this.laberinto = laberinto;\n    }\n\n    public synchronized void mueveJugador(Jugador jugador, Celda celda2)\n            throws JugadorComido {\n\n        if (celda2.isZonaExclusiva()) {\n            if (estaZonaOcupada() &amp;&amp; ocupado != jugador)\n                return;\n            else\n                ocupado = jugador;\n        }\n\n        if (estoySaliendo(jugador, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            throw new JugadorComido();\n        }\n\n        jugador.setCelda(celda2);\n\n        if (celda2.getTipo() == Tipo.LLAVE) {\n            laberinto.limpiaCepos();\n            notifyAll();\n        }\n    }\n\n    public synchronized void mueveMarciano(Marciano marciano, Celda celda2)\n            throws JugadorComido, InterruptedException {\n\n        if (celda2.isZonaExclusiva()) {\n            while (estaZonaOcupada() &amp;&amp; ocupado != marciano)\n                wait();\n            ocupado = marciano;\n        }\n\n        if (estoySaliendo(marciano, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            return;\n        }\n\n        if (celda2.getEstado() == Estado.JUGADOR) {\n            throw new JugadorComido();\n        }\n\n        marciano.setCelda(celda2);\n\n        while (celda2.getTipo() == Tipo.CEPO) {\n            wait();\n        }\n    }\n\n    private boolean estaZonaOcupada() {\n        return ocupado != null;\n    }\n\n    private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n        return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n    }\n\n    private boolean estoySaliendo(Marciano marciano, Celda celda2) {\n        return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n    }\n}\n</code></pre></p>"},{"location":"exams/2012/p2_ex01/","title":"P2 ex01","text":"","tags":["complejidad"]},{"location":"exams/2012/p2_ex01/#a-2-puntos","title":"A. (2 puntos)","text":"<p>Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads). <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre></p> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase Swap1 pueden utilizar simult\u00e1neamente la variable aux al invocar el m\u00e9todo swap. Por tanto, swap deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a aux.</p> <p>Por el contrario, en Swap2 la variable aux es local al m\u00e9todo swap, y cada hebra que lo invoca usa su propia copia de aux. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p>","tags":["complejidad"]},{"location":"exams/2012/p2_ex02/","title":"P2 ex02","text":"","tags":["complejidad"]},{"location":"exams/2012/p2_ex02/#a-4-puntos","title":"A. (4 puntos)","text":"<p>Escriba una clase con un contador interno, que se incrementa cada vez que se invoca el m\u00e9todo <code>siguiente()</code>. La clase debe poderse utilizar en un programa concurrente. Adem\u00e1s, la clase proporciona otros dos m\u00e9todos, <code>esperarPar()</code> y <code>esperarImpar()</code>, que hacen que la hebra (thread) que los invoca se quede bloqueada hasta que el valor del contador sea par o impar, respectivamente.</p> <p>Se supone que el intervalo entre dos invocaciones consecutivas de <code>siguiente()</code> es suficiente para que todas las hebras que estuvieran bloqueadas puedan continuar.</p> <p>El esquema de la clase es el siguiente:</p> <pre><code>public class Secuenciador  {\n    private int numero = 0;\n\n    public int siguiente() {...}\n    // devuelve 1 la primera vez que se invoca, 2 la segunda, etc.\n\n    public void esperarPar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea par\n\n    public void esperarImpar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea impar\n}\n</code></pre> Mostrar soluci\u00f3n <p>Los m\u00e9todos deben ser todos sincronizados. Adem\u00e1s, se deben incluir esperas condicionales en <code>esperarPar</code> y <code>esperarImpar</code>. Como el \u00fanico m\u00e9todo que modifica el valor del contador es <code>siguiente</code>, el aviso (<code>notifyAll</code>) para que las hebras bloqueadas vuelvan a comprobar la condici\u00f3n debe estar en este m\u00e9todo.</p> <p>Una posible implementaci\u00f3n es:</p> <pre><code>public class Secuenciador {\n    private int numero = 0;\n\n    public synchronized int siguiente() {\n        numero++;\n        notifyAll();\n        return numero;\n    }\n\n    public synchronized void esperarPar() {\n        while (numero % 2 != 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n\n    public synchronized void esperarImpar() {\n        while (numero % 2 == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p2_ex03/","title":"P2 ex03","text":"","tags":["complejidad"]},{"location":"exams/2012/p2_ex03/#a-4-puntos","title":"A. (4 puntos)","text":"<p>Modifique la clase <code>Monitor.java</code> de la pr\u00e1ctica 1 donde se han definido una serie de celdas como zona exclusiva en la que s\u00f3lo puede haber una pieza dentro (o un marciano, o un jugador). Por ejemplo,</p> <p></p> <p>Suponga que las celdas tienen un m\u00e9todo:</p> <pre><code>public boolean isZonaExclusiva()\n</code></pre> <p>El comportamiento de las piezas del juego es as\u00ed:</p> <ul> <li> <p>Cuando un jugador intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, debe buscar otra celda.</p> </li> <li> <p>Cuando un marciano intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, espera a que se libere.</p> </li> <li> <p>Tanto marcianos como jugador, cuando salen de la zona exclusiva hacia una celda que no lo es, liberan a los marcianos que pudieran estar esperando.</p> </li> </ul> <p>Sugerencia: se recomienda disponer de un campo</p> <pre><code>private Object ocupado;\n</code></pre> <p>que se inicia a <code>null</code> y sirve para indicar qu\u00e9 objeto (jugador o marciano) est\u00e1 dentro de la zona. Sirve para comprobar si hay alguien dentro:</p> <pre><code>private boolean estaZonaOcupada() { return ocupado != null; }\n</code></pre> <p>y para saber si salen:</p> <pre><code>private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n    return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n}\n\nprivate boolean estoySaliendo(Marciano marciano, Celda celda2) {\n    return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.pract1;\npublic class MonitorExtendido extends Monitor {\n\n    private final Laberinto laberinto;\n    private Object ocupado;\n\n    public MonitorExtendido(Laberinto laberinto) {\n        super(laberinto);\n        this.laberinto = laberinto;\n    }\n\n    public synchronized void mueveJugador(Jugador jugador, Celda celda2)\n            throws JugadorComido {\n\n        if (celda2.isZonaExclusiva()) {\n            if (estaZonaOcupada() &amp;&amp; ocupado != jugador)\n                return;\n            else\n                ocupado = jugador;\n        }\n\n        if (estoySaliendo(jugador, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            throw new JugadorComido();\n        }\n\n        jugador.setCelda(celda2);\n\n        if (celda2.getTipo() == Tipo.LLAVE) {\n            laberinto.limpiaCepos();\n            notifyAll();\n        }\n    }\n\n    public synchronized void mueveMarciano(Marciano marciano, Celda celda2)\n            throws JugadorComido, InterruptedException {\n\n        if (celda2.isZonaExclusiva()) {\n            while (estaZonaOcupada() &amp;&amp; ocupado != marciano)\n                wait();\n            ocupado = marciano;\n        }\n\n        if (estoySaliendo(marciano, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            return;\n        }\n\n        if (celda2.getEstado() == Estado.JUGADOR) {\n            throw new JugadorComido();\n        }\n\n        marciano.setCelda(celda2);\n\n        while (celda2.getTipo() == Tipo.CEPO) {\n            wait();\n        }\n    }\n\n    private boolean estaZonaOcupada() {\n        return ocupado != null;\n    }\n\n    private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n        return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n    }\n\n    private boolean estoySaliendo(Marciano marciano, Celda celda2) {\n        return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n    }\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2013/extra/","title":"Examen 2013 \u2014 Extraordinario","text":""},{"location":"exams/2013/extra/#ejercicio-1","title":"Ejercicio 1","text":"<p>La siguiente clase implementa un conjunto de enteros ordenados mediante un \u00e1rbol binario. El \u00e1rbol no contiene datos duplicados. <pre><code>public class Arbol {\n    private class Nodo {\n        int valor;\n        Nodo izq, der;\n    }\n\n    private Nodo raiz;\n    private int n; // n\u00famero de datos almacenados en el \u00e1rbol\n    ...\n    public int cuenta(int x) {...} // n\u00famero de valores &lt;= x\n    ...\n}\n</code></pre> - (a) (1,5 puntos) Escriba el m\u00e9todo <code>int cuenta(int x)</code> de forma que devuelva el n\u00famero de valores menores o iguales que <code>x</code> en el \u00e1rbol.</p> <p>Ejemplo:</p> <p>Si el \u00e1rbol contiene los valores (1,3,4,6,10,14), obtendremos  - cuenta(1) = 1  - cuenta(6) = 4  - cuenta(9) = 4</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo, utilizando un m\u00e9todo auxiliar recursivo, es la siguiente:</p> <p><pre><code>public int cuenta(int x) {\n    return cuenta(raiz, x);\n}\n\nprivate int cuenta(Nodo nodo, int x) {\n    if (nodo == null) {\n        return 0;\n    }\n\n    if (nodo.valor == x) { \n        // suma 1 y sigue buscando por la izquierda\n        return 1 + cuenta(nodo.izq, x);\n    } else if (nodo.valor &lt; x) { \n        // suma 1 y sigue buscando por los dos lados\n        return 1 + cuenta(nodo.izq, x) + cuenta(nodo.der, x);\n    } else { \n        // no suma y sigue buscando por la izquierda\n        return cuenta(nodo.izq, x);\n    }\n}\n</code></pre> El algoritmo usa la propiedad del \u00e1rbol binario de b\u00fasqueda de que todos los nodos que est\u00e1n en el sub\u00e1rbol izquierdo de uno dado tienen un valor menor que \u00e9ste. Por tanto, si se encuentra el valor <code>x</code> ya no hay que seguir buscando por su derecha. Si el valor del nodo es menor que <code>x</code>, puede haber nodos menores tanto a la izquierda como a la derecha. Por \u00faltimo, si el valor del nodo es mayor que <code>x</code>, basta con seguir contando por la izquierda, ya que los nodos que haya a la derecha ser\u00e1n tambi\u00e9n mayores que <code>x</code>.</p> <ul> <li>(b) (1,5 puntos) Calcule la complejidad del algoritmo, justificando el resultado ne</li> </ul> Mostrar soluci\u00f3n <p>Para la complejidad, observamos que se van recorriendo todos los nodos del \u00e1rbol, excepto cuando se encuentra un valor mayor que x, en cuyo caso se descarta el sub\u00e1rbol derecho.</p> <p>M\u00e1s en detalle, el m\u00e9todo cuenta tiene cuatro casos posibles. Si calculamos el n\u00famero de operaciones que se hacen cada vez que se ejecuta, tenemos - Sumas:     1) nodo == null:! T(n) = 0     2) nodo.valor == x! T(n) = 1 + T(n/2)     3) nodo.valor &lt; x! T(n) = 2 + 2T(n/2)     4) nodo.valor &gt; x! T(n) = T(n/2) - Llamadas recursivas:     1) nodo == null:! T(n) = 0     2) nodo.valor == x! T(n) = 1 + T(n/2)     3) nodo.valor &lt; x! T(n) = 1 + 2T(n/2)     4) nodo.valor &gt; x! T(n) = T(n/2) Suponiendo que el caso 3 es el m\u00e1s frecuente,     T(n) \u2248 1 + 2T(n/2) que es lineal, O(n).</p>"},{"location":"exams/2013/extra/#ejercicio-2","title":"Ejercicio 2","text":"<ul> <li>(a) (3 puntos) Escriba un monitor en Java que controle el acceso a un parking de coches. El parking tiene un n\u00famero de plazas N y dispone de dos accesos, Este y Oeste.</li> </ul> <p>Si el parking no est\u00e1 lleno, se admiten entradas por ambos accesos libremente. Si el parking est\u00e1 lleno, los coches deben esperar a que haya plazas disponibles. Cuando queda una plaza libre, el monitor debe alternar los accesos de entrada entre Este y Oeste. Cuando un coche abandona el parking, se considera irrelevante el acceso que usa para salir.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es el siguiente:</p> <pre><code>class Monitor {\n    ...\n    Monitor(int numPlazas) { ... }\n    ...\n    entraCochePorEste(...) { ... }\n    ...\n    entraCochePorOeste(...) { ... }\n    ...\n    saleCoche(...) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n correcta es: <pre><code>public class Monitor {\n\n    private int numPlazas, numCoches;\n    private boolean turnoEste, turnoOeste;\n    private int esperaEnEste, esperaEnOeste;\n\n    public Monitor(int numPlazas) {\n        this.numPlazas = numPlazas;\n        numCoches = 0;\n        turnoEste = turnoOeste = true;\n        esperaEnEste = esperaEnOeste = 0;\n    }\n\n    public synchronized void entraCochePorEste() throws InterruptedException {\n        esperaEnEste++;\n        while ((numCoches &gt;= numPlazas) || (turnoOeste &amp;&amp; (esperaEnOeste &gt; 0))) {\n            wait();\n        }\n        esperaEnEste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = false;\n            turnoOeste = true;\n        }\n    }\n\n    public synchronized void entraCochePorOeste() throws InterruptedException {\n        esperaEnOeste++;\n        while ((numCoches &gt;= numPlazas) || (turnoEste &amp;&amp; (esperaEnEste &gt; 0))) {\n            wait();\n        }\n        esperaEnOeste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = true;\n            turnoOeste = false;\n        }\n    }\n\n    public synchronized void saleCoche() {\n        numCoches--;\n        notifyAll();\n    }\n}\n</code></pre></p>"},{"location":"exams/2013/extra/#ejercicio-3","title":"Ejercicio 3","text":"<ul> <li>(a) (4 puntos) Se desea programar una aplicaci\u00f3n compuesta por tres actividades: <code>MainActivity</code> (actividad inicial), <code>ActivityA</code>, y <code>ActivityB</code>. La tarea de <code>MainActivity</code> consiste en mostrar una lista con dos opciones al usuario: lanzar y terminar.</li> </ul> <p>Si el usuario pulsa lanzar, se lanza la actividad <code>ActivityA</code>, que devuelve como resultado un c\u00f3digo que indica si la actividad ha terminado con \u00e9xito o no (<code>RESULT_OK</code> o <code>RESULT_CANCELED</code>). Si el resultado es <code>RESULT_OK</code>, se lanza la actividad <code>ActivityB</code>, sin esperar a que devuelva ning\u00fan resultado.</p> <p>Mire la soluci\u00f3n que se proporciona a continuaci\u00f3n e indique si es correcta o no. En caso de tener fallos, indique qu\u00e9 fallos hay y c\u00f3mo se corrigen.</p> <pre><code>public class MainActivity extends Activity {\n\n    public static final int LANZA_A = 0;\n    public static final int LANZA_B = 1;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        String[] acciones = {\"lanzar\", \"terminar\"};\n        setListAdapter(new ArrayAdapter&lt;String&gt;(\n                this,\n                android.R.layout.simple_list_item_1,\n                acciones));\n    }\n\n    private void lanza() {\n        Intent lanzaA = new Intent(this, ActivityA.class);\n        if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {\n            Intent lanzaB = new Intent(this, ActivityB.class);\n            startActivityForResult(lanzaB, LANZA_B);\n        }\n    }\n\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        super.onListItemClick(l, v, position, id);\n        switch (position) {\n            case 0: {\n                lanza();\n                break;\n            }\n            case 1: {\n                finish();\n                break;\n            }\n            default: { }\n        }\n    }\n\n    public static void main(String[] args) {\n        onCreate(this);\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Se indican los cambios sobre el c\u00f3digo original ```java public class MainActivity extends ~~Activity~~ ListActivity {     public static final int LANZA_A = 0;     public static final int LANZA_B = 1;</p> <pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    String[] acciones = {\"lanzar\", \"terminar\"};\n    setListAdapter(new ArrayAdapter&lt;String&gt;(\n            this,\n            android.R.layout.simple_list_item_1,\n            acciones));\n}\n\nprivate void lanza() {\n    Intent lanzaA = new Intent(this, ActivityA.class);\n    startActivityForResult(lanzaA, LANZA_A);\n    ~~if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {~~\n        ~~Intent lanzaB = new Intent(this, ActivityB.class);~~\n        ~~startActivityForResult(lanzaB, LANZA_B);~~\n    ~~}~~\n}\n\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == LANZA_A) {\n        if (resultCode == RESULT_OK) {\n            Intent lanzaB = new Intent(this, ActivityB.class);\n            startActivity(lanzaB);\n        }\n    }\n}\n\n@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    switch (position) {\n        case 0: {lanza(); break;}\n        case 1: {finish(); break;}\n        default: { }\n        }\n    }\n\n    ~~public static void main(String[] args) {~~    // Las actividades en Android siguen un ciclo de vida,\n        ~~onCreate(this);~~                         // no tienen main\n    ~~}~~\n}\n</code></pre>"},{"location":"exams/2013/extra/#ejercicio-4","title":"Ejercicio 4","text":"<p>Se desea modificar la aplicaci\u00f3n <code>Teleconote</code> de manera que la pantalla con la lista de notas (controlada por la actividad <code>ListaNotasActivity</code>) se comporte de forma que, al pinchar en una nota, si est\u00e1 cifrada, se descifre sin pedir ninguna contrase\u00f1a. Si la nota no est\u00e1 cifrada, se deja como est\u00e1.</p> <p>Obs\u00e9rvese que no hay que mostrar el contenido de la nota, s\u00f3lo descifrarla en caso necesario desde <code>ListaNotasActivity</code>.</p> <p>Puede suponer que la clase que contiene la tarea as\u00edncrona, que program\u00f3 en <code>DetalleNotaActivity</code>, est\u00e1 refactorizada como una clase de paquete, de la siguiente forma:</p> <pre><code>public class Cifrar extends AsyncTask&lt;?,?,?&gt; {\n    protected void onPreExecute() {...}\n\n    @Override\n    protected ... doInBackground(...) {...}\n\n    protected void onProgressUpdate(...) {...}\n\n    protected void onPostExecute(...) {...}\n}\n</code></pre> <p>La tarea recibe varias cadenas (el t\u00edtulo y contenido de la nota, as\u00ed como su id), comunica el n\u00famero de caracteres cifrados o descifrados, y devuelve el objeto nota con los campos <code>titulo</code> y <code>contenido</code> descifrados.</p> <ul> <li>(a) (3 puntos) Indique qu\u00e9 signatura deber\u00eda tener la clase <code>Cifrar</code>.</li> </ul> Mostrar soluci\u00f3n <p>La signatura correcta de la clase <code>Cifrar</code> es:</p> <pre><code>Cifrar&lt;String, Integer, Nota&gt;\n</code></pre> <ul> <li>(b) (7 puntos) Indique los cambios necesarios para que se ejecute la tarea de descifrado con esta modificaci\u00f3n. Tenga en cuenta que los cambios deben almacenarse en la base de datos, y que debe actualizarse la pantalla de <code>ListaNotasActivity</code>.</li> </ul> <p>NOTA: Lim\u00edtese a hacer los cambios necesarios. No es necesario volver a escribir el c\u00f3digo de <code>Cifrar</code> ni las partes de <code>ListaNotasActivity</code> que no haya que modificar.</p> Mostrar soluci\u00f3n <p>A continuaci\u00f3n se muestran \u00fanicamente los cambios necesarios para ejecutar la tarea de descifrado desde <code>ListaNotasActivity</code>. Los cambios relevantes se destacan conceptualmente.  <pre><code>@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = notasCursor;\n    c.moveToPosition(position);\n\n    Nota nota = getNota(c);\n    if ((nota != null) &amp;&amp; (nota.isCifrado())) {\n        new Cifrar().execute(\n            nota.getContenido(),\n            nota.getTitulo(),\n            nota.getCategoria(),\n            id + \"\"\n        );\n    }\n    startActivityForResult(intent, MODIFICA_NOTA);\n}\n</code></pre></p> <pre><code>private class Cifrar extends AsyncTask&lt;String, Integer, Nota&gt; {\n\n    private final String CLAVE = new String(\"miclave\");\n    private long id = -1;\n\n    // Se puede acceder a la UI\n    @Override\n    protected void onPreExecute() {\n    }\n\n    // M\u00e9todo de descifrado (no se modifica)\n    private String descifra(String texto, String clave) {\n        // C\u00f3digo existente que almacena el texto\n        // descifrado en un buffer\n        ...\n        publishProgress(i);\n        return buffer.toString();\n    }\n\n    // Ejecuci\u00f3n en segundo plano\n    @Override\n    protected Nota doInBackground(String... params) {\n        Log.i(TAG, \"doInBackground\");\n\n        String titulo = params[0];\n        String contenido = params[1];\n        String categoria = params[2];\n\n        if ((titulo == null) || (contenido == null) || (categoria == null))\n            return null;\n\n        try {\n            id = Long.parseLong(params[3]);\n        } catch (NumberFormatException e) {\n            return null;\n        }\n\n        String tituloDescifrado = descifra(titulo, CLAVE);\n        String contenidoDescifrado = descifra(contenido, CLAVE);\n\n        Nota miNota = new Nota(\n            tituloDescifrado,\n            contenidoDescifrado,\n            categoria,\n            false\n        );\n        return miNota;\n    }\n\n    // Actualizaciones de progreso en la UI\n    @Override\n    protected void onProgressUpdate(Integer... value) {\n        super.onProgressUpdate(value);\n        Log.i(TAG, \"onProgressUpdate\");\n        texto.append(\"\nEjecut\u00e1ndose...\" + value[0]);\n        // Mostrar progreso por pantalla\n    }\n\n    // Al finalizar, se actualiza la BBDD y la lista\n    @Override\n    protected void onPostExecute(Nota miNota) {\n        Log.i(TAG, \"onPostExecute, nota Cifrada\");\n        notaDbAdaptador.actualizaNota(id, miNota);\n        cursorAdapter.notifyDataSetChanged();\n        actualizaLista();\n    }\n}\n</code></pre>"},{"location":"exams/2013/extra01/","title":"Extra01","text":"<p>La siguiente clase implementa un conjunto de enteros ordenados mediante un \u00e1rbol binario. El \u00e1rbol no contiene datos duplicados. <pre><code>public class Arbol {\n    private class Nodo {\n        int valor;\n        Nodo izq, der;\n    }\n\n    private Nodo raiz;\n    private int n; // n\u00famero de datos almacenados en el \u00e1rbol\n    ...\n    public int cuenta(int x) {...} // n\u00famero de valores &lt;= x\n    ...\n}\n</code></pre> - (a) (1,5 puntos) Escriba el m\u00e9todo <code>int cuenta(int x)</code> de forma que devuelva el n\u00famero de valores menores o iguales que <code>x</code> en el \u00e1rbol.</p> <p>Ejemplo:</p> <p>Si el \u00e1rbol contiene los valores (1,3,4,6,10,14), obtendremos  - cuenta(1) = 1  - cuenta(6) = 4  - cuenta(9) = 4</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo, utilizando un m\u00e9todo auxiliar recursivo, es la siguiente:</p> <p><pre><code>public int cuenta(int x) {\n    return cuenta(raiz, x);\n}\n\nprivate int cuenta(Nodo nodo, int x) {\n    if (nodo == null) {\n        return 0;\n    }\n\n    if (nodo.valor == x) { \n        // suma 1 y sigue buscando por la izquierda\n        return 1 + cuenta(nodo.izq, x);\n    } else if (nodo.valor &lt; x) { \n        // suma 1 y sigue buscando por los dos lados\n        return 1 + cuenta(nodo.izq, x) + cuenta(nodo.der, x);\n    } else { \n        // no suma y sigue buscando por la izquierda\n        return cuenta(nodo.izq, x);\n    }\n}\n</code></pre> El algoritmo usa la propiedad del \u00e1rbol binario de b\u00fasqueda de que todos los nodos que est\u00e1n en el sub\u00e1rbol izquierdo de uno dado tienen un valor menor que \u00e9ste. Por tanto, si se encuentra el valor <code>x</code> ya no hay que seguir buscando por su derecha. Si el valor del nodo es menor que <code>x</code>, puede haber nodos menores tanto a la izquierda como a la derecha. Por \u00faltimo, si el valor del nodo es mayor que <code>x</code>, basta con seguir contando por la izquierda, ya que los nodos que haya a la derecha ser\u00e1n tambi\u00e9n mayores que <code>x</code>.</p> <ul> <li>(b) (1,5 puntos) Calcule la complejidad del algoritmo, justificando el resultado ne</li> </ul> Mostrar soluci\u00f3n <p>Para la complejidad, observamos que se van recorriendo todos los nodos del \u00e1rbol, excepto cuando se encuentra un valor mayor que x, en cuyo caso se descarta el sub\u00e1rbol derecho.</p> <p>M\u00e1s en detalle, el m\u00e9todo cuenta tiene cuatro casos posibles. Si calculamos el n\u00famero de operaciones que se hacen cada vez que se ejecuta, tenemos - Sumas:     1) nodo == null:! T(n) = 0     2) nodo.valor == x! T(n) = 1 + T(n/2)     3) nodo.valor &lt; x! T(n) = 2 + 2T(n/2)     4) nodo.valor &gt; x! T(n) = T(n/2) - Llamadas recursivas:     1) nodo == null:! T(n) = 0     2) nodo.valor == x! T(n) = 1 + T(n/2)     3) nodo.valor &lt; x! T(n) = 1 + 2T(n/2)     4) nodo.valor &gt; x! T(n) = T(n/2) Suponiendo que el caso 3 es el m\u00e1s frecuente,     T(n) \u2248 1 + 2T(n/2) que es lineal, O(n).</p>","tags":["complejidad"]},{"location":"exams/2013/extra02/","title":"Extra02","text":"<ul> <li>(a) (3 puntos) Escriba un monitor en Java que controle el acceso a un parking de coches. El parking tiene un n\u00famero de plazas N y dispone de dos accesos, Este y Oeste.</li> </ul> <p>Si el parking no est\u00e1 lleno, se admiten entradas por ambos accesos libremente. Si el parking est\u00e1 lleno, los coches deben esperar a que haya plazas disponibles. Cuando queda una plaza libre, el monitor debe alternar los accesos de entrada entre Este y Oeste. Cuando un coche abandona el parking, se considera irrelevante el acceso que usa para salir.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es el siguiente:</p> <pre><code>class Monitor {\n    ...\n    Monitor(int numPlazas) { ... }\n    ...\n    entraCochePorEste(...) { ... }\n    ...\n    entraCochePorOeste(...) { ... }\n    ...\n    saleCoche(...) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n correcta es: <pre><code>public class Monitor {\n\n    private int numPlazas, numCoches;\n    private boolean turnoEste, turnoOeste;\n    private int esperaEnEste, esperaEnOeste;\n\n    public Monitor(int numPlazas) {\n        this.numPlazas = numPlazas;\n        numCoches = 0;\n        turnoEste = turnoOeste = true;\n        esperaEnEste = esperaEnOeste = 0;\n    }\n\n    public synchronized void entraCochePorEste() throws InterruptedException {\n        esperaEnEste++;\n        while ((numCoches &gt;= numPlazas) || (turnoOeste &amp;&amp; (esperaEnOeste &gt; 0))) {\n            wait();\n        }\n        esperaEnEste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = false;\n            turnoOeste = true;\n        }\n    }\n\n    public synchronized void entraCochePorOeste() throws InterruptedException {\n        esperaEnOeste++;\n        while ((numCoches &gt;= numPlazas) || (turnoEste &amp;&amp; (esperaEnEste &gt; 0))) {\n            wait();\n        }\n        esperaEnOeste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = true;\n            turnoOeste = false;\n        }\n    }\n\n    public synchronized void saleCoche() {\n        numCoches--;\n        notifyAll();\n    }\n}\n</code></pre></p>","tags":["monitores"]},{"location":"exams/2013/extra03/","title":"Extra03","text":"<ul> <li>(a) (4 puntos) Se desea programar una aplicaci\u00f3n compuesta por tres actividades: <code>MainActivity</code> (actividad inicial), <code>ActivityA</code>, y <code>ActivityB</code>. La tarea de <code>MainActivity</code> consiste en mostrar una lista con dos opciones al usuario: lanzar y terminar.</li> </ul> <p>Si el usuario pulsa lanzar, se lanza la actividad <code>ActivityA</code>, que devuelve como resultado un c\u00f3digo que indica si la actividad ha terminado con \u00e9xito o no (<code>RESULT_OK</code> o <code>RESULT_CANCELED</code>). Si el resultado es <code>RESULT_OK</code>, se lanza la actividad <code>ActivityB</code>, sin esperar a que devuelva ning\u00fan resultado.</p> <p>Mire la soluci\u00f3n que se proporciona a continuaci\u00f3n e indique si es correcta o no. En caso de tener fallos, indique qu\u00e9 fallos hay y c\u00f3mo se corrigen.</p> <pre><code>public class MainActivity extends Activity {\n\n    public static final int LANZA_A = 0;\n    public static final int LANZA_B = 1;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        String[] acciones = {\"lanzar\", \"terminar\"};\n        setListAdapter(new ArrayAdapter&lt;String&gt;(\n                this,\n                android.R.layout.simple_list_item_1,\n                acciones));\n    }\n\n    private void lanza() {\n        Intent lanzaA = new Intent(this, ActivityA.class);\n        if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {\n            Intent lanzaB = new Intent(this, ActivityB.class);\n            startActivityForResult(lanzaB, LANZA_B);\n        }\n    }\n\n    @Override\n    public void onListItemClick(ListView l, View v, int position, long id) {\n        super.onListItemClick(l, v, position, id);\n        switch (position) {\n            case 0: {\n                lanza();\n                break;\n            }\n            case 1: {\n                finish();\n                break;\n            }\n            default: { }\n        }\n    }\n\n    public static void main(String[] args) {\n        onCreate(this);\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Se indican los cambios sobre el c\u00f3digo original ```java public class MainActivity extends ~~Activity~~ ListActivity {     public static final int LANZA_A = 0;     public static final int LANZA_B = 1;</p> <pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    String[] acciones = {\"lanzar\", \"terminar\"};\n    setListAdapter(new ArrayAdapter&lt;String&gt;(\n            this,\n            android.R.layout.simple_list_item_1,\n            acciones));\n}\n\nprivate void lanza() {\n    Intent lanzaA = new Intent(this, ActivityA.class);\n    startActivityForResult(lanzaA, LANZA_A);\n    ~~if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {~~\n        ~~Intent lanzaB = new Intent(this, ActivityB.class);~~\n        ~~startActivityForResult(lanzaB, LANZA_B);~~\n    ~~}~~\n}\n\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == LANZA_A) {\n        if (resultCode == RESULT_OK) {\n            Intent lanzaB = new Intent(this, ActivityB.class);\n            startActivity(lanzaB);\n        }\n    }\n}\n\n@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    switch (position) {\n        case 0: {lanza(); break;}\n        case 1: {finish(); break;}\n        default: { }\n        }\n    }\n\n    ~~public static void main(String[] args) {~~    // Las actividades en Android siguen un ciclo de vida,\n        ~~onCreate(this);~~                         // no tienen main\n    ~~}~~\n}\n</code></pre>","tags":["android"]},{"location":"exams/2013/extra04/","title":"Extra04","text":"<p>Se desea modificar la aplicaci\u00f3n <code>Teleconote</code> de manera que la pantalla con la lista de notas (controlada por la actividad <code>ListaNotasActivity</code>) se comporte de forma que, al pinchar en una nota, si est\u00e1 cifrada, se descifre sin pedir ninguna contrase\u00f1a. Si la nota no est\u00e1 cifrada, se deja como est\u00e1.</p> <p>Obs\u00e9rvese que no hay que mostrar el contenido de la nota, s\u00f3lo descifrarla en caso necesario desde <code>ListaNotasActivity</code>.</p> <p>Puede suponer que la clase que contiene la tarea as\u00edncrona, que program\u00f3 en <code>DetalleNotaActivity</code>, est\u00e1 refactorizada como una clase de paquete, de la siguiente forma:</p> <pre><code>public class Cifrar extends AsyncTask&lt;?,?,?&gt; {\n    protected void onPreExecute() {...}\n\n    @Override\n    protected ... doInBackground(...) {...}\n\n    protected void onProgressUpdate(...) {...}\n\n    protected void onPostExecute(...) {...}\n}\n</code></pre> <p>La tarea recibe varias cadenas (el t\u00edtulo y contenido de la nota, as\u00ed como su id), comunica el n\u00famero de caracteres cifrados o descifrados, y devuelve el objeto nota con los campos <code>titulo</code> y <code>contenido</code> descifrados.</p> <ul> <li>(a) (3 puntos) Indique qu\u00e9 signatura deber\u00eda tener la clase <code>Cifrar</code>.</li> </ul> Mostrar soluci\u00f3n <p>La signatura correcta de la clase <code>Cifrar</code> es:</p> <pre><code>Cifrar&lt;String, Integer, Nota&gt;\n</code></pre> <ul> <li>(b) (7 puntos) Indique los cambios necesarios para que se ejecute la tarea de descifrado con esta modificaci\u00f3n. Tenga en cuenta que los cambios deben almacenarse en la base de datos, y que debe actualizarse la pantalla de <code>ListaNotasActivity</code>.</li> </ul> <p>NOTA: Lim\u00edtese a hacer los cambios necesarios. No es necesario volver a escribir el c\u00f3digo de <code>Cifrar</code> ni las partes de <code>ListaNotasActivity</code> que no haya que modificar.</p> Mostrar soluci\u00f3n <p>A continuaci\u00f3n se muestran \u00fanicamente los cambios necesarios para ejecutar la tarea de descifrado desde <code>ListaNotasActivity</code>. Los cambios relevantes se destacan conceptualmente.  <pre><code>@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = notasCursor;\n    c.moveToPosition(position);\n\n    Nota nota = getNota(c);\n    if ((nota != null) &amp;&amp; (nota.isCifrado())) {\n        new Cifrar().execute(\n            nota.getContenido(),\n            nota.getTitulo(),\n            nota.getCategoria(),\n            id + \"\"\n        );\n    }\n    startActivityForResult(intent, MODIFICA_NOTA);\n}\n</code></pre></p> <pre><code>private class Cifrar extends AsyncTask&lt;String, Integer, Nota&gt; {\n\n    private final String CLAVE = new String(\"miclave\");\n    private long id = -1;\n\n    // Se puede acceder a la UI\n    @Override\n    protected void onPreExecute() {\n    }\n\n    // M\u00e9todo de descifrado (no se modifica)\n    private String descifra(String texto, String clave) {\n        // C\u00f3digo existente que almacena el texto\n        // descifrado en un buffer\n        ...\n        publishProgress(i);\n        return buffer.toString();\n    }\n\n    // Ejecuci\u00f3n en segundo plano\n    @Override\n    protected Nota doInBackground(String... params) {\n        Log.i(TAG, \"doInBackground\");\n\n        String titulo = params[0];\n        String contenido = params[1];\n        String categoria = params[2];\n\n        if ((titulo == null) || (contenido == null) || (categoria == null))\n            return null;\n\n        try {\n            id = Long.parseLong(params[3]);\n        } catch (NumberFormatException e) {\n            return null;\n        }\n\n        String tituloDescifrado = descifra(titulo, CLAVE);\n        String contenidoDescifrado = descifra(contenido, CLAVE);\n\n        Nota miNota = new Nota(\n            tituloDescifrado,\n            contenidoDescifrado,\n            categoria,\n            false\n        );\n        return miNota;\n    }\n\n    // Actualizaciones de progreso en la UI\n    @Override\n    protected void onProgressUpdate(Integer... value) {\n        super.onProgressUpdate(value);\n        Log.i(TAG, \"onProgressUpdate\");\n        texto.append(\"\nEjecut\u00e1ndose...\" + value[0]);\n        // Mostrar progreso por pantalla\n    }\n\n    // Al finalizar, se actualiza la BBDD y la lista\n    @Override\n    protected void onPostExecute(Nota miNota) {\n        Log.i(TAG, \"onPostExecute, nota Cifrada\");\n        notaDbAdaptador.actualizaNota(id, miNota);\n        cursorAdapter.notifyDataSetChanged();\n        actualizaLista();\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2013/p1/","title":"Examen 2013 \u2014 Parcial 1","text":""},{"location":"exams/2013/p1/#problema-1","title":"Problema 1","text":"<p>Tenemos arrays de datos que est\u00e1n ordenados en orden ascendente, pero con los datos desplazados una distancia \\( h \\ge 0 \\). Por ejemplo:</p> h array 0 [1, 3, 5, 7, 11, 13] 1 [13, 1, 3, 5, 7, 11] 2 [11, 13, 1, 3, 5, 7] 3 [7, 11, 13, 1, 3, 5] \u2026 \u2026 <p>Supondremos que todos los datos del array son distintos.</p> <ul> <li>(a) (1,5 puntos) Dados un array y el desplazamiento \\( h \\), desarrolle un algoritmo de complejidad O(1) que devuelva el n\u00famero mayor conociendo el array y el desplazamiento: <pre><code>int getMayor1(int[] array, int h)\n</code></pre> Demuestre que el algoritmo es efectivamente de complejidad O(1).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor1(int[] array, int h) {\n    return array[(array.length - 1 + h) % array.length];\n}\n</code></pre> El algoritmo es de complejidad O(1) porque el n\u00famero de pasos del algoritmo es independiente de n.</p> <ul> <li>(b) (1,5 puntos) Desarrolle un algoritmo de complejidad O(n) que devuelva el n\u00famero mayor conociendo el array, pero sin saber el desplazamiento: <pre><code>int getMayor2(int[] array)\n</code></pre> Demuestre que el algoritmo es de complejidad O(n)</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor2(int[] array) {\n    int mayor = Integer.MIN_VALUE;\n    for (int num : array) {\n        if (mayor &lt; num)\n            mayor = num;\n    }\n    return mayor;\n}\n</code></pre> El algoritmo es de complejidad O(n) porque es un bucle que se ejecuta n veces.</p> <ul> <li>(c) (2 puntos) Desarrolle un algoritmo de complejidad O(log n) que devuelva el n\u00famero mayor conociendo el array, pero sin conocer el desplazamiento: <pre><code>int getMayor3(int[] array)\n</code></pre></li> </ul> <p>Pista:</p> <p>Hay que usar el algoritmo del apartado a) probando con diferentes valores de h. Para un valor de h: - Sabemos que es el correcto si el n\u00famero siguiente es menor que <code>array[h]</code>. - Sabemos si hay que aumentar o disminuir h comparando <code>array[h]</code> con <code>array[0]</code>.</p> Mostrar soluci\u00f3n <p>La siguiente soluci\u00f3n utiliza un m\u00e9todo auxiliar, <code>busca</code>:</p> <p><pre><code>private static int getMayor3(int[] array) {\n    return busca(array, 0, array.length);\n    }\n\n    private static int busca(int[] array, int a, int z) {\n        if (a &gt;= z)\n            return array[a];\n        int h = (a + z) / 2;\n        int num = array[h];\n        int num_1 = array[(h + 1) % array.length];\n        if (num &gt; num_1)\n            return num;\n        if (array[0] &lt; num)\n            return busca(array, h + 1, z);\n        else\n            return busca(array, a, h);\n    }\n</code></pre> El algoritmo es de complejidad O(log n) porque es un esquema de divisi\u00f3n sucesiva. M\u00e1s desarrollado: - Al principio, h puede estar entre O y N-1 - Tras 1 paso, h puede estar entre (O y N/2) o entre (N/2 y N); es decir, hemos reducido las opciones a la mitad (N/2) - Tras k pasos, el rango es N/2<sup>k</sup>; de forma que el rango se reduce a 1 (h encontrado) cuando 1 &lt;= N/2<sup>k</sup> -&gt; k=log(N)1 &lt;= N / 2^k  \u279c  k = log\u2082(N) \u2282 O(log N)</p>"},{"location":"exams/2013/p1/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) Sean tres hebras (threads), T1, T2 y T3, que utilizan tres recursos, R1, R2 y R3.</li> </ul> <p>La hebra T1 s\u00f3lo necesita el recurso R1.  </p> <p>La hebra T2 necesita los recursos R2 y R3.  </p> <p>Por \u00faltimo, la hebra T3 requiere los tres recursos, R1, R2 y R3.</p> <p>Escriba un monitor que controle el acceso de las hebras a los recursos. Cada hebra solicita los recursos que necesita invocando un m\u00e9todo del monitor. Cuando una hebra termina de usar los recursos que necesita, lo indica para que otras hebras puedan usarlos. El monitor ha de asegurar que ning\u00fan recurso es utilizado por m\u00e1s de una hebra a la vez.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es:</p> <pre><code>class Monitor {\n    \u2026\n    \u2026 requiereR1 (\u2026) { \u2026 }\n    \u2026 requiereR2_R3 (\u2026) { \u2026 }\n    \u2026 requiereR1_R2_R3 ( \u2026) { \u2026}\n    \u2026 liberaR1(\u2026) { \u2026 }\n    \u2026 liberaR2_R3 (\u2026) { \u2026 }\n    \u2026 liberaR1_R2_R3 ( \u2026) { \u2026}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n ser\u00eda:</p> <pre><code>public class Monitor {\n    private boolean ocupadoR1 = false;\n    private boolean ocupadoR2 = false;\n    private boolean ocupadoR3 = false;\n\n    public synchronized void requiereR1 () \n               throws InterruptedException {\n        while (ocupadoR1) wait();\n        ocupadoR1 = true;\n    }\n\n    public synchronized void requiereR2_R3() \n               throws InterruptedException {\n        while (ocupadoR2 || ocupadoR3) wait();\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void requiereR1_R2_R3 () \n                   throws InterruptedException { \n        while (ocupadoR1 || ocupadoR2 || ocupadoR3) wait();\n        ocupadoR1 = true;\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void liberaR1() {\n        ocupadoR1 = false;\n        notifyAll();\n    }\n\n    public synchronized void libreraR2_R3 () {\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll();\n    }\n\n    public synchronized void liberaR1_R2_R3 () {\n        ocupadoR1 = false;\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll(); \n    }\n}\n</code></pre>"},{"location":"exams/2013/p1_ex01/","title":"P1 ex01","text":"<p>Tenemos arrays de datos que est\u00e1n ordenados en orden ascendente, pero con los datos desplazados una distancia \\( h \\ge 0 \\). Por ejemplo:</p> h array 0 [1, 3, 5, 7, 11, 13] 1 [13, 1, 3, 5, 7, 11] 2 [11, 13, 1, 3, 5, 7] 3 [7, 11, 13, 1, 3, 5] \u2026 \u2026 <p>Supondremos que todos los datos del array son distintos.</p> <ul> <li>(a) (1,5 puntos) Dados un array y el desplazamiento \\( h \\), desarrolle un algoritmo de complejidad O(1) que devuelva el n\u00famero mayor conociendo el array y el desplazamiento: <pre><code>int getMayor1(int[] array, int h)\n</code></pre> Demuestre que el algoritmo es efectivamente de complejidad O(1).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor1(int[] array, int h) {\n    return array[(array.length - 1 + h) % array.length];\n}\n</code></pre> El algoritmo es de complejidad O(1) porque el n\u00famero de pasos del algoritmo es independiente de n.</p> <ul> <li>(b) (1,5 puntos) Desarrolle un algoritmo de complejidad O(n) que devuelva el n\u00famero mayor conociendo el array, pero sin saber el desplazamiento: <pre><code>int getMayor2(int[] array)\n</code></pre> Demuestre que el algoritmo es de complejidad O(n)</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor2(int[] array) {\n    int mayor = Integer.MIN_VALUE;\n    for (int num : array) {\n        if (mayor &lt; num)\n            mayor = num;\n    }\n    return mayor;\n}\n</code></pre> El algoritmo es de complejidad O(n) porque es un bucle que se ejecuta n veces.</p> <ul> <li>(c) (2 puntos) Desarrolle un algoritmo de complejidad O(log n) que devuelva el n\u00famero mayor conociendo el array, pero sin conocer el desplazamiento: <pre><code>int getMayor3(int[] array)\n</code></pre></li> </ul> <p>Pista:</p> <p>Hay que usar el algoritmo del apartado a) probando con diferentes valores de h. Para un valor de h: - Sabemos que es el correcto si el n\u00famero siguiente es menor que <code>array[h]</code>. - Sabemos si hay que aumentar o disminuir h comparando <code>array[h]</code> con <code>array[0]</code>.</p> Mostrar soluci\u00f3n <p>La siguiente soluci\u00f3n utiliza un m\u00e9todo auxiliar, <code>busca</code>:</p> <p><pre><code>private static int getMayor3(int[] array) {\n    return busca(array, 0, array.length);\n    }\n\n    private static int busca(int[] array, int a, int z) {\n        if (a &gt;= z)\n            return array[a];\n        int h = (a + z) / 2;\n        int num = array[h];\n        int num_1 = array[(h + 1) % array.length];\n        if (num &gt; num_1)\n            return num;\n        if (array[0] &lt; num)\n            return busca(array, h + 1, z);\n        else\n            return busca(array, a, h);\n    }\n</code></pre> El algoritmo es de complejidad O(log n) porque es un esquema de divisi\u00f3n sucesiva. M\u00e1s desarrollado: - Al principio, h puede estar entre O y N-1 - Tras 1 paso, h puede estar entre (O y N/2) o entre (N/2 y N); es decir, hemos reducido las opciones a la mitad (N/2) - Tras k pasos, el rango es N/2<sup>k</sup>; de forma que el rango se reduce a 1 (h encontrado) cuando 1 &lt;= N/2<sup>k</sup> -&gt; k=log(N)1 &lt;= N / 2^k  \u279c  k = log\u2082(N) \u2282 O(log N)</p>","tags":["complejidad"]},{"location":"exams/2013/p1_ex02/","title":"P1 ex02","text":"<ul> <li>(a) (5 puntos) Sean tres hebras (threads), T1, T2 y T3, que utilizan tres recursos, R1, R2 y R3.</li> </ul> <p>La hebra T1 s\u00f3lo necesita el recurso R1.  </p> <p>La hebra T2 necesita los recursos R2 y R3.  </p> <p>Por \u00faltimo, la hebra T3 requiere los tres recursos, R1, R2 y R3.</p> <p>Escriba un monitor que controle el acceso de las hebras a los recursos. Cada hebra solicita los recursos que necesita invocando un m\u00e9todo del monitor. Cuando una hebra termina de usar los recursos que necesita, lo indica para que otras hebras puedan usarlos. El monitor ha de asegurar que ning\u00fan recurso es utilizado por m\u00e1s de una hebra a la vez.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es:</p> <pre><code>class Monitor {\n    \u2026\n    \u2026 requiereR1 (\u2026) { \u2026 }\n    \u2026 requiereR2_R3 (\u2026) { \u2026 }\n    \u2026 requiereR1_R2_R3 ( \u2026) { \u2026}\n    \u2026 liberaR1(\u2026) { \u2026 }\n    \u2026 liberaR2_R3 (\u2026) { \u2026 }\n    \u2026 liberaR1_R2_R3 ( \u2026) { \u2026}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n ser\u00eda:</p> <pre><code>public class Monitor {\n    private boolean ocupadoR1 = false;\n    private boolean ocupadoR2 = false;\n    private boolean ocupadoR3 = false;\n\n    public synchronized void requiereR1 () \n               throws InterruptedException {\n        while (ocupadoR1) wait();\n        ocupadoR1 = true;\n    }\n\n    public synchronized void requiereR2_R3() \n               throws InterruptedException {\n        while (ocupadoR2 || ocupadoR3) wait();\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void requiereR1_R2_R3 () \n                   throws InterruptedException { \n        while (ocupadoR1 || ocupadoR2 || ocupadoR3) wait();\n        ocupadoR1 = true;\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void liberaR1() {\n        ocupadoR1 = false;\n        notifyAll();\n    }\n\n    public synchronized void libreraR2_R3 () {\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll();\n    }\n\n    public synchronized void liberaR1_R2_R3 () {\n        ocupadoR1 = false;\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll(); \n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2013/p1r/","title":"Examen 2013 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2013/p1r/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o N\u00d7N, desarrolle un algoritmo de orden O(N\u00b2) para averiguar si un valor K est\u00e1 presente o no en la matriz. Razone el orden de complejidad del algoritmo desarrollado.</li> </ul> <p>Ejemplo <pre><code>84   32  -13   33   13\n7    82   93   89  -23\n31  -24  -28   57  -93\n86  -71  -44   75  -12\n-10 -18   53   24   78\n</code></pre> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre></p> Mostrar soluci\u00f3n <p><pre><code>boolean busca1(int[][] matriz, int m) {\n    for (int x = 0; x &lt; matriz.length; x++) {\n        for (int y = 0; y &lt; matriz[x].length; y++) {\n            if (matriz[x][y] == m)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre> En cuanto a la complejidad, es un bucle que hace N vueltas, y en cada una hay otro bucle anidado que hace otras N vueltas. Por tanto, en total es de O(N\u00b2).</p> <ul> <li>(b) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o N\u00d7N que est\u00e1 ordenada de forma que:</li> </ul> <p>[ \\forall i, j:; matriz[i][j] \\le matriz[i+1][j] ;\\wedge; matriz[i][j] \\le matriz[i][j+1] ]</p> <p>(se cumple que cada elemento es menor o igual que el de abajo y el de la derecha).</p> <p>Se propone el siguiente algoritmo de b\u00fasqueda de un dato <code>m</code>:</p> <pre><code>private static boolean busca2(int[][] matriz, int m) {\n    int xa = 0;\n    int xz = matriz.length;\n    int ya = 0;\n    int yz = matriz[0].length;\n    return busca2(matriz, xa, xz, ya, yz, m);\n}\n\nprivate static boolean busca2(int[][] matriz,\n        int xa, int xz, int ya, int yz, int m) {\n\n    if (xa &gt;= xz || ya &gt;= yz)\n        return false;\n\n    int xm = (xa + xz) / 2;\n    int ym = (ya + yz) / 2;\n    int ref = matriz[xm][ym];\n\n    if (ref == m)\n        return true;\n\n    if (ref &lt; m)\n        return busca2(matriz, xm + 1, xz, ya, yz, m)\n            || busca2(matriz, xa, xz, ym + 1, yz, m);\n    else\n        return busca2(matriz, xa, xm, ya, yz, m)\n            || busca2(matriz, xa, xz, ya, ym, m);\n}\n</code></pre> <p>Se pide calcular la complejidad temporal del algoritmo, razonando el resultado.</p> <p>Ejemplo:</p> <pre><code>-93  -71  -28  -18    7\n-44  -24  -13   13   33\n-23  -12   24   53   78\n-10   31   57   82   86\n 32   75   84   89   93\n</code></pre> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre> Mostrar soluci\u00f3n <p>Un problema de tama\u00f1o  [ X = N^2 ] se parte en 2 subproblemas de tama\u00f1o (X/2). Esto hace k veces, siendo [ \\frac{X}{2^k} = 1 ;\\Rightarrow; k = \\log_2(X) ]</p> <p>En la primera ronda hay 1 comparaci\u00f3n * En la segunda ronda 2 comparaciones * En la tercera ronda 4 comparaciones * (\\dots) * En la k-\u00e9sima ronda, (2^k) comparaciones</p> <p>El n\u00famero total de comparaciones es la suma [ 1 + 2 + 2^2 + 2^3 + \\dots + 2^k ]</p> <p>Sustituyendo  [ 2 \\cdot 2^{\\log_2(X)} = 2X ]</p> <p>Como [ X = N^2 ] la soluci\u00f3n al problema cuesta [ 2N^2 ] comparaciones, siendo de la familia O(N^2)</p>"},{"location":"exams/2013/p1r/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) Desarrolle un monitor en Java que gestione el despegue de aviones y avionetas en un aeropuerto como se especifica a continuaci\u00f3n:</li> </ul> <p>Los aviones, al despegar, generan turbulencias, por lo que entre dos despegues consecutivos debe transcurrir un intervalo m\u00ednimo de tiempo:</p> <ul> <li>3 minutos despu\u00e9s del despegue de un avi\u00f3n.</li> <li>2 minutos despu\u00e9s del despegue de una avioneta.</li> </ul> <p>Adem\u00e1s se debe impedir que despeguen consecutivamente dos avionetas si hay aviones esperando. No hay restricciones de este tipo respecto a los aviones (pueden despegar consecutivamente).</p> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorDespegue {\n    ...\n\n    // Lo invoca un avi\u00f3n cuando quiere despegar\n    ... despegarAvion() {...}\n\n    // Lo invoca una avioneta cuando quiere despegar\n    ... despegarAvioneta() {...}\n\n    // Lo invoca el temporizador para indicar que\n    // ha transcurrido el intervalo m\u00ednimo desde\n    // el despegue anterior\n    ... autorizarDespegue() {...}\n    ...\n}\n</code></pre> <p>Para gestionar el intervalo de tiempo entre despegues, se dispone de una clase <code>Temporizador</code>, cuya interfaz se muestra a continuaci\u00f3n. El m\u00e9todo <code>iniciarTemporizador</code> arranca un temporizador que deja pasar un cierto tiempo. Cuando el tiempo expira, se invoca el m\u00e9todo <code>autorizarDespegue</code> del objeto <code>GestorDespegue</code> que se pasa en el constructor. No es necesario desarrollar esta clase.</p> <pre><code>public class Temporizador {\n    public Temporizador(GestorDespegue gestor) { ... }\n    public void iniciarTemporizador(int minutos) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n posible al problema del monitor de gesti\u00f3n de despegues es la siguiente:</p> <pre><code>public class GestorDespegue {\n\n    private boolean pistaOcupada = true;\n    private int nAvionesEsperando = 0;\n\n    private final int tiempoAvion = 3;\n    private final int tiempoAvioneta = 2;\n\n    private boolean anteriorAvioneta = false;\n\n    private Temporizador unTemporizador = new Temporizador(this);\n\n    // Invocado por un avi\u00f3n cuando quiere despegar\n    public synchronized void despegarAvion() throws InterruptedException {\n        nAvionesEsperando++;\n        while (pistaOcupada)\n            wait();\n\n        nAvionesEsperando--;\n        anteriorAvioneta = false;\n\n        unTemporizador.iniciarTemporizador(tiempoAvion);\n        pistaOcupada = true;\n    }\n\n    // Invocado por una avioneta cuando quiere despegar\n    public synchronized void despegarAvioneta() throws InterruptedException {\n        while (pistaOcupada || (nAvionesEsperando &gt; 0 &amp;&amp; anteriorAvioneta))\n            wait();\n\n        anteriorAvioneta = true;\n        unTemporizador.iniciarTemporizador(tiempoAvioneta);\n        pistaOcupada = true;\n    }\n\n    // Invocado por el temporizador cuando finaliza el intervalo m\u00ednimo\n    public synchronized void finTemporizador() throws InterruptedException {\n        pistaOcupada = false;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2013/p1r_ex01/","title":"P1r ex01","text":"<ul> <li>(a) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o N\u00d7N, desarrolle un algoritmo de orden O(N\u00b2) para averiguar si un valor K est\u00e1 presente o no en la matriz. Razone el orden de complejidad del algoritmo desarrollado.</li> </ul> <p>Ejemplo <pre><code>84   32  -13   33   13\n7    82   93   89  -23\n31  -24  -28   57  -93\n86  -71  -44   75  -12\n-10 -18   53   24   78\n</code></pre> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre></p> Mostrar soluci\u00f3n <p><pre><code>boolean busca1(int[][] matriz, int m) {\n    for (int x = 0; x &lt; matriz.length; x++) {\n        for (int y = 0; y &lt; matriz[x].length; y++) {\n            if (matriz[x][y] == m)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre> En cuanto a la complejidad, es un bucle que hace N vueltas, y en cada una hay otro bucle anidado que hace otras N vueltas. Por tanto, en total es de O(N\u00b2).</p> <ul> <li>(b) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o N\u00d7N que est\u00e1 ordenada de forma que:</li> </ul> <p>[ \\forall i, j:; matriz[i][j] \\le matriz[i+1][j] ;\\wedge; matriz[i][j] \\le matriz[i][j+1] ]</p> <p>(se cumple que cada elemento es menor o igual que el de abajo y el de la derecha).</p> <p>Se propone el siguiente algoritmo de b\u00fasqueda de un dato <code>m</code>:</p> <pre><code>private static boolean busca2(int[][] matriz, int m) {\n    int xa = 0;\n    int xz = matriz.length;\n    int ya = 0;\n    int yz = matriz[0].length;\n    return busca2(matriz, xa, xz, ya, yz, m);\n}\n\nprivate static boolean busca2(int[][] matriz,\n        int xa, int xz, int ya, int yz, int m) {\n\n    if (xa &gt;= xz || ya &gt;= yz)\n        return false;\n\n    int xm = (xa + xz) / 2;\n    int ym = (ya + yz) / 2;\n    int ref = matriz[xm][ym];\n\n    if (ref == m)\n        return true;\n\n    if (ref &lt; m)\n        return busca2(matriz, xm + 1, xz, ya, yz, m)\n            || busca2(matriz, xa, xz, ym + 1, yz, m);\n    else\n        return busca2(matriz, xa, xm, ya, yz, m)\n            || busca2(matriz, xa, xz, ya, ym, m);\n}\n</code></pre> <p>Se pide calcular la complejidad temporal del algoritmo, razonando el resultado.</p> <p>Ejemplo:</p> <pre><code>-93  -71  -28  -18    7\n-44  -24  -13   13   33\n-23  -12   24   53   78\n-10   31   57   82   86\n 32   75   84   89   93\n</code></pre> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre> Mostrar soluci\u00f3n <p>Un problema de tama\u00f1o  [ X = N^2 ] se parte en 2 subproblemas de tama\u00f1o (X/2). Esto hace k veces, siendo [ \\frac{X}{2^k} = 1 ;\\Rightarrow; k = \\log_2(X) ]</p> <p>En la primera ronda hay 1 comparaci\u00f3n * En la segunda ronda 2 comparaciones * En la tercera ronda 4 comparaciones * (\\dots) * En la k-\u00e9sima ronda, (2^k) comparaciones</p> <p>El n\u00famero total de comparaciones es la suma [ 1 + 2 + 2^2 + 2^3 + \\dots + 2^k ]</p> <p>Sustituyendo  [ 2 \\cdot 2^{\\log_2(X)} = 2X ]</p> <p>Como [ X = N^2 ] la soluci\u00f3n al problema cuesta [ 2N^2 ] comparaciones, siendo de la familia O(N^2)</p>","tags":["complejidad"]},{"location":"exams/2013/p1r_ex02/","title":"P1r ex02","text":"<ul> <li>(a) (5 puntos) Desarrolle un monitor en Java que gestione el despegue de aviones y avionetas en un aeropuerto como se especifica a continuaci\u00f3n:</li> </ul> <p>Los aviones, al despegar, generan turbulencias, por lo que entre dos despegues consecutivos debe transcurrir un intervalo m\u00ednimo de tiempo:</p> <ul> <li>3 minutos despu\u00e9s del despegue de un avi\u00f3n.</li> <li>2 minutos despu\u00e9s del despegue de una avioneta.</li> </ul> <p>Adem\u00e1s se debe impedir que despeguen consecutivamente dos avionetas si hay aviones esperando. No hay restricciones de este tipo respecto a los aviones (pueden despegar consecutivamente).</p> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorDespegue {\n    ...\n\n    // Lo invoca un avi\u00f3n cuando quiere despegar\n    ... despegarAvion() {...}\n\n    // Lo invoca una avioneta cuando quiere despegar\n    ... despegarAvioneta() {...}\n\n    // Lo invoca el temporizador para indicar que\n    // ha transcurrido el intervalo m\u00ednimo desde\n    // el despegue anterior\n    ... autorizarDespegue() {...}\n    ...\n}\n</code></pre> <p>Para gestionar el intervalo de tiempo entre despegues, se dispone de una clase <code>Temporizador</code>, cuya interfaz se muestra a continuaci\u00f3n. El m\u00e9todo <code>iniciarTemporizador</code> arranca un temporizador que deja pasar un cierto tiempo. Cuando el tiempo expira, se invoca el m\u00e9todo <code>autorizarDespegue</code> del objeto <code>GestorDespegue</code> que se pasa en el constructor. No es necesario desarrollar esta clase.</p> <pre><code>public class Temporizador {\n    public Temporizador(GestorDespegue gestor) { ... }\n    public void iniciarTemporizador(int minutos) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n posible al problema del monitor de gesti\u00f3n de despegues es la siguiente:</p> <pre><code>public class GestorDespegue {\n\n    private boolean pistaOcupada = true;\n    private int nAvionesEsperando = 0;\n\n    private final int tiempoAvion = 3;\n    private final int tiempoAvioneta = 2;\n\n    private boolean anteriorAvioneta = false;\n\n    private Temporizador unTemporizador = new Temporizador(this);\n\n    // Invocado por un avi\u00f3n cuando quiere despegar\n    public synchronized void despegarAvion() throws InterruptedException {\n        nAvionesEsperando++;\n        while (pistaOcupada)\n            wait();\n\n        nAvionesEsperando--;\n        anteriorAvioneta = false;\n\n        unTemporizador.iniciarTemporizador(tiempoAvion);\n        pistaOcupada = true;\n    }\n\n    // Invocado por una avioneta cuando quiere despegar\n    public synchronized void despegarAvioneta() throws InterruptedException {\n        while (pistaOcupada || (nAvionesEsperando &gt; 0 &amp;&amp; anteriorAvioneta))\n            wait();\n\n        anteriorAvioneta = true;\n        unTemporizador.iniciarTemporizador(tiempoAvioneta);\n        pistaOcupada = true;\n    }\n\n    // Invocado por el temporizador cuando finaliza el intervalo m\u00ednimo\n    public synchronized void finTemporizador() throws InterruptedException {\n        pistaOcupada = false;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2013/p2/","title":"Examen 2013 \u2014 Parcial 2","text":""},{"location":"exams/2013/p2/#problema-1","title":"Problema 1","text":"<p>Se desea desarrollar una aplicaci\u00f3n que facilite la selecci\u00f3n de un vino, ofreci\u00e9ndonos informaci\u00f3n de los vinos m\u00e1s populares. La pantalla inicial muestra una lista de vinos, y est\u00e1 gestionada por una actividad denominada <code>ListaVinosActivity</code>.  Al pinchar en el nombre de un vino se muestra otra pantalla con los detalles correspondientes. Esta pantalla est\u00e1 gestionada por la actividad <code>DetalleVinoActivity</code>.</p> <p></p> <p>Se proporcionan las clases Vino y Bodega (ver al final). </p> <p>Se pide: - (a) (5 puntos) Programe <code>ListaVinosActivity</code>. Suponga que dispone de la plantilla (layout) correspondiente en un fichero lista_vinos.xml, y utilice los nombres que necesite como crea oportuno. Utilice un <code>ArrayAdapter</code> para mostrar los elementos de la lista.</p> <p>Cuando se pulse en un elemento de la lista (el nombre de un vino), la actividad <code>ListaVinosActivity</code> debe lanzar la actividad <code>DetalleVinoActivity</code> pas\u00e1ndole el nombre del vino en la clave NOMBRE, y sin esperar un resultado de vuelta de dicha actividad.</p> <p>La actividad debe mostrar una traza (Log) de tipo informativo (i)  con el n\u00famero de vinos cargados, y una traza de tipo depuraci\u00f3n (d) con la opci\u00f3n que ha pulsado, como se muestra a continuaci\u00f3n.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public class ListaVinosActivity extends ListActivity {\n   public static final String NOMBRE = \"nombre\";\n   private static final String TAG = ListaVinosActivity.class.getSimpleName();\n   private Bodega bodega;\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.lista_vinos);\n      bodega = Bodega.getBodega();\n      List&lt;Vino&gt; lista = bodega.getListaVinos(); \n      Log.i(TAG, \"Cargando \" + lista.size() + \" vinos\"); \n      setListAdapter(new ArrayAdapter&lt;Vino&gt;(this,\n                       android.R.layout.simple_list_item_1, lista));\n   }\n   @Override\n   protected void onListItemClick(ListView l, View v, int position, long id) { \n      super.onListItemClick(l, v, position, id);\n      Intent intent = new Intent(this, DetalleVinoActivity.class);\n      Vino vino = bodega.getListaVinos().get(position);\n      Log.d(TAG, \"Pulsado en \" + vino);\n      intent.putExtra(NOMBRE, vino.getNombre());\n      startActivity(intent);\n   }\n}\n</code></pre> <ul> <li> <p>(b) (5 puntos) Programe <code>DetalleVinoActivity</code>. Suponga que la plantilla detalle_vino.xml muestra los campos de un  objeto <code>Vino</code> en los siguientes componentes: </p> <ul> <li> <ol> <li>foto en un <code>ImageView</code> (R.id.foto),</li> </ol> </li> <li> <ol> <li>nombre, denominaci\u00f3n y descripci\u00f3n en tres <code>EditText</code> (R.id.nombre, R.id.denominacion, R.id.descripcion).</li> </ol> </li> </ul> </li> </ul> <p>La actividad recibe en la intenci\u00f3n el nombre del vino en la clave NOMBRE. Debe crear un objeto <code>Bodega</code> y recuperar el objeto <code>Vino</code> correspondiente al nombre recibido. A continuaci\u00f3n, rellene los campos de la pantalla con los valores del vino. Puede suponer que todos los campos de un objeto <code>Vino</code> tienen un valor correcto.</p> Mostrar soluci\u00f3n <pre><code>public class DetalleVinoActivity extends Activity {\n   private EditText nombre;\n   private EditText denominacion;\n   private EditText descripcion;\n   private ImageView foto;\n   private static final String TAG = DetalleVinoActivity.class.getSimpleName();\n\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.detalle_vino);\n      Intent intent = getIntent();\n      String nombreVino = intent.getStringExtra(ListaVinosActivity.NOMBRE);\n      Bodega bodega = Bodega.getBodega();\n      Vino vino = bodega.getVino(nombreVino);\n      nombre = (EditText) findViewById(R.id.nombre); \n      nombre.setText(vino.getNombre());\n      denominacion = (EditText) findViewById(R.id.denominacion);\n      denominacion.setText(vino.getDenominacion().toString());\n      descripcion = (EditText) findViewById(R.id.descripcion);\n      descripcion.setText(vino.getDescripcion());\n      foto = (ImageView) findViewById(R.id.foto); \n      foto.setImageResource(vino.getFoto());\n   }\n}\n</code></pre> <p>Clases auxiliares: <pre><code>public class Vino {\n    enum Denominacion { RIOJA, RIBERA, PENEDES; }\n    private String nombre;\n    private Denominacion denominacion;\n    private int foto;\n    private String descripcion;\n    // suponga que tiene m\u00e9todos m\u00e9todos get/put para todos los campos\n    // suponga que tiene un m\u00e9todo toString() que imprime el nombre del vino\n}\n\npublic class Bodega {\n    public Vino getVino(String nombre) {... }\n    public List&lt;Vino&gt; getListaVinos() {...}\n    public static Bodega getBodega(){...}\n}\n\n// ejemplo de uso de las clases anteriores\n\npublic class Ejemplo {\n\n    public static void main(String [] args) {\n        Bodega bodega = Bodega.getBodega(); // creo la bodega\n        List&lt;Vino&gt; vinos = bodega.getListaVinos(); // lista de vinos\n        Vino vino = vinos.get(0); // obtener vino  recorriendo lista\n        // vino dado el nombre del vino\n        Vino valdehermoso = bodega.getVino(\"Valdehermoso\"); \n    }\n}\n</code></pre></p>"},{"location":"exams/2013/p2_ex01/","title":"P2 ex01","text":"<p>Se desea desarrollar una aplicaci\u00f3n que facilite la selecci\u00f3n de un vino, ofreci\u00e9ndonos informaci\u00f3n de los vinos m\u00e1s populares. La pantalla inicial muestra una lista de vinos, y est\u00e1 gestionada por una actividad denominada <code>ListaVinosActivity</code>.  Al pinchar en el nombre de un vino se muestra otra pantalla con los detalles correspondientes. Esta pantalla est\u00e1 gestionada por la actividad <code>DetalleVinoActivity</code>.</p> <p></p> <p>Se proporcionan las clases Vino y Bodega (ver al final). </p> <p>Se pide: - (a) (5 puntos) Programe <code>ListaVinosActivity</code>. Suponga que dispone de la plantilla (layout) correspondiente en un fichero lista_vinos.xml, y utilice los nombres que necesite como crea oportuno. Utilice un <code>ArrayAdapter</code> para mostrar los elementos de la lista.</p> <p>Cuando se pulse en un elemento de la lista (el nombre de un vino), la actividad <code>ListaVinosActivity</code> debe lanzar la actividad <code>DetalleVinoActivity</code> pas\u00e1ndole el nombre del vino en la clave NOMBRE, y sin esperar un resultado de vuelta de dicha actividad.</p> <p>La actividad debe mostrar una traza (Log) de tipo informativo (i)  con el n\u00famero de vinos cargados, y una traza de tipo depuraci\u00f3n (d) con la opci\u00f3n que ha pulsado, como se muestra a continuaci\u00f3n.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public class ListaVinosActivity extends ListActivity {\n   public static final String NOMBRE = \"nombre\";\n   private static final String TAG = ListaVinosActivity.class.getSimpleName();\n   private Bodega bodega;\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.lista_vinos);\n      bodega = Bodega.getBodega();\n      List&lt;Vino&gt; lista = bodega.getListaVinos(); \n      Log.i(TAG, \"Cargando \" + lista.size() + \" vinos\"); \n      setListAdapter(new ArrayAdapter&lt;Vino&gt;(this,\n                       android.R.layout.simple_list_item_1, lista));\n   }\n   @Override\n   protected void onListItemClick(ListView l, View v, int position, long id) { \n      super.onListItemClick(l, v, position, id);\n      Intent intent = new Intent(this, DetalleVinoActivity.class);\n      Vino vino = bodega.getListaVinos().get(position);\n      Log.d(TAG, \"Pulsado en \" + vino);\n      intent.putExtra(NOMBRE, vino.getNombre());\n      startActivity(intent);\n   }\n}\n</code></pre> <ul> <li> <p>(b) (5 puntos) Programe <code>DetalleVinoActivity</code>. Suponga que la plantilla detalle_vino.xml muestra los campos de un  objeto <code>Vino</code> en los siguientes componentes: </p> <ul> <li> <ol> <li>foto en un <code>ImageView</code> (R.id.foto),</li> </ol> </li> <li> <ol> <li>nombre, denominaci\u00f3n y descripci\u00f3n en tres <code>EditText</code> (R.id.nombre, R.id.denominacion, R.id.descripcion).</li> </ol> </li> </ul> </li> </ul> <p>La actividad recibe en la intenci\u00f3n el nombre del vino en la clave NOMBRE. Debe crear un objeto <code>Bodega</code> y recuperar el objeto <code>Vino</code> correspondiente al nombre recibido. A continuaci\u00f3n, rellene los campos de la pantalla con los valores del vino. Puede suponer que todos los campos de un objeto <code>Vino</code> tienen un valor correcto.</p> Mostrar soluci\u00f3n <pre><code>public class DetalleVinoActivity extends Activity {\n   private EditText nombre;\n   private EditText denominacion;\n   private EditText descripcion;\n   private ImageView foto;\n   private static final String TAG = DetalleVinoActivity.class.getSimpleName();\n\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.detalle_vino);\n      Intent intent = getIntent();\n      String nombreVino = intent.getStringExtra(ListaVinosActivity.NOMBRE);\n      Bodega bodega = Bodega.getBodega();\n      Vino vino = bodega.getVino(nombreVino);\n      nombre = (EditText) findViewById(R.id.nombre); \n      nombre.setText(vino.getNombre());\n      denominacion = (EditText) findViewById(R.id.denominacion);\n      denominacion.setText(vino.getDenominacion().toString());\n      descripcion = (EditText) findViewById(R.id.descripcion);\n      descripcion.setText(vino.getDescripcion());\n      foto = (ImageView) findViewById(R.id.foto); \n      foto.setImageResource(vino.getFoto());\n   }\n}\n</code></pre> <p>Clases auxiliares: <pre><code>public class Vino {\n    enum Denominacion { RIOJA, RIBERA, PENEDES; }\n    private String nombre;\n    private Denominacion denominacion;\n    private int foto;\n    private String descripcion;\n    // suponga que tiene m\u00e9todos m\u00e9todos get/put para todos los campos\n    // suponga que tiene un m\u00e9todo toString() que imprime el nombre del vino\n}\n\npublic class Bodega {\n    public Vino getVino(String nombre) {... }\n    public List&lt;Vino&gt; getListaVinos() {...}\n    public static Bodega getBodega(){...}\n}\n\n// ejemplo de uso de las clases anteriores\n\npublic class Ejemplo {\n\n    public static void main(String [] args) {\n        Bodega bodega = Bodega.getBodega(); // creo la bodega\n        List&lt;Vino&gt; vinos = bodega.getListaVinos(); // lista de vinos\n        Vino vino = vinos.get(0); // obtener vino  recorriendo lista\n        // vino dado el nombre del vino\n        Vino valdehermoso = bodega.getVino(\"Valdehermoso\"); \n    }\n}\n</code></pre></p>","tags":["android"]},{"location":"exams/2014/extra/","title":"Examen 2014 \u2014 Extraordinario","text":""},{"location":"exams/2014/extra/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (2,5 puntos) En una matriz de valores enteros de dos dimensiones, se dice que un elemento es un pico si es mayor o igual que sus cuatro vecinos en vertical y horizontal (o sus tres vecinos, en el caso de que se encuentre en el borde de la matriz, o sus dos vecinos si est\u00e1 en una esquina).</li> </ul> <p>Para encontrar un pico en una matriz de N filas por M columnas (se puede demostrar que siempre existe al menos uno) se puede utilizar el siguiente algoritmo:     1. Si M es igual a 1, encontrar el mayor valor de esa columna, y devolverlo como resultado.     2. En otro caso, encontrar el mayor valor en la columna central de la matriz.     3. Si ese valor es mayor o igual que sus vecinos derecho e izquierdo (si existen), devolverlo como resultado.     4. En otro caso, si ese valor es menor que su vecino izquierdo (si existe), continuar el mismo algoritmo con la mitad izquierda de la matriz. Y si no es as\u00ed, continuar el mismo algoritmo con la mitad derecha de la matriz (quitando la columna central en ambos casos).</p> <p>Se pide indicar razonadamente cu\u00e1l es la complejidad del algoritmo descrito, en t\u00e9rminos de N y M.</p> Mostrar soluci\u00f3n <p>La b\u00fasqueda del mayor valor en una columna de N enteros tiene complejidad N, ya que todos los valores de la columna han de ser comprobados, y las operaciones a realizar con cada uno de ellos son de complejidad constante. </p> <p>Por otra parte, en el peor caso habr\u00e1 que hacer esa b\u00fasqueda tantas veces como se puedan dividir iterativamente en dos partes iguales las M columnas, para llegar al final a una sola. Es decir, logaritmo en base dos de M veces. Por tanto, la complejidad total del algoritmo es N*log(M).</p>"},{"location":"exams/2014/extra/#problema-2","title":"Problema 2","text":"<p>Un sistema de gesti\u00f3n de un almac\u00e9n de piezas est\u00e1 compuesto por un conjunto de productores y de consumidores, que se modelan mediante hebras. Las hebras productoras a\u00f1aden piezas, mientras que las consumidoras las solicitan y retiran.</p> <p>Se pide dise\u00f1ar un monitor GestorPiezas que gestione las interacciones de estas hebras, cuya interfaz est\u00e1 formada por los siguientes m\u00e9todos:     \u2026 void solicitarPiezas (int cantidadPiezas): este m\u00e9todo lo invocan las hebras consumidoras cuando quieren solicitar una cantidad de piezas determinada. Si hay piezas suficientes, se le proporcionan inmediatamente (se actualiza el n\u00famero de piezas almacenadas). Si no las hay, se bloquea la hebra hasta que haya suficientes. En este caso, hay que bloquear al resto de hebras consumidoras hasta que se satisfaga la petici\u00f3n pendiente.</p> <pre><code>\u2026 void agregarPiezas (int cantidadPiezas): este m\u00e9todo lo invocan las hebras productoras para a\u00f1adir piezas al almac\u00e9n. La cantidad de piezas que se pueden almacenar es ilimitada.\n</code></pre> <p>Nota: el n\u00famero de piezas debe ser positivo en todos los casos.</p> Mostrar soluci\u00f3n <pre><code>public class GestorAlmacen {\n    private int cantidadAlmacen = 0;\n    private boolean peticionPendiente = false;\n\n    public synchronized void solicitarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        while (peticionPendiente) wait();\n        peticionPendiente = true;\n        while (cantidadAlmacen &lt; cantidadPiezas) wait();\n        cantidadAlmacen = cantidadAlmacen - cantidadPiezas;\n        peticionPendiente = false;\n        notifyAll();\n    }\n\n    public synchronized void agregarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        cantidadAlmacen = cantidadAlmacen + cantidadPiezas;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2014/extra/#problema-3","title":"Problema 3","text":"<p>Sobre el proyecto del pacman, deseamos mover funcionalidad del men\u00fa a botones:</p> <p></p> <p>Se pide:</p> <ul> <li>(a) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para poner botones? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>a) Hay que a\u00f1adir una fila de botones en res / layout / main.xml</p> <pre><code>&lt;LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:gravity=\"center\" &gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_reset\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"RESET\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_fantasma\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"fantasma\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_depredador\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"depredador\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>b) Hay que asociar la funcionalidad a cada bot\u00f3n en MainActivity.java</p> <pre><code>public void clic(View view) {\n    Escenario escenario = Escenario.getInstance();\n    switch(view.getId()) {\n        case R.id.boton_reset:\n            escenario.restart();\n            return;\n        case R.id.boton_fantasma:\n            escenario.addMovil(this, R.id.fantasma00);\n            return;\n        case R.id.boton_depredador:\n            escenario.addMovil(this, R.id.depredador);\n            return;\n    }\n}\n</code></pre> <p>Si se van a eliminar las entradas del men\u00fa, hay que revisar los R.id que desaparecen, ajustando los identificadores que se usan en cada parte del c\u00f3digo.</p> <p>NOTA: Hay otras formas de hacerlo:</p> <p>\u2022 En el layout: identificando cada bot\u00f3n por un onClick() espec\u00edfico</p> <p>\u2022 En java, en onCreate(): localizando los botones y asoci\u00e1ndoles la funcionalidad. Por ejemplo</p> <pre><code>Button bv = (Button) findViewById(R.id.boton_reset);\nbv.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Escenario escenario = Escenario.getInstance();\n        escenario.restart();\n    }\n});\n</code></pre> <p>\u2022 En java, hacemos que la clase MainActivity implemente OnClickListener y escribimos el m\u00e9todo onClick() en la clase principal y la asociamos a cada bot\u00f3n</p> <pre><code>public class MainActivity extends \u2026 implements OnClickListener {\n\n    // en onCreate():\n    Button botonReset = (Button)rootView.findViewById(R.id.boton_reset);\n    botonReset.setOnClickListener(this);\n\n    // en la clase MainActivity:\n    public void onClick(View view) {\n        Escenario escenario = Escenario.getInstance();\n        switch (view.getId()) {\n            case R.id.boton_reset:\n                escenario.restart();\n                return;\n            case R.id.boton_fantasma:\n                escenario.addMovil(this, R.id.fantasma00);\n                return;\n            case R.id.boton_depredador:\n                escenario.addMovil(this, R.id.depredador);\n                return;\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para eliminar entradas del men\u00fa? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>a) Hay que eliminar las entradas de res / menu / main.xml</p> <pre><code>~~&lt;item~~\n    ~~android:id=\"@+id/button_reset\"~~\n    ~~android:icon=\"@drawable/fantasma_rojo\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/button_reset\"/&gt;~~\n\n~~&lt;item~~\n    ~~android:id=\"@+id/fantasma00\"~~\n    ~~android:icon=\"@drawable/fantasma_rojo\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/fantasma00\"/&gt;~~\n\n~~&lt;item~~\n    ~~android:id=\"@+id/depredador\"~~\n    ~~android:icon=\"@drawable/anibal\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/depredador\"/&gt;~~\n</code></pre> <p>b) Hay que eliminar la funcionalidad de la clase MainActivity</p> <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    Escenario escenario = Escenario.getInstance();\n    switch (item.getItemId()) {\n        ~~case R.id.button_reset:~~\n            ~~escenario.restart();~~\n            ~~return true;~~\n    ~~}~~\n    ~~if (escenario.addMovil(this, item.getItemId()))~~\n        ~~return true;~~\n    return super.onOptionsItemSelected(item);\n}\n</code></pre> <p>OJO: hemos eliminado la facilidad de a\u00f1adir nuevos fantasmas sin m\u00e1s que a\u00f1adirlos en la especificaci\u00f3n xml del men\u00fa.</p> <ul> <li>(c) (0,5 puntos) \u00bfPodemos mantener ambos? Es decir, la misma funcionalidad accesible por men\u00fa y por bot\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed. Se pueden a\u00f1adir los botones y dejar el c\u00f3digo para el men\u00fa. La misma funci\u00f3n se puede realizar de 2 formas: por bot\u00f3n y por men\u00fa.</p> <p>La respuesta debe ser razonada, incluyendo c\u00f3digo java y especificaciones en XML, aunque no es necesario que la sintaxis de java y xml sea perfectamente correcta.</p>"},{"location":"exams/2014/extra/#problema-4","title":"Problema 4","text":"<ul> <li>(a) (0,8 puntos) Una aplicaci\u00f3n Android llamada APP est\u00e1 ejecut\u00e1ndose y dispone del foco (interact\u00faa con el usuario). Supongamos que se recibe una llamada telef\u00f3nica, el usuario la atiende y luego cuelga. \u00bfCu\u00e1les son los m\u00e9todos del ciclo de vida de APP llamados?</li> </ul> Mostrar soluci\u00f3n <p>La secuencia m\u00e1s com\u00fan es:</p> <pre><code>onPause()\nonStop()\nonRestart()\nonStart()\nonResume()\n</code></pre> <p>pero tambi\u00e9n puede ocurrir la siguiente secuencia:</p> <pre><code>onPause()\nonStop()\nonDestroy()\nonCreate()\nonStart()\nonResume()\n</code></pre> <p>Tambi\u00e9n podr\u00eda ocurrir que la llamada entrante no llegue a retirar toda la actividad de la pantalla sino que quede en el fondo. En ese caso la secuencia ser\u00eda:</p> <pre><code>onPause()\nonResume()\n</code></pre> <p>Todas las soluciones anteriores se consideran v\u00e1lidas.</p> <ul> <li>(b) (0,7 puntos) Describir brevemente qu\u00e9 es y para qu\u00e9 se usa un <code>SimpleCursorAdapter</code>.</li> </ul> Mostrar soluci\u00f3n <p>Es un mecanismo que sirve para conectar el cursor con el que se accede a las filas que resultan de una consulta en una base datos con una <code>ListView</code> definida en el layout de una actividad. Se usa para mostrar los resultados de una consulta en una pantalla</p> <ul> <li>(c) (1 punto) En la actividad principal de una aplicaci\u00f3n hay un bot\u00f3n que tiene asociado un m\u00e9todo <code>onClick</code> que lanza la ejecuci\u00f3n de una tarea as\u00edncrona para cargar un fichero remoto. Indicar qu\u00e9 m\u00e9todos hay que programar en la clase que implementa la <code>AsyncTask</code>, en qu\u00e9 hebra (thread) se ejecuta cada uno de ellos, y describa sucintamente qu\u00e9 hacen.</li> </ul> Mostrar soluci\u00f3n <p>Suponiendo que la cabecera de la clase es:</p> <pre><code>class MyClass extends AsyncTask&lt;Params, Progress, Result&gt;\n</code></pre> <p>los m\u00e9todos que hay que programar son:</p> <pre><code>void onPreExecute()\n</code></pre> <p>Se ejecuta en la UIThread, cuando se llama a execute(). Sirve para iniciar la tarea antes de empezar a ejecutar doInbackground.</p> <pre><code>Result doInBackground(Params\u2026)\n</code></pre> <p>Se ejecuta en la hebra auxiliar. Es equivalente a run() en las threads normales. Params son los par\u00e1metros que se le pasan al arrancar la tarea.</p> <pre><code>void onProgressUpdate (Progress\u2026)\n</code></pre> <p>Se ejecuta en la UIThread cada vez que se llama a publishProgress(Progress\u2026) desde el cuerpo de doInBackground.</p> <pre><code>void onPostExecute (Result)\n</code></pre> <p>Se ejecuta en la UIThread cuando termina doInBackground (con return Result).</p>"},{"location":"exams/2014/extra01/","title":"Extra01","text":"<ul> <li>(a) (2,5 puntos) En una matriz de valores enteros de dos dimensiones, se dice que un elemento es un pico si es mayor o igual que sus cuatro vecinos en vertical y horizontal (o sus tres vecinos, en el caso de que se encuentre en el borde de la matriz, o sus dos vecinos si est\u00e1 en una esquina).</li> </ul> <p>Para encontrar un pico en una matriz de N filas por M columnas (se puede demostrar que siempre existe al menos uno) se puede utilizar el siguiente algoritmo:     1. Si M es igual a 1, encontrar el mayor valor de esa columna, y devolverlo como resultado.     2. En otro caso, encontrar el mayor valor en la columna central de la matriz.     3. Si ese valor es mayor o igual que sus vecinos derecho e izquierdo (si existen), devolverlo como resultado.     4. En otro caso, si ese valor es menor que su vecino izquierdo (si existe), continuar el mismo algoritmo con la mitad izquierda de la matriz. Y si no es as\u00ed, continuar el mismo algoritmo con la mitad derecha de la matriz (quitando la columna central en ambos casos).</p> <p>Se pide indicar razonadamente cu\u00e1l es la complejidad del algoritmo descrito, en t\u00e9rminos de N y M.</p> Mostrar soluci\u00f3n <p>La b\u00fasqueda del mayor valor en una columna de N enteros tiene complejidad N, ya que todos los valores de la columna han de ser comprobados, y las operaciones a realizar con cada uno de ellos son de complejidad constante. </p> <p>Por otra parte, en el peor caso habr\u00e1 que hacer esa b\u00fasqueda tantas veces como se puedan dividir iterativamente en dos partes iguales las M columnas, para llegar al final a una sola. Es decir, logaritmo en base dos de M veces. Por tanto, la complejidad total del algoritmo es N*log(M).</p>","tags":["complejidad"]},{"location":"exams/2014/extra02/","title":"Extra02","text":"<p>Un sistema de gesti\u00f3n de un almac\u00e9n de piezas est\u00e1 compuesto por un conjunto de productores y de consumidores, que se modelan mediante hebras. Las hebras productoras a\u00f1aden piezas, mientras que las consumidoras las solicitan y retiran.</p> <p>Se pide dise\u00f1ar un monitor GestorPiezas que gestione las interacciones de estas hebras, cuya interfaz est\u00e1 formada por los siguientes m\u00e9todos:     \u2026 void solicitarPiezas (int cantidadPiezas): este m\u00e9todo lo invocan las hebras consumidoras cuando quieren solicitar una cantidad de piezas determinada. Si hay piezas suficientes, se le proporcionan inmediatamente (se actualiza el n\u00famero de piezas almacenadas). Si no las hay, se bloquea la hebra hasta que haya suficientes. En este caso, hay que bloquear al resto de hebras consumidoras hasta que se satisfaga la petici\u00f3n pendiente.</p> <pre><code>\u2026 void agregarPiezas (int cantidadPiezas): este m\u00e9todo lo invocan las hebras productoras para a\u00f1adir piezas al almac\u00e9n. La cantidad de piezas que se pueden almacenar es ilimitada.\n</code></pre> <p>Nota: el n\u00famero de piezas debe ser positivo en todos los casos.</p> Mostrar soluci\u00f3n <pre><code>public class GestorAlmacen {\n    private int cantidadAlmacen = 0;\n    private boolean peticionPendiente = false;\n\n    public synchronized void solicitarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        while (peticionPendiente) wait();\n        peticionPendiente = true;\n        while (cantidadAlmacen &lt; cantidadPiezas) wait();\n        cantidadAlmacen = cantidadAlmacen - cantidadPiezas;\n        peticionPendiente = false;\n        notifyAll();\n    }\n\n    public synchronized void agregarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        cantidadAlmacen = cantidadAlmacen + cantidadPiezas;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2014/extra03/","title":"Extra03","text":"<p>Sobre el proyecto del pacman, deseamos mover funcionalidad del men\u00fa a botones:</p> <p></p> <p>Se pide:</p> <ul> <li>(a) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para poner botones? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>a) Hay que a\u00f1adir una fila de botones en res / layout / main.xml</p> <pre><code>&lt;LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:gravity=\"center\" &gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_reset\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"RESET\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_fantasma\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"fantasma\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_depredador\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"depredador\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>b) Hay que asociar la funcionalidad a cada bot\u00f3n en MainActivity.java</p> <pre><code>public void clic(View view) {\n    Escenario escenario = Escenario.getInstance();\n    switch(view.getId()) {\n        case R.id.boton_reset:\n            escenario.restart();\n            return;\n        case R.id.boton_fantasma:\n            escenario.addMovil(this, R.id.fantasma00);\n            return;\n        case R.id.boton_depredador:\n            escenario.addMovil(this, R.id.depredador);\n            return;\n    }\n}\n</code></pre> <p>Si se van a eliminar las entradas del men\u00fa, hay que revisar los R.id que desaparecen, ajustando los identificadores que se usan en cada parte del c\u00f3digo.</p> <p>NOTA: Hay otras formas de hacerlo:</p> <p>\u2022 En el layout: identificando cada bot\u00f3n por un onClick() espec\u00edfico</p> <p>\u2022 En java, en onCreate(): localizando los botones y asoci\u00e1ndoles la funcionalidad. Por ejemplo</p> <pre><code>Button bv = (Button) findViewById(R.id.boton_reset);\nbv.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Escenario escenario = Escenario.getInstance();\n        escenario.restart();\n    }\n});\n</code></pre> <p>\u2022 En java, hacemos que la clase MainActivity implemente OnClickListener y escribimos el m\u00e9todo onClick() en la clase principal y la asociamos a cada bot\u00f3n</p> <pre><code>public class MainActivity extends \u2026 implements OnClickListener {\n\n    // en onCreate():\n    Button botonReset = (Button)rootView.findViewById(R.id.boton_reset);\n    botonReset.setOnClickListener(this);\n\n    // en la clase MainActivity:\n    public void onClick(View view) {\n        Escenario escenario = Escenario.getInstance();\n        switch (view.getId()) {\n            case R.id.boton_reset:\n                escenario.restart();\n                return;\n            case R.id.boton_fantasma:\n                escenario.addMovil(this, R.id.fantasma00);\n                return;\n            case R.id.boton_depredador:\n                escenario.addMovil(this, R.id.depredador);\n                return;\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para eliminar entradas del men\u00fa? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>a) Hay que eliminar las entradas de res / menu / main.xml</p> <pre><code>~~&lt;item~~\n    ~~android:id=\"@+id/button_reset\"~~\n    ~~android:icon=\"@drawable/fantasma_rojo\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/button_reset\"/&gt;~~\n\n~~&lt;item~~\n    ~~android:id=\"@+id/fantasma00\"~~\n    ~~android:icon=\"@drawable/fantasma_rojo\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/fantasma00\"/&gt;~~\n\n~~&lt;item~~\n    ~~android:id=\"@+id/depredador\"~~\n    ~~android:icon=\"@drawable/anibal\"~~\n    ~~android:showAsAction=\"ifRoom\"~~\n    ~~android:title=\"@string/depredador\"/&gt;~~\n</code></pre> <p>b) Hay que eliminar la funcionalidad de la clase MainActivity</p> <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    Escenario escenario = Escenario.getInstance();\n    switch (item.getItemId()) {\n        ~~case R.id.button_reset:~~\n            ~~escenario.restart();~~\n            ~~return true;~~\n    ~~}~~\n    ~~if (escenario.addMovil(this, item.getItemId()))~~\n        ~~return true;~~\n    return super.onOptionsItemSelected(item);\n}\n</code></pre> <p>OJO: hemos eliminado la facilidad de a\u00f1adir nuevos fantasmas sin m\u00e1s que a\u00f1adirlos en la especificaci\u00f3n xml del men\u00fa.</p> <ul> <li>(c) (0,5 puntos) \u00bfPodemos mantener ambos? Es decir, la misma funcionalidad accesible por men\u00fa y por bot\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed. Se pueden a\u00f1adir los botones y dejar el c\u00f3digo para el men\u00fa. La misma funci\u00f3n se puede realizar de 2 formas: por bot\u00f3n y por men\u00fa.</p> <p>La respuesta debe ser razonada, incluyendo c\u00f3digo java y especificaciones en XML, aunque no es necesario que la sintaxis de java y xml sea perfectamente correcta.</p>","tags":["android"]},{"location":"exams/2014/extra04/","title":"Extra04","text":"<ul> <li>(a) (0,8 puntos) Una aplicaci\u00f3n Android llamada APP est\u00e1 ejecut\u00e1ndose y dispone del foco (interact\u00faa con el usuario). Supongamos que se recibe una llamada telef\u00f3nica, el usuario la atiende y luego cuelga. \u00bfCu\u00e1les son los m\u00e9todos del ciclo de vida de APP llamados?</li> </ul> Mostrar soluci\u00f3n <p>La secuencia m\u00e1s com\u00fan es:</p> <pre><code>onPause()\nonStop()\nonRestart()\nonStart()\nonResume()\n</code></pre> <p>pero tambi\u00e9n puede ocurrir la siguiente secuencia:</p> <pre><code>onPause()\nonStop()\nonDestroy()\nonCreate()\nonStart()\nonResume()\n</code></pre> <p>Tambi\u00e9n podr\u00eda ocurrir que la llamada entrante no llegue a retirar toda la actividad de la pantalla sino que quede en el fondo. En ese caso la secuencia ser\u00eda:</p> <pre><code>onPause()\nonResume()\n</code></pre> <p>Todas las soluciones anteriores se consideran v\u00e1lidas.</p> <ul> <li>(b) (0,7 puntos) Describir brevemente qu\u00e9 es y para qu\u00e9 se usa un <code>SimpleCursorAdapter</code>.</li> </ul> Mostrar soluci\u00f3n <p>Es un mecanismo que sirve para conectar el cursor con el que se accede a las filas que resultan de una consulta en una base datos con una <code>ListView</code> definida en el layout de una actividad. Se usa para mostrar los resultados de una consulta en una pantalla</p> <ul> <li>(c) (1 punto) En la actividad principal de una aplicaci\u00f3n hay un bot\u00f3n que tiene asociado un m\u00e9todo <code>onClick</code> que lanza la ejecuci\u00f3n de una tarea as\u00edncrona para cargar un fichero remoto. Indicar qu\u00e9 m\u00e9todos hay que programar en la clase que implementa la <code>AsyncTask</code>, en qu\u00e9 hebra (thread) se ejecuta cada uno de ellos, y describa sucintamente qu\u00e9 hacen.</li> </ul> Mostrar soluci\u00f3n <p>Suponiendo que la cabecera de la clase es:</p> <pre><code>class MyClass extends AsyncTask&lt;Params, Progress, Result&gt;\n</code></pre> <p>los m\u00e9todos que hay que programar son:</p> <pre><code>void onPreExecute()\n</code></pre> <p>Se ejecuta en la UIThread, cuando se llama a execute(). Sirve para iniciar la tarea antes de empezar a ejecutar doInbackground.</p> <pre><code>Result doInBackground(Params\u2026)\n</code></pre> <p>Se ejecuta en la hebra auxiliar. Es equivalente a run() en las threads normales. Params son los par\u00e1metros que se le pasan al arrancar la tarea.</p> <pre><code>void onProgressUpdate (Progress\u2026)\n</code></pre> <p>Se ejecuta en la UIThread cada vez que se llama a publishProgress(Progress\u2026) desde el cuerpo de doInBackground.</p> <pre><code>void onPostExecute (Result)\n</code></pre> <p>Se ejecuta en la UIThread cuando termina doInBackground (con return Result).</p>","tags":["android"]},{"location":"exams/2014/p1/","title":"Examen 2014 \u2014 Parcial 1","text":""},{"location":"exams/2014/p1/#problema-1","title":"Problema 1","text":"<p>Se necesita comprobar la bondad de los algoritmos de construcci\u00f3n de laberintos que se puedan desarrollar para la pr\u00e1ctica del Pacman. El objetivo es poder construir un laberinto conexo, esto es, un terreno en el que todas las casillas est\u00e9n conectadas, bien directamente o bien a trav\u00e9s de otras que las interconecten. De esta forma, no habr\u00e1 zonas del laberinto aisladas.</p> <p>Para ello, se pide desarrollar una clase auxiliar, llamada <code>Conectividad</code>, que averig\u00fce si un terreno es conexo o no. La especificaci\u00f3n de la clase es la siguiente:</p> <pre><code>package es.upm.dit.adsw.pacman2;\n\npublic class Conectividad {\n    private final Terreno terreno;\n\n    /**\n     * @param terreno\n     */\n    public Conectividad(Terreno terreno) {\n        this.terreno = terreno;\n    }\n\n    /**\n     * Determina si el terreno es conexo\n     * @return true si el terreno es conexo, false en caso contrario\n     */\n    public boolean esConexo() { ... }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Implementaci\u00f3n del m\u00e9todo <code>esConexo()</code>. Este m\u00e9todo ha de comprobar que desde cualquier casilla del terreno se puede alcanzar cualquier otra casilla.</li> </ul> <p>Sugerencia: Se propone el siguiente algoritmo para determinar si un terreno tiene casillas conexas.</p> <p>Se define un conjunto de casillas visitadas (ya analizadas alguna vez) y una lista de casillas pendientes (a\u00fan no analizadas).</p> <p>Se elige una casilla inicial, por ejemplo (0,0), y se a\u00f1ade a la lista de pendientes.</p> <p>Mientras haya casillas pendientes:   1. Se saca una casilla de la lista de pendientes.   2. Se a\u00f1ade la casilla al conjunto de visitadas.   3. Para cada direcci\u00f3n:      * Si existe una casilla adyacente accesible (no separada por una pared)      * Y no ha sido visitada, se a\u00f1ade a la lista de pendientes.</p> <p>Cuando ya no hay casillas pendientes:   * O bien se han visitado todas las casillas   * O existen zonas aisladas que no se han podido alcanzar</p> <p>Si el tama\u00f1o del conjunto de visitadas coincide con el n\u00famero total de casillas (N^2), entonces el terreno es conexo.</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo <code>esConexo()</code> es la siguiente:</p> <pre><code>public boolean esConexo() {\n    Set&lt;Casilla&gt; visitadas = new HashSet&lt;Casilla&gt;();\n    List&lt;Casilla&gt; pendientes = new ArrayList&lt;Casilla&gt;();\n\n    Casilla origen = terreno.getCasilla(0, 0);\n    pendientes.add(origen);\n\n    while (!pendientes.isEmpty()) {\n        Casilla c = pendientes.remove(0);\n        visitadas.add(c);\n\n        for (Direccion d : Direccion.values()) {\n            if (!c.hayPared(d)) {\n                Casilla v = terreno.getCasilla(c, d);\n                if (v != null &amp;&amp; !visitadas.contains(v)) {\n                    pendientes.add(v);\n                }\n            }\n        }\n    }\n\n    int N = terreno.getN();\n    return visitadas.size() == N * N;\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Complejidad temporal del algoritmo. (0,5 puntos) Determine la complejidad temporal del algoritmo programado en el apartado anterior. (1 punto) Justifique su respuesta. Se considera m\u00e1s importante el razonamiento sobre la complejidad que el c\u00e1lculo correcto.</li> </ul> Mostrar soluci\u00f3n <p>Dado que el algoritmo recorre, en el peor de los casos, todas las casillas del terreno, la complejidad b\u00e1sica ser\u00e1:</p> <p>[ O(N^2) \\times (\\text{complejidad de las operaciones}) ]</p> <p>Las operaciones b\u00e1sicas (comparaciones, asignaciones, accesos simples) tienen complejidad O(1).</p> <p>El acceso a las estructuras de datos depende de su implementaci\u00f3n. En el caso de<code>HashSet</code> las operaciones de inserci\u00f3n, borrado y b\u00fasqueda tienen complejidad O(1) de forma habitual. En el caso de <code>ArrayList</code>n la operaci\u00f3n <code>remove(0)</code> implica desplazar todos los elementos restantes, por lo que su complejidad es O(N).</p> <p>Por lo tanto, para el primer caso tenemos que el algoritmo es O(N\u00b2) y para el segundo O(N\u00b3).</p>"},{"location":"exams/2014/p1/#problema-2","title":"Problema 2","text":"<p>Sea un cruce de calles por el que circulan coches de oeste a este y de norte a sur. Para regular el tr\u00e1fico hay dos sem\u00e1foros, uno en la entrada oeste y otro en la entrada norte, y dos sensores, que se activan cuando llega un coche a cada una de las entradas. Tambi\u00e9n hay sensores que indican la salida del cruce.</p> <p>Se desea desarrollar un monitor en Java que simule la gesti\u00f3n de los sem\u00e1foros con las siguientes forma:</p> <ul> <li> <p>Los coches se modelan como hebras (threads) que invocan un m\u00e9todo <code>llegaNorte()</code> o <code>llegaOeste()</code> cuando llegan al cruce.</p> </li> <li> <p>Si el sem\u00e1foro correspondiente est\u00e1 en verde, el coche pasa inmediatamente.</p> </li> <li> <p>Si el sem\u00e1foro est\u00e1 en rojo, el coche espera hasta que se ponga en verde.</p> </li> <li> <p>Los coches tardan un cierto tiempo en atravesar el cruce. Al salir invocan el m\u00e9todo <code>sale()</code> del monitor.</p> </li> <li> <p>Una hebra de control llama peri\u00f3dicamente al m\u00e9todo <code>cambiaSem\u00e1foros()</code> para cambiar la configuraci\u00f3n de los sem\u00e1foros.</p> </li> </ul> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorCruce {\n    ...\n\n    // Lo invoca un coche que llega por el norte\n    llegaNorte() { ... }\n\n    // Lo invoca un coche que llega por el oeste\n    llegaOeste() { ... }\n\n    // Lo invoca un coche que sale del cruce\n    sale() { ... }\n\n    // Lo invoca la hebra de control\n    cambiaSem\u00e1foros() { ... }\n...\n}\n</code></pre> <ul> <li>(a) Se pide (5 puntos)  Desarrollar el c\u00f3digo completo del monitor , justificando la respuesta. Se valorar\u00e1 especialmente el razonamiento sobre el dise\u00f1o del monitor.</li> </ul> Mostrar soluci\u00f3n <p>En el sistema existen dos tipos de hebras que representan, respectivamente, el comportamiento de los coches y el control de los sem\u00e1foros. Estas hebras invocan los m\u00e9todos del monitor para actualizar el estado del cruce y sincronizarse.</p> <p>El monitor almacena el estado del cruce mediante atributos privados. En este caso se identifican los siguientes:</p> <ul> <li>Estado de los sem\u00e1foros: puede representarse mediante un valor booleano. Basta con una sola variable, ya que cuando un sem\u00e1foro est\u00e1 en verde, el otro est\u00e1 en rojo.</li> <li>N\u00famero de coches en el cruce: se representa mediante un booleano, ya que solo se permite un coche a la vez.</li> </ul> <p>N\u00f3tese que no es necesario representar el n\u00famero de coches que esperan, ni el tiempo que transcurre entre la entrada y la un salida de un coche. Este \u00faltimo aspecto se debe modelar en la clase que representa elcomportamiento de los coches. Tampoco hay que modelar aqu\u00ed el tiempo que transcurre entre los cambios de los sem\u00e1foros, que corresponde a la hebra de control.</p> <p>En cuanto a la implementaci\u00f3n del gestor, debe realizarse como un monitor, por lo que todos los atributos dedatos deber ser privados, y todos los m\u00e9todos p\u00fablicos (excepto los constructores) deben estar sincronizados.</p> <p>Una posible implementaci\u00f3n es la siguiente:</p> <pre><code>public class GestorCruce {\n\n    // true indica sem\u00e1foro norte en verde (oeste en rojo)\n    private boolean norteVerde = true;\n\n    // Indica si hay un coche pasando por el cruce\n    private boolean cochePasando = false;\n\n    // Invocado por un coche que llega desde el norte\n    public synchronized void entraNorte() throws InterruptedException {\n        while (!norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que llega desde el oeste\n    public synchronized void entraOeste() throws InterruptedException {\n        while (norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que sale del cruce\n    public synchronized void sale() {\n        cochePasando = false;\n        notifyAll();\n    }\n\n    // Invocado por la hebra de control de los sem\u00e1foros\n    public synchronized void cambiaSemaforos() {\n        norteVerde = !norteVerde;\n        notifyAll();\n    }\n}\n</code></pre> <p>Obs\u00e9rvese que si cambian los sem\u00e1foros cuando hay un coche en el cruce, no puede entrar ning\u00fan otro coche en la nueva orientaci\u00f3n hasta que el coche que est\u00e1 en el cruce salga, ya que <code>cochePasando</code> ser\u00e1 <code>true</code>.</p> <p>Los m\u00e9todos <code>entraNorte</code> y <code>entraOeste</code> propagan <code>IntrruptedException</code>. Una alternativa ser\u00eda maneja la interrupci\u00f3n en estos m\u00e9todos con un bloque try-catch.</p>"},{"location":"exams/2014/p1_ex01/","title":"P1 ex01","text":"<p>Se necesita comprobar la bondad de los algoritmos de construcci\u00f3n de laberintos que se puedan desarrollar para la pr\u00e1ctica del Pacman. El objetivo es poder construir un laberinto conexo, esto es, un terreno en el que todas las casillas est\u00e9n conectadas, bien directamente o bien a trav\u00e9s de otras que las interconecten. De esta forma, no habr\u00e1 zonas del laberinto aisladas.</p> <p>Para ello, se pide desarrollar una clase auxiliar, llamada <code>Conectividad</code>, que averig\u00fce si un terreno es conexo o no. La especificaci\u00f3n de la clase es la siguiente:</p> <pre><code>package es.upm.dit.adsw.pacman2;\n\npublic class Conectividad {\n    private final Terreno terreno;\n\n    /**\n     * @param terreno\n     */\n    public Conectividad(Terreno terreno) {\n        this.terreno = terreno;\n    }\n\n    /**\n     * Determina si el terreno es conexo\n     * @return true si el terreno es conexo, false en caso contrario\n     */\n    public boolean esConexo() { ... }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Implementaci\u00f3n del m\u00e9todo <code>esConexo()</code>. Este m\u00e9todo ha de comprobar que desde cualquier casilla del terreno se puede alcanzar cualquier otra casilla.</li> </ul> <p>Sugerencia: Se propone el siguiente algoritmo para determinar si un terreno tiene casillas conexas.</p> <p>Se define un conjunto de casillas visitadas (ya analizadas alguna vez) y una lista de casillas pendientes (a\u00fan no analizadas).</p> <p>Se elige una casilla inicial, por ejemplo (0,0), y se a\u00f1ade a la lista de pendientes.</p> <p>Mientras haya casillas pendientes:   1. Se saca una casilla de la lista de pendientes.   2. Se a\u00f1ade la casilla al conjunto de visitadas.   3. Para cada direcci\u00f3n:      * Si existe una casilla adyacente accesible (no separada por una pared)      * Y no ha sido visitada, se a\u00f1ade a la lista de pendientes.</p> <p>Cuando ya no hay casillas pendientes:   * O bien se han visitado todas las casillas   * O existen zonas aisladas que no se han podido alcanzar</p> <p>Si el tama\u00f1o del conjunto de visitadas coincide con el n\u00famero total de casillas (N^2), entonces el terreno es conexo.</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo <code>esConexo()</code> es la siguiente:</p> <pre><code>public boolean esConexo() {\n    Set&lt;Casilla&gt; visitadas = new HashSet&lt;Casilla&gt;();\n    List&lt;Casilla&gt; pendientes = new ArrayList&lt;Casilla&gt;();\n\n    Casilla origen = terreno.getCasilla(0, 0);\n    pendientes.add(origen);\n\n    while (!pendientes.isEmpty()) {\n        Casilla c = pendientes.remove(0);\n        visitadas.add(c);\n\n        for (Direccion d : Direccion.values()) {\n            if (!c.hayPared(d)) {\n                Casilla v = terreno.getCasilla(c, d);\n                if (v != null &amp;&amp; !visitadas.contains(v)) {\n                    pendientes.add(v);\n                }\n            }\n        }\n    }\n\n    int N = terreno.getN();\n    return visitadas.size() == N * N;\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Complejidad temporal del algoritmo. (0,5 puntos) Determine la complejidad temporal del algoritmo programado en el apartado anterior. (1 punto) Justifique su respuesta. Se considera m\u00e1s importante el razonamiento sobre la complejidad que el c\u00e1lculo correcto.</li> </ul> Mostrar soluci\u00f3n <p>Dado que el algoritmo recorre, en el peor de los casos, todas las casillas del terreno, la complejidad b\u00e1sica ser\u00e1:</p> <p>[ O(N^2) \\times (\\text{complejidad de las operaciones}) ]</p> <p>Las operaciones b\u00e1sicas (comparaciones, asignaciones, accesos simples) tienen complejidad O(1).</p> <p>El acceso a las estructuras de datos depende de su implementaci\u00f3n. En el caso de<code>HashSet</code> las operaciones de inserci\u00f3n, borrado y b\u00fasqueda tienen complejidad O(1) de forma habitual. En el caso de <code>ArrayList</code>n la operaci\u00f3n <code>remove(0)</code> implica desplazar todos los elementos restantes, por lo que su complejidad es O(N).</p> <p>Por lo tanto, para el primer caso tenemos que el algoritmo es O(N\u00b2) y para el segundo O(N\u00b3).</p>","tags":["complejidad"]},{"location":"exams/2014/p1_ex02/","title":"P1 ex02","text":"<p>Sea un cruce de calles por el que circulan coches de oeste a este y de norte a sur. Para regular el tr\u00e1fico hay dos sem\u00e1foros, uno en la entrada oeste y otro en la entrada norte, y dos sensores, que se activan cuando llega un coche a cada una de las entradas. Tambi\u00e9n hay sensores que indican la salida del cruce.</p> <p>Se desea desarrollar un monitor en Java que simule la gesti\u00f3n de los sem\u00e1foros con las siguientes forma:</p> <ul> <li> <p>Los coches se modelan como hebras (threads) que invocan un m\u00e9todo <code>llegaNorte()</code> o <code>llegaOeste()</code> cuando llegan al cruce.</p> </li> <li> <p>Si el sem\u00e1foro correspondiente est\u00e1 en verde, el coche pasa inmediatamente.</p> </li> <li> <p>Si el sem\u00e1foro est\u00e1 en rojo, el coche espera hasta que se ponga en verde.</p> </li> <li> <p>Los coches tardan un cierto tiempo en atravesar el cruce. Al salir invocan el m\u00e9todo <code>sale()</code> del monitor.</p> </li> <li> <p>Una hebra de control llama peri\u00f3dicamente al m\u00e9todo <code>cambiaSem\u00e1foros()</code> para cambiar la configuraci\u00f3n de los sem\u00e1foros.</p> </li> </ul> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorCruce {\n    ...\n\n    // Lo invoca un coche que llega por el norte\n    llegaNorte() { ... }\n\n    // Lo invoca un coche que llega por el oeste\n    llegaOeste() { ... }\n\n    // Lo invoca un coche que sale del cruce\n    sale() { ... }\n\n    // Lo invoca la hebra de control\n    cambiaSem\u00e1foros() { ... }\n...\n}\n</code></pre> <ul> <li>(a) Se pide (5 puntos)  Desarrollar el c\u00f3digo completo del monitor , justificando la respuesta. Se valorar\u00e1 especialmente el razonamiento sobre el dise\u00f1o del monitor.</li> </ul> Mostrar soluci\u00f3n <p>En el sistema existen dos tipos de hebras que representan, respectivamente, el comportamiento de los coches y el control de los sem\u00e1foros. Estas hebras invocan los m\u00e9todos del monitor para actualizar el estado del cruce y sincronizarse.</p> <p>El monitor almacena el estado del cruce mediante atributos privados. En este caso se identifican los siguientes:</p> <ul> <li>Estado de los sem\u00e1foros: puede representarse mediante un valor booleano. Basta con una sola variable, ya que cuando un sem\u00e1foro est\u00e1 en verde, el otro est\u00e1 en rojo.</li> <li>N\u00famero de coches en el cruce: se representa mediante un booleano, ya que solo se permite un coche a la vez.</li> </ul> <p>N\u00f3tese que no es necesario representar el n\u00famero de coches que esperan, ni el tiempo que transcurre entre la entrada y la un salida de un coche. Este \u00faltimo aspecto se debe modelar en la clase que representa elcomportamiento de los coches. Tampoco hay que modelar aqu\u00ed el tiempo que transcurre entre los cambios de los sem\u00e1foros, que corresponde a la hebra de control.</p> <p>En cuanto a la implementaci\u00f3n del gestor, debe realizarse como un monitor, por lo que todos los atributos dedatos deber ser privados, y todos los m\u00e9todos p\u00fablicos (excepto los constructores) deben estar sincronizados.</p> <p>Una posible implementaci\u00f3n es la siguiente:</p> <pre><code>public class GestorCruce {\n\n    // true indica sem\u00e1foro norte en verde (oeste en rojo)\n    private boolean norteVerde = true;\n\n    // Indica si hay un coche pasando por el cruce\n    private boolean cochePasando = false;\n\n    // Invocado por un coche que llega desde el norte\n    public synchronized void entraNorte() throws InterruptedException {\n        while (!norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que llega desde el oeste\n    public synchronized void entraOeste() throws InterruptedException {\n        while (norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que sale del cruce\n    public synchronized void sale() {\n        cochePasando = false;\n        notifyAll();\n    }\n\n    // Invocado por la hebra de control de los sem\u00e1foros\n    public synchronized void cambiaSemaforos() {\n        norteVerde = !norteVerde;\n        notifyAll();\n    }\n}\n</code></pre> <p>Obs\u00e9rvese que si cambian los sem\u00e1foros cuando hay un coche en el cruce, no puede entrar ning\u00fan otro coche en la nueva orientaci\u00f3n hasta que el coche que est\u00e1 en el cruce salga, ya que <code>cochePasando</code> ser\u00e1 <code>true</code>.</p> <p>Los m\u00e9todos <code>entraNorte</code> y <code>entraOeste</code> propagan <code>IntrruptedException</code>. Una alternativa ser\u00eda maneja la interrupci\u00f3n en estos m\u00e9todos con un bloque try-catch.</p>","tags":["monitores"]},{"location":"exams/2014/p1r/","title":"Examen 2014 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2014/p1r/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (5 puntos) Se llama mont\u00f3n (heap) a un array de valores enteros en el que, representado como un \u00e1rbol binario, todo nodo es mayor o igual que culaquiera de sus dos hijos (si existen):</li> </ul> <p>Se ve que para todo nodo representado en la posici\u00f3n <code>i</code> de un array su hijo izquierdo se encuentra en la posici\u00f3n <code>2\u00b7i + 1</code> y su hijo derecho se encuentra en la posici\u00f3n <code>2\u00b7i + 2</code>.</p> <p>As\u00ed pues, para ordenar de mayor a menor un conjunto de valores enteros, basta con colocarlos primero como un mont\u00f3n, y despu\u00e9s ir extrayendo sucesivamente el primer valor del array (la ra\u00edz principal), y a continuaci\u00f3n recuperar el mont\u00f3n de los elementos restantes, hasta que no quede ning\u00fan elemento.</p> <p>Para recuperar el mont\u00f3n de los restantes elementos cuando se extrae el primer elemento de la tabla, basta con colocar en su lugar el \u00faltimo, y a continuaci\u00f3n hacer descender \u00e9ste en el \u00e1rbol iterativamente, si resulta necesario, hasta el nivel donde no sea menor que ninguno de sus dos (posibles) descendientes. Detr\u00e1s se puede ver el c\u00f3digo de esta operaci\u00f3n, aunque no resulta necesario en absoluto consultarlo, si se ha entendido correctamente este p\u00e1rrafo.</p> <p>Sabiendo que la operaci\u00f3n de construir un mont\u00f3n a partir de un array de enteros cualquiera tiene una complejidad del orden de n \u2217 log(n), se pide encontrar y justificar la complejidad del algoritmo completo de ordenaci\u00f3n descrito</p> <pre><code>private static int[] montonOrdenado(int[] monton) {\n    int[] resultado = new int[monton.length];\n\n    for (int j = 0; j &lt; monton.length; j++) {\n        resultado[j] = monton[0];\n\n        int ultimoIndice = monton.length - 1 - j;\n        monton[0] = monton[ultimoIndice];\n        --ultimoIndice;\n\n        int i = 0;\n        while (true) {\n            int indiceHijoIzquierdo = 2 * i + 1;\n            int indiceHijoDerecho = 2 * i + 2;\n\n            // No hay hijos\n            if (indiceHijoIzquierdo &gt; ultimoIndice)\n                break;\n\n            // Solo hay hijo izquierdo\n            if (indiceHijoDerecho &gt; ultimoIndice) {\n                if (monton[i] &lt; monton[indiceHijoIzquierdo])\n                    intercambia(monton, i, indiceHijoIzquierdo);\n                break;\n            }\n\n            // Ambos hijos son menores o iguales\n            if ((monton[i] &gt;= monton[indiceHijoIzquierdo])\n                    &amp;&amp; (monton[i] &gt;= monton[indiceHijoDerecho]))\n                break;\n\n            // Uno de los hijos es mayor\n            if (monton[indiceHijoDerecho] &lt; monton[indiceHijoIzquierdo]) {\n                intercambia(monton, i, indiceHijoIzquierdo);\n                i = indiceHijoIzquierdo;\n            } else {\n                intercambia(monton, i, indiceHijoDerecho);\n                i = indiceHijoDerecho;\n            }\n        }\n    }\n    return resultado;\n}\n\nprivate static void intercambia(int[] array, int i, int j) {\n    int t = array[i];\n    array[i] = array[j];\n    array[j] = t;\n}\n</code></pre> Mostrar soluci\u00f3n <p>En la extracci\u00f3n de los valores en orden (descendente) del array, para cada uno de ellos hay que hacer descender en el \u00e1rbol la nueva raiz, hasta que encuentre un lugar apropiado para que se siga cumpliendo la condici\u00f3n de heap. Y como el \u00e1rbol est\u00e1 siempre equilibrado, este descenso ser\u00e1, como mucho, de longitud log(n).</p> <p>Como, por otra parte, esta operaci\u00f3n ha de realizarse para cada uno de los valores del array, la complejidad de la extracci\u00f3n ordenada de los n valores ser\u00e1 de orden n\u00b7log(n). Con lo que se tiene una complejidad para el algoritmo de ordenaci\u00f3n completo (creaci\u00f3n del heap original m\u00e1s extracci\u00f3n ordenada de todos sus valores) de orden n\u00b7log(n) + n\u00b7log(n). Expresi\u00f3n que, seg\u00fan las reglas de combinaci\u00f3n de \u00f3rdenes de complejidad, equivale simplemente a n\u00b7log(n).</p>"},{"location":"exams/2014/p1r/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) En un museo se exhibe un cortometraje de corta duraci\u00f3n repetidamente, con un breve descanso entre proyecciones. La capacidad de la sala es de 50 personas. En el descanso, se vac\u00eda la sala y pueden entrar los visitantes que lo deseen, sin sobrepasar la capacidad de la sala. Una vez comenzada la proyecci\u00f3n, no se permite el acceso a nuevos visitantes, que quedan esperando al siguiente descanso.</li> </ul> <p>Escriba una clase Monitor que controle el acceso a la sala. Cada visitante es modelado como una hebra, que invoca el m\u00e9todo <code>accederASala()</code> del Monitor cuando desea ver la proyecci\u00f3n. Adem\u00e1s hay otra hebra, Proyector, que peri\u00f3dicamente invoca el m\u00e9todo <code>comienzaProyecci\u00f3n()</code> y, tras la finalizaci\u00f3n de la proyecci\u00f3n, invoca el m\u00e9todo <code>terminaProyecci\u00f3n()</code>.</p> <p>El monitor debe permitir acceso a la Sala a las hebras <code>Visitante</code> siempre que: - No se sobrepase la capacidad de la sala - No haya comenzado la proyecci\u00f3n</p> <p>Cuando la proyecci\u00f3n termine, se debe permitir que los visitantes que estaban esperando accedan a la sala. Se entiende que TODOS los asistentes a una proyecci\u00f3n salen de la sala al terminar la proyecci\u00f3n.</p> <p>SE PIDE EXCLUSIVAMENTE EL C\u00d3DIGO DEL MONITOR. NO ESCRIBA EL C\u00d3DIGO DE VISITANTE.</p> <p>A continuaci\u00f3n se incluye el c\u00f3digo del Proyector.</p> <pre><code>public class Proyector extends Thread\n{\n    private final Monitor monitor;\n    private final int duracionProyeccion = 15000;\n    private final int duracionDescanso = 5000;\n\n    Proyector (Monitor monitor) {\n        this.monitor = monitor;\n        this.start();\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                sleep(duracionDescanso);\n                monitor.comienzaProyeccion();\n                sleep(duracionProyeccion);\n                monitor.terminaProyeccion();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>```java</p> <p>private int N= 10; private int numVisitantes; private boolean proyectando;</p> <p>Monitor() {     numVisitantes= 0;     proyectando= false; }</p> <p>public synchronized void comienzaProyeccion() {     proyectando= true; }</p> <p>public synchronized void terminaProyeccion() {     proyectando= false;     numVisitantes= 0;     notifyAll(); }</p> <p>public synchronized void accederASala() {     while ( proyectando || numVisitantes &gt;= N)     {         try {             wait();         } catch (InterruptedException e) {         }     }     numVisitantes++; } ```</p>"},{"location":"exams/2014/p1r_ex01/","title":"P1r ex01","text":"<ul> <li>(a) (5 puntos) Se llama mont\u00f3n (heap) a un array de valores enteros en el que, representado como un \u00e1rbol binario, todo nodo es mayor o igual que culaquiera de sus dos hijos (si existen):</li> </ul> <p>Se ve que para todo nodo representado en la posici\u00f3n <code>i</code> de un array su hijo izquierdo se encuentra en la posici\u00f3n <code>2\u00b7i + 1</code> y su hijo derecho se encuentra en la posici\u00f3n <code>2\u00b7i + 2</code>.</p> <p>As\u00ed pues, para ordenar de mayor a menor un conjunto de valores enteros, basta con colocarlos primero como un mont\u00f3n, y despu\u00e9s ir extrayendo sucesivamente el primer valor del array (la ra\u00edz principal), y a continuaci\u00f3n recuperar el mont\u00f3n de los elementos restantes, hasta que no quede ning\u00fan elemento.</p> <p>Para recuperar el mont\u00f3n de los restantes elementos cuando se extrae el primer elemento de la tabla, basta con colocar en su lugar el \u00faltimo, y a continuaci\u00f3n hacer descender \u00e9ste en el \u00e1rbol iterativamente, si resulta necesario, hasta el nivel donde no sea menor que ninguno de sus dos (posibles) descendientes. Detr\u00e1s se puede ver el c\u00f3digo de esta operaci\u00f3n, aunque no resulta necesario en absoluto consultarlo, si se ha entendido correctamente este p\u00e1rrafo.</p> <p>Sabiendo que la operaci\u00f3n de construir un mont\u00f3n a partir de un array de enteros cualquiera tiene una complejidad del orden de n \u2217 log(n), se pide encontrar y justificar la complejidad del algoritmo completo de ordenaci\u00f3n descrito</p> <pre><code>private static int[] montonOrdenado(int[] monton) {\n    int[] resultado = new int[monton.length];\n\n    for (int j = 0; j &lt; monton.length; j++) {\n        resultado[j] = monton[0];\n\n        int ultimoIndice = monton.length - 1 - j;\n        monton[0] = monton[ultimoIndice];\n        --ultimoIndice;\n\n        int i = 0;\n        while (true) {\n            int indiceHijoIzquierdo = 2 * i + 1;\n            int indiceHijoDerecho = 2 * i + 2;\n\n            // No hay hijos\n            if (indiceHijoIzquierdo &gt; ultimoIndice)\n                break;\n\n            // Solo hay hijo izquierdo\n            if (indiceHijoDerecho &gt; ultimoIndice) {\n                if (monton[i] &lt; monton[indiceHijoIzquierdo])\n                    intercambia(monton, i, indiceHijoIzquierdo);\n                break;\n            }\n\n            // Ambos hijos son menores o iguales\n            if ((monton[i] &gt;= monton[indiceHijoIzquierdo])\n                    &amp;&amp; (monton[i] &gt;= monton[indiceHijoDerecho]))\n                break;\n\n            // Uno de los hijos es mayor\n            if (monton[indiceHijoDerecho] &lt; monton[indiceHijoIzquierdo]) {\n                intercambia(monton, i, indiceHijoIzquierdo);\n                i = indiceHijoIzquierdo;\n            } else {\n                intercambia(monton, i, indiceHijoDerecho);\n                i = indiceHijoDerecho;\n            }\n        }\n    }\n    return resultado;\n}\n\nprivate static void intercambia(int[] array, int i, int j) {\n    int t = array[i];\n    array[i] = array[j];\n    array[j] = t;\n}\n</code></pre> Mostrar soluci\u00f3n <p>En la extracci\u00f3n de los valores en orden (descendente) del array, para cada uno de ellos hay que hacer descender en el \u00e1rbol la nueva raiz, hasta que encuentre un lugar apropiado para que se siga cumpliendo la condici\u00f3n de heap. Y como el \u00e1rbol est\u00e1 siempre equilibrado, este descenso ser\u00e1, como mucho, de longitud log(n).</p> <p>Como, por otra parte, esta operaci\u00f3n ha de realizarse para cada uno de los valores del array, la complejidad de la extracci\u00f3n ordenada de los n valores ser\u00e1 de orden n\u00b7log(n). Con lo que se tiene una complejidad para el algoritmo de ordenaci\u00f3n completo (creaci\u00f3n del heap original m\u00e1s extracci\u00f3n ordenada de todos sus valores) de orden n\u00b7log(n) + n\u00b7log(n). Expresi\u00f3n que, seg\u00fan las reglas de combinaci\u00f3n de \u00f3rdenes de complejidad, equivale simplemente a n\u00b7log(n).</p>","tags":["complejidad"]},{"location":"exams/2014/p1r_ex02/","title":"P1r ex02","text":"<ul> <li>(a) (5 puntos) En un museo se exhibe un cortometraje de corta duraci\u00f3n repetidamente, con un breve descanso entre proyecciones. La capacidad de la sala es de 50 personas. En el descanso, se vac\u00eda la sala y pueden entrar los visitantes que lo deseen, sin sobrepasar la capacidad de la sala. Una vez comenzada la proyecci\u00f3n, no se permite el acceso a nuevos visitantes, que quedan esperando al siguiente descanso.</li> </ul> <p>Escriba una clase Monitor que controle el acceso a la sala. Cada visitante es modelado como una hebra, que invoca el m\u00e9todo <code>accederASala()</code> del Monitor cuando desea ver la proyecci\u00f3n. Adem\u00e1s hay otra hebra, Proyector, que peri\u00f3dicamente invoca el m\u00e9todo <code>comienzaProyecci\u00f3n()</code> y, tras la finalizaci\u00f3n de la proyecci\u00f3n, invoca el m\u00e9todo <code>terminaProyecci\u00f3n()</code>.</p> <p>El monitor debe permitir acceso a la Sala a las hebras <code>Visitante</code> siempre que: - No se sobrepase la capacidad de la sala - No haya comenzado la proyecci\u00f3n</p> <p>Cuando la proyecci\u00f3n termine, se debe permitir que los visitantes que estaban esperando accedan a la sala. Se entiende que TODOS los asistentes a una proyecci\u00f3n salen de la sala al terminar la proyecci\u00f3n.</p> <p>SE PIDE EXCLUSIVAMENTE EL C\u00d3DIGO DEL MONITOR. NO ESCRIBA EL C\u00d3DIGO DE VISITANTE.</p> <p>A continuaci\u00f3n se incluye el c\u00f3digo del Proyector.</p> <pre><code>public class Proyector extends Thread\n{\n    private final Monitor monitor;\n    private final int duracionProyeccion = 15000;\n    private final int duracionDescanso = 5000;\n\n    Proyector (Monitor monitor) {\n        this.monitor = monitor;\n        this.start();\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                sleep(duracionDescanso);\n                monitor.comienzaProyeccion();\n                sleep(duracionProyeccion);\n                monitor.terminaProyeccion();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>```java</p> <p>private int N= 10; private int numVisitantes; private boolean proyectando;</p> <p>Monitor() {     numVisitantes= 0;     proyectando= false; }</p> <p>public synchronized void comienzaProyeccion() {     proyectando= true; }</p> <p>public synchronized void terminaProyeccion() {     proyectando= false;     numVisitantes= 0;     notifyAll(); }</p> <p>public synchronized void accederASala() {     while ( proyectando || numVisitantes &gt;= N)     {         try {             wait();         } catch (InterruptedException e) {         }     }     numVisitantes++; } ```</p>","tags":["monitores"]},{"location":"exams/2014/p2/","title":"Examen 2014 \u2014 Parcial 2","text":""},{"location":"exams/2014/p2/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (5 puntos) En la pr\u00e1ctica 2 (Pacman en Android) deseamos a\u00f1adir una nueva funcionalidad: que los jugadores ganen puntos. Consideraremos que cada escenario tiene s\u00f3lo un jugador. El jugador ganar\u00e1 1 punto cada vez que se mueva y avance una casilla.</li> </ul> <p>Adem\u00e1s, deseamos que al guardar una partida en la base de datos se almacene la puntuaci\u00f3n, y que se recupere cuando se carga la partida. Al cargar una partida almacenada, se desea que DbLoadActivity muestre una lista de las partidas guardadas, mostrando en cada fila el nombre de la partida y los puntos obtenidos.</p> <p>Se pide: indique qu\u00e9 clases de la pr\u00e1ctica debe modificar y c\u00f3mo. Incluya exclusivamente las modificaciones realizadas. No hace falta que escriba completas las cabeceras de los m\u00e9todos. En caso de que tenga varias alternativas, justifique y discuta su respuesta. </p> <p>Nota. En MyDbAdapter, basta con que indique las modificaciones necesarias para crear la tabla e insertar una nueva partida.</p> mostrar soluci\u00f3n <p>Debemos a\u00f1adir un campo puntos. Se puede a\u00f1adir en Escenario o en Jugador.</p> <ol> <li>Jugador</li> </ol> <pre><code>private int puntos;\n...\npublic int getPuntos() { return puntos; }\npublic void setPuntos(int puntos) { this.puntos = puntos; }\npublic void incrementa(int puntos) { this.puntos += puntos; }\n\nprivate Jugador() { ...\n    puntos = 0;\n}\n</code></pre> <ol> <li>Terreno, m\u00e9todo move</li> </ol> <pre><code>public synchronized Casilla move(Movil movil, Direccion direccion) {\n    origen.setMovil(null);\n    destino.setMovil(movil);\n    movil.setCasilla(destino);\n    jugador.incrementa(1);\n    ...\n}\n</code></pre> <ol> <li>MyDbAdapter</li> </ol> <p>3.1. En DatabaseHelper, debemos cambiar el String para crear la tabla, a\u00f1adiendo una columna:</p> <pre><code>CREATE TABLE TABLE_FOTOS (id INTEGER PRIMARY KEY AUTOINCREMENT,\nname TEXT, moviles TEXT, casillas TEXT, date TEXT, puntos INT);\n</code></pre> <p>3.2. inserfFoto()</p> <pre><code>public static final String COL_PUNTOS = \"puntos\";\n\npublic long insertFoto(String name) {\n    Escenario escenario = Escenario.getInstance();\n    Jugador jugador = escenario.getTerreno().getJugador();\n    ContentValues values = new ContentValues();\n    values.put(COL_NAME, name);\n    values.put(COL_MOVILES, DbUtils.getStringMoviles(terreno));\n    values.put(COL_CASILLAS, DbUtils.getStringCasillas(terreno));\n    values.put(COL_DATE, prepareDate());\n    values.put(COL_PUNTOS, escenario.getPuntos());\n    return db.insert(TABLE_FOTOS, null, values);\n}\n</code></pre> <ol> <li>DbLoadActivity</li> </ol> <pre><code>public class DbLoadActivity extends ListActivity {\n    private static final String TAG = \u201cDbLoadActivity\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) { ...\n        String[] columns = { MyDbAdapter.COL_NAME, MyDbAdapter.COL_PUNTOS};\n        ...\n    }\n\n    protected void onListItemClick(ListView listView,\n        View view, int position, long id) {\n        ...\n        Jugador jugador = escenario.getTerreno().getJugador();\n        jugador.setPuntos(cursor.getInt(cursor.getColumnIndex(\n            MyDbAdapter.COL_PUNTOS));\n    }\n    ...\n}\n</code></pre>"},{"location":"exams/2014/p2/#problema-2","title":"Problema 2","text":"<p>Conteste a las siguientes preguntas:</p> <ul> <li>(a) (1,5 puntos) En un layout existe un widget de tipo EditText con id \u201ctelefono\u201d. Escribir el c\u00f3digo que extrae lo tecleado por el usuario en el widget y genera una traza con el contenido.</li> </ul> Mostrar soluci\u00f3n <pre><code>EditText telefono = (EditText) findViewById(R.id.telefono);\nString numero = telefono.getText().toString();\nLog.i.(TAG, \u201cTel\u00e9fono: \u201c + numero);\n</code></pre> <ul> <li>(b) (1,5 puntos) Estando en una actividad se desea pasar a otra actividad llamada PantallaActivity. Escribir el c\u00f3digo necesario para lanzar esta actividad pas\u00e1ndole un par\u00e1metro entero llamado \u201cn\u201d.</li> </ul> Mostrar soluci\u00f3n <pre><code>Intent intent = new Intent(this, PantallaActivity.class);\nintent.putExtra(\"n\", n);\nstartActivity(intent);\n</code></pre> <ul> <li>(c) (2 puntos) Necesitamos enviar un mensaje (String M) a una larga lista de destinatarios cuyas direcciones de email tenemos en una lista de direcciones <code>List&lt;Email&gt;</code>. Tenemos un m\u00e9todo para enviar un correo:</li> </ul> <pre><code>boolean send(Email direccion, String mensaje)\n</code></pre> <p>Como este m\u00e9todo puede ser lento, usaremos una AsyncTask para el env\u00edo a la lista. Suponga que llamamos al m\u00e9todo execute() pas\u00e1ndole como par\u00e1metro la String M. Escriba la cabecera y cuerpo del m\u00e9todo de la AsyncTask que se ejecuta en otra hebra (thread) de forma que ocurra lo siguiente:     - cada vez que termina el env\u00edo de un mensaje, se lanza un Toast en la UI-thread con un mensaje que pone el email y el boolean que ha devuelto el m\u00e9todo send()     - el resultado final es el tiempo transcurrido en la hebra as\u00edncrona en milisegundos (un entero largo)</p> Mostrar soluci\u00f3n <pre><code>class Correo extends AsyncTask&lt;String,String, Long&gt; {\n    List&lt;Email&gt; direcciones ...;\n\n    protected void onPreExecute() {...} // se ejecuta en la UIThread\n\n    // se ejecuta en una nueva hebra, diferente de la UI Thread\n    @Override\n    protected Long doInBackground(final String... params) {\n        Long t0 = System.currentTimeMillis();\n        String mensaje = params[0];\n        for (Email direccion : direcciones) {\n            boolean enviado = send(direccion, mensaje);\n            String resultado = direccion + \": \u201c + enviado;\n            publishProgress(resultado);\n        }\n        Long t1 = System.currentTimeMillis();\n        return t1 - t0;\n    }\n\n    protected void onProgressUpdate(String... message) {...} // en la UIThread\n    protected void onPostExecute(Long result) {...} // en la UIThread\n}\n</code></pre> <p>S\u00f3lo se da el c\u00f3digo del m\u00e9todo doInBackground, dado que los otros m\u00e9todos se ejecutan en la UIThread. En particular, los Toast que se mencionan en el enunciado se lanzan desde los m\u00e9todos     onProgressUpdate y onPostExecute, que se ejecutan en la hebra principal (UIThread).</p>"},{"location":"exams/2014/p2_ex01/","title":"P2 ex01","text":"<ul> <li>(a) (5 puntos) En la pr\u00e1ctica 2 (Pacman en Android) deseamos a\u00f1adir una nueva funcionalidad: que los jugadores ganen puntos. Consideraremos que cada escenario tiene s\u00f3lo un jugador. El jugador ganar\u00e1 1 punto cada vez que se mueva y avance una casilla.</li> </ul> <p>Adem\u00e1s, deseamos que al guardar una partida en la base de datos se almacene la puntuaci\u00f3n, y que se recupere cuando se carga la partida. Al cargar una partida almacenada, se desea que DbLoadActivity muestre una lista de las partidas guardadas, mostrando en cada fila el nombre de la partida y los puntos obtenidos.</p> <p>Se pide: indique qu\u00e9 clases de la pr\u00e1ctica debe modificar y c\u00f3mo. Incluya exclusivamente las modificaciones realizadas. No hace falta que escriba completas las cabeceras de los m\u00e9todos. En caso de que tenga varias alternativas, justifique y discuta su respuesta. </p> <p>Nota. En MyDbAdapter, basta con que indique las modificaciones necesarias para crear la tabla e insertar una nueva partida.</p> mostrar soluci\u00f3n <p>Debemos a\u00f1adir un campo puntos. Se puede a\u00f1adir en Escenario o en Jugador.</p> <ol> <li>Jugador</li> </ol> <pre><code>private int puntos;\n...\npublic int getPuntos() { return puntos; }\npublic void setPuntos(int puntos) { this.puntos = puntos; }\npublic void incrementa(int puntos) { this.puntos += puntos; }\n\nprivate Jugador() { ...\n    puntos = 0;\n}\n</code></pre> <ol> <li>Terreno, m\u00e9todo move</li> </ol> <pre><code>public synchronized Casilla move(Movil movil, Direccion direccion) {\n    origen.setMovil(null);\n    destino.setMovil(movil);\n    movil.setCasilla(destino);\n    jugador.incrementa(1);\n    ...\n}\n</code></pre> <ol> <li>MyDbAdapter</li> </ol> <p>3.1. En DatabaseHelper, debemos cambiar el String para crear la tabla, a\u00f1adiendo una columna:</p> <pre><code>CREATE TABLE TABLE_FOTOS (id INTEGER PRIMARY KEY AUTOINCREMENT,\nname TEXT, moviles TEXT, casillas TEXT, date TEXT, puntos INT);\n</code></pre> <p>3.2. inserfFoto()</p> <pre><code>public static final String COL_PUNTOS = \"puntos\";\n\npublic long insertFoto(String name) {\n    Escenario escenario = Escenario.getInstance();\n    Jugador jugador = escenario.getTerreno().getJugador();\n    ContentValues values = new ContentValues();\n    values.put(COL_NAME, name);\n    values.put(COL_MOVILES, DbUtils.getStringMoviles(terreno));\n    values.put(COL_CASILLAS, DbUtils.getStringCasillas(terreno));\n    values.put(COL_DATE, prepareDate());\n    values.put(COL_PUNTOS, escenario.getPuntos());\n    return db.insert(TABLE_FOTOS, null, values);\n}\n</code></pre> <ol> <li>DbLoadActivity</li> </ol> <pre><code>public class DbLoadActivity extends ListActivity {\n    private static final String TAG = \u201cDbLoadActivity\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) { ...\n        String[] columns = { MyDbAdapter.COL_NAME, MyDbAdapter.COL_PUNTOS};\n        ...\n    }\n\n    protected void onListItemClick(ListView listView,\n        View view, int position, long id) {\n        ...\n        Jugador jugador = escenario.getTerreno().getJugador();\n        jugador.setPuntos(cursor.getInt(cursor.getColumnIndex(\n            MyDbAdapter.COL_PUNTOS));\n    }\n    ...\n}\n</code></pre>","tags":["android"]},{"location":"exams/2014/p2_ex02/","title":"P2 ex02","text":"<p>Conteste a las siguientes preguntas:</p> <ul> <li>(a) (1,5 puntos) En un layout existe un widget de tipo EditText con id \u201ctelefono\u201d. Escribir el c\u00f3digo que extrae lo tecleado por el usuario en el widget y genera una traza con el contenido.</li> </ul> Mostrar soluci\u00f3n <pre><code>EditText telefono = (EditText) findViewById(R.id.telefono);\nString numero = telefono.getText().toString();\nLog.i.(TAG, \u201cTel\u00e9fono: \u201c + numero);\n</code></pre> <ul> <li>(b) (1,5 puntos) Estando en una actividad se desea pasar a otra actividad llamada PantallaActivity. Escribir el c\u00f3digo necesario para lanzar esta actividad pas\u00e1ndole un par\u00e1metro entero llamado \u201cn\u201d.</li> </ul> Mostrar soluci\u00f3n <pre><code>Intent intent = new Intent(this, PantallaActivity.class);\nintent.putExtra(\"n\", n);\nstartActivity(intent);\n</code></pre> <ul> <li>(c) (2 puntos) Necesitamos enviar un mensaje (String M) a una larga lista de destinatarios cuyas direcciones de email tenemos en una lista de direcciones <code>List&lt;Email&gt;</code>. Tenemos un m\u00e9todo para enviar un correo:</li> </ul> <pre><code>boolean send(Email direccion, String mensaje)\n</code></pre> <p>Como este m\u00e9todo puede ser lento, usaremos una AsyncTask para el env\u00edo a la lista. Suponga que llamamos al m\u00e9todo execute() pas\u00e1ndole como par\u00e1metro la String M. Escriba la cabecera y cuerpo del m\u00e9todo de la AsyncTask que se ejecuta en otra hebra (thread) de forma que ocurra lo siguiente:     - cada vez que termina el env\u00edo de un mensaje, se lanza un Toast en la UI-thread con un mensaje que pone el email y el boolean que ha devuelto el m\u00e9todo send()     - el resultado final es el tiempo transcurrido en la hebra as\u00edncrona en milisegundos (un entero largo)</p> Mostrar soluci\u00f3n <pre><code>class Correo extends AsyncTask&lt;String,String, Long&gt; {\n    List&lt;Email&gt; direcciones ...;\n\n    protected void onPreExecute() {...} // se ejecuta en la UIThread\n\n    // se ejecuta en una nueva hebra, diferente de la UI Thread\n    @Override\n    protected Long doInBackground(final String... params) {\n        Long t0 = System.currentTimeMillis();\n        String mensaje = params[0];\n        for (Email direccion : direcciones) {\n            boolean enviado = send(direccion, mensaje);\n            String resultado = direccion + \": \u201c + enviado;\n            publishProgress(resultado);\n        }\n        Long t1 = System.currentTimeMillis();\n        return t1 - t0;\n    }\n\n    protected void onProgressUpdate(String... message) {...} // en la UIThread\n    protected void onPostExecute(Long result) {...} // en la UIThread\n}\n</code></pre> <p>S\u00f3lo se da el c\u00f3digo del m\u00e9todo doInBackground, dado que los otros m\u00e9todos se ejecutan en la UIThread. En particular, los Toast que se mencionan en el enunciado se lanzan desde los m\u00e9todos     onProgressUpdate y onPostExecute, que se ejecutan en la hebra principal (UIThread).</p>","tags":["android"]},{"location":"exams/2015/extra/","title":"Examen 2015 \u2014 Extraordinario","text":""},{"location":"exams/2015/extra/#problema-1","title":"Problema 1","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n es [0, 2, 6, 9, 11, 15] (la soluci\u00f3n no es necesariamente \u00fanica).</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>int[] lis(int[] x) {\n    int n = x.length;\n    int[] p = new int[n];\n    int[] m = new int[n + 1];\n    int le = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        int lo = 1;\n        int hi = le;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi + 1) / 2;\n            if (x[m[mid]] &lt; x[i])\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        int newLe = lo;\n        p[i] = m[newLe - 1];\n        m[newLe] = i;\n        if (newLe &gt; le)\n            le = newLe;\n    }\n\n    int[] s = new int[le];\n    int k = m[le];\n    for (int i = le - 1; i &gt;= 0; i--) {\n        s[i] = x[k];\n        k = p[k];\n    }\n    return s;\n}\n</code></pre></p> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n de tama\u00f1o N de la secuencia de entrada, razonando la soluci\u00f3n. NOTA: A efectos del examen se valorar\u00e1 m\u00e1s el razonamiento que el resultado final.</li> </ul> Mostrar soluci\u00f3n <p>Al principio hay un doble bucle anidado, siendo el bucle externo de complejidad lineal, mientras que el bucle interno es en principio de complejidad logar\u00edtmica, ya que hace b\u00fasqueda dicot\u00f3mica en un intervalo de tama\u00f1o no mayor que n.  Visto en m\u00e1s detalle, el bucle interno empieza con un intervalo de una unidad y aumenta su tama\u00f1o como mucho en una unidad m\u00e1s en cada vuelta al bucle externo (algunas vueltas se incrementa en una unidad y algunas vueltas no se incrementa).  As\u00ed pues, su tiempo de ejecuci\u00f3n estar\u00e1 acotado por una constante que multiplica a (log 1 + log 2 ... log n), lo cual es igual a log(12...n), es decir, log(n!). Cantidad que puede acotarse tambi\u00e9n por log(n^n), es decir, nlog(n) (aplicando la f\u00f3rmula de Stirling se obtiene un valor mas aproximado, (nlog n - n), pero del mismo orden de complejidad). Es decir, el bucle doble tiene complejidad lineal logar\u00edtmica. Y a continuaci\u00f3n del bucle doble anidado hay un bucle simple que es de complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser lineal logar\u00edtmica. En t\u00e9rminos formales: </p> <p>C(for.while) = O(log 1 + log 2 ... log n) = O(log(12...n)) = O(log(n!)) = O(n*log n)</p> <p>C(lis) =</p> <p>= C(for.while) + C(for)</p> <p>= O(n*log n) + O(n)</p> <p>= O(n*log n)</p>"},{"location":"exams/2015/extra/#problema-2","title":"Problema 2","text":"<p>Un sistema est\u00e1 compuesto por un conjunto de hebras que deben acceder a un recurso compartido con exclusi\u00f3n mutua. Estas hebras se dividen en dos grupos: H1 y H2. Las hebras del grupo H2 acceden al recurso con prioridad respecto a las del grupo H1. Es decir, las hebras H1 no pueden acceder al recurso si hay alguna hebra H2 esperando. Adem\u00e1s, las hebras del grupo H1 deben acceder al recurso en el mismo orden en el que lo han solicitado.</p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor GestorRecurso que gestione el acceso al recurso, de acuerdo a las caracter\u00edsticas descritas. El monitor deber\u00e1 tener tres operaciones:<ul> <li>\u2026 solicitarRecursoH1(): Este m\u00e9todo lo invocan las hebras del grupo H1 para solicitar acceso al recurso.</li> <li>\u2026 solicitarRecursoH2(): Este m\u00e9todo lo invocan las hebras del grupo H2 para solicitar acceso al recurso.</li> <li>\u2026 liberarRecurso(): Este m\u00e9todo lo invocan las hebras de los dos grupos para liberar el recurso.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorRecurso {\n    private int turno = 0;\n    private int ultimoSolicitar = 0;\n    private int nH2Esperando = 0;\n    private boolean recursoOcupado = false;\n\n    public synchronized void SolicitarRecursoH1() throws InterruptedException {\n        int miTurno = ultimoSolicitar;\n        ultimoSolicitar++;\n        while (miTurno &gt; turno || nH2Esperando &gt; 0 || recursoOcupado) {\n            wait();\n        }\n        turno++;\n        recursoOcupado = true;\n    }\n\n    public synchronized void SolicitarRecursoH2() throws InterruptedException {\n        nH2Esperando++;\n        while (recursoOcupado) {\n            wait();\n        }\n        recursoOcupado = true;\n        nH2Esperando--;\n    }\n\n    public synchronized void LiberarRecurso() {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2015/extra/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (2 puntos) En el pacman presentado como proyecto 1, queremos modificar el comportamiento del Fantasma00 de forma que evite acercarse a los Depredadores. Los Depredadores no saben nada del asco que suscitan. Suponga que nos facilitan un m\u00e9todo en Terreno que nos dice si hay un depredador a menos de 3 casillas de distancia de la que pasamos como argumento:</li> </ul> <p>public synchronized boolean hayDepredador(Casilla casilla)</p> <pre><code>- \u00bfPodemos hacerlo en el m\u00e9todo run() de Fantasma00?Razone si s\u00ed o si no.\n- \u00bfPodemos hacerlo en el m\u00e9todo puedoMoverme() de Fantasma00? Razone si s\u00ed o si no.\n- Si cree que se puede hacer de ambas maneras, indique ventajas e inconvenientes de una y otra opci\u00f3n\n</code></pre> Mostrar soluci\u00f3n <ul> <li>S\u00ed se puede en run().</li> <li>Se puede optimizar el movimiento huyendo del depredador (moviendo en direcci\u00f3n opuesta).</li> <li>Se ejecuta fuera de la zona cr\u00edtica y el depredador y dem\u00e1s fantasmas se pueden mover mientras estamos eligiendo a d\u00f3nde ir.</li> <li>S\u00ed se puede en puedoMoverme().</li> <li>S\u00f3lo podemos hacer que el fantasma espere, sin moverse.</li> <li>se ejecuta dentro de la zona cr\u00edtica de forma que el depredador y todos los fantasmas est\u00e1n quietos mientras tomamos la decisi\u00f3n.</li> </ul>"},{"location":"exams/2015/extra/#problema-4","title":"Problema 4","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione los gastos de un usuario. Cada vez que se realiza un gasto, el usuario puede introducir la cantidad gastada (\u201cImporte\u201d, campo num\u00e9rico real) y en qu\u00e9 se lo ha gastado (\u201cConcepto\u201d, de tipo texto). Estos registros se guardar\u00e1n en una base de datos sqlite, con una \u00fanica tabla. La aplicaci\u00f3n mostrar\u00e1 los registros existentes mediante una ListActivity. </p> <p>La aplicaci\u00f3n dispone de un men\u00fa con dos opciones, \u201cA\u00f1adir\u201d y \u201cAcerca de\u201d. La especificaci\u00f3n del men\u00fa es la siguiente:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;item\n        android:id=\"@+id/annadir\"\n        android:title=\"A\u00f1adir\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/ayuda\"\n        android:title=\"Acerca de\" /&gt;\n\n&lt;/menu&gt;\n</code></pre> <p>La sentencia SQL para crear la tabla en la base de datos es:</p> <pre><code>CREATE TABLE gastos (_id INTEGER PRIMARY KEY AUTOINCREMENT, Concepto TEXT NOT NULL, Importe REAL NOT NULL)\n</code></pre> <p>La aplicaci\u00f3n dispone de un adaptador de bases de datos, con la siguiente codificaci\u00f3n (parcial):</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba una sentencia SQL que devuelva todos los registros de la base de datos cuyo importe supere el valor de 50,00.</li> </ul> Mostrar soluci\u00f3n <pre><code>SELECT * FROM gastos WHERE Importe &gt; 50;\n</code></pre> <ul> <li> <p>(b) (1 punto) Sobreescriba el m\u00e9todo adecuado de ListActivity para implementar el siguiente comportamiento:</p> <ul> <li>1) la opci\u00f3n \u201cAcerca de\u201d muestra un Toast con el nombre del autor del c\u00f3digo (usted);</li> <li>2) la opci\u00f3n \u201cA\u00f1adir\u201d se lance otra actividad llamada \u201cAnadirGastoActivity\u201d que ya est\u00e1 implementada.</li> </ul> <p>Tenga en cuenta que \u201cAnadirGastoActivity\u201d devolver\u00e1 un Intent con los datos del usuario.</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n\n        case R.id.ayuda:\n            Toast.makeText(\n                    this,\n                    getString(R.string.msg_ayuda),\n                    Toast.LENGTH_SHORT\n            ).show();\n            return true;\n\n        case R.id.annadir: {\n            Intent miIntent = new Intent(\n                    this,\n                    AnadirGastoActivity.class\n            );\n            miIntent.putExtra(REQUEST_CODE, CREA_PRODUCTO);\n            startActivityForResult(miIntent, CREA_PRODUCTO);\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfQu\u00e9 m\u00e9todos relativos al ciclo de vida de las actividades ListActivity y AnadirGastoActivity se ejecutan desde que se selecciona la opci\u00f3n \u201cA\u00f1adir\u201d del men\u00fa hasta que se vuelve a mostrar la lista de gasto? Escriba s\u00f3lo el nombre del m\u00e9todo y la actividad a la que pertenece, y el orden adecuado.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Actividad onPause() ListActivity onCreate() AnadirGastoActivity onStart() AnadirGastoActivity onResume() AnadirGastoActivity onStop() AnadirGastoActivity onPause() AnadirGastoActivity onRestart() ListActivity onStart() ListActivity onResume() ListActivity onStop() AnadirGastoActivity <ul> <li>(d) (1 punto) Escriba un m\u00e9todo de la clase DatabaseHelper que a\u00f1ada un nuevo registro a la base de datos. La informaci\u00f3n del Concepto y del Importe se pasar\u00e1 como par\u00e1metros del m\u00e9todo.</li> </ul> Mostrar soluci\u00f3n <pre><code>public long creaProducto(String gasto, float importe) {\n    ContentValues valoresIniciales = new ContentValues();\n\n    valoresIniciales.put(\"Concepto\", gasto);\n    valoresIniciales.put(\"Importe\", importe);\n\n    return db.insert(DATABASE_TABLE, null, valoresIniciales);\n}\n</code></pre> <ul> <li>(e) (1 punto) Escriba una especificaci\u00f3n de layout adecuada que se pueda utilizar en la actividad \u201cAnadirGastoActivity\u201d. Adem\u00e1s de los campos de informaci\u00f3n, dispondr\u00e1 de un bot\u00f3n \u201cGuardar\u201d y otro \u201cCancelar\u201d (s\u00f3lo hay que poner los botones). </li> </ul> Mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent \"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content \"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Concepto \" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editConcepto\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"&gt;\n        &lt;/EditText&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cantidad \u201c /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editTextCantidad\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:inputType=\"numberDecimal\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout android:orientation=\"horizontal\"&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonGuardar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Guardar\" /&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonCancelar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cancelar\" /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>"},{"location":"exams/2015/extra/#problema-5","title":"Problema 5","text":"<ul> <li>(a) (2 puntos) El proyecto 2 se basa en una adaptaci\u00f3n del proyecto 1. Seleccione la respuesta o respuestas correctas en la hoja de respuestas. Las respuestas incorrectas restan.<ul> <li> <ol> <li>La clase Terreno se adapta al ciclo de vida de Android</li> <li>I. No ser\u00eda imprescindible realizar esta adaptaci\u00f3n; simplemente la aplicaci\u00f3n seguir\u00eda usando recursos cuando no est\u00e1 en primer plano.</li> <li>II. Si no hacemos la adaptaci\u00f3n, tendremos interbloqueos.</li> <li>III. Los m\u00f3viles se congelan en onPause() y se descongelan en onResume().</li> <li>IV. Los m\u00f3viles se resucitan en onCreate()</li> </ol> </li> <li> <ol> <li>Las clases que extienden Movil (p.ej. Jugador, Estatua, Depredador, \u2026)</li> <li>I. Deben implementar restart() porque es un m\u00e9todo abstracto en Movil</li> <li>II. Si adem\u00e1s implementan Runnable, deben crear en restart() una hebra (new Thread()) y llamar a start() en la hebra creada</li> <li>III. Si adem\u00e1 s implementan Runnable, deben crear en pause() una hebra (new Thread()) y llamar a pause() en la hebra creada</li> <li>IV. Siempre que extienden Movil deben implementar Runnable</li> </ol> </li> </ul> </li> </ul> Mostrar soluci\u00f3n <ul> <li> <p>En 1 la opci\u00f3n correcta es III.</p> </li> <li> <p>En 2 las opciones correctas son III y IV.</p> </li> </ul> <ul> <li>(b) (3 puntos) Deseamos simplificar el comportamiento que hemos implementado el proyecto 2 para mover con el dedo el jugador. El nuevo comportamiento consiste en que si pulsamos en la casilla donde est\u00e1 el jugador, lanza un popup. Si pulsamos en una casilla diferente, el jugador se mueve en la direcci\u00f3n en la que est\u00e1 dicha casilla respecto del jugador.</li> </ul> <p>Adem\u00e1s, queremos poner una traza de error si se pulsa fuera del tablero.</p> <p>Suponga que dispone del m\u00e9todo popup para lanzar el popup como en la pr\u00e1ctica, as\u00ed como el resto de m\u00e9todos de las clases.</p> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onTouch(View view, MotionEvent event) {\n    try {\n        Movil jugador = terreno.getJugador();\n        if (jugador == null) {\n            return false;\n        }\n\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            int x1 = (int) (event.getX() / lado1);\n            int y1 = terreno.getN() - 1 - (int) (event.getY() / lado1);\n\n            Casilla casilla = terreno.getCasilla(x1, y1);\n            Casilla casillaJugador = jugador.getCasilla();\n\n            if (casillaJugador.equals(casilla)) {\n                popup(casilla);\n            } else {\n                int dx = (int) (x1 - casillaJugador.getX());\n                int dy = (int) (y1 - casillaJugador.getY());\n                Direccion direccion = null;\n\n                if (dy &gt; 0)\n                    direccion = Direccion.NORTE;\n                else if (dy &lt; 0)\n                    direccion = Direccion.SUR;\n                else if (dx &gt; 0)\n                    direccion = Direccion.ESTE;\n                else if (dx &lt; 0)\n                    direccion = Direccion.OESTE;\n\n                if (direccion != null) {\n                    terreno.move(jugador, direccion);\n                }\n            }\n        }\n    } catch (Exception e) {\n        Log.e(TAG, \"Ha pulsado fuera del tablero\");\n    }\n    return false;\n}\n</code></pre>"},{"location":"exams/2015/extra_ex01/","title":"Extra ex01","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n es [0, 2, 6, 9, 11, 15] (la soluci\u00f3n no es necesariamente \u00fanica).</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>int[] lis(int[] x) {\n    int n = x.length;\n    int[] p = new int[n];\n    int[] m = new int[n + 1];\n    int le = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        int lo = 1;\n        int hi = le;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi + 1) / 2;\n            if (x[m[mid]] &lt; x[i])\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        int newLe = lo;\n        p[i] = m[newLe - 1];\n        m[newLe] = i;\n        if (newLe &gt; le)\n            le = newLe;\n    }\n\n    int[] s = new int[le];\n    int k = m[le];\n    for (int i = le - 1; i &gt;= 0; i--) {\n        s[i] = x[k];\n        k = p[k];\n    }\n    return s;\n}\n</code></pre></p> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n de tama\u00f1o N de la secuencia de entrada, razonando la soluci\u00f3n. NOTA: A efectos del examen se valorar\u00e1 m\u00e1s el razonamiento que el resultado final.</li> </ul> Mostrar soluci\u00f3n <p>Al principio hay un doble bucle anidado, siendo el bucle externo de complejidad lineal, mientras que el bucle interno es en principio de complejidad logar\u00edtmica, ya que hace b\u00fasqueda dicot\u00f3mica en un intervalo de tama\u00f1o no mayor que n.  Visto en m\u00e1s detalle, el bucle interno empieza con un intervalo de una unidad y aumenta su tama\u00f1o como mucho en una unidad m\u00e1s en cada vuelta al bucle externo (algunas vueltas se incrementa en una unidad y algunas vueltas no se incrementa).  As\u00ed pues, su tiempo de ejecuci\u00f3n estar\u00e1 acotado por una constante que multiplica a (log 1 + log 2 ... log n), lo cual es igual a log(12...n), es decir, log(n!). Cantidad que puede acotarse tambi\u00e9n por log(n^n), es decir, nlog(n) (aplicando la f\u00f3rmula de Stirling se obtiene un valor mas aproximado, (nlog n - n), pero del mismo orden de complejidad). Es decir, el bucle doble tiene complejidad lineal logar\u00edtmica. Y a continuaci\u00f3n del bucle doble anidado hay un bucle simple que es de complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser lineal logar\u00edtmica. En t\u00e9rminos formales: </p> <p>C(for.while) = O(log 1 + log 2 ... log n) = O(log(12...n)) = O(log(n!)) = O(n*log n)</p> <p>C(lis) =</p> <p>= C(for.while) + C(for)</p> <p>= O(n*log n) + O(n)</p> <p>= O(n*log n)</p>","tags":["complejidad"]},{"location":"exams/2015/extra_ex02/","title":"Extra ex02","text":"<p>Un sistema est\u00e1 compuesto por un conjunto de hebras que deben acceder a un recurso compartido con exclusi\u00f3n mutua. Estas hebras se dividen en dos grupos: H1 y H2. Las hebras del grupo H2 acceden al recurso con prioridad respecto a las del grupo H1. Es decir, las hebras H1 no pueden acceder al recurso si hay alguna hebra H2 esperando. Adem\u00e1s, las hebras del grupo H1 deben acceder al recurso en el mismo orden en el que lo han solicitado.</p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor GestorRecurso que gestione el acceso al recurso, de acuerdo a las caracter\u00edsticas descritas. El monitor deber\u00e1 tener tres operaciones:<ul> <li>\u2026 solicitarRecursoH1(): Este m\u00e9todo lo invocan las hebras del grupo H1 para solicitar acceso al recurso.</li> <li>\u2026 solicitarRecursoH2(): Este m\u00e9todo lo invocan las hebras del grupo H2 para solicitar acceso al recurso.</li> <li>\u2026 liberarRecurso(): Este m\u00e9todo lo invocan las hebras de los dos grupos para liberar el recurso.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorRecurso {\n    private int turno = 0;\n    private int ultimoSolicitar = 0;\n    private int nH2Esperando = 0;\n    private boolean recursoOcupado = false;\n\n    public synchronized void SolicitarRecursoH1() throws InterruptedException {\n        int miTurno = ultimoSolicitar;\n        ultimoSolicitar++;\n        while (miTurno &gt; turno || nH2Esperando &gt; 0 || recursoOcupado) {\n            wait();\n        }\n        turno++;\n        recursoOcupado = true;\n    }\n\n    public synchronized void SolicitarRecursoH2() throws InterruptedException {\n        nH2Esperando++;\n        while (recursoOcupado) {\n            wait();\n        }\n        recursoOcupado = true;\n        nH2Esperando--;\n    }\n\n    public synchronized void LiberarRecurso() {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2015/extra_ex03/","title":"Extra ex03","text":"<ul> <li>(a) (2 puntos) En el pacman presentado como proyecto 1, queremos modificar el comportamiento del Fantasma00 de forma que evite acercarse a los Depredadores. Los Depredadores no saben nada del asco que suscitan. Suponga que nos facilitan un m\u00e9todo en Terreno que nos dice si hay un depredador a menos de 3 casillas de distancia de la que pasamos como argumento:</li> </ul> <p>public synchronized boolean hayDepredador(Casilla casilla)</p> <pre><code>- \u00bfPodemos hacerlo en el m\u00e9todo run() de Fantasma00?Razone si s\u00ed o si no.\n- \u00bfPodemos hacerlo en el m\u00e9todo puedoMoverme() de Fantasma00? Razone si s\u00ed o si no.\n- Si cree que se puede hacer de ambas maneras, indique ventajas e inconvenientes de una y otra opci\u00f3n\n</code></pre> Mostrar soluci\u00f3n <ul> <li>S\u00ed se puede en run().</li> <li>Se puede optimizar el movimiento huyendo del depredador (moviendo en direcci\u00f3n opuesta).</li> <li>Se ejecuta fuera de la zona cr\u00edtica y el depredador y dem\u00e1s fantasmas se pueden mover mientras estamos eligiendo a d\u00f3nde ir.</li> <li>S\u00ed se puede en puedoMoverme().</li> <li>S\u00f3lo podemos hacer que el fantasma espere, sin moverse.</li> <li>se ejecuta dentro de la zona cr\u00edtica de forma que el depredador y todos los fantasmas est\u00e1n quietos mientras tomamos la decisi\u00f3n.</li> </ul>","tags":["monitores"]},{"location":"exams/2015/extra_ex04/","title":"Extra ex04","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione los gastos de un usuario. Cada vez que se realiza un gasto, el usuario puede introducir la cantidad gastada (\u201cImporte\u201d, campo num\u00e9rico real) y en qu\u00e9 se lo ha gastado (\u201cConcepto\u201d, de tipo texto). Estos registros se guardar\u00e1n en una base de datos sqlite, con una \u00fanica tabla. La aplicaci\u00f3n mostrar\u00e1 los registros existentes mediante una ListActivity. </p> <p>La aplicaci\u00f3n dispone de un men\u00fa con dos opciones, \u201cA\u00f1adir\u201d y \u201cAcerca de\u201d. La especificaci\u00f3n del men\u00fa es la siguiente:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;item\n        android:id=\"@+id/annadir\"\n        android:title=\"A\u00f1adir\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/ayuda\"\n        android:title=\"Acerca de\" /&gt;\n\n&lt;/menu&gt;\n</code></pre> <p>La sentencia SQL para crear la tabla en la base de datos es:</p> <pre><code>CREATE TABLE gastos (_id INTEGER PRIMARY KEY AUTOINCREMENT, Concepto TEXT NOT NULL, Importe REAL NOT NULL)\n</code></pre> <p>La aplicaci\u00f3n dispone de un adaptador de bases de datos, con la siguiente codificaci\u00f3n (parcial):</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba una sentencia SQL que devuelva todos los registros de la base de datos cuyo importe supere el valor de 50,00.</li> </ul> Mostrar soluci\u00f3n <pre><code>SELECT * FROM gastos WHERE Importe &gt; 50;\n</code></pre> <ul> <li> <p>(b) (1 punto) Sobreescriba el m\u00e9todo adecuado de ListActivity para implementar el siguiente comportamiento:</p> <ul> <li>1) la opci\u00f3n \u201cAcerca de\u201d muestra un Toast con el nombre del autor del c\u00f3digo (usted);</li> <li>2) la opci\u00f3n \u201cA\u00f1adir\u201d se lance otra actividad llamada \u201cAnadirGastoActivity\u201d que ya est\u00e1 implementada.</li> </ul> <p>Tenga en cuenta que \u201cAnadirGastoActivity\u201d devolver\u00e1 un Intent con los datos del usuario.</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n\n        case R.id.ayuda:\n            Toast.makeText(\n                    this,\n                    getString(R.string.msg_ayuda),\n                    Toast.LENGTH_SHORT\n            ).show();\n            return true;\n\n        case R.id.annadir: {\n            Intent miIntent = new Intent(\n                    this,\n                    AnadirGastoActivity.class\n            );\n            miIntent.putExtra(REQUEST_CODE, CREA_PRODUCTO);\n            startActivityForResult(miIntent, CREA_PRODUCTO);\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfQu\u00e9 m\u00e9todos relativos al ciclo de vida de las actividades ListActivity y AnadirGastoActivity se ejecutan desde que se selecciona la opci\u00f3n \u201cA\u00f1adir\u201d del men\u00fa hasta que se vuelve a mostrar la lista de gasto? Escriba s\u00f3lo el nombre del m\u00e9todo y la actividad a la que pertenece, y el orden adecuado.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Actividad onPause() ListActivity onCreate() AnadirGastoActivity onStart() AnadirGastoActivity onResume() AnadirGastoActivity onStop() AnadirGastoActivity onPause() AnadirGastoActivity onRestart() ListActivity onStart() ListActivity onResume() ListActivity onStop() AnadirGastoActivity <ul> <li>(d) (1 punto) Escriba un m\u00e9todo de la clase DatabaseHelper que a\u00f1ada un nuevo registro a la base de datos. La informaci\u00f3n del Concepto y del Importe se pasar\u00e1 como par\u00e1metros del m\u00e9todo.</li> </ul> Mostrar soluci\u00f3n <pre><code>public long creaProducto(String gasto, float importe) {\n    ContentValues valoresIniciales = new ContentValues();\n\n    valoresIniciales.put(\"Concepto\", gasto);\n    valoresIniciales.put(\"Importe\", importe);\n\n    return db.insert(DATABASE_TABLE, null, valoresIniciales);\n}\n</code></pre> <ul> <li>(e) (1 punto) Escriba una especificaci\u00f3n de layout adecuada que se pueda utilizar en la actividad \u201cAnadirGastoActivity\u201d. Adem\u00e1s de los campos de informaci\u00f3n, dispondr\u00e1 de un bot\u00f3n \u201cGuardar\u201d y otro \u201cCancelar\u201d (s\u00f3lo hay que poner los botones). </li> </ul> Mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent \"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content \"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Concepto \" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editConcepto\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"&gt;\n        &lt;/EditText&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cantidad \u201c /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editTextCantidad\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:inputType=\"numberDecimal\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout android:orientation=\"horizontal\"&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonGuardar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Guardar\" /&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonCancelar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cancelar\" /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>","tags":["android"]},{"location":"exams/2015/extra_ex05/","title":"Extra ex05","text":"<ul> <li>(a) (2 puntos) El proyecto 2 se basa en una adaptaci\u00f3n del proyecto 1. Seleccione la respuesta o respuestas correctas en la hoja de respuestas. Las respuestas incorrectas restan.<ul> <li> <ol> <li>La clase Terreno se adapta al ciclo de vida de Android</li> <li>I. No ser\u00eda imprescindible realizar esta adaptaci\u00f3n; simplemente la aplicaci\u00f3n seguir\u00eda usando recursos cuando no est\u00e1 en primer plano.</li> <li>II. Si no hacemos la adaptaci\u00f3n, tendremos interbloqueos.</li> <li>III. Los m\u00f3viles se congelan en onPause() y se descongelan en onResume().</li> <li>IV. Los m\u00f3viles se resucitan en onCreate()</li> </ol> </li> <li> <ol> <li>Las clases que extienden Movil (p.ej. Jugador, Estatua, Depredador, \u2026)</li> <li>I. Deben implementar restart() porque es un m\u00e9todo abstracto en Movil</li> <li>II. Si adem\u00e1s implementan Runnable, deben crear en restart() una hebra (new Thread()) y llamar a start() en la hebra creada</li> <li>III. Si adem\u00e1 s implementan Runnable, deben crear en pause() una hebra (new Thread()) y llamar a pause() en la hebra creada</li> <li>IV. Siempre que extienden Movil deben implementar Runnable</li> </ol> </li> </ul> </li> </ul> Mostrar soluci\u00f3n <ul> <li> <p>En 1 la opci\u00f3n correcta es III.</p> </li> <li> <p>En 2 las opciones correctas son III y IV.</p> </li> </ul> <ul> <li>(b) (3 puntos) Deseamos simplificar el comportamiento que hemos implementado el proyecto 2 para mover con el dedo el jugador. El nuevo comportamiento consiste en que si pulsamos en la casilla donde est\u00e1 el jugador, lanza un popup. Si pulsamos en una casilla diferente, el jugador se mueve en la direcci\u00f3n en la que est\u00e1 dicha casilla respecto del jugador.</li> </ul> <p>Adem\u00e1s, queremos poner una traza de error si se pulsa fuera del tablero.</p> <p>Suponga que dispone del m\u00e9todo popup para lanzar el popup como en la pr\u00e1ctica, as\u00ed como el resto de m\u00e9todos de las clases.</p> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onTouch(View view, MotionEvent event) {\n    try {\n        Movil jugador = terreno.getJugador();\n        if (jugador == null) {\n            return false;\n        }\n\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            int x1 = (int) (event.getX() / lado1);\n            int y1 = terreno.getN() - 1 - (int) (event.getY() / lado1);\n\n            Casilla casilla = terreno.getCasilla(x1, y1);\n            Casilla casillaJugador = jugador.getCasilla();\n\n            if (casillaJugador.equals(casilla)) {\n                popup(casilla);\n            } else {\n                int dx = (int) (x1 - casillaJugador.getX());\n                int dy = (int) (y1 - casillaJugador.getY());\n                Direccion direccion = null;\n\n                if (dy &gt; 0)\n                    direccion = Direccion.NORTE;\n                else if (dy &lt; 0)\n                    direccion = Direccion.SUR;\n                else if (dx &gt; 0)\n                    direccion = Direccion.ESTE;\n                else if (dx &lt; 0)\n                    direccion = Direccion.OESTE;\n\n                if (direccion != null) {\n                    terreno.move(jugador, direccion);\n                }\n            }\n        }\n    } catch (Exception e) {\n        Log.e(TAG, \"Ha pulsado fuera del tablero\");\n    }\n    return false;\n}\n</code></pre>","tags":["android"]},{"location":"exams/2015/p1/","title":"Examen 2015 \u2014 Parcial 1","text":""},{"location":"exams/2015/p1/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (5 puntos) Como medida de similitud (o diferencia) entre dos documentos dados, representados como ficheros de texto, compa\u00f1\u00edas como Google utilizan el concepto de \u201cdistancia\u201d (o su contrario, \u201cproximidad\u201d) entre dos documentos, seg\u00fan el algoritmo que se describe a continuaci\u00f3n. </li> </ul> <p>Se descomponen los dos ficheros de texto en palabras y, para cada uno de los dos ficheros, se construye un vector ordenado con tantos componentes como palabras diferentes hay entre los dos ficheros, siendo el valor de cada elemento el n\u00famero de veces que la palabra en cuesti\u00f3n se repite en el fichero de texto dado. En especial, si una determinada palabra existe en un fichero pero no en el otro, el valor correspondiente para el segundo vector,  es cero. Por ejemplo, </p> Palabra d1 d2 \u00e1rbol 5 7 barco 2 0 \u2026 \u2026 \u2026 zapatiesta 0 3 <p>La palabra \u2018\u00e1rbol\u2019 aparece 5 veces en el fichero 1 y 7 veces en el 2. La palabra \u2018barco\u2019 no aparece en el fichero 2. La palabra \u2018zapatiesta\u2019 no aparece en el fichero 1.</p> <p>A continuaci\u00f3n se realiza el producto escalar de los dos vectores que, una vez dividido por el producto del n\u00famero total de palabras que hay en cada uno de los dos textos, nos da como resultado la medida de proximidad entre los dos documentos dados. </p> <p>Suponiendo que los dos documentos a comparar tienen una longitud similar, digamos N caracteres, y que la longitud m\u00e1xima de una palabra en espa\u00f1ol es K, se pide dar la complejidad del algoritmo descrito en t\u00e9rminos de N, a base de justificar la complejidad de cada una de las partes de las que se compone (el algoritmo). </p> <p>NOTA: Si no puede justificar la complejidad del algoritmo de ordenaci\u00f3n, considere que es O(NlogN).</p> Mostrar soluci\u00f3n <p>La extracci\u00f3n de las palabras se realiza iterando dentro de un simple bucle a lo largo de cada uno de los dos textos, lo cual da una complejidad lineal, es decir, O(N). </p> <p>Cada vez que en el bucle anterior se encuentra una palabra, se consultan y actualizan dos HashMap, cuyas operaciones son en todo caso de orden constante, y se hacen un n\u00famero m\u00e1ximo de ellas finito (y peque\u00f1o) por cada palabra encontrada, por lo que la fase anterior no ve modificada su complejidad de O(N). </p> <p>A continuaci\u00f3n han de construirse los dos vectores ordenados a partir de los valores que est\u00e1n desordenados en los HashMap, lo cual nos dicen que tiene una complejidad de O(N*logN). </p> <p>Por \u00faltimo, el c\u00e1lculo del producto escalar es otro bucle simple, repetido tantas veces como palabras diferentes hay, de una multiplicaci\u00f3n (complejidad constante) m\u00e1s una suma (tambi\u00e9n complejidad constante), lo cual da una complejidad para el producto escalar de O(N). La divisi\u00f3n posterior, siendo una sola y de complejidad constante, no cambia la complejidad de esta fase.  </p> <p>Asi pues, la complejidad total ser\u00e1, sumando las de cada una de sus tres fases, </p> <p>O(N) + O(NlogN) + O(N), lo cual se reduce, simplemente, a O(NlogN).</p>"},{"location":"exams/2015/p1/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (4 puntos) Se pretende sincronizar la fabricaci\u00f3n en una l\u00ednea de ensamblado de mesas. Hay varios fabricantes de patas, que las depositan en una l\u00ednea con un l\u00edmite de capacidad MAX_NUM_PATAS. Cuando se llena, los fabricantes dejan de producir patas hasta que haya hueco libre. Hay varios fabricantes de tableros, que depositan en otra l\u00ednea de capacidad limitada MAX_NUM_TABLEROS. Por \u00faltimo, hay varios ensambladores de mesas: cada uno coge cuatro patas y un tablero y ensambla una mesa. </li> </ul> <p>Se trata de escribir en Java un monitor que sincronice estos tres sistemas, de forma que la producci\u00f3n se detenga cuando se alcanza la capacidad m\u00e1xima de almacenamiento (de patas o tableros independientemente) y sistema de ensamblaje no avance si le faltan piezas para hacer una nueva mesa. </p> <p>NO ESCRIBA NING\u00daN C\u00d3DIGO para los subsistemas de producci\u00f3n y ensamblaje. </p> <p>El sincronizador responde al siguiente esquema: <pre><code>class Sincronizador { \n    ...  \n    ... ponPata() {...}    // lo invoca el productor de patas por cada una \n    ... ponTablero() {...} // lo invoca el productor de tableros \n    ... cogePatasyTablero () {...}   // lo invoca el ensamblador de mesas \n    ... \n} \n</code></pre> Se pide: Desarrollar el c\u00f3digo completo del monitor sincronizador.</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.em;\n\npublic class Sincronizador {\n\n   private static final int NUM_MAX_PATAS    = 10;\n   private static final int NUM_MAX_TABLEROS = 4;\n   private int numPatas = 0;\n   private int numTableros = 0;\n\n   public synchronized void ponTablero() throws InterruptedException {\n      while (numTableros &gt;= NUM_MAX_TABLEROS)\n      {\n         wait();\n      }\n\n      numTableros++;\n\n      notifyAll();\n   }\n\n   public synchronized void ponPatas() throws InterruptedException {\n      while (numPatas &gt;= NUM_MAX_PATAS)\n      {\n         wait();\n      }\n\n      numPatas++;\n\n      notifyAll();\n   }\n\n   public synchronized void cogePatasyTablero() throws InterruptedException {\n      while (numTableros &lt; 1 || numPatas &lt; 4)\n      {\n         wait();\n      }\n\n      numTableros--;\n      numPatas -= 4;\n\n      notifyAll();\n   }\n\n}\n</code></pre></p>"},{"location":"exams/2015/p1/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (1 punto) Describa dos casos posibles de error significativamente diferentes para detectar errores de la clase Paredes del alumno en el borde del tablero (concretamente en la casilla (0, 0)) y progr\u00e1melos con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponiendo que partimos de la casilla c = (0,0), dos ejemplos de casos de error podr\u00edan ser: </p> <p>1) Poner una pared hacia el OESTE. La pared no se a\u00f1ade.  2) Obtener la posible pared hacia el SUR. El resultado debe ser null. </p> <p>Y los casos de prueba correspondientes podr\u00edan ser:</p> <pre><code>private Terreno terreno \u2026 \nprivate Paredes paredes \u2026\n\n@Test\npublic void Test001() {\n   Casilla c = terreno.getCasilla(0, 0);\n   int size = paredes.size();\n   paredes.add(c, Direccion.OESTE);\n   assertEquals(paredes.size(), size); // la pared no se ha a\u00f1adido\n}\n\n@Test\npublic void Test002() {\n   Casilla c = terreno.getCasilla(0, 0);\n   assertNull(paredes.get(c, Direccion.SUR));\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba el m\u00e9todo necesario para que un fantasma empiece movi\u00e9ndose hacia el NORTE hasta que choca con una pared; cuando choca intenta moverse al ESTE hasta que choca con una pared; y as\u00ed sucesivamente, rotando 90\u00ba a la derecha cada vez que choca. Si no puede desplazarse a ninguna de las casillas circundantes, deja pasar esta vez y espera al siguiente ciclo.</li> </ul> Mostar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>public class Fantasma01 {\n...\n\npublic void run() {\n    Direccion[] direcciones =\n        {Direccion.NORTE, Direccion.ESTE, Direccion.SUR, Direccion.OESTE};\n    int direccionActual = 0;\n\n    while (vivo) {\n        if (casilla != null) {\n            for (int i = 0; i &lt; 4; i++) {\n                if (!terreno.hayPared(casilla, direcciones[direccionActual])) {\n                    terreno.move(this, direcciones[direccionActual]);\n                    break;\n                }\n                direccionActual = (direccionActual + 1) % 4;\n            }\n            try {\n                Thread.sleep(DELAY);\n            } catch (InterruptedException ignored) {}\n        }\n    }\n}\n}\n</code></pre></p>"},{"location":"exams/2015/p1_ex01/","title":"P1 ex01","text":"<ul> <li>(a) (5 puntos) Como medida de similitud (o diferencia) entre dos documentos dados, representados como ficheros de texto, compa\u00f1\u00edas como Google utilizan el concepto de \u201cdistancia\u201d (o su contrario, \u201cproximidad\u201d) entre dos documentos, seg\u00fan el algoritmo que se describe a continuaci\u00f3n. </li> </ul> <p>Se descomponen los dos ficheros de texto en palabras y, para cada uno de los dos ficheros, se construye un vector ordenado con tantos componentes como palabras diferentes hay entre los dos ficheros, siendo el valor de cada elemento el n\u00famero de veces que la palabra en cuesti\u00f3n se repite en el fichero de texto dado. En especial, si una determinada palabra existe en un fichero pero no en el otro, el valor correspondiente para el segundo vector,  es cero. Por ejemplo, </p> Palabra d1 d2 \u00e1rbol 5 7 barco 2 0 \u2026 \u2026 \u2026 zapatiesta 0 3 <p>La palabra \u2018\u00e1rbol\u2019 aparece 5 veces en el fichero 1 y 7 veces en el 2. La palabra \u2018barco\u2019 no aparece en el fichero 2. La palabra \u2018zapatiesta\u2019 no aparece en el fichero 1.</p> <p>A continuaci\u00f3n se realiza el producto escalar de los dos vectores que, una vez dividido por el producto del n\u00famero total de palabras que hay en cada uno de los dos textos, nos da como resultado la medida de proximidad entre los dos documentos dados. </p> <p>Suponiendo que los dos documentos a comparar tienen una longitud similar, digamos N caracteres, y que la longitud m\u00e1xima de una palabra en espa\u00f1ol es K, se pide dar la complejidad del algoritmo descrito en t\u00e9rminos de N, a base de justificar la complejidad de cada una de las partes de las que se compone (el algoritmo). </p> <p>NOTA: Si no puede justificar la complejidad del algoritmo de ordenaci\u00f3n, considere que es O(NlogN).</p> Mostrar soluci\u00f3n <p>La extracci\u00f3n de las palabras se realiza iterando dentro de un simple bucle a lo largo de cada uno de los dos textos, lo cual da una complejidad lineal, es decir, O(N). </p> <p>Cada vez que en el bucle anterior se encuentra una palabra, se consultan y actualizan dos HashMap, cuyas operaciones son en todo caso de orden constante, y se hacen un n\u00famero m\u00e1ximo de ellas finito (y peque\u00f1o) por cada palabra encontrada, por lo que la fase anterior no ve modificada su complejidad de O(N). </p> <p>A continuaci\u00f3n han de construirse los dos vectores ordenados a partir de los valores que est\u00e1n desordenados en los HashMap, lo cual nos dicen que tiene una complejidad de O(N*logN). </p> <p>Por \u00faltimo, el c\u00e1lculo del producto escalar es otro bucle simple, repetido tantas veces como palabras diferentes hay, de una multiplicaci\u00f3n (complejidad constante) m\u00e1s una suma (tambi\u00e9n complejidad constante), lo cual da una complejidad para el producto escalar de O(N). La divisi\u00f3n posterior, siendo una sola y de complejidad constante, no cambia la complejidad de esta fase.  </p> <p>Asi pues, la complejidad total ser\u00e1, sumando las de cada una de sus tres fases, </p> <p>O(N) + O(NlogN) + O(N), lo cual se reduce, simplemente, a O(NlogN).</p>","tags":["complejidad"]},{"location":"exams/2015/p1_ex02/","title":"P1 ex02","text":"<ul> <li>(a) (4 puntos) Se pretende sincronizar la fabricaci\u00f3n en una l\u00ednea de ensamblado de mesas. Hay varios fabricantes de patas, que las depositan en una l\u00ednea con un l\u00edmite de capacidad MAX_NUM_PATAS. Cuando se llena, los fabricantes dejan de producir patas hasta que haya hueco libre. Hay varios fabricantes de tableros, que depositan en otra l\u00ednea de capacidad limitada MAX_NUM_TABLEROS. Por \u00faltimo, hay varios ensambladores de mesas: cada uno coge cuatro patas y un tablero y ensambla una mesa. </li> </ul> <p>Se trata de escribir en Java un monitor que sincronice estos tres sistemas, de forma que la producci\u00f3n se detenga cuando se alcanza la capacidad m\u00e1xima de almacenamiento (de patas o tableros independientemente) y sistema de ensamblaje no avance si le faltan piezas para hacer una nueva mesa. </p> <p>NO ESCRIBA NING\u00daN C\u00d3DIGO para los subsistemas de producci\u00f3n y ensamblaje. </p> <p>El sincronizador responde al siguiente esquema: <pre><code>class Sincronizador { \n    ...  \n    ... ponPata() {...}    // lo invoca el productor de patas por cada una \n    ... ponTablero() {...} // lo invoca el productor de tableros \n    ... cogePatasyTablero () {...}   // lo invoca el ensamblador de mesas \n    ... \n} \n</code></pre> Se pide: Desarrollar el c\u00f3digo completo del monitor sincronizador.</p> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.em;\n\npublic class Sincronizador {\n\n   private static final int NUM_MAX_PATAS    = 10;\n   private static final int NUM_MAX_TABLEROS = 4;\n   private int numPatas = 0;\n   private int numTableros = 0;\n\n   public synchronized void ponTablero() throws InterruptedException {\n      while (numTableros &gt;= NUM_MAX_TABLEROS)\n      {\n         wait();\n      }\n\n      numTableros++;\n\n      notifyAll();\n   }\n\n   public synchronized void ponPatas() throws InterruptedException {\n      while (numPatas &gt;= NUM_MAX_PATAS)\n      {\n         wait();\n      }\n\n      numPatas++;\n\n      notifyAll();\n   }\n\n   public synchronized void cogePatasyTablero() throws InterruptedException {\n      while (numTableros &lt; 1 || numPatas &lt; 4)\n      {\n         wait();\n      }\n\n      numTableros--;\n      numPatas -= 4;\n\n      notifyAll();\n   }\n\n}\n</code></pre></p>","tags":["monitores"]},{"location":"exams/2015/p1_ex03/","title":"P1 ex03","text":"<ul> <li>(a) (1 punto) Describa dos casos posibles de error significativamente diferentes para detectar errores de la clase Paredes del alumno en el borde del tablero (concretamente en la casilla (0, 0)) y progr\u00e1melos con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponiendo que partimos de la casilla c = (0,0), dos ejemplos de casos de error podr\u00edan ser: </p> <p>1) Poner una pared hacia el OESTE. La pared no se a\u00f1ade.  2) Obtener la posible pared hacia el SUR. El resultado debe ser null. </p> <p>Y los casos de prueba correspondientes podr\u00edan ser:</p> <pre><code>private Terreno terreno \u2026 \nprivate Paredes paredes \u2026\n\n@Test\npublic void Test001() {\n   Casilla c = terreno.getCasilla(0, 0);\n   int size = paredes.size();\n   paredes.add(c, Direccion.OESTE);\n   assertEquals(paredes.size(), size); // la pared no se ha a\u00f1adido\n}\n\n@Test\npublic void Test002() {\n   Casilla c = terreno.getCasilla(0, 0);\n   assertNull(paredes.get(c, Direccion.SUR));\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba el m\u00e9todo necesario para que un fantasma empiece movi\u00e9ndose hacia el NORTE hasta que choca con una pared; cuando choca intenta moverse al ESTE hasta que choca con una pared; y as\u00ed sucesivamente, rotando 90\u00ba a la derecha cada vez que choca. Si no puede desplazarse a ninguna de las casillas circundantes, deja pasar esta vez y espera al siguiente ciclo.</li> </ul> Mostar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>public class Fantasma01 {\n...\n\npublic void run() {\n    Direccion[] direcciones =\n        {Direccion.NORTE, Direccion.ESTE, Direccion.SUR, Direccion.OESTE};\n    int direccionActual = 0;\n\n    while (vivo) {\n        if (casilla != null) {\n            for (int i = 0; i &lt; 4; i++) {\n                if (!terreno.hayPared(casilla, direcciones[direccionActual])) {\n                    terreno.move(this, direcciones[direccionActual]);\n                    break;\n                }\n                direccionActual = (direccionActual + 1) % 4;\n            }\n            try {\n                Thread.sleep(DELAY);\n            } catch (InterruptedException ignored) {}\n        }\n    }\n}\n}\n</code></pre></p>","tags":["???"]},{"location":"exams/2015/p1r/","title":"Examen 2015 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2015/p1r/#problema-1","title":"Problema 1","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n (puede haber m\u00e1s de una) es:</p> <p>[0, 2, 6, 9, 11, 15]</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre></p> <pre><code>int[] getLIS(int[] x) {\n    int n = x.length;\n    int[] len = new int[n];\n    Arrays.fill(len, 1);\n    int[] pred = new int[n];\n    Arrays.fill(pred, -1);\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 0; j &lt; i; j++) {\n            if (x[j] &lt; x[i] &amp;&amp; len[i] &lt; len[j] + 1) {\n                len[i] = len[j] + 1;\n                pred[i] = j;\n            }\n        }\n    }\n    int bi = 0;\n    for (int i = 1; i &lt; n; i++) {\n        if (len[bi] &lt; len[i])\n            bi = i;\n    }\n    int cnt = len[bi];\n    int[] res = new int[cnt];\n    for (int i = bi; i != -1; i = pred[i])\n        res[--cnt] = x[i];\n    return res;\n}\n</code></pre> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n del tama\u00f1o N de la secuencia de entrada, razonando la soluci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>La iniciaci\u00f3n de los arrays \"len\" y \"pred\" es de complejidad lineal, pues se visitan todos sus elementos una sola vez, y su longitud es n.</p> <p>A continuaci\u00f3n hay un bucle doble anidado, cuyo cuerpo, de complejidad constante, se ejecuta 1 + 2 + 3 + ... + n-1 veces, es decir, un total de n/2*(n-1) veces. Por lo que su complejidad es cuadr\u00e1tica.</p> <p>Al final hay dos bucles simples con cuerpo de complejidad constante y n\u00famero de vueltas de orden n, que tienen pues complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser cuadr\u00e1tica. En t\u00e9rminos formales: C(for.for) = O(1+2+3+...+(n-1)) = O(n/2 * (n-1)) = O(n^2 / 2) - O(n/2) = O(n^2) C(LIS) = C(arrays.fill) + C(Arrays.fill) + C(for.for) + C(for) + C(for) = O(n) + O(n) + C(for.for) + O(n) + O(n/k) = O(n) + O(n) + O(n^2) + O(n) + O(n) = O(n^2).</p>"},{"location":"exams/2015/p1r/#problema-2","title":"Problema 2","text":"<p>Se tiene un sistema con dos hebras (H1 y H2) que acceden continuamente a un recurso compartido, que se debe usar con exclusi\u00f3n mutua. Para que el sistema funcione correctamente las hebras tienen que acceder seg\u00fan el siguiente patr\u00f3n, que se  debe repetir c\u00edclicamente: H1, H1, H2, H1, H2, como se ve en la figura siguiente:</p> <p></p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor (GestorCiclosAcceso) para sincronizar las hebras seg\u00fan el comportamiento descrito. El monitor debe proporcionar las siguientes operaciones:<ul> <li>... void accederH1(): Este m\u00e9todo lo invoca la hebra H1 para solicitar acceso al recurso compartido.</li> <li>... void accederH2(): Este m\u00e9todo lo invoca la hebra H2 para solicitar acceso al recurso compartido.</li> <li>... void liberar(): Este m\u00e9todo lo invocan las hebras para liberar el recurso compartido.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p><pre><code>public class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\npublic class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre> Otra posible implementaci\u00f3n, que utiliza m\u00e1quinas de estados, es la siguiente:</p> <pre><code>public class GestorCiclosAcceso2 {\n    // estado 0 - espera H1\n    // estado 1 - espera H1\n    // estado 2 - espera H2\n    // estado 3 - espera H1\n    // estado 4 - espera H2\n    private int state = 0;\n    private boolean busy = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (busy || !espera(1))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (busy || !espera(2))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        busy = false;\n        notifyAll();\n    }\n\n    private boolean espera(int i) {\n        switch (state) {\n            case 0:\n            case 1:\n            case 3:\n                return i == 1;\n            case 2:\n            case 4:\n                return i == 2;\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"exams/2015/p1r/#problema-3","title":"Problema 3","text":"<p>Dado el siguiente terreno de prueba y la situaci\u00f3n del jugador y el depredador que se muestra:</p> <p></p> <ul> <li>(a) (1 punto) Describa un caso posible de error para detectar errores del m\u00e9todo primerPaso de la clase Depredador del alumno y progr\u00e1melo con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponemos que la variable terreno se refiere al terreno creado con la configuraci\u00f3n de la figura, y que la variable depredador se refiere al depredador situado en el terreno anterior.</p> <p>El primer paso de la ruta m\u00e1s corta desde la casilla donde est\u00e1 el depredador (1,1) y la del jugador (3,2) es la casilla (1,0). Para comprobar que el funcionamiento del m\u00e9todo primerPaso() es correcto, pues, basta con probar la siguiente aserci\u00f3n</p> <p>assertEquals(terreno.getCasilla(1,0),</p> <p>depredador.primerPaso(terreno.getCasilla(1,1),terreno.getCasilla(3,2)))</p> <ul> <li>(b) (1 punto) Escriba un caso de prueba para comprobar si el n\u00famero de paredes en el terreno es igual a 10 (los bordes no cuentan), utilizando m\u00e9todos p\u00fablicos de las clases del proyecto.</li> </ul> Mostar soluci\u00f3n <p>Para comprobar el n\u00famero de paredes basta hacer     assertEquals(10, terreno.getparedes().size()</p>"},{"location":"exams/2015/p1r_ex01/","title":"P1r ex01","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n (puede haber m\u00e1s de una) es:</p> <p>[0, 2, 6, 9, 11, 15]</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre></p> <pre><code>int[] getLIS(int[] x) {\n    int n = x.length;\n    int[] len = new int[n];\n    Arrays.fill(len, 1);\n    int[] pred = new int[n];\n    Arrays.fill(pred, -1);\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 0; j &lt; i; j++) {\n            if (x[j] &lt; x[i] &amp;&amp; len[i] &lt; len[j] + 1) {\n                len[i] = len[j] + 1;\n                pred[i] = j;\n            }\n        }\n    }\n    int bi = 0;\n    for (int i = 1; i &lt; n; i++) {\n        if (len[bi] &lt; len[i])\n            bi = i;\n    }\n    int cnt = len[bi];\n    int[] res = new int[cnt];\n    for (int i = bi; i != -1; i = pred[i])\n        res[--cnt] = x[i];\n    return res;\n}\n</code></pre> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n del tama\u00f1o N de la secuencia de entrada, razonando la soluci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>La iniciaci\u00f3n de los arrays \"len\" y \"pred\" es de complejidad lineal, pues se visitan todos sus elementos una sola vez, y su longitud es n.</p> <p>A continuaci\u00f3n hay un bucle doble anidado, cuyo cuerpo, de complejidad constante, se ejecuta 1 + 2 + 3 + ... + n-1 veces, es decir, un total de n/2*(n-1) veces. Por lo que su complejidad es cuadr\u00e1tica.</p> <p>Al final hay dos bucles simples con cuerpo de complejidad constante y n\u00famero de vueltas de orden n, que tienen pues complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser cuadr\u00e1tica. En t\u00e9rminos formales: C(for.for) = O(1+2+3+...+(n-1)) = O(n/2 * (n-1)) = O(n^2 / 2) - O(n/2) = O(n^2) C(LIS) = C(arrays.fill) + C(Arrays.fill) + C(for.for) + C(for) + C(for) = O(n) + O(n) + C(for.for) + O(n) + O(n/k) = O(n) + O(n) + O(n^2) + O(n) + O(n) = O(n^2).</p>","tags":["complejidad"]},{"location":"exams/2015/p1r_ex02/","title":"P1r ex02","text":"<p>Se tiene un sistema con dos hebras (H1 y H2) que acceden continuamente a un recurso compartido, que se debe usar con exclusi\u00f3n mutua. Para que el sistema funcione correctamente las hebras tienen que acceder seg\u00fan el siguiente patr\u00f3n, que se  debe repetir c\u00edclicamente: H1, H1, H2, H1, H2, como se ve en la figura siguiente:</p> <p></p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor (GestorCiclosAcceso) para sincronizar las hebras seg\u00fan el comportamiento descrito. El monitor debe proporcionar las siguientes operaciones:<ul> <li>... void accederH1(): Este m\u00e9todo lo invoca la hebra H1 para solicitar acceso al recurso compartido.</li> <li>... void accederH2(): Este m\u00e9todo lo invoca la hebra H2 para solicitar acceso al recurso compartido.</li> <li>... void liberar(): Este m\u00e9todo lo invocan las hebras para liberar el recurso compartido.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p><pre><code>public class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\npublic class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre> Otra posible implementaci\u00f3n, que utiliza m\u00e1quinas de estados, es la siguiente:</p> <pre><code>public class GestorCiclosAcceso2 {\n    // estado 0 - espera H1\n    // estado 1 - espera H1\n    // estado 2 - espera H2\n    // estado 3 - espera H1\n    // estado 4 - espera H2\n    private int state = 0;\n    private boolean busy = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (busy || !espera(1))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (busy || !espera(2))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        busy = false;\n        notifyAll();\n    }\n\n    private boolean espera(int i) {\n        switch (state) {\n            case 0:\n            case 1:\n            case 3:\n                return i == 1;\n            case 2:\n            case 4:\n                return i == 2;\n        }\n        return false;\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2015/p1r_ex03/","title":"P1r ex03","text":"<p>Dado el siguiente terreno de prueba y la situaci\u00f3n del jugador y el depredador que se muestra:</p> <p></p> <ul> <li>(a) (1 punto) Describa un caso posible de error para detectar errores del m\u00e9todo primerPaso de la clase Depredador del alumno y progr\u00e1melo con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponemos que la variable terreno se refiere al terreno creado con la configuraci\u00f3n de la figura, y que la variable depredador se refiere al depredador situado en el terreno anterior.</p> <p>El primer paso de la ruta m\u00e1s corta desde la casilla donde est\u00e1 el depredador (1,1) y la del jugador (3,2) es la casilla (1,0). Para comprobar que el funcionamiento del m\u00e9todo primerPaso() es correcto, pues, basta con probar la siguiente aserci\u00f3n</p> <p>assertEquals(terreno.getCasilla(1,0),</p> <p>depredador.primerPaso(terreno.getCasilla(1,1),terreno.getCasilla(3,2)))</p> <ul> <li>(b) (1 punto) Escriba un caso de prueba para comprobar si el n\u00famero de paredes en el terreno es igual a 10 (los bordes no cuentan), utilizando m\u00e9todos p\u00fablicos de las clases del proyecto.</li> </ul> Mostar soluci\u00f3n <p>Para comprobar el n\u00famero de paredes basta hacer     assertEquals(10, terreno.getparedes().size()</p>","tags":["???"]},{"location":"exams/2015/p2/","title":"Examen 2015 \u2014 Parcial 2","text":""},{"location":"exams/2015/p2/#problema-1","title":"Problema 1","text":"<p>Se pretende desarrollar una aplicaci\u00f3n para Android de gesti\u00f3n de una colecci\u00f3n de libros. La informaci\u00f3n de los libros se almacena en una Base de Datos sqlite. Una ListActivity muestra informaci\u00f3n de los libros almacenados.</p> <p>De los libros se almacena la siguiente informaci\u00f3n: Autor, T\u00edtulo, A\u00f1o de publicaci\u00f3n. Los dos primeros campos ser\u00e1n textuales, el \u00faltimo ser\u00e1 un n\u00famero. La Bases de Datos constar\u00e1 de una \u00fanica tabla que contenga esta informaci\u00f3n.</p> <ul> <li>(a) (1 punto) Escriba la sentencia SQL correcta para la creaci\u00f3n de la Base de Datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>CREATE TABLE libros (_id INTEGER PRIMARY KEY AUTOINCREMENT, Autor TEXT NOT NULL, Titulo TEXT NOT NULL, A\u00f1o INTEGER NOT NULL)\n</code></pre> <p>Se decide programar un adaptador para manejar la base de datos. Parte de dicho adaptador es la siguiente:</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n\n    private class MySQLiteHelper extends SQLiteOpenHelper\n    {\n        @Override\n        public void onCreate(SQLiteDatabase db) { \u2026 }\n        \u2026\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un m\u00e9todo de la clase DatabaseHelper que devuelva un Cursor con la informaci\u00f3n de todos los libros. La cabecera del m\u00e9todo ser\u00e1: public Cursor selectAll() { \u2026 }. Si necesita atributos adicionales, decl\u00e1relos correctamente. No duplique las declaraciones de la pregunta anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public Cursor recuperaTodosLosLibros() {\n    return db.query(\"libros\", new String[] {\n        COL_ID, COL_AUTOR, COL_TITULO, COL_ANYO\n    }, null, null, null, null, null);\n}\n</code></pre> <p>Se pretende disponer de una actividad ListaLibrosActivity, que herede de ListActivity, seg\u00fan el siguiente esquema:</p> <pre><code>public class ListaLibrosActivity extends ListActivity {\n    private DatabaseHelper dbHelper;\n    private SimpleCursorAdapter cursorAdapter;\n    \u2026\n}\n</code></pre> <ul> <li>(c) (2 puntos) Se pretende que dicha actividad reaccione de forma que cuando el usuario pulse sobre un registro mostrado en el ListView, se lance otra actividad, llamada \u201cEditarLibroActivity\u201d, que ya est\u00e1 ya implementada. A la actividad \u201cEditarLibroActivity\u201d se le ha de pasar toda la informaci\u00f3n del libro seleccionado. Escriba el c\u00f3digo necesario para implementar este comportamiento. </li> </ul> Mostrar soluci\u00f3n <pre><code>public void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = productosCursor;\n    c.moveToPosition(position);\n    Intent intent = new Intent(this, EditarLibroActivity.class);\n    intent.putExtra(ProductoDbAdaptador.COL_ID, id);\n    intent.putExtra(Producto.AUTOR, c.getString(indiceAutor));\n    intent.putExtra(Producto.TITULO, c.getInt(indiceTitulo));\n    intent.putExtra(Producto.ANYO, c.getInt(indiceAnyo));\n    intent.putExtra(REQUEST_CODE, MODIFICA_PRODUCTO);\n    startActivityForResult(intent, MODIFICA_PRODUCTO);\n}\n</code></pre> <ul> <li>(d) (1 punto) Se desea guardar la base de datos de forma autom\u00e1tica, cuando la aplicaci\u00f3n sea interrumpida por otra ACTIVIDAD (por ejemplo, una llamada de tel\u00e9fono o pulsar el bot\u00f3n de aplicaciones). Cuando se vuelva a la aplicaci\u00f3n, se debe cargar la base de datos. \u00bfQu\u00e9 m\u00e9todos han de sobrecargarse relativos al ciclo de vida de la actividad principal? Ponga S\u00d3LO el nombre de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>sol a) onStart() \u2013 onStop() sol b) onResume() \u2013 onPause()</p>"},{"location":"exams/2015/p2/#problema-2","title":"Problema 2","text":"<p>En el Juego del Pacman para Android tenemos un tablero de 8x8:</p> <p></p> <ul> <li>(a) (1 punto) Indique las coordinadas (x,y) que debe pasar a juego.pon(terreno.getCasilla(x.y), 0) para poner un Patito (con identificador 0) en la casilla con un c\u00edrculo azul (objetivo) situada en el extremo superior derecho.</li> </ul> Mostrar soluci\u00f3n <p>X = 7, Y = 7</p> <ul> <li>(b) (1 punto) Suponga que tenemos un gestor de eventos t\u00e1ctiles onTouch(View v, MotionEvent event). Si pulsamos en el objetivo (c\u00edrculo azul situado en el extremo superior derecho), \u00bfqu\u00e9 valores nos dar\u00e1n x e y si se calculan como sigue? int x = (int) event.getX() / lado1; int y = (int) event.getY() / lado1</li> </ul> Mostrar soluci\u00f3n <p>X = 7, Y = 0</p> <p>Deseamos cambiar el comportamiento del gestor de eventos t\u00e1ctiles, de forma que el jugador ya no se mueva con el dedo. Queremos que al poner el dedo en una posici\u00f3n, aparezca un Patito si la casilla est\u00e1 vac\u00eda. El id de Patito registrado en Juego es 0. Adem\u00e1s, queremos que muestre:     - una traza informativa (info) al pulsar en la pantalla. Ej. \u201cPulso en (3, 4)\u201d     - una traza de depuraci\u00f3n (debug) cuando pone el patito. Ej. \u201cPatito puesto en (3, 4)\u201d     - una traza de depuraci\u00f3n si no coincide la posici\u00f3n al poner y quitar el dedo, porque ha realizado alg\u00fan movimiento. Ej. \u201cNo coinciden poner y quitar dedo\u201d     - una traza de advertencia (warn) si ya hay alg\u00fan m\u00f3vil en esa posici\u00f3n. \u201cPatito no puesto ya hay otro m\u00f3vil\u201d.</p> <ul> <li>(c) (3 puntos) Complete el c\u00f3digo del m\u00e9todo onTouch() que se da en la hoja de respuestas.</li> </ul> Mostrar soluci\u00f3n <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"exams/2015/p2_ex01/","title":"P2 ex01","text":"<p>Se pretende desarrollar una aplicaci\u00f3n para Android de gesti\u00f3n de una colecci\u00f3n de libros. La informaci\u00f3n de los libros se almacena en una Base de Datos sqlite. Una ListActivity muestra informaci\u00f3n de los libros almacenados.</p> <p>De los libros se almacena la siguiente informaci\u00f3n: Autor, T\u00edtulo, A\u00f1o de publicaci\u00f3n. Los dos primeros campos ser\u00e1n textuales, el \u00faltimo ser\u00e1 un n\u00famero. La Bases de Datos constar\u00e1 de una \u00fanica tabla que contenga esta informaci\u00f3n.</p> <ul> <li>(a) (1 punto) Escriba la sentencia SQL correcta para la creaci\u00f3n de la Base de Datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>CREATE TABLE libros (_id INTEGER PRIMARY KEY AUTOINCREMENT, Autor TEXT NOT NULL, Titulo TEXT NOT NULL, A\u00f1o INTEGER NOT NULL)\n</code></pre> <p>Se decide programar un adaptador para manejar la base de datos. Parte de dicho adaptador es la siguiente:</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n\n    private class MySQLiteHelper extends SQLiteOpenHelper\n    {\n        @Override\n        public void onCreate(SQLiteDatabase db) { \u2026 }\n        \u2026\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un m\u00e9todo de la clase DatabaseHelper que devuelva un Cursor con la informaci\u00f3n de todos los libros. La cabecera del m\u00e9todo ser\u00e1: public Cursor selectAll() { \u2026 }. Si necesita atributos adicionales, decl\u00e1relos correctamente. No duplique las declaraciones de la pregunta anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public Cursor recuperaTodosLosLibros() {\n    return db.query(\"libros\", new String[] {\n        COL_ID, COL_AUTOR, COL_TITULO, COL_ANYO\n    }, null, null, null, null, null);\n}\n</code></pre> <p>Se pretende disponer de una actividad ListaLibrosActivity, que herede de ListActivity, seg\u00fan el siguiente esquema:</p> <pre><code>public class ListaLibrosActivity extends ListActivity {\n    private DatabaseHelper dbHelper;\n    private SimpleCursorAdapter cursorAdapter;\n    \u2026\n}\n</code></pre> <ul> <li>(c) (2 puntos) Se pretende que dicha actividad reaccione de forma que cuando el usuario pulse sobre un registro mostrado en el ListView, se lance otra actividad, llamada \u201cEditarLibroActivity\u201d, que ya est\u00e1 ya implementada. A la actividad \u201cEditarLibroActivity\u201d se le ha de pasar toda la informaci\u00f3n del libro seleccionado. Escriba el c\u00f3digo necesario para implementar este comportamiento. </li> </ul> Mostrar soluci\u00f3n <pre><code>public void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = productosCursor;\n    c.moveToPosition(position);\n    Intent intent = new Intent(this, EditarLibroActivity.class);\n    intent.putExtra(ProductoDbAdaptador.COL_ID, id);\n    intent.putExtra(Producto.AUTOR, c.getString(indiceAutor));\n    intent.putExtra(Producto.TITULO, c.getInt(indiceTitulo));\n    intent.putExtra(Producto.ANYO, c.getInt(indiceAnyo));\n    intent.putExtra(REQUEST_CODE, MODIFICA_PRODUCTO);\n    startActivityForResult(intent, MODIFICA_PRODUCTO);\n}\n</code></pre> <ul> <li>(d) (1 punto) Se desea guardar la base de datos de forma autom\u00e1tica, cuando la aplicaci\u00f3n sea interrumpida por otra ACTIVIDAD (por ejemplo, una llamada de tel\u00e9fono o pulsar el bot\u00f3n de aplicaciones). Cuando se vuelva a la aplicaci\u00f3n, se debe cargar la base de datos. \u00bfQu\u00e9 m\u00e9todos han de sobrecargarse relativos al ciclo de vida de la actividad principal? Ponga S\u00d3LO el nombre de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>sol a) onStart() \u2013 onStop() sol b) onResume() \u2013 onPause()</p>","tags":["android"]},{"location":"exams/2015/p2_ex02/","title":"P2 ex02","text":"<p>En el Juego del Pacman para Android tenemos un tablero de 8x8:</p> <p></p> <ul> <li>(a) (1 punto) Indique las coordinadas (x,y) que debe pasar a juego.pon(terreno.getCasilla(x.y), 0) para poner un Patito (con identificador 0) en la casilla con un c\u00edrculo azul (objetivo) situada en el extremo superior derecho.</li> </ul> Mostrar soluci\u00f3n <p>X = 7, Y = 7</p> <ul> <li>(b) (1 punto) Suponga que tenemos un gestor de eventos t\u00e1ctiles onTouch(View v, MotionEvent event). Si pulsamos en el objetivo (c\u00edrculo azul situado en el extremo superior derecho), \u00bfqu\u00e9 valores nos dar\u00e1n x e y si se calculan como sigue? int x = (int) event.getX() / lado1; int y = (int) event.getY() / lado1</li> </ul> Mostrar soluci\u00f3n <p>X = 7, Y = 0</p> <p>Deseamos cambiar el comportamiento del gestor de eventos t\u00e1ctiles, de forma que el jugador ya no se mueva con el dedo. Queremos que al poner el dedo en una posici\u00f3n, aparezca un Patito si la casilla est\u00e1 vac\u00eda. El id de Patito registrado en Juego es 0. Adem\u00e1s, queremos que muestre:     - una traza informativa (info) al pulsar en la pantalla. Ej. \u201cPulso en (3, 4)\u201d     - una traza de depuraci\u00f3n (debug) cuando pone el patito. Ej. \u201cPatito puesto en (3, 4)\u201d     - una traza de depuraci\u00f3n si no coincide la posici\u00f3n al poner y quitar el dedo, porque ha realizado alg\u00fan movimiento. Ej. \u201cNo coinciden poner y quitar dedo\u201d     - una traza de advertencia (warn) si ya hay alg\u00fan m\u00f3vil en esa posici\u00f3n. \u201cPatito no puesto ya hay otro m\u00f3vil\u201d.</p> <ul> <li>(c) (3 puntos) Complete el c\u00f3digo del m\u00e9todo onTouch() que se da en la hoja de respuestas.</li> </ul> Mostrar soluci\u00f3n <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2016/extra/","title":"Examen 2016 \u2014 Extraordinario","text":""},{"location":"exams/2016/extra/#problema-1","title":"Problema 1","text":"<p>Queremos programar una clase Conjunto usando internamente una tabla hash con lista de desbordamiento. Se pide programar los siguientes m\u00e9todos:</p> <pre><code>void add(Object x)\n</code></pre> <pre><code>boolean contains(Object x)\n</code></pre> <pre><code>void remove(Object x)\n</code></pre> <p>Razone la complejidad de dichos m\u00e9todos.</p> <p>No se aceptar\u00e1 como soluci\u00f3n recurrir a la clase Map o a la clase Set de la biblioteca de java.</p> <ul> <li>(a) (2,1 puntos) Escribir el c\u00f3digo de los m\u00e9todos mencionados.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Conjunto {\n    private List&lt;Object&gt;[] tabla;\n\n    public Conjunto(int size) {\n        tabla = new List[size];\n    }\n\n    public void add(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            tabla[h] = new ArrayList&lt;Object&gt;();\n        if (!tabla[h].contains(x))\n            tabla[h].add(x);\n    }\n\n    public void remove(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            return;\n        tabla[h].remove(x);\n    }\n\n    public boolean contains(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            return false;\n        return tabla[h].contains(x);\n    }\n\n    private int hash(Object x) {\n        return Math.abs(x.hashCode() % tabla.length);\n    }\n}\n</code></pre> <ul> <li>(b) (1,4 puntos) Razonar la complejidad de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad de add() es O(1) sobre el supuesto de que la tabla de direccionamiento est\u00e1 dimensionada holgadamente; si no, ser\u00eda la complejidad de la lista de desbordamiento.</p> <p>La complejidad de remove() y contains() es la misma.</p>"},{"location":"exams/2016/extra/#problema-2","title":"Problema 2","text":"<p>Se pide programar un m\u00e9todo que determine si existen dos elementos de un array de enteros que sumen un cierto valor K.</p> <pre><code>boolean check(int[] datos, int k)\n</code></pre> <p>Ejemplos:</p> <pre><code>check([4, 6, 10, 8], 13) \u00e0 FALSE\ncheck([1, 4, 45, 6, 10, -8], 16) \u00e0 TRUE\n</code></pre> <p>Razone la complejidad en tiempo de ejecuci\u00f3n de dicho m\u00e9todo.</p> <p>Sugerencia. Para conseguir un algoritmo O(N) puede meter los datos del array en un conjunto (similar al propuesto en la primera pregunta).</p> <ul> <li>(a) (3,5) Implemente el m\u00e9todo y razone su complejidad. La complejidad del m\u00e9todo ha de ser O(N), en cualquier otro caso, solo se podr\u00e1 optar a la mitad de los puntos.</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n \u00f3ptima es: <pre><code>// O(n)\nstatic boolean check1(int[] data, int K) {\n    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n    for (int v : data) {\n        if (set.contains(K - v))\n            return true;\n        set.add(v);\n    }\n    return false;\n}\n</code></pre> O(N) porque se trata de un bucle que recorre los elementos del array y, dentro del bucle, las operaciones contains() y add() son O(1).</p> <p>Soluciones alternativas con otra complejidad son: <pre><code>// O(n log n)\nstatic boolean check2(int[] data, int K) {\n    int[] mdata = new int[data.length];\n    System.arraycopy(data, 0, mdata, 0, data.length);\n\n    Arrays.sort(mdata);\n\n    int a = 0;\n    int z = mdata.length - 1;\n\n    while (a &lt; z) {\n        int s = mdata[a] + mdata[z];\n        if (s == K)\n            return true;\n        if (s &lt; K)\n            a++;\n        else\n            z--;\n    }\n    return false;\n}\n</code></pre></p> <pre><code>// O(n^2)\nstatic boolean check3(int[] data, int K) {\n    for (int i = 0; i &lt; data.length; i++) {\n        for (int j = i + 1; j &lt; data.length; j++) {\n            if (data[i] + data[j] == K)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre>"},{"location":"exams/2016/extra/#problema-3","title":"Problema 3","text":"<p>En un programa de supervisi\u00f3n y control de una central t\u00e9rmica, existen un conjunto de hebras que toman la temperatura del vapor en distintos puntos de la caldera regularmente y la almacenan junto con la hora de la medida, para que posteriormente otro conjunto de hebras pueda leer la \u00faltima temperatura y hora medidas y realizar c\u00e1lculos con ellas. Y se desea que cada una de las hebras del primer conjunto almacene la temperatura y hora medidas con exclusi\u00f3n mutua de todas las dem\u00e1s hebras, pero que cualquier n\u00famero de hebras del segundo tipo pueda estar leyendo esos valores al mismo tiempo.</p> <p>Para solucionar el problema se propone usar un solo objeto, bien de la clase GestorHoraTemperatura, o bien de la clase GestorHoraTemperatura2.</p> <pre><code>public class GestorHoraTemperatura {\n    private HoraTemperatura ht;\n\n    public synchronized void almacenarHoraTemperatura(HoraTemperatura ht) {\n        this.ht = ht;\n    }\n\n    public HoraTemperatura leerHoraTemperatura() {\n        return ht;\n    }\n}\n\npublic class GestorHoraTemperatura2 {\n    private static HoraTemperatura ht;\n\n    public synchronized void almacenarHoraTemperatura(HoraTemperatura ht) {\n        GestorHoraTemperatura2.ht = ht;\n    }\n\n    public synchronized static HoraTemperatura leerHoraTemperatura() {\n        return ht;\n    }\n}\n\npublic class HoraTemperatura {\n    private int hora; // en milisegundos\n    private int temperatura; // en grados cent\u00edgrados\n\n    // Constructor\n    public HoraTemperatura(int h, int t) {\n        hora = h;\n        temperatura = t;\n    }\n\n    // Getters y Setters\n    // \u2026\n}\n</code></pre> <ul> <li>(a) Para cada una de las dos soluciones propuestas, se pide responder si se conseguir\u00e1 o no la sincronizaci\u00f3n deseada (una sola de las hebras del primer grupo, o cualquier n\u00famero de hebras de las del segundo grupo), argumentando las respuestas.</li> </ul> Mostrar soluci\u00f3n <p>Ninguna de las dos soluciones propuestas es correcta. En la primera de ellas, los procesos que escriben la temperatura y la hora (llam\u00e9mosles \"escritores\") lo hacen en exclusi\u00f3n mutua entre ellos, lo cual es correcto, y los procesos que leen los valores (llam\u00e9mosles \"lectores\") pueden estar cualquier n\u00famero de ellos leyendo al mismo tiempo (al no estar el m\u00e9todo de lectura sincronizado). Lo cual tambi\u00e9n coincide con lo que se desea.</p> <p>El problema de esta (seudo) soluci\u00f3n, sin embargo, es que tambi\u00e9n cualquier n\u00famero de lectores pueden estar leyendo al mismo tiempo que un escritor escribe, lo cual es desde luego un comportamiento incorrecto.</p> <p>En la segunda soluci\u00f3n propuesta, los lectores no pueden leer al mismo tiempo, ya que el m\u00e9todo correspondiente est\u00e1 sincronizado. Lo cual est\u00e1 en contra de lo deseado. Adem\u00e1s, al ser ahora la operaci\u00f3n que hace la lectura un m\u00e9todo de clase (est\u00e1tico), su exclusi\u00f3n mutua estar\u00e1 gobernada por el cerrojo de la clase, que es independiente de los cerrojos de los objetos de la clase, con lo que no ejecutar\u00e1 con exclusi\u00f3n mutua del otro m\u00e9todo, el de escritura. Es decir, que puede haber un lector leyendo al mismo tiempo que un escritor escribiendo, lo cual es desde luego un comportamiento incorrecto. </p>"},{"location":"exams/2016/extra/#problema-4","title":"Problema 4","text":"<p>En un sistema de comunicaciones hay un almac\u00e9n con capacidad para N mensajes, con N comprendido entre MIN = 16 y MAX = 1024. Hay un cierto n\u00famero de hebras (emisores) que almacenan mensajes en el almac\u00e9n, y otras (receptores), que extraen mensajes de \u00e9l. No se pueden almacenar mensajes si el almac\u00e9n est\u00e1 lleno, ni se pueden extraer si est\u00e1 vac\u00edo.</p> <p>El almac\u00e9n se crea con capacidad MIN. Una hebra supervisora comprueba peri\u00f3dicamente su ocupaci\u00f3n (n\u00famero de mensajes almacenados), llamando al m\u00e9todo adjust (ver esquema). Si la ocupaci\u00f3n es mayor del 80 % de su capacidad, duplica la capacidad del almac\u00e9n, siempre que sea posible sin sobrepasar el valor MAX. Si hab\u00eda emisores esperando por falta de espacio se les debe dar la oportunidad de enviar sus mensajes lo antes posible. Por otra parte, si la ocupaci\u00f3n del almac\u00e9n es menor que el 20 % de su capacidad, el supervisor reduce la capacidad a la mitad (pero nunca por debajo de MIN).</p> <ul> <li>(a) (5 puntos) Escriba una clase monitor que cumpla las condiciones anteriores, seg\u00fan el esquema que se da a continuaci\u00f3n.</li> </ul> <pre><code>public class Store {\n\n    private static final int MIN = 5;\n\n    private Message[] buffer;\n    private int capacity;\n    private int count = 0;\n    private int in = 0;\n    private int out = 0;\n\n    // crea un almac\u00e9n de capacidad MIN\n    public Store() {\n        this.capacity = MIN;\n        this.buffer = new Message[capacity];\n    }\n\n    // almacena un mensaje en el almac\u00e9n\n    public synchronized void put(Message m) throws InterruptedException {\n        while (count == capacity) {\n            wait();\n        }\n        buffer[in] = m;\n        in = (in + 1) % capacity;\n        count++;\n        notifyAll();\n    }\n\n    // extrae un mensaje del almac\u00e9n\n    public synchronized Message get() throws InterruptedException {\n        while (count == 0) {\n            wait();\n        }\n        Message m = buffer[out];\n        buffer[out] = null;\n        out = (out + 1) % capacity;\n        count--;\n        notifyAll();\n        return m;\n    }\n\n    // ajusta la capacidad del almac\u00e9n seg\u00fan la especificaci\u00f3n\n    public synchronized void adjust() {\n        int newCapacity = Math.max(MIN, count);\n        if (newCapacity == capacity)\n            return;\n\n        Message[] nuevo = new Message[newCapacity];\n        for (int i = 0; i &lt; count; i++) {\n            nuevo[i] = buffer[(out + i) % capacity];\n        }\n\n        buffer = nuevo;\n        capacity = newCapacity;\n        out = 0;\n        in = count;\n        notifyAll();\n    }\n}\n</code></pre> <p>NOTA: Suponga que est\u00e1 definida la clase Message que se utiliza en este esquema.</p> Mostrar soluci\u00f3n <pre><code>public class Store {\n\n    private static final int MIN = 16;\n    private static final int MAX = 1024;\n\n    private int N;\n    private List&lt;Message&gt; list = new ArrayList&lt;&gt;();\n\n    // crea un almac\u00e9n de capacidad inicial N\n    public Store(int N) {\n        this.N = Math.min(Math.max(N, MIN), MAX);\n    }\n\n    // almacena un mensaje en el almac\u00e9n\n    public synchronized void put(Message m) {\n        while (list.size() &gt;= N) {\n            try {\n                wait();\n            } catch (Exception ignored) {}\n        }\n        list.add(m);\n        notifyAll();\n    }\n\n    // extrae un mensaje del almac\u00e9n\n    public synchronized Message get() {\n        while (list.isEmpty()) {\n            try {\n                wait();\n            } catch (Exception ignored) {}\n        }\n        Message m = list.remove(0);\n        notifyAll();\n        return m;\n    }\n\n    // ajusta la capacidad del almac\u00e9n seg\u00fan la especificaci\u00f3n\n    public synchronized void adjust() {\n        if (list.size() &gt; 0.8 * N) {\n            N = Math.min(2 * N, MAX);\n        }\n        if (list.size() &lt; 0.2 * N) {\n            N = Math.max(N / 2, MIN);\n        }\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2016/extra/#problema-5","title":"Problema 5","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione las notas obtenidas por cada estudiante. En la primera pantalla, se pide el login y password al estudiante, con los cuales se puede acceder a un servidor que contiene las notas. Cuando las notas se han descargado, se presenta una pantalla en la que se muestra un listado con cada asignatura disponible y su calificaci\u00f3n.</p> <ul> <li>(a) (1,25 puntos) Escriba una especificaci\u00f3n de layout adecuada para la actividad principal. Este layout debe permitir introducir una cadena de login, una de password, y debe disponer de un bot\u00f3n para proceder a la descarga de las notas.</li> </ul> <p>Nota: Si lo desea, para evitar que se vea la password puede usar  <pre><code>android:inputType=\"textPassword\".\n</code></pre></p> mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\"es.upm.dit.adsw.descarganotas.MainActivity\"&gt;\n\n    &lt;LinearLayout\n        android:orientation=\"horizontal\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Login:\" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editLogin\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:orientation=\"horizontal\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Password:\" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editText2\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:inputType=\"textPassword\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;Button\n        android:id=\"@+id/descargar\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Descargar\" /&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre> <p>Se dispone de la siguiente clase auxiliar, denominada BajarNotasAsyncTask, con la siguiente cabecera: <pre><code>private class BajarNotaAsyncTask extends AsyncTask&lt;String, Void, Void&gt; { ... }\n</code></pre> (b) (1,25 puntos) Escriba el c\u00f3digo adecuado para que al pulsar el bot\u00f3n de la actividad principal, comience la descarga de las notas. Nota: NO CODIFIQUE la clase BajarNotasAsyncTask.</p> Mostrar soluci\u00f3n <pre><code>Button descargar = (Button) findViewById(R.id.descargar);\ndescargar.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        EditText loginET = (EditText) findViewById(R.id.editLogin);\n        EditText passwordET = (EditText) findViewById(R.id.editPassword);\n\n        String login = loginET.getText().toString();\n        String password = passwordET.getText().toString();\n\n        BajarNotasAsyncTask task = new BajarNotasAsyncTask();\n        task.execute(login, password);\n    }\n});\n</code></pre> <p>Se dispone de las siguientes clases para almacenar las notas de los alumnos (est\u00e1n incompletas): <pre><code>class Nota { // esta clase tiene la nota de una asignatura\n    private String asignatura;\n    private double nota;\n\n    // constructor y getters al uso\n}\n\nclass ListaNotasSingleton {\n    private static final List&lt;Nota&gt; listaNotas = new ArrayList&lt;&gt;();\n\n    private ListaNotasSingleton() {\n        /* nadie lo toca */\n    }\n\n    public static void add(Nota nota) {\n        listaNotas.add(nota);\n    }\n\n    public static List&lt;Nota&gt; getNotas() {\n        return listaNotas;\n    }\n}\n</code></pre></p> <p>La ejecuci\u00f3n de BajarNotasAsyncTask a\u00f1ade en el singleton ListaNotasSingleton las notas obtenidas hasta el momento por el alumno.</p> <ul> <li>(c) (1,25 puntos) Sobreescriba el m\u00e9todo adecuado de la clase BajarNotasAsyncTask de forma que, una vez bajadas las notas, se arranque una actividad denominada NotasListActivity.</li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\nprotected void onPostExecute(Void v) {\n    super.onPostExecute(v);\n    Intent intent = new Intent(MainActivity.this, NotasListActivity.class);\n    startActivity(intent);\n}\n</code></pre> <p>La actividad NotasListActivity presenta un layout denominado \u201cactivity_notas_list.xml\u201d, en el cual est\u00e1 definido un widget ListView con identificador \u201c@+id/listaNotas\u201d. Adem\u00e1s, se dispone de un layout para cada fila, denominado \u201cnota_item_row.xml\u201d y una clase adaptadora de la lista de notas denominada \u201cNotasArrayAdapter\u201d.</p> <ul> <li>(d) (1,25 puntos) Programe el m\u00e9todo onCreate de la clase NotasListActivity</li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_notas_list);\n\n    ListView listView = (ListView) findViewById(R.id.listaNotas);\n\n    NotasArrayAdapter adapter =\n            new NotasArrayAdapter(\n                    this,\n                    R.layout.nota_item_row,\n                    ListaNotasSingleton.getEntries()\n            );\n\n    listView.setAdapter(adapter);\n    listView.setOnItemClickListener(new OnItemClickListenerListViewItem());\n}\n</code></pre>"},{"location":"exams/2016/extra/#problema-6","title":"Problema 6","text":"<p>Se quiere construir un diccionario donde las claves son Object que no se pueden comparar entre s\u00ed. Los valores tambi\u00e9n son Object de java. Para ello se ha decidido programar un \u00e1rbol binario de b\u00fasqueda, usando el hash de la clave como criterio para optar por el sub\u00e1rbol izquierdo o el derecho.</p> <p>Se pide programar una clase BST_Object que incorpore el m\u00e9todo <pre><code>void put(Object clave, Object valor)\n</code></pre> que inserta un valor asociado a la clave; si la clave ya exist\u00eda, se reemplaza el antiguo valor por el nuevo </p> <ul> <li>(a) (1 punto) Programe los campos, el constructor y el m\u00e9todo put(). No es necesario que programe m\u00e1s m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class BST_Object {\n\n    private Nodo root = null;\n\n    public void put(Object clave, Object valor) {\n        if (clave == null)\n            throw new IllegalArgumentException(\"put(null, valor)\");\n        root = put(root, clave, valor);\n    }\n\n    private Nodo put(Nodo nodo, Object clave, Object valor) {\n        if (nodo == null)\n            return new Nodo(clave, valor);\n\n        if (clave.equals(nodo.clave))\n            nodo.valor = valor;\n        else if (clave.hashCode() &lt;= nodo.clave.hashCode())\n            nodo.izq = put(nodo.izq, clave, valor);\n        else\n            nodo.der = put(nodo.der, clave, valor);\n\n        return nodo;\n    }\n\n    private class Nodo {\n        Object clave;\n        Object valor;\n        Nodo izq;\n        Nodo der;\n\n        Nodo(Object clave, Object valor) {\n            this.clave = clave;\n            this.valor = valor;\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2016/extra/#problema-7","title":"Problema 7","text":"<p>En una aplicaci\u00f3n Android, se dispone de la clase RssRetrieveTask, que descarga as\u00edncronamente una serie de noticias de una fuente seleccionada, con la siguiente cabecera: <pre><code>private class RssRetrieveTask extends AsyncTask&lt;String, Void, Void&gt; { ... }\n</code></pre> donde el primer par\u00e1metro es una lista de Strings, la primera de las cuales es el URL de la fuente RSS de noticias, y el resto son palabras de filtrado.</p> <p>En el layout de la actividad principal se ha definido un bot\u00f3n con identificador \"@+id/boton_leer\", y se pretende que, al pulsar el bot\u00f3n, se active la tarea as\u00edncrona RssRetrieveTask. </p> <ul> <li>(a) (1 punto) Escriba el c\u00f3digo adecuado que atienda a la pulsaci\u00f3n del bot\u00f3n de forma que se active esta tarea.</li> </ul> Mostrar soluci\u00f3n <p>En el m\u00e9todo onCreate se a\u00f1aden las siguientes l\u00edneas: <pre><code>Button readButton = (Button) findViewById(R.id.read_button);\nreadButton.setOnClickListener(new ReadOnClickListener() {\n    @Override\n    public void onClick(View v) {\n        try {\n            String words = wordsEdit.getText().toString();\n            String[] urls = getResources().getStringArray(R.array.feeds_url);\n            String url = urls[feedSpinner.getSelectedItemPosition()];\n            Log.d(TAG, \"Palabras \" + words);\n            Log.d(TAG, \"URL \" + url);\n            RssRetrieveTask task = new RssRetrieveTask();\n            task.execute(url, words);\n        } catch (Exception e) {\n            Log.e(TAG, \"Error \" + e.toString());\n            Toast.makeText(getBaseContext(), \"Error al recuperar las noticias\",\n                    Toast.LENGTH_LONG).show();\n        }\n    }\n});\n</code></pre> Nota 1: se admiten las otras dos formas de asignar un m\u00e9todo al listener de un button.</p> <p>Nota 2: las sentencias \u201cLog\u201d y \u201cToast\u201d son absolutamente opcionales y no influyen en la nota</p>"},{"location":"exams/2016/extra_ex01/","title":"Extra ex01","text":"<p>Queremos programar una clase Conjunto usando internamente una tabla hash con lista de desbordamiento. Se pide programar los siguientes m\u00e9todos:</p> <pre><code>void add(Object x)\n</code></pre> <pre><code>boolean contains(Object x)\n</code></pre> <pre><code>void remove(Object x)\n</code></pre> <p>Razone la complejidad de dichos m\u00e9todos.</p> <p>No se aceptar\u00e1 como soluci\u00f3n recurrir a la clase Map o a la clase Set de la biblioteca de java.</p> <ul> <li>(a) (2,1 puntos) Escribir el c\u00f3digo de los m\u00e9todos mencionados.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Conjunto {\n    private List&lt;Object&gt;[] tabla;\n\n    public Conjunto(int size) {\n        tabla = new List[size];\n    }\n\n    public void add(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            tabla[h] = new ArrayList&lt;Object&gt;();\n        if (!tabla[h].contains(x))\n            tabla[h].add(x);\n    }\n\n    public void remove(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            return;\n        tabla[h].remove(x);\n    }\n\n    public boolean contains(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            return false;\n        return tabla[h].contains(x);\n    }\n\n    private int hash(Object x) {\n        return Math.abs(x.hashCode() % tabla.length);\n    }\n}\n</code></pre> <ul> <li>(b) (1,4 puntos) Razonar la complejidad de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad de add() es O(1) sobre el supuesto de que la tabla de direccionamiento est\u00e1 dimensionada holgadamente; si no, ser\u00eda la complejidad de la lista de desbordamiento.</p> <p>La complejidad de remove() y contains() es la misma.</p>","tags":["complejidad"]},{"location":"exams/2016/extra_ex02/","title":"Extra ex02","text":"<p>Se pide programar un m\u00e9todo que determine si existen dos elementos de un array de enteros que sumen un cierto valor K.</p> <pre><code>boolean check(int[] datos, int k)\n</code></pre> <p>Ejemplos:</p> <pre><code>check([4, 6, 10, 8], 13) \u00e0 FALSE\ncheck([1, 4, 45, 6, 10, -8], 16) \u00e0 TRUE\n</code></pre> <p>Razone la complejidad en tiempo de ejecuci\u00f3n de dicho m\u00e9todo.</p> <p>Sugerencia. Para conseguir un algoritmo O(N) puede meter los datos del array en un conjunto (similar al propuesto en la primera pregunta).</p> <ul> <li>(a) (3,5) Implemente el m\u00e9todo y razone su complejidad. La complejidad del m\u00e9todo ha de ser O(N), en cualquier otro caso, solo se podr\u00e1 optar a la mitad de los puntos.</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n \u00f3ptima es: <pre><code>// O(n)\nstatic boolean check1(int[] data, int K) {\n    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n    for (int v : data) {\n        if (set.contains(K - v))\n            return true;\n        set.add(v);\n    }\n    return false;\n}\n</code></pre> O(N) porque se trata de un bucle que recorre los elementos del array y, dentro del bucle, las operaciones contains() y add() son O(1).</p> <p>Soluciones alternativas con otra complejidad son: <pre><code>// O(n log n)\nstatic boolean check2(int[] data, int K) {\n    int[] mdata = new int[data.length];\n    System.arraycopy(data, 0, mdata, 0, data.length);\n\n    Arrays.sort(mdata);\n\n    int a = 0;\n    int z = mdata.length - 1;\n\n    while (a &lt; z) {\n        int s = mdata[a] + mdata[z];\n        if (s == K)\n            return true;\n        if (s &lt; K)\n            a++;\n        else\n            z--;\n    }\n    return false;\n}\n</code></pre></p> <pre><code>// O(n^2)\nstatic boolean check3(int[] data, int K) {\n    for (int i = 0; i &lt; data.length; i++) {\n        for (int j = i + 1; j &lt; data.length; j++) {\n            if (data[i] + data[j] == K)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2016/extra_ex03/","title":"Extra ex03","text":"<p>En un programa de supervisi\u00f3n y control de una central t\u00e9rmica, existen un conjunto de hebras que toman la temperatura del vapor en distintos puntos de la caldera regularmente y la almacenan junto con la hora de la medida, para que posteriormente otro conjunto de hebras pueda leer la \u00faltima temperatura y hora medidas y realizar c\u00e1lculos con ellas. Y se desea que cada una de las hebras del primer conjunto almacene la temperatura y hora medidas con exclusi\u00f3n mutua de todas las dem\u00e1s hebras, pero que cualquier n\u00famero de hebras del segundo tipo pueda estar leyendo esos valores al mismo tiempo.</p> <p>Para solucionar el problema se propone usar un solo objeto, bien de la clase GestorHoraTemperatura, o bien de la clase GestorHoraTemperatura2.</p> <pre><code>public class GestorHoraTemperatura {\n    private HoraTemperatura ht;\n\n    public synchronized void almacenarHoraTemperatura(HoraTemperatura ht) {\n        this.ht = ht;\n    }\n\n    public HoraTemperatura leerHoraTemperatura() {\n        return ht;\n    }\n}\n\npublic class GestorHoraTemperatura2 {\n    private static HoraTemperatura ht;\n\n    public synchronized void almacenarHoraTemperatura(HoraTemperatura ht) {\n        GestorHoraTemperatura2.ht = ht;\n    }\n\n    public synchronized static HoraTemperatura leerHoraTemperatura() {\n        return ht;\n    }\n}\n\npublic class HoraTemperatura {\n    private int hora; // en milisegundos\n    private int temperatura; // en grados cent\u00edgrados\n\n    // Constructor\n    public HoraTemperatura(int h, int t) {\n        hora = h;\n        temperatura = t;\n    }\n\n    // Getters y Setters\n    // \u2026\n}\n</code></pre> <ul> <li>(a) Para cada una de las dos soluciones propuestas, se pide responder si se conseguir\u00e1 o no la sincronizaci\u00f3n deseada (una sola de las hebras del primer grupo, o cualquier n\u00famero de hebras de las del segundo grupo), argumentando las respuestas.</li> </ul> Mostrar soluci\u00f3n <p>Ninguna de las dos soluciones propuestas es correcta. En la primera de ellas, los procesos que escriben la temperatura y la hora (llam\u00e9mosles \"escritores\") lo hacen en exclusi\u00f3n mutua entre ellos, lo cual es correcto, y los procesos que leen los valores (llam\u00e9mosles \"lectores\") pueden estar cualquier n\u00famero de ellos leyendo al mismo tiempo (al no estar el m\u00e9todo de lectura sincronizado). Lo cual tambi\u00e9n coincide con lo que se desea.</p> <p>El problema de esta (seudo) soluci\u00f3n, sin embargo, es que tambi\u00e9n cualquier n\u00famero de lectores pueden estar leyendo al mismo tiempo que un escritor escribe, lo cual es desde luego un comportamiento incorrecto.</p> <p>En la segunda soluci\u00f3n propuesta, los lectores no pueden leer al mismo tiempo, ya que el m\u00e9todo correspondiente est\u00e1 sincronizado. Lo cual est\u00e1 en contra de lo deseado. Adem\u00e1s, al ser ahora la operaci\u00f3n que hace la lectura un m\u00e9todo de clase (est\u00e1tico), su exclusi\u00f3n mutua estar\u00e1 gobernada por el cerrojo de la clase, que es independiente de los cerrojos de los objetos de la clase, con lo que no ejecutar\u00e1 con exclusi\u00f3n mutua del otro m\u00e9todo, el de escritura. Es decir, que puede haber un lector leyendo al mismo tiempo que un escritor escribiendo, lo cual es desde luego un comportamiento incorrecto. </p>","tags":["hebras"]},{"location":"exams/2016/extra_ex04/","title":"Extra ex04","text":"<p>En un sistema de comunicaciones hay un almac\u00e9n con capacidad para N mensajes, con N comprendido entre MIN = 16 y MAX = 1024. Hay un cierto n\u00famero de hebras (emisores) que almacenan mensajes en el almac\u00e9n, y otras (receptores), que extraen mensajes de \u00e9l. No se pueden almacenar mensajes si el almac\u00e9n est\u00e1 lleno, ni se pueden extraer si est\u00e1 vac\u00edo.</p> <p>El almac\u00e9n se crea con capacidad MIN. Una hebra supervisora comprueba peri\u00f3dicamente su ocupaci\u00f3n (n\u00famero de mensajes almacenados), llamando al m\u00e9todo adjust (ver esquema). Si la ocupaci\u00f3n es mayor del 80 % de su capacidad, duplica la capacidad del almac\u00e9n, siempre que sea posible sin sobrepasar el valor MAX. Si hab\u00eda emisores esperando por falta de espacio se les debe dar la oportunidad de enviar sus mensajes lo antes posible. Por otra parte, si la ocupaci\u00f3n del almac\u00e9n es menor que el 20 % de su capacidad, el supervisor reduce la capacidad a la mitad (pero nunca por debajo de MIN).</p> <ul> <li>(a) (5 puntos) Escriba una clase monitor que cumpla las condiciones anteriores, seg\u00fan el esquema que se da a continuaci\u00f3n.</li> </ul> <pre><code>public class Store {\n\n    private static final int MIN = 5;\n\n    private Message[] buffer;\n    private int capacity;\n    private int count = 0;\n    private int in = 0;\n    private int out = 0;\n\n    // crea un almac\u00e9n de capacidad MIN\n    public Store() {\n        this.capacity = MIN;\n        this.buffer = new Message[capacity];\n    }\n\n    // almacena un mensaje en el almac\u00e9n\n    public synchronized void put(Message m) throws InterruptedException {\n        while (count == capacity) {\n            wait();\n        }\n        buffer[in] = m;\n        in = (in + 1) % capacity;\n        count++;\n        notifyAll();\n    }\n\n    // extrae un mensaje del almac\u00e9n\n    public synchronized Message get() throws InterruptedException {\n        while (count == 0) {\n            wait();\n        }\n        Message m = buffer[out];\n        buffer[out] = null;\n        out = (out + 1) % capacity;\n        count--;\n        notifyAll();\n        return m;\n    }\n\n    // ajusta la capacidad del almac\u00e9n seg\u00fan la especificaci\u00f3n\n    public synchronized void adjust() {\n        int newCapacity = Math.max(MIN, count);\n        if (newCapacity == capacity)\n            return;\n\n        Message[] nuevo = new Message[newCapacity];\n        for (int i = 0; i &lt; count; i++) {\n            nuevo[i] = buffer[(out + i) % capacity];\n        }\n\n        buffer = nuevo;\n        capacity = newCapacity;\n        out = 0;\n        in = count;\n        notifyAll();\n    }\n}\n</code></pre> <p>NOTA: Suponga que est\u00e1 definida la clase Message que se utiliza en este esquema.</p> Mostrar soluci\u00f3n <pre><code>public class Store {\n\n    private static final int MIN = 16;\n    private static final int MAX = 1024;\n\n    private int N;\n    private List&lt;Message&gt; list = new ArrayList&lt;&gt;();\n\n    // crea un almac\u00e9n de capacidad inicial N\n    public Store(int N) {\n        this.N = Math.min(Math.max(N, MIN), MAX);\n    }\n\n    // almacena un mensaje en el almac\u00e9n\n    public synchronized void put(Message m) {\n        while (list.size() &gt;= N) {\n            try {\n                wait();\n            } catch (Exception ignored) {}\n        }\n        list.add(m);\n        notifyAll();\n    }\n\n    // extrae un mensaje del almac\u00e9n\n    public synchronized Message get() {\n        while (list.isEmpty()) {\n            try {\n                wait();\n            } catch (Exception ignored) {}\n        }\n        Message m = list.remove(0);\n        notifyAll();\n        return m;\n    }\n\n    // ajusta la capacidad del almac\u00e9n seg\u00fan la especificaci\u00f3n\n    public synchronized void adjust() {\n        if (list.size() &gt; 0.8 * N) {\n            N = Math.min(2 * N, MAX);\n        }\n        if (list.size() &lt; 0.2 * N) {\n            N = Math.max(N / 2, MIN);\n        }\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2016/extra_ex05/","title":"Extra ex05","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione las notas obtenidas por cada estudiante. En la primera pantalla, se pide el login y password al estudiante, con los cuales se puede acceder a un servidor que contiene las notas. Cuando las notas se han descargado, se presenta una pantalla en la que se muestra un listado con cada asignatura disponible y su calificaci\u00f3n.</p> <ul> <li>(a) (1,25 puntos) Escriba una especificaci\u00f3n de layout adecuada para la actividad principal. Este layout debe permitir introducir una cadena de login, una de password, y debe disponer de un bot\u00f3n para proceder a la descarga de las notas.</li> </ul> <p>Nota: Si lo desea, para evitar que se vea la password puede usar  <pre><code>android:inputType=\"textPassword\".\n</code></pre></p> mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\"es.upm.dit.adsw.descarganotas.MainActivity\"&gt;\n\n    &lt;LinearLayout\n        android:orientation=\"horizontal\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Login:\" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editLogin\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:orientation=\"horizontal\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Password:\" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editText2\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:inputType=\"textPassword\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;Button\n        android:id=\"@+id/descargar\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Descargar\" /&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre> <p>Se dispone de la siguiente clase auxiliar, denominada BajarNotasAsyncTask, con la siguiente cabecera: <pre><code>private class BajarNotaAsyncTask extends AsyncTask&lt;String, Void, Void&gt; { ... }\n</code></pre> (b) (1,25 puntos) Escriba el c\u00f3digo adecuado para que al pulsar el bot\u00f3n de la actividad principal, comience la descarga de las notas. Nota: NO CODIFIQUE la clase BajarNotasAsyncTask.</p> Mostrar soluci\u00f3n <pre><code>Button descargar = (Button) findViewById(R.id.descargar);\ndescargar.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        EditText loginET = (EditText) findViewById(R.id.editLogin);\n        EditText passwordET = (EditText) findViewById(R.id.editPassword);\n\n        String login = loginET.getText().toString();\n        String password = passwordET.getText().toString();\n\n        BajarNotasAsyncTask task = new BajarNotasAsyncTask();\n        task.execute(login, password);\n    }\n});\n</code></pre> <p>Se dispone de las siguientes clases para almacenar las notas de los alumnos (est\u00e1n incompletas): <pre><code>class Nota { // esta clase tiene la nota de una asignatura\n    private String asignatura;\n    private double nota;\n\n    // constructor y getters al uso\n}\n\nclass ListaNotasSingleton {\n    private static final List&lt;Nota&gt; listaNotas = new ArrayList&lt;&gt;();\n\n    private ListaNotasSingleton() {\n        /* nadie lo toca */\n    }\n\n    public static void add(Nota nota) {\n        listaNotas.add(nota);\n    }\n\n    public static List&lt;Nota&gt; getNotas() {\n        return listaNotas;\n    }\n}\n</code></pre></p> <p>La ejecuci\u00f3n de BajarNotasAsyncTask a\u00f1ade en el singleton ListaNotasSingleton las notas obtenidas hasta el momento por el alumno.</p> <ul> <li>(c) (1,25 puntos) Sobreescriba el m\u00e9todo adecuado de la clase BajarNotasAsyncTask de forma que, una vez bajadas las notas, se arranque una actividad denominada NotasListActivity.</li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\nprotected void onPostExecute(Void v) {\n    super.onPostExecute(v);\n    Intent intent = new Intent(MainActivity.this, NotasListActivity.class);\n    startActivity(intent);\n}\n</code></pre> <p>La actividad NotasListActivity presenta un layout denominado \u201cactivity_notas_list.xml\u201d, en el cual est\u00e1 definido un widget ListView con identificador \u201c@+id/listaNotas\u201d. Adem\u00e1s, se dispone de un layout para cada fila, denominado \u201cnota_item_row.xml\u201d y una clase adaptadora de la lista de notas denominada \u201cNotasArrayAdapter\u201d.</p> <ul> <li>(d) (1,25 puntos) Programe el m\u00e9todo onCreate de la clase NotasListActivity</li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_notas_list);\n\n    ListView listView = (ListView) findViewById(R.id.listaNotas);\n\n    NotasArrayAdapter adapter =\n            new NotasArrayAdapter(\n                    this,\n                    R.layout.nota_item_row,\n                    ListaNotasSingleton.getEntries()\n            );\n\n    listView.setAdapter(adapter);\n    listView.setOnItemClickListener(new OnItemClickListenerListViewItem());\n}\n</code></pre>","tags":["android"]},{"location":"exams/2016/extra_ex06/","title":"Extra ex06","text":"<p>Se quiere construir un diccionario donde las claves son Object que no se pueden comparar entre s\u00ed. Los valores tambi\u00e9n son Object de java. Para ello se ha decidido programar un \u00e1rbol binario de b\u00fasqueda, usando el hash de la clave como criterio para optar por el sub\u00e1rbol izquierdo o el derecho.</p> <p>Se pide programar una clase BST_Object que incorpore el m\u00e9todo <pre><code>void put(Object clave, Object valor)\n</code></pre> que inserta un valor asociado a la clave; si la clave ya exist\u00eda, se reemplaza el antiguo valor por el nuevo </p> <ul> <li>(a) (1 punto) Programe los campos, el constructor y el m\u00e9todo put(). No es necesario que programe m\u00e1s m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class BST_Object {\n\n    private Nodo root = null;\n\n    public void put(Object clave, Object valor) {\n        if (clave == null)\n            throw new IllegalArgumentException(\"put(null, valor)\");\n        root = put(root, clave, valor);\n    }\n\n    private Nodo put(Nodo nodo, Object clave, Object valor) {\n        if (nodo == null)\n            return new Nodo(clave, valor);\n\n        if (clave.equals(nodo.clave))\n            nodo.valor = valor;\n        else if (clave.hashCode() &lt;= nodo.clave.hashCode())\n            nodo.izq = put(nodo.izq, clave, valor);\n        else\n            nodo.der = put(nodo.der, clave, valor);\n\n        return nodo;\n    }\n\n    private class Nodo {\n        Object clave;\n        Object valor;\n        Nodo izq;\n        Nodo der;\n\n        Nodo(Object clave, Object valor) {\n            this.clave = clave;\n            this.valor = valor;\n        }\n    }\n}\n</code></pre>","tags":["???"]},{"location":"exams/2016/extra_ex07/","title":"Extra ex07","text":"<p>En una aplicaci\u00f3n Android, se dispone de la clase RssRetrieveTask, que descarga as\u00edncronamente una serie de noticias de una fuente seleccionada, con la siguiente cabecera: <pre><code>private class RssRetrieveTask extends AsyncTask&lt;String, Void, Void&gt; { ... }\n</code></pre> donde el primer par\u00e1metro es una lista de Strings, la primera de las cuales es el URL de la fuente RSS de noticias, y el resto son palabras de filtrado.</p> <p>En el layout de la actividad principal se ha definido un bot\u00f3n con identificador \"@+id/boton_leer\", y se pretende que, al pulsar el bot\u00f3n, se active la tarea as\u00edncrona RssRetrieveTask. </p> <ul> <li>(a) (1 punto) Escriba el c\u00f3digo adecuado que atienda a la pulsaci\u00f3n del bot\u00f3n de forma que se active esta tarea.</li> </ul> Mostrar soluci\u00f3n <p>En el m\u00e9todo onCreate se a\u00f1aden las siguientes l\u00edneas: <pre><code>Button readButton = (Button) findViewById(R.id.read_button);\nreadButton.setOnClickListener(new ReadOnClickListener() {\n    @Override\n    public void onClick(View v) {\n        try {\n            String words = wordsEdit.getText().toString();\n            String[] urls = getResources().getStringArray(R.array.feeds_url);\n            String url = urls[feedSpinner.getSelectedItemPosition()];\n            Log.d(TAG, \"Palabras \" + words);\n            Log.d(TAG, \"URL \" + url);\n            RssRetrieveTask task = new RssRetrieveTask();\n            task.execute(url, words);\n        } catch (Exception e) {\n            Log.e(TAG, \"Error \" + e.toString());\n            Toast.makeText(getBaseContext(), \"Error al recuperar las noticias\",\n                    Toast.LENGTH_LONG).show();\n        }\n    }\n});\n</code></pre> Nota 1: se admiten las otras dos formas de asignar un m\u00e9todo al listener de un button.</p> <p>Nota 2: las sentencias \u201cLog\u201d y \u201cToast\u201d son absolutamente opcionales y no influyen en la nota</p>","tags":["android"]},{"location":"exams/2016/p1/","title":"Examen 2016 \u2014 Parcial 1","text":""},{"location":"exams/2016/p1/#problema-1","title":"Problema 1","text":"<p>Queremos desplegar un conjunto de sensores de contaminaci\u00f3n en Madrid. Cada sensor S est\u00e1 en unas coordenadas (x, y) medidas en metros en una cuadr\u00edcula centrada en la Puerta del Sol, yendo el eje X de oeste a este y el eje Y de sur a norte.</p> <p>Los sensores son fr\u00e1giles y pueden fallar. Pero no queremos quedarnos sin datos, as\u00ed que se les facilita la capacidad de que puedan mandar sus mediciones a otro sensor, que debe estar a una distancia menor que d0 metros.</p> <pre><code>public class Sensor {\n    private final String id;\n    private final int x, y;\n\n    public Sensor(String id, int x, int y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distancia(Sensor b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Dada una lista con todos los sensores, escriba un m\u00e9todo que cargue un diccionario donde cada sensor est\u00e1 asociado a una lista con los sensores que est\u00e1n a su alcance (a menos de d0 metros). N\u00f3tese que si el sensor A est\u00e1 dentro del alcance de B, tambi\u00e9n est\u00e1 B dentro del alcance de A. Razone la complejidad de este m\u00e9todo: <pre><code>public class Red {\n    private Diccionario diccionario = new \u2026\n\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\u2026}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Soluci\u00f3n usando un diccionario de la biblioteca de Java</p> <pre><code>public class Red {\n    private Map&lt;Sensor, List&lt;Sensor&gt;&gt; diccionario = new HashMap&lt;&gt;();\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        for (int i = 0; i &lt; sensores.size(); i++) {\n            Sensor s1 = sensores.get(i);\n            List&lt;Sensor&gt; lista = new ArrayList&lt;&gt;();\n            for (int j = 0; j &lt; sensores.size(); j++) {\n                if (i == j)\n                    continue;\n                Sensor s2 = sensores.get(j);\n                if (s1.distancia(s2) &lt; d0)\n                    lista.add(s2);\n        }\n        diccionario.put(s1, lista);\n    }\n}\n</code></pre> <p>Para usar un diccionario como el del ejercicio 3, hay que cambiar CV y la implementaci\u00f3n de la misma manera:</p> <pre><code>class CVExamen {\n    final Sensor clave;\n    List&lt;Sensor&gt; valor;\n\n    CVExamen(Sensor clave, List&lt;Sensor&gt; valor) {\n        this.clave = clave;\n        this.valor = valor;\n    }\n}\n\npublic interface Diccionario {\n    void put(Sensor clave, List&lt;Sensor&gt; valor);\n    List&lt;Sensor&gt; get(Sensor clave);\n    List&lt;Sensor&gt; remove(Sensor clave);\n    int size();\n    void clear();\n}\n</code></pre> <p>Complejidad.</p> <p>Siendo N el n\u00famero de sensores, tenemos un bucle exterior que se hace N veces. Cada pasada por el bucle incluye: - bucle interior: N veces, de complejidad O(n). - diccionario.put(), donde lacomplejidad,  si el n\u00famero de ranuras es sensiblemente superior a N es O(1), si no es O(n).</p> <p>El total es, por tanto O(n) + \u2026 = O(n)</p> <p>Y la operaci\u00f3n total de carga N \u00d7 O(n) -&gt; O(n2)</p>"},{"location":"exams/2016/p1/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (3,5 puntos) Escriba un m\u00e9todo para crear un diccionario que, para cada sensor S, contenga el conjunto de sensores a los que mandar\u00e1 regularmente una copia de sus medidas. Sabiendo que los sensores de destino podr\u00edan verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se env\u00edan a los F sensores que a su vez tengan menos sensores a su alcance.</li> </ul> <pre><code>public Diccionario cercanos (int f) {\u2026}\n</code></pre> <p>NOTA: El algoritmo es como sigue:     - 1. para cada sensor S obtenemos la lista de nodos a distancia alcanzable (pregunta 1)     - 2. ordenamos la lista en funci\u00f3n del n\u00famero de sensores al alcance de cada sensor     - 3. nos quedamos con los F primeros sensores en una nueva lista     - 4. asociamos la nueva lista a S en el diccionario de resultado</p> <p>NOTAS:     - Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java.     - Como algoritmo de ordenaci\u00f3n, elija uno de los presentados en clase, adaptando el c\u00f3digo al caso.     - Puede usar m\u00e9todos auxiliares si lo cree oportuno. Privados, por supuesto.</p> <p>Razone la complejidad de su c\u00f3digo</p> Mostrar soluci\u00f3n <p>Probablemente, el n\u00famero de sensores dentro del alcance sea un n\u00famero peque\u00f1o. En ese caso la ordenaci\u00f3n se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenaci\u00f3n.</p> <p>En la soluci\u00f3n que sigue se recurre al algoritmo de inserci\u00f3n.</p> <p>Usando la biblioteca de Java:</p> <pre><code>public Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n    Map&lt;Sensor, List&lt;Sensor&gt;&gt; resultado = new HashMap&lt;&gt;();\n\n    for (Sensor sensor : diccionario.keySet()) {\n        List&lt;Sensor&gt; list1 = getListaOrdenadaSensores(sensor);\n        List&lt;Sensor&gt; list2 = new ArrayList&lt;&gt;();\n\n        int m = Math.min(f, list1.size());\n        for (int i = 0; i &lt; m; i++)\n            list2.add(list1.get(i));\n\n        resultado.put(sensor, list2);\n    }\n    return resultado;\n}\n\nprivate List&lt;Sensor&gt; getListaOrdenadaSensores(Sensor sensor) {\n    List&lt;Sensor&gt; list0 = diccionario.get(sensor);\n    List&lt;Sensor&gt; list1 = new ArrayList&lt;&gt;(list0);\n    sort(list1);\n    return list1;\n}\n\nprivate void sort(List&lt;Sensor&gt; list) {\n    // inserci\u00f3n\n    for (int i = 1; i &lt; list.size(); i++)\n        inserta(list, i, list.get(i));\n}\n\n// inserta sensor en datos, entre 0 y z-1\nprivate void inserta(List&lt;Sensor&gt; datos, int z, Sensor sensor) {\n    int j = z;\n    while (0 &lt; j &amp;&amp; compareTo(sensor, datos.get(j - 1)) &lt; 0)\n        j--;\n\n    if (j != z) {\n        datos.remove(sensor);\n        datos.add(j, sensor);\n    }\n}\n\nprivate int compareTo(Sensor s1, Sensor s2) {\n    int size1 = diccionario.get(s1).size();\n    int size2 = diccionario.get(s2).size();\n    return size2 - size1;\n}\n</code></pre> <p>Con respecto a la complejidad, hay que revisar N sensores.</p> <p>Para cada sensor hay que localizar su lista de sensores en el diccionario: get().</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>Cada lista, de X elementos, hay que ordenarla. Si usamos un algoritmo de inserci\u00f3n como el de arriba, por t\u00e9rmino medio ser\u00e1 la ordenaci\u00f3n de un array de x elementos: O(x2):     - 1. Podemos pensar que X sea constante, independientemente de N, en cuyo caso la ordenaci\u00f3n ser\u00e1 de tiempo constante, O(1).     - 2. Podemos pensar que X sea proporcional a N, en cuyo caso la ordenaci\u00f3n ser\u00e1 una proporci\u00f3n de N: O(n2)</p> <p>Nos quedamos con f elementos: O(1).</p> <p>Y hacemos una operaci\u00f3n put() en el diccionario se salida.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>En el caso 1, el total es N \u00d7 (O(1) + O(1) + O(1) + O(1)) -&gt; N \u00d7 O(1) -&gt; O(n)</p> <p>En el caso 2, el total es N \u00d7 (O(1) + O(n2) + O(1) + O(1)) -&gt; N \u00d7 O(n2) -&gt; O(n3)</p> <p>Resumiendo, si el n\u00famero de sensores dentro del alcance es independiente de N, la complejidad es O(n). Si el n\u00famero de sensores dentro del alcance es proporcional a N, la complejidad depende del algoritmo de ordenaci\u00f3n.</p>"},{"location":"exams/2016/p1/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (1 punto) Modifique la clase Sensor para que se pueda integrar en una hebra que comparta informaci\u00f3n con los sensores cercanos cada 30 s. Para ello se puede implementar la interfaz Runnable.</li> </ul> <pre><code>public class Sensor implements Runnable {\n    // ...\n    private Red red;\n    private int medida; // valor le\u00eddo por el sensor\n\n    public Sensor(String id, int x, int y, Red red) {\n        this.red = red;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // transmitir la lectura cada 30 segundos\n                red.transmitir(this, medida);\n                Thread.sleep(30000); // 30 s\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Para implementar la interfaz Runnable espreciso redefinir el m\u00e9todo run(): <pre><code>@Override\npublic void run() {\n    while (true) {\n        try {\n            sleep(30000);\n        } catch (InterruptedException ignored) {\n        }\n\n        for (Sensor s : red.cercanos(f).get(this)) {\n            red.enviar(s, medida);\n        }\n    }\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Escriba una l\u00ednea de c\u00f3digo java para arrancar una hebra que ejecute el c\u00f3digo concurrente de Sensor.</li> </ul> Mostrar soluci\u00f3n <p>Para arrancar una hebra que ejecute el m\u00e9todo run() anterior hay que crear la hebra a partir del Runnable y hacer start(): <pre><code>new Thread(new Sensor()).start();\n</code></pre> o alternativamente: <pre><code>Runnable sensor = new Sensor(\u2026);\nThread tread = new Thread(sensor);\nthread.start();\n</code></pre></p> <ul> <li>(c) (1 punto) En el puesto de mando y control, un servidor ejecuta un programa basado en la clase Red de las preguntas anteriores, y recibe peticiones de los operadores locales y de los muchos sensores distribuidos por Madrid. Modifique la clase Red para que pueda atender cargas, recargas y peticiones concurrentes sin problemas de concurrencia.</li> </ul> <p>NOTAS 1. Suponga que el valor medido por el sensor (medida) se actualiza autom\u00e1ticamente por alg\u00fan mecanismo que no es relevante para examen. 2. Suponga que la clase Red incluye el m\u00e9todo <pre><code>public void enviar (Sensor destino, int medida) {\u2026}\n</code></pre></p> Mostrar soluci\u00f3n <p>Para que la clase Red se pueda usar de forma segura desde varias hebras es preciso convertirla en un monitor. Como no tiene atributos p\u00fablicos basta para ello con sincronizar todos sus m\u00e9todos p\u00fablicos: <pre><code>public class Red {\n    private Diccionario diccionario = new DiccionarioImpl();\n\n    public synchronized void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        // ...\n    }\n\n    public synchronized Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n        // ...\n        return null;\n    }\n\n    public synchronized void enviar(Sensor destino, int medida) {\n        // ...\n    }\n}\n</code></pre></p>"},{"location":"exams/2016/p1_ex01/","title":"P1 ex01","text":"<p>Queremos desplegar un conjunto de sensores de contaminaci\u00f3n en Madrid. Cada sensor S est\u00e1 en unas coordenadas (x, y) medidas en metros en una cuadr\u00edcula centrada en la Puerta del Sol, yendo el eje X de oeste a este y el eje Y de sur a norte.</p> <p>Los sensores son fr\u00e1giles y pueden fallar. Pero no queremos quedarnos sin datos, as\u00ed que se les facilita la capacidad de que puedan mandar sus mediciones a otro sensor, que debe estar a una distancia menor que d0 metros.</p> <pre><code>public class Sensor {\n    private final String id;\n    private final int x, y;\n\n    public Sensor(String id, int x, int y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distancia(Sensor b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Dada una lista con todos los sensores, escriba un m\u00e9todo que cargue un diccionario donde cada sensor est\u00e1 asociado a una lista con los sensores que est\u00e1n a su alcance (a menos de d0 metros). N\u00f3tese que si el sensor A est\u00e1 dentro del alcance de B, tambi\u00e9n est\u00e1 B dentro del alcance de A. Razone la complejidad de este m\u00e9todo: <pre><code>public class Red {\n    private Diccionario diccionario = new \u2026\n\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\u2026}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Soluci\u00f3n usando un diccionario de la biblioteca de Java</p> <pre><code>public class Red {\n    private Map&lt;Sensor, List&lt;Sensor&gt;&gt; diccionario = new HashMap&lt;&gt;();\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        for (int i = 0; i &lt; sensores.size(); i++) {\n            Sensor s1 = sensores.get(i);\n            List&lt;Sensor&gt; lista = new ArrayList&lt;&gt;();\n            for (int j = 0; j &lt; sensores.size(); j++) {\n                if (i == j)\n                    continue;\n                Sensor s2 = sensores.get(j);\n                if (s1.distancia(s2) &lt; d0)\n                    lista.add(s2);\n        }\n        diccionario.put(s1, lista);\n    }\n}\n</code></pre> <p>Para usar un diccionario como el del ejercicio 3, hay que cambiar CV y la implementaci\u00f3n de la misma manera:</p> <pre><code>class CVExamen {\n    final Sensor clave;\n    List&lt;Sensor&gt; valor;\n\n    CVExamen(Sensor clave, List&lt;Sensor&gt; valor) {\n        this.clave = clave;\n        this.valor = valor;\n    }\n}\n\npublic interface Diccionario {\n    void put(Sensor clave, List&lt;Sensor&gt; valor);\n    List&lt;Sensor&gt; get(Sensor clave);\n    List&lt;Sensor&gt; remove(Sensor clave);\n    int size();\n    void clear();\n}\n</code></pre> <p>Complejidad.</p> <p>Siendo N el n\u00famero de sensores, tenemos un bucle exterior que se hace N veces. Cada pasada por el bucle incluye: - bucle interior: N veces, de complejidad O(n). - diccionario.put(), donde lacomplejidad,  si el n\u00famero de ranuras es sensiblemente superior a N es O(1), si no es O(n).</p> <p>El total es, por tanto O(n) + \u2026 = O(n)</p> <p>Y la operaci\u00f3n total de carga N \u00d7 O(n) -&gt; O(n2)</p>","tags":["complejidad"]},{"location":"exams/2016/p1_ex02/","title":"P1 ex02","text":"<ul> <li>(a) (3,5 puntos) Escriba un m\u00e9todo para crear un diccionario que, para cada sensor S, contenga el conjunto de sensores a los que mandar\u00e1 regularmente una copia de sus medidas. Sabiendo que los sensores de destino podr\u00edan verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se env\u00edan a los F sensores que a su vez tengan menos sensores a su alcance.</li> </ul> <pre><code>public Diccionario cercanos (int f) {\u2026}\n</code></pre> <p>NOTA: El algoritmo es como sigue:     - 1. para cada sensor S obtenemos la lista de nodos a distancia alcanzable (pregunta 1)     - 2. ordenamos la lista en funci\u00f3n del n\u00famero de sensores al alcance de cada sensor     - 3. nos quedamos con los F primeros sensores en una nueva lista     - 4. asociamos la nueva lista a S en el diccionario de resultado</p> <p>NOTAS:     - Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java.     - Como algoritmo de ordenaci\u00f3n, elija uno de los presentados en clase, adaptando el c\u00f3digo al caso.     - Puede usar m\u00e9todos auxiliares si lo cree oportuno. Privados, por supuesto.</p> <p>Razone la complejidad de su c\u00f3digo</p> Mostrar soluci\u00f3n <p>Probablemente, el n\u00famero de sensores dentro del alcance sea un n\u00famero peque\u00f1o. En ese caso la ordenaci\u00f3n se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenaci\u00f3n.</p> <p>En la soluci\u00f3n que sigue se recurre al algoritmo de inserci\u00f3n.</p> <p>Usando la biblioteca de Java:</p> <pre><code>public Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n    Map&lt;Sensor, List&lt;Sensor&gt;&gt; resultado = new HashMap&lt;&gt;();\n\n    for (Sensor sensor : diccionario.keySet()) {\n        List&lt;Sensor&gt; list1 = getListaOrdenadaSensores(sensor);\n        List&lt;Sensor&gt; list2 = new ArrayList&lt;&gt;();\n\n        int m = Math.min(f, list1.size());\n        for (int i = 0; i &lt; m; i++)\n            list2.add(list1.get(i));\n\n        resultado.put(sensor, list2);\n    }\n    return resultado;\n}\n\nprivate List&lt;Sensor&gt; getListaOrdenadaSensores(Sensor sensor) {\n    List&lt;Sensor&gt; list0 = diccionario.get(sensor);\n    List&lt;Sensor&gt; list1 = new ArrayList&lt;&gt;(list0);\n    sort(list1);\n    return list1;\n}\n\nprivate void sort(List&lt;Sensor&gt; list) {\n    // inserci\u00f3n\n    for (int i = 1; i &lt; list.size(); i++)\n        inserta(list, i, list.get(i));\n}\n\n// inserta sensor en datos, entre 0 y z-1\nprivate void inserta(List&lt;Sensor&gt; datos, int z, Sensor sensor) {\n    int j = z;\n    while (0 &lt; j &amp;&amp; compareTo(sensor, datos.get(j - 1)) &lt; 0)\n        j--;\n\n    if (j != z) {\n        datos.remove(sensor);\n        datos.add(j, sensor);\n    }\n}\n\nprivate int compareTo(Sensor s1, Sensor s2) {\n    int size1 = diccionario.get(s1).size();\n    int size2 = diccionario.get(s2).size();\n    return size2 - size1;\n}\n</code></pre> <p>Con respecto a la complejidad, hay que revisar N sensores.</p> <p>Para cada sensor hay que localizar su lista de sensores en el diccionario: get().</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>Cada lista, de X elementos, hay que ordenarla. Si usamos un algoritmo de inserci\u00f3n como el de arriba, por t\u00e9rmino medio ser\u00e1 la ordenaci\u00f3n de un array de x elementos: O(x2):     - 1. Podemos pensar que X sea constante, independientemente de N, en cuyo caso la ordenaci\u00f3n ser\u00e1 de tiempo constante, O(1).     - 2. Podemos pensar que X sea proporcional a N, en cuyo caso la ordenaci\u00f3n ser\u00e1 una proporci\u00f3n de N: O(n2)</p> <p>Nos quedamos con f elementos: O(1).</p> <p>Y hacemos una operaci\u00f3n put() en el diccionario se salida.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a N, la complejidad es O(1).</p> <p>De lo contrario, ser\u00e1 O(n).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es O(1).</p> <p>En el caso 1, el total es N \u00d7 (O(1) + O(1) + O(1) + O(1)) -&gt; N \u00d7 O(1) -&gt; O(n)</p> <p>En el caso 2, el total es N \u00d7 (O(1) + O(n2) + O(1) + O(1)) -&gt; N \u00d7 O(n2) -&gt; O(n3)</p> <p>Resumiendo, si el n\u00famero de sensores dentro del alcance es independiente de N, la complejidad es O(n). Si el n\u00famero de sensores dentro del alcance es proporcional a N, la complejidad depende del algoritmo de ordenaci\u00f3n.</p>","tags":["complejidad"]},{"location":"exams/2016/p1_ex03/","title":"P1 ex03","text":"<ul> <li>(a) (1 punto) Modifique la clase Sensor para que se pueda integrar en una hebra que comparta informaci\u00f3n con los sensores cercanos cada 30 s. Para ello se puede implementar la interfaz Runnable.</li> </ul> <pre><code>public class Sensor implements Runnable {\n    // ...\n    private Red red;\n    private int medida; // valor le\u00eddo por el sensor\n\n    public Sensor(String id, int x, int y, Red red) {\n        this.red = red;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // transmitir la lectura cada 30 segundos\n                red.transmitir(this, medida);\n                Thread.sleep(30000); // 30 s\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Para implementar la interfaz Runnable espreciso redefinir el m\u00e9todo run(): <pre><code>@Override\npublic void run() {\n    while (true) {\n        try {\n            sleep(30000);\n        } catch (InterruptedException ignored) {\n        }\n\n        for (Sensor s : red.cercanos(f).get(this)) {\n            red.enviar(s, medida);\n        }\n    }\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Escriba una l\u00ednea de c\u00f3digo java para arrancar una hebra que ejecute el c\u00f3digo concurrente de Sensor.</li> </ul> Mostrar soluci\u00f3n <p>Para arrancar una hebra que ejecute el m\u00e9todo run() anterior hay que crear la hebra a partir del Runnable y hacer start(): <pre><code>new Thread(new Sensor()).start();\n</code></pre> o alternativamente: <pre><code>Runnable sensor = new Sensor(\u2026);\nThread tread = new Thread(sensor);\nthread.start();\n</code></pre></p> <ul> <li>(c) (1 punto) En el puesto de mando y control, un servidor ejecuta un programa basado en la clase Red de las preguntas anteriores, y recibe peticiones de los operadores locales y de los muchos sensores distribuidos por Madrid. Modifique la clase Red para que pueda atender cargas, recargas y peticiones concurrentes sin problemas de concurrencia.</li> </ul> <p>NOTAS 1. Suponga que el valor medido por el sensor (medida) se actualiza autom\u00e1ticamente por alg\u00fan mecanismo que no es relevante para examen. 2. Suponga que la clase Red incluye el m\u00e9todo <pre><code>public void enviar (Sensor destino, int medida) {\u2026}\n</code></pre></p> Mostrar soluci\u00f3n <p>Para que la clase Red se pueda usar de forma segura desde varias hebras es preciso convertirla en un monitor. Como no tiene atributos p\u00fablicos basta para ello con sincronizar todos sus m\u00e9todos p\u00fablicos: <pre><code>public class Red {\n    private Diccionario diccionario = new DiccionarioImpl();\n\n    public synchronized void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        // ...\n    }\n\n    public synchronized Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n        // ...\n        return null;\n    }\n\n    public synchronized void enviar(Sensor destino, int medida) {\n        // ...\n    }\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2016/p1r/","title":"Examen 2016 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2016/p1r/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un algoritmo que, dado un array de enteros, calcule cu\u00e1l es el n\u00famero que se repite m\u00e1s veces. As\u00ed, si el array contiene {2, 4, 3, 4, 2, 6, 1, 4, 4}, el algoritmo devuelve 4. Si hay empate, devuelve el primer valor. Se pide:</p> <ul> <li>(a) (1 punto) Escribir un m\u00e9todo en Java que compute el algoritmo descrito. Si el array est\u00e1 vac\u00edo o es nulo, se lanzar\u00e1 una excepci\u00f3n. La cabecera del m\u00e9todo debe ser:</li> </ul> <pre><code>int mayoria (int []v) throws exception\n</code></pre> Mostrar soluci\u00f3n <p>Hay varias posibles soluciones:</p> <ol> <li>hacer un histograma, eligiendo el valor mayor seg\u00fan se cuenta</li> <li>ordenar el array y contar repeticiones sucesivas</li> </ol> <p>Se incluye la soluci\u00f3n 1, almacenando el histograma en un Map. Una posible soluci\u00f3n es: <pre><code>public static int mayoria(int[] v) throws Exception {\n    if (v == null || v.length == 0)\n        throw new IllegalArgumentException(\"mayoria: invalid argument\");\n\n    Map&lt;Integer, Integer&gt; histograma = new HashMap&lt;Integer, Integer&gt;();\n    int masRep = v[0];        // candidato inicial\n    int repeticiones = 1;    // aparece una vez\n\n    for (int i = 0; i &lt; v.length; i++) {\n        Integer veces = histograma.get(v[i]);\n        veces = (veces == null) ? 1 : veces + 1;\n        histograma.put(v[i], veces);\n\n        if (veces &gt; repeticiones) {\n            repeticiones = veces;\n            masRep = v[i];\n        }\n    }\n    return masRep;\n}\n</code></pre></p> <p>Se desea calcular la complejidad del m\u00e9todo del apartado anterior. Se pide:</p> <ul> <li>(b) (1 punto) \u00bfCu\u00e1l es la ecuaci\u00f3n de recurrencia?</li> </ul> Mostrar soluci\u00f3n <p>T(n) = T(n-1) +c si n &gt; 1</p> <p>T(0) = d</p> <p>(c) (1 punto) Determinar su complejidad.</p> Mostrar soluci\u00f3n <p>Se puede resolver la ecuaci\u00f3n de (b) o razonar de la siguiente forma:</p> <p>Las instrucciones sencillas (if, asignaciones, acceso al array) son constantes O(1).</p> <p>El acceso al Map (get y put) podemos considerarlo tambi\u00e9n constante en condiciones adecuadas de carga.</p> <p>S\u00f3lo el bucle for depende de n, procesando cada elemento una \u00fanica vez, ergo es de complejidad O(n).</p> <p>Como O(1) \u2286 O(n), el resultado es que el algoritmo es de complejidad O(n).</p> <p>Comentarios adicionales: - no puede existir un algoritmo mejor que O(n) porque al menos hay que ver cada elemento una vez. - se puede tener un algoritmo O(n2) si con un for vamos viendo cada elemento, y para cada elemento contamos el n\u00famero de repeticiones recorriendo el array (for dentro de for). - el O(n log n) se obtiene en varias circunstancias:     - suponiendo un algoritmo de ordenaci\u00f3n de esa complejidad.     - usando un \u00e1rbol binario de b\u00fasqueda para almacenar el histograma.</p>"},{"location":"exams/2016/p1r/#problema-2","title":"Problema 2","text":"<p>Una aplicaci\u00f3n m\u00f3vil registra la actividad de un senderista. Cuando empieza una caminata, la aplicaci\u00f3n guarda la fecha (de comienzo del paseo) y una lista de coordenadas en el plano (x, y), obtenidas cada segundo. Cuando el senderista termina su actividad, la aplicaci\u00f3n manda a un servidor la siguiente informaci\u00f3n: nombre completo del senderista (String), fecha de comienzo de la actividad (Date) y la lista de coordenadas recorridas.</p> <p>El servidor, escrito en Java, guarda para cada senderista, todas las rutas que haya recorrido. Para ello, dispone de un diccionario donde la clave es el nombre del senderista y el valor es una lista de todas las rutas recorridas por dicho senderista.</p> <p>Se dispone de las siguientes declaraciones:</p> <pre><code>public class Coordenada {\n    private double x, y;\n    // constructor, getters y setters al uso\n\n    public double distancia(Coordenada b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n\npublic class Servidor {\n    private Diccionario rutas = new /* implementaci\u00f3n */;\n\n    public void anadir(String senderista, Ruta ruta) {\n        // ...\n    }\n\n    public String campeon() {\n        // ...\n        return null;\n    }\n}\n\npublic class Ruta {\n    private Date fechaComienzo;\n    private List&lt;Coordenada&gt; puntos;\n    // constructor, getters y setters al uso\n\n    public double longitud() {\n        // ...\n        return 0.0;\n    }\n}\n</code></pre> <ul> <li>(a) (1 punto) Codificar el m\u00e9todo a\u00f1adir.</li> </ul> Mostrar soluci\u00f3n <p>Como se usa un diccionario, es necesario que tengamos una lista de senderistas registrados. Por ello queda: <pre><code>// rutas de cada senderista\nprivate Diccionario rutasPorSenderista = new DiccionarioHashMap(1000);\n// tambi\u00e9n vale:\n// private Map&lt;String, List&lt;Ruta&gt;&gt; rutasPorSenderista = new HashMap&lt;&gt;();\n\n// senderistas registrados, puede evitarse a\u00f1adiendo keySet() a Diccionario\nprivate List&lt;String&gt; lsenderistas = new ArrayList&lt;String&gt;();\n\npublic void anadir(String senderista, Ruta ruta) {\n    List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n\n    if (lr == null) { // senderista no registrado\n        lsenderistas.add(senderista);\n        lr = new ArrayList&lt;Ruta&gt;();\n    }\n\n    lr.add(ruta);\n    rutasPorSenderista.put(senderista, lr);\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Codificar un m\u00e9todo de la clase Ruta que calcule la longitud total del recorrido (m\u00e9todo longitud de la clase Ruta).</li> </ul> Mostrar soluci\u00f3n <pre><code>public double longitud() {\n    double total = 0;\n\n    if (puntos == null || puntos.size() &lt; 2) { // \u00bfno hay puntos?\n        return 0;\n    }\n\n    Coordenada ant = puntos.get(0);\n    for (int i = 1; i &lt; puntos.size(); i++) {\n        Coordenada sig = puntos.get(i);\n        total += ant.distancia(sig);\n        ant = sig;\n    }\n\n    return total;\n}\n</code></pre> <ul> <li>(c) (2 puntos) Codificar un m\u00e9todo de la clase Servidor que determine qu\u00e9 senderista ha recorrido m\u00e1s distancia en total, sumando todas sus rutas (m\u00e9todo campeon de la clase Servidor). En caso de empate, puede devolver cualquiera.</li> </ul> Mostrar soluci\u00f3n <p>campe\u00f3n usa un m\u00e9todo auxiliar para averiguar la la suma de longitudes de las rutas de un usuario: <pre><code>public String campeon() {\n    String champ = null;\n    double maxLong = -1;\n\n    // tambi\u00e9n:\n    // for (String senderista : rutasPorSenderista.keySet())\n    for (String senderista : lsenderistas) {\n        List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n        double mayorCamino = sumaTotal(lr);\n\n        if (mayorCamino &gt; maxLong) {\n            maxLong = mayorCamino;\n            champ = senderista;\n        }\n    }\n    return champ;\n}\n\nprivate double sumaTotal(List&lt;Ruta&gt; lr) {\n    double suma = 0;\n    for (Ruta r : lr)\n        suma += r.longitud();\n    return suma;\n}\n</code></pre></p>"},{"location":"exams/2016/p1r/#problema-3","title":"Problema 3","text":"<p>Sea un un sistema de gesti\u00f3n de turnos en un supermercado. Los usuarios, con el tel\u00e9fono inteligente, piden n\u00famero al gestor de turnos, y pueden preguntar en cualquier momento por el turno actual. Los dependientes, con unos botones que hay en los mostradores, hacen avanzar el turno actual.</p> <p>Hay un gestor central que coordina las peticiones y avances para que no haya duplicidades ni se pierda ning\u00fan turno. Su esquema es:</p> <pre><code>class Gestor {\n    // devuelve turnos correlativos 1, 2, 3, ...\n    public int getTurno() { \u2026 }\n\n    // avanza el turno al n\u00famero siguiente\n    public void avanzaTurno() { \u2026 }\n\n    // dice en qu\u00e9 turno estamos\n    public int getActual() { \u2026 }\n}\n</code></pre> <ul> <li>(a) (1,5 puntos) Complete la clase Gestor, teniendo en cuenta que debe poder recibir llamadas concurrentes de clientes y dependientes.</li> </ul> Mostrar soluci\u00f3n <p>public class Gestor {     private int turno = 0;     private int actual = 0;</p> <pre><code>// devuelve turnos correlativos 1, 2, 3, ...\npublic synchronized int getTurno() {\n    turno++;\n    return turno;\n}\n\n// avanza el turno al n\u00famero siguiente\npublic synchronized void avanzaTurno() {\n    if (actual &lt;= turno)\n        actual++;\n}\n\n// dice en qu\u00e9 turno estamos\npublic synchronized int getActual() {\n    return actual;\n}\n</code></pre> <p>}</p> <ul> <li>(b) (1,5 puntos) Escriba el c\u00f3digo de una clase Cliente que defina una hebra (thread) que efect\u00fae las siguientes operaciones:      \u2013 Pide turno     \u2013 Cada 10 s consulta el turno actual     \u2013 Si faltan menos de 5 turnos hace BIP()     \u2013 Si le toca el turno hace BIP(); BIP();     \u2013 Si se ha pasado el turno termina la ejecuci\u00f3n de la hebra</li> </ul> <p>NOTAS: 1. Suponga que el m\u00e9todo BIP() est\u00e1 disponible directamente en la plataforma de ejecuci\u00f3n 2. El m\u00e9todo avanzaTurno no debe incrementar el n\u00famero de turno m\u00e1s all\u00e1 del \u00faltimo n\u00famero emitido. Por ejemplo, si el \u00faltimo n\u00famero devuelto por getTurno es el 41, el m\u00e9todo avanzaTurno puede llegar a 42, pero no puede avanzar a 43. 3. Los m\u00e9todos de Gestor devuelven el control inmediatamente, sin esperas.</p> Mostrar soluci\u00f3n <p>public class Cliente extends Thread {     private Gestor gestor;</p> <pre><code>public Cliente(int id, Gestor gestor) {\n    this.gestor = gestor;\n}\n\n@Override\npublic void run() {\n    int turno = gestor.getTurno();\n    int actual;\n\n    do {\n        actual = gestor.getActual();\n\n        if (turno - actual &lt; 5)\n            BIP();\n\n        if (actual == turno) {\n            BIP();\n            break;\n        }\n\n        try {\n            sleep(10000);\n        } catch (InterruptedException ignored) {\n        }\n\n    } while (turno &gt; actual);\n}\n</code></pre> <p>}</p>"},{"location":"exams/2016/p1r_ex01/","title":"P1r ex01","text":"<p>Se quiere desarrollar un algoritmo que, dado un array de enteros, calcule cu\u00e1l es el n\u00famero que se repite m\u00e1s veces. As\u00ed, si el array contiene {2, 4, 3, 4, 2, 6, 1, 4, 4}, el algoritmo devuelve 4. Si hay empate, devuelve el primer valor. Se pide:</p> <ul> <li>(a) (1 punto) Escribir un m\u00e9todo en Java que compute el algoritmo descrito. Si el array est\u00e1 vac\u00edo o es nulo, se lanzar\u00e1 una excepci\u00f3n. La cabecera del m\u00e9todo debe ser:</li> </ul> <pre><code>int mayoria (int []v) throws exception\n</code></pre> Mostrar soluci\u00f3n <p>Hay varias posibles soluciones:</p> <ol> <li>hacer un histograma, eligiendo el valor mayor seg\u00fan se cuenta</li> <li>ordenar el array y contar repeticiones sucesivas</li> </ol> <p>Se incluye la soluci\u00f3n 1, almacenando el histograma en un Map. Una posible soluci\u00f3n es: <pre><code>public static int mayoria(int[] v) throws Exception {\n    if (v == null || v.length == 0)\n        throw new IllegalArgumentException(\"mayoria: invalid argument\");\n\n    Map&lt;Integer, Integer&gt; histograma = new HashMap&lt;Integer, Integer&gt;();\n    int masRep = v[0];        // candidato inicial\n    int repeticiones = 1;    // aparece una vez\n\n    for (int i = 0; i &lt; v.length; i++) {\n        Integer veces = histograma.get(v[i]);\n        veces = (veces == null) ? 1 : veces + 1;\n        histograma.put(v[i], veces);\n\n        if (veces &gt; repeticiones) {\n            repeticiones = veces;\n            masRep = v[i];\n        }\n    }\n    return masRep;\n}\n</code></pre></p> <p>Se desea calcular la complejidad del m\u00e9todo del apartado anterior. Se pide:</p> <ul> <li>(b) (1 punto) \u00bfCu\u00e1l es la ecuaci\u00f3n de recurrencia?</li> </ul> Mostrar soluci\u00f3n <p>T(n) = T(n-1) +c si n &gt; 1</p> <p>T(0) = d</p> <p>(c) (1 punto) Determinar su complejidad.</p> Mostrar soluci\u00f3n <p>Se puede resolver la ecuaci\u00f3n de (b) o razonar de la siguiente forma:</p> <p>Las instrucciones sencillas (if, asignaciones, acceso al array) son constantes O(1).</p> <p>El acceso al Map (get y put) podemos considerarlo tambi\u00e9n constante en condiciones adecuadas de carga.</p> <p>S\u00f3lo el bucle for depende de n, procesando cada elemento una \u00fanica vez, ergo es de complejidad O(n).</p> <p>Como O(1) \u2286 O(n), el resultado es que el algoritmo es de complejidad O(n).</p> <p>Comentarios adicionales: - no puede existir un algoritmo mejor que O(n) porque al menos hay que ver cada elemento una vez. - se puede tener un algoritmo O(n2) si con un for vamos viendo cada elemento, y para cada elemento contamos el n\u00famero de repeticiones recorriendo el array (for dentro de for). - el O(n log n) se obtiene en varias circunstancias:     - suponiendo un algoritmo de ordenaci\u00f3n de esa complejidad.     - usando un \u00e1rbol binario de b\u00fasqueda para almacenar el histograma.</p>","tags":["complejidad"]},{"location":"exams/2016/p1r_ex02/","title":"P1r ex02","text":"<p>Una aplicaci\u00f3n m\u00f3vil registra la actividad de un senderista. Cuando empieza una caminata, la aplicaci\u00f3n guarda la fecha (de comienzo del paseo) y una lista de coordenadas en el plano (x, y), obtenidas cada segundo. Cuando el senderista termina su actividad, la aplicaci\u00f3n manda a un servidor la siguiente informaci\u00f3n: nombre completo del senderista (String), fecha de comienzo de la actividad (Date) y la lista de coordenadas recorridas.</p> <p>El servidor, escrito en Java, guarda para cada senderista, todas las rutas que haya recorrido. Para ello, dispone de un diccionario donde la clave es el nombre del senderista y el valor es una lista de todas las rutas recorridas por dicho senderista.</p> <p>Se dispone de las siguientes declaraciones:</p> <pre><code>public class Coordenada {\n    private double x, y;\n    // constructor, getters y setters al uso\n\n    public double distancia(Coordenada b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n\npublic class Servidor {\n    private Diccionario rutas = new /* implementaci\u00f3n */;\n\n    public void anadir(String senderista, Ruta ruta) {\n        // ...\n    }\n\n    public String campeon() {\n        // ...\n        return null;\n    }\n}\n\npublic class Ruta {\n    private Date fechaComienzo;\n    private List&lt;Coordenada&gt; puntos;\n    // constructor, getters y setters al uso\n\n    public double longitud() {\n        // ...\n        return 0.0;\n    }\n}\n</code></pre> <ul> <li>(a) (1 punto) Codificar el m\u00e9todo a\u00f1adir.</li> </ul> Mostrar soluci\u00f3n <p>Como se usa un diccionario, es necesario que tengamos una lista de senderistas registrados. Por ello queda: <pre><code>// rutas de cada senderista\nprivate Diccionario rutasPorSenderista = new DiccionarioHashMap(1000);\n// tambi\u00e9n vale:\n// private Map&lt;String, List&lt;Ruta&gt;&gt; rutasPorSenderista = new HashMap&lt;&gt;();\n\n// senderistas registrados, puede evitarse a\u00f1adiendo keySet() a Diccionario\nprivate List&lt;String&gt; lsenderistas = new ArrayList&lt;String&gt;();\n\npublic void anadir(String senderista, Ruta ruta) {\n    List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n\n    if (lr == null) { // senderista no registrado\n        lsenderistas.add(senderista);\n        lr = new ArrayList&lt;Ruta&gt;();\n    }\n\n    lr.add(ruta);\n    rutasPorSenderista.put(senderista, lr);\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Codificar un m\u00e9todo de la clase Ruta que calcule la longitud total del recorrido (m\u00e9todo longitud de la clase Ruta).</li> </ul> Mostrar soluci\u00f3n <pre><code>public double longitud() {\n    double total = 0;\n\n    if (puntos == null || puntos.size() &lt; 2) { // \u00bfno hay puntos?\n        return 0;\n    }\n\n    Coordenada ant = puntos.get(0);\n    for (int i = 1; i &lt; puntos.size(); i++) {\n        Coordenada sig = puntos.get(i);\n        total += ant.distancia(sig);\n        ant = sig;\n    }\n\n    return total;\n}\n</code></pre> <ul> <li>(c) (2 puntos) Codificar un m\u00e9todo de la clase Servidor que determine qu\u00e9 senderista ha recorrido m\u00e1s distancia en total, sumando todas sus rutas (m\u00e9todo campeon de la clase Servidor). En caso de empate, puede devolver cualquiera.</li> </ul> Mostrar soluci\u00f3n <p>campe\u00f3n usa un m\u00e9todo auxiliar para averiguar la la suma de longitudes de las rutas de un usuario: <pre><code>public String campeon() {\n    String champ = null;\n    double maxLong = -1;\n\n    // tambi\u00e9n:\n    // for (String senderista : rutasPorSenderista.keySet())\n    for (String senderista : lsenderistas) {\n        List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n        double mayorCamino = sumaTotal(lr);\n\n        if (mayorCamino &gt; maxLong) {\n            maxLong = mayorCamino;\n            champ = senderista;\n        }\n    }\n    return champ;\n}\n\nprivate double sumaTotal(List&lt;Ruta&gt; lr) {\n    double suma = 0;\n    for (Ruta r : lr)\n        suma += r.longitud();\n    return suma;\n}\n</code></pre></p>","tags":["???"]},{"location":"exams/2016/p1r_ex03/","title":"P1r ex03","text":"<p>Sea un un sistema de gesti\u00f3n de turnos en un supermercado. Los usuarios, con el tel\u00e9fono inteligente, piden n\u00famero al gestor de turnos, y pueden preguntar en cualquier momento por el turno actual. Los dependientes, con unos botones que hay en los mostradores, hacen avanzar el turno actual.</p> <p>Hay un gestor central que coordina las peticiones y avances para que no haya duplicidades ni se pierda ning\u00fan turno. Su esquema es:</p> <pre><code>class Gestor {\n    // devuelve turnos correlativos 1, 2, 3, ...\n    public int getTurno() { \u2026 }\n\n    // avanza el turno al n\u00famero siguiente\n    public void avanzaTurno() { \u2026 }\n\n    // dice en qu\u00e9 turno estamos\n    public int getActual() { \u2026 }\n}\n</code></pre> <ul> <li>(a) (1,5 puntos) Complete la clase Gestor, teniendo en cuenta que debe poder recibir llamadas concurrentes de clientes y dependientes.</li> </ul> Mostrar soluci\u00f3n <p>public class Gestor {     private int turno = 0;     private int actual = 0;</p> <pre><code>// devuelve turnos correlativos 1, 2, 3, ...\npublic synchronized int getTurno() {\n    turno++;\n    return turno;\n}\n\n// avanza el turno al n\u00famero siguiente\npublic synchronized void avanzaTurno() {\n    if (actual &lt;= turno)\n        actual++;\n}\n\n// dice en qu\u00e9 turno estamos\npublic synchronized int getActual() {\n    return actual;\n}\n</code></pre> <p>}</p> <ul> <li>(b) (1,5 puntos) Escriba el c\u00f3digo de una clase Cliente que defina una hebra (thread) que efect\u00fae las siguientes operaciones:      \u2013 Pide turno     \u2013 Cada 10 s consulta el turno actual     \u2013 Si faltan menos de 5 turnos hace BIP()     \u2013 Si le toca el turno hace BIP(); BIP();     \u2013 Si se ha pasado el turno termina la ejecuci\u00f3n de la hebra</li> </ul> <p>NOTAS: 1. Suponga que el m\u00e9todo BIP() est\u00e1 disponible directamente en la plataforma de ejecuci\u00f3n 2. El m\u00e9todo avanzaTurno no debe incrementar el n\u00famero de turno m\u00e1s all\u00e1 del \u00faltimo n\u00famero emitido. Por ejemplo, si el \u00faltimo n\u00famero devuelto por getTurno es el 41, el m\u00e9todo avanzaTurno puede llegar a 42, pero no puede avanzar a 43. 3. Los m\u00e9todos de Gestor devuelven el control inmediatamente, sin esperas.</p> Mostrar soluci\u00f3n <p>public class Cliente extends Thread {     private Gestor gestor;</p> <pre><code>public Cliente(int id, Gestor gestor) {\n    this.gestor = gestor;\n}\n\n@Override\npublic void run() {\n    int turno = gestor.getTurno();\n    int actual;\n\n    do {\n        actual = gestor.getActual();\n\n        if (turno - actual &lt; 5)\n            BIP();\n\n        if (actual == turno) {\n            BIP();\n            break;\n        }\n\n        try {\n            sleep(10000);\n        } catch (InterruptedException ignored) {\n        }\n\n    } while (turno &gt; actual);\n}\n</code></pre> <p>}</p>","tags":["monitores"]},{"location":"exams/2016/p2/","title":"Examen 2016 \u2014 Parcial 2","text":""},{"location":"exams/2016/p2/#problema-1","title":"Problema 1","text":"<p>En un programa existe una zona cr\u00edtica especial, llam\u00e9mosla \u201csupersticiosa\u201d, en la que puede haber cualquier n\u00famero de hebras, siempre que no sean trece.</p> <ul> <li>(a) (5 puntos) Se pide realizar una clase sincronizada (seg\u00fan el esquema que da a continuaci\u00f3n) que realice tal protocolo de sincronizaci\u00f3n. Para simplificar el c\u00f3digo, no tenga en cuenta la excepci\u00f3n que pueda presentarse en la operaci\u00f3n wait().</li> </ul> <pre><code>package es.upm.dit.adsw.super;\n\npublic class Supersticiosa {\n    // ...\n\n    // quiero entrar en la zona cr\u00edtica\n    public synchronized void entrar() {\n        // ...\n    }\n\n    // quiero salir de la zona cr\u00edtica\n    public synchronized void salir() {\n        // ...\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>package es.upm.dit.adsw.super;\n\npublic class Supersticioso {\n    // n\u00famero de peticiones de entrada a la R.C.\n    // menos n\u00famero de peticiones de salida de la R.C.\n    private int n = 0;\n\n    // quiero entrar en la zona cr\u00edtica\n    public synchronized void entrar() {\n        n++;\n        while (n == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        notifyAll();\n    }\n\n    // quiero salir de la zona cr\u00edtica\n    public synchronized void salir() {\n        n--;\n        while (n == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        notifyAll();\n    }\n}\n</code></pre> <p>Otra posible soluci\u00f3n para una interpretaci\u00f3n diferente del enunciado es:</p> <pre><code>public class Supersticioso {\n    private int nDentro = 0;\n\n    public synchronized void entrar() {\n        while (nDentro + 1 == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        nDentro++;\n    }\n\n    public synchronized void salir() {\n        nDentro--;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2016/p2/#problema-2","title":"Problema 2","text":"<p>Queremos ampliar la pr\u00e1ctica 7-8 de forma que junto con el detalle de cada noticia, cada usuario pueda valorarla o hacer un comentario. No necesita el c\u00f3digo de la pr\u00e1ctica para realizar este problema.</p> <p>A continuaci\u00f3n se le muestra una secuencia del uso de la nueva pantalla. El usuario parte de DetailActivity, donde ve la noticia (t\u00edtulo y descripci\u00f3n) y aparecen los comentarios y la puntuaci\u00f3n vac\u00edos, junto con dos botones (Comentar y Puntuar).</p> <p>Si pincha en Comentar, va a la segunda pantalla (ComentarActivity), donde rellena el comentario y puede dar a Guardar o Cancelar. En ambos casos volver\u00e1 a DetailActivity. En la imagen se muestra c\u00f3mo ha pulsado Guardar y se muestra el comentario que el usuario ha introducido en DetailActivity.</p> <p></p> <p>A continuaci\u00f3n, suponemos que el usuario da a Puntuar, en que introduce una puntaci\u00f3n, y tiene las mismas opciones que en ComentarActivity. Suponemos que ha pulsado Guardar y vuelve a DetailActivity, donde se muestra la puntaci\u00f3n asignada.</p> <p></p> <ul> <li>(a) (5 puntos) Se pide:<ul> <li>Programe el c\u00f3digo necesario para que DetailActivity tenga el nuevo bot\u00f3n Comentar y realice la funcionalidad descrita cuando se pincha en dicho bot\u00f3n:<ul> <li> <ol> <li>Muestre una pantalla ComentarActivity.</li> </ol> </li> <li> <ol> <li>Si el usuario pulsa Guardar en dicha pantalla, se vuelve a DetailActivity y se muestra el comentario escrito en la pantalla, junto con la traza informativa \u201cNuevo comentario\u201d.</li> </ol> </li> <li> <ol> <li>Si el usuario pulsa Cancelar en dicha pantalla, se vuelve a DetailActivity y se muestra un Toast y una traza informativa con el contenido \u201cEl usuario no ha hecho comentarios\u201d.</li> </ol> </li> </ul> </li> </ul> </li> </ul> <p>Nota: Suponga que est\u00e1n programados ya todos los layouts, as\u00ed como las clases ComentarActivity y PuntuarActivity. Use las variables que necesite indicando d\u00f3nde estar\u00edan definidas.</p> Mostrar soluci\u00f3n <pre><code>public class DetailActivity extends AppCompatActivity {\n    private static final String TAG = DetailActivity.class.getName();\n    private static final int COMENTAR = 0;\n    private static final int PUNTUAR = 1;\n\n    private TextView comentarioTextView;\n    private RssContent.EntryRss entry;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_detail);\n\n        Bundle extras = getIntent().getExtras();\n        if (extras == null) {\n            Log.e(TAG, \"Fallo - Deber\u00eda recibir la noticia\");\n            finish();\n        }\n\n        entry = (RssContent.EntryRss) extras.getSerializable(\"entry\");\n        if (entry == null) {\n            Log.e(TAG, \"Entry mal recuperado\");\n            finish();\n        }\n\n        comentarioTextView = (TextView) findViewById(R.id.comentario);\n        comentarioTextView.setText(entry.comentario);\n\n        Button botonComentar = (Button) findViewById(R.id.comentar);\n        botonComentar.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Log.d(TAG, \"Comentar\");\n                Intent i = new Intent(DetailActivity.this, ComentarActivity.class);\n                i.putExtra(\"titulo\", entry.title);\n                startActivityForResult(i, COMENTAR);\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int reqCode, int resultCode, Intent data) {\n        switch (reqCode) {\n            case COMENTAR: {\n                if (resultCode == RESULT_OK) {\n                    Log.i(TAG, \"Nuevo comentario\");\n                    Bundle extras = data.getExtras();\n                    String comentario = extras.getString(\"comentario\");\n                    comentarioTextView.setText(comentario);\n                    entry.comentario = comentario;\n                    RssContent.modifyEntryRss(entry); // almaceno cambio\n                } else {\n                    String msg = \"El usuario no ha hecho comentarios\";\n                    Log.i(TAG, msg);\n                    Toast.makeText(getBaseContext(), msg, Toast.LENGTH_SHORT).show();\n                }\n                break;\n            }\n            case PUNTUAR: {\n                break;\n            }\n            default:\n                Log.e(TAG, \"Acci\u00f3n inesperada\");\n                finish();\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2016/p2_ex01/","title":"P2 ex01","text":"<p>En un programa existe una zona cr\u00edtica especial, llam\u00e9mosla \u201csupersticiosa\u201d, en la que puede haber cualquier n\u00famero de hebras, siempre que no sean trece.</p> <ul> <li>(a) (5 puntos) Se pide realizar una clase sincronizada (seg\u00fan el esquema que da a continuaci\u00f3n) que realice tal protocolo de sincronizaci\u00f3n. Para simplificar el c\u00f3digo, no tenga en cuenta la excepci\u00f3n que pueda presentarse en la operaci\u00f3n wait().</li> </ul> <pre><code>package es.upm.dit.adsw.super;\n\npublic class Supersticiosa {\n    // ...\n\n    // quiero entrar en la zona cr\u00edtica\n    public synchronized void entrar() {\n        // ...\n    }\n\n    // quiero salir de la zona cr\u00edtica\n    public synchronized void salir() {\n        // ...\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>package es.upm.dit.adsw.super;\n\npublic class Supersticioso {\n    // n\u00famero de peticiones de entrada a la R.C.\n    // menos n\u00famero de peticiones de salida de la R.C.\n    private int n = 0;\n\n    // quiero entrar en la zona cr\u00edtica\n    public synchronized void entrar() {\n        n++;\n        while (n == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        notifyAll();\n    }\n\n    // quiero salir de la zona cr\u00edtica\n    public synchronized void salir() {\n        n--;\n        while (n == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        notifyAll();\n    }\n}\n</code></pre> <p>Otra posible soluci\u00f3n para una interpretaci\u00f3n diferente del enunciado es:</p> <pre><code>public class Supersticioso {\n    private int nDentro = 0;\n\n    public synchronized void entrar() {\n        while (nDentro + 1 == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        nDentro++;\n    }\n\n    public synchronized void salir() {\n        nDentro--;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2016/p2_ex02/","title":"P2 ex02","text":"<p>Queremos ampliar la pr\u00e1ctica 7-8 de forma que junto con el detalle de cada noticia, cada usuario pueda valorarla o hacer un comentario. No necesita el c\u00f3digo de la pr\u00e1ctica para realizar este problema.</p> <p>A continuaci\u00f3n se le muestra una secuencia del uso de la nueva pantalla. El usuario parte de DetailActivity, donde ve la noticia (t\u00edtulo y descripci\u00f3n) y aparecen los comentarios y la puntuaci\u00f3n vac\u00edos, junto con dos botones (Comentar y Puntuar).</p> <p>Si pincha en Comentar, va a la segunda pantalla (ComentarActivity), donde rellena el comentario y puede dar a Guardar o Cancelar. En ambos casos volver\u00e1 a DetailActivity. En la imagen se muestra c\u00f3mo ha pulsado Guardar y se muestra el comentario que el usuario ha introducido en DetailActivity.</p> <p></p> <p>A continuaci\u00f3n, suponemos que el usuario da a Puntuar, en que introduce una puntaci\u00f3n, y tiene las mismas opciones que en ComentarActivity. Suponemos que ha pulsado Guardar y vuelve a DetailActivity, donde se muestra la puntaci\u00f3n asignada.</p> <p></p> <ul> <li>(a) (5 puntos) Se pide:<ul> <li>Programe el c\u00f3digo necesario para que DetailActivity tenga el nuevo bot\u00f3n Comentar y realice la funcionalidad descrita cuando se pincha en dicho bot\u00f3n:<ul> <li> <ol> <li>Muestre una pantalla ComentarActivity.</li> </ol> </li> <li> <ol> <li>Si el usuario pulsa Guardar en dicha pantalla, se vuelve a DetailActivity y se muestra el comentario escrito en la pantalla, junto con la traza informativa \u201cNuevo comentario\u201d.</li> </ol> </li> <li> <ol> <li>Si el usuario pulsa Cancelar en dicha pantalla, se vuelve a DetailActivity y se muestra un Toast y una traza informativa con el contenido \u201cEl usuario no ha hecho comentarios\u201d.</li> </ol> </li> </ul> </li> </ul> </li> </ul> <p>Nota: Suponga que est\u00e1n programados ya todos los layouts, as\u00ed como las clases ComentarActivity y PuntuarActivity. Use las variables que necesite indicando d\u00f3nde estar\u00edan definidas.</p> Mostrar soluci\u00f3n <pre><code>public class DetailActivity extends AppCompatActivity {\n    private static final String TAG = DetailActivity.class.getName();\n    private static final int COMENTAR = 0;\n    private static final int PUNTUAR = 1;\n\n    private TextView comentarioTextView;\n    private RssContent.EntryRss entry;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_detail);\n\n        Bundle extras = getIntent().getExtras();\n        if (extras == null) {\n            Log.e(TAG, \"Fallo - Deber\u00eda recibir la noticia\");\n            finish();\n        }\n\n        entry = (RssContent.EntryRss) extras.getSerializable(\"entry\");\n        if (entry == null) {\n            Log.e(TAG, \"Entry mal recuperado\");\n            finish();\n        }\n\n        comentarioTextView = (TextView) findViewById(R.id.comentario);\n        comentarioTextView.setText(entry.comentario);\n\n        Button botonComentar = (Button) findViewById(R.id.comentar);\n        botonComentar.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Log.d(TAG, \"Comentar\");\n                Intent i = new Intent(DetailActivity.this, ComentarActivity.class);\n                i.putExtra(\"titulo\", entry.title);\n                startActivityForResult(i, COMENTAR);\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int reqCode, int resultCode, Intent data) {\n        switch (reqCode) {\n            case COMENTAR: {\n                if (resultCode == RESULT_OK) {\n                    Log.i(TAG, \"Nuevo comentario\");\n                    Bundle extras = data.getExtras();\n                    String comentario = extras.getString(\"comentario\");\n                    comentarioTextView.setText(comentario);\n                    entry.comentario = comentario;\n                    RssContent.modifyEntryRss(entry); // almaceno cambio\n                } else {\n                    String msg = \"El usuario no ha hecho comentarios\";\n                    Log.i(TAG, msg);\n                    Toast.makeText(getBaseContext(), msg, Toast.LENGTH_SHORT).show();\n                }\n                break;\n            }\n            case PUNTUAR: {\n                break;\n            }\n            default:\n                Log.e(TAG, \"Acci\u00f3n inesperada\");\n                finish();\n        }\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2017/extra/","title":"Examen 2017 - Extraordinario","text":""},{"location":"exams/2017/extra/#problema-1","title":"Problema 1","text":"<p>A pesar de que un genoma tiene m\u00e1s de dos gigas de (solo cuatro tipos distintos de) bases (A, G, C, T), la mayor parte del mismo es \u201cbasura\u201d, pues solo una peque\u00f1a fracci\u00f3n de subsecuencias (contiguas) del mismo codifica la producci\u00f3n de amino\u00e1cidos, es decir, prote\u00ednas. A esas subsecuencias significativas de bases se les conoce con el nombre de genes.</p> <p>Las subsecuencias que constituyen genes son de longitud moderada, entre cien y mil bases, y tienen la caracter\u00edstica de que al menos una de las cuatro bases se presenta en dicha subsecuencia con (mucha) menor frecuencia que las otras tres. Digamos, por ejemplo, 20 por ciento menos. Interpretado este porcentaje sobre el n\u00famero total de bases de la subsecuencia considerada.</p> <ul> <li>(a) (5 puntos) Se pide dise\u00f1ar un algoritmo (no un programa) que, a partir de un genoma especificado como una (muy) larga secuencia de bases, encuentre los genes de longitud 300 bases. Y a continuaci\u00f3n, analizar la complejidad en espacio y en tiempo de dicho algoritmo en t\u00e9rminos del tama\u00f1o del genoma.</li> </ul> Mostrar soluci\u00f3n <p>Se supone declarada una clase, llam\u00e9mosla Contadores, con cuatro atributos enteros de valor inicial cero, que se van a usar para contar del n\u00famero de cada tipo de base que hay, desde el principio del genoma hasta un punto dado. Y se supone tambi\u00e9n que tenemos un array, llam\u00e9mosle ultimas300, que mantiene el valor de los cuatro contadores para cada uno de los \u00faltimos 300 puntos del genoma que hemos visitado, seg\u00fan lo exploramos desde el principio hasta el final de su cadena de bases.</p> <p>El algoritmo es:     1) Ir leyendo de un fichero el genoma base a base desde el principio hasta su posici\u00f3n 299, actualizando los contadores de ultimas300 en las posiciones 0-298.     2) Leer la siguiente base del genoma, incrementar el contador correspondiente a esa base en la \u00faltima posici\u00f3n actualizada del array en una unidad, y guardar los cuatro valores actuales en la siguiente posici\u00f3n de ultimas300, manejando este array de manera circular (la posici\u00f3n siguiente a la 299 es la cero).     3) Restar de los cuatro contadores actuales los contadores que est\u00e1n en el array 299 posiciones antes (de manera circular tambi\u00e9n). Si uno de esos cuatro valores es menor que 60 (=300/4*0.8), hemos encontrado un gen y lo imprimimos.     4) Si a\u00fan quedan bases por leer en el genoma, volvemos al punto 2). En otro caso, hemos acabado el algoritmo.</p> <p>La complejidad en espacio es constante, pues el tama\u00f1o de ultimas300 es fijo, no depende del tama\u00f1o del genoma. En cuanto a la complejidad en tiempo, la parte 1) es tambi\u00e9n constante, ya que tampoco depende del tama\u00f1o del genoma. Mientras que las partes 2), 3) y 4) se ejecutan una vez por cada base del genoma (exceptuando las 299 primeras, valor constante). Y como resulta que esas tres partes tienen una complejidad constante, se tiene:</p> <p>C1 + C2O(n-299) + C3O(n-299) + C4O(n-299) = (C1 - 299(C2+C3+C4)) + (C2+C3+C4)O(n) = C5 + C6O(n) = C6*O(n) = O(n)</p> <p>Es decir, el algoritmo tiene una complejidad lineal en el tiempo.</p>"},{"location":"exams/2017/extra/#problema-2","title":"Problema 2","text":"<p>La clase RegistroDatos, permite almacenar los datos producidos por un conjunto de sensores. Los datos producidos por los sensores se env\u00edan como objetos de la clase Dato, cuya estructura se muestra a continuaci\u00f3n:</p> <pre><code>public class Dato implements Comparable&lt;Dato&gt; {\n\n    private String id;   // Identificador \u00fanico del sensor que ha generado el dato\n    private Date d;      // Fecha en la que se ha producido el dato (clase Date de Java)\n    private long v;      // Valor del dato producido\n    ... //Contiene constructor, getters, y setters\n}\n</code></pre> <p>La clase RegistroDatos guarda los datos recibidos en un array (private List []datos). Cada dato se guarda en la posici\u00f3n del array que se obtiene aplicando el m\u00e9todo hashCode de la clase String al identificador \u00fanico del sensor que ha producido el dato y adaptando el resultado al tama\u00f1o del array datos.  <p>Adem\u00e1s, se lleva una cuenta del n\u00famero de datos que ha generado cada sensor, mediante el atributo cuentaDatos (private Map  cuentaDatos), usando como clave el identificador \u00fanico del sensor que ha producido el dato y como valor un objeto de la clase Registro, cuya estructura se muestra a continuaci\u00f3n: <pre><code>public class Registro implements Comparable&lt;Registro&gt; {\n\n    private final String clave; // Identificador \u00fanico del sensor\n    private int cnt;            // N\u00famero de datos producidos por ese sensor\n    ... //Contiene constructor, getters, y setters\n}\n</code></pre> <ul> <li>(a) (5 puntos) Se pide completar los m\u00e9todos Constructor, put, getDatos, size y countAbove de la clase RegistroDatos. El esqueleto de la se muestra a continuaci\u00f3n:</li> </ul> <pre><code>public class RegistroDatos {\n    private List&lt;Dato&gt;[] datos;\n    private Map&lt;String, Registro&gt; cuentaDatos;\n\n    /**\n     * Constructor\n     * @param n n\u00famero de posiciones del array datos donde se van a almacenar\n     * los datos producidos por los sensores\n     */\n    public RegistroDatos(int n) {\n        //TODO\n    }\n\n    /**\n     * Devuelve cuantos sensores han producido un n\u00famero de datos por encima\n     * de un determinado umbral c.\n     * @param c umbral de cuenta.\n     * @return n\u00famero de sensores que han generado m\u00e1s de c datos\n     */\n    public int countAbove(int c) {\n        //TODO\n    }\n\n    /**\n     * Devuelve los datos producidos por un determinado sensor\n     * @param sensorId identificador del sensor\n     * @return lista de datos producidos por ese sensor.\n     * Si no hay ning\u00fan sensor con ese sensorId devolver\u00e1 una lista con 0 valores.\n     */\n    public List&lt;Dato&gt; getDatos(String sensorId) {\n        //TODO\n    }\n\n    /**\n     * Almacena un nuevo dato en el Registro de datos, para ello incrementa en uno la\n     * cuenta de datos\n     * proporcionados por el sensor, y almacena el dato en la posici\u00f3n correspondiente de\n     * la tabla Hash\n     * @param dato la nuevo dato a almacenar\n     */\n    private void put(Dato dato) {\n        //TODO\n    }\n\n    /**\n     * Numero de Datos total almacenado.\n     * @return numero de datos.\n     */\n    public int size() {\n        //TODO\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>public class RegistroDatos {\n    private List&lt;Dato&gt;[] datos;\n    private Map&lt;String, Registro&gt; cuentaDatos;\n\n    /**\n     * Constructor\n     * @param n n\u00famero de posiciones del array datos donde se van a almacenar\n     * los datos producidos por los sensores\n     */\n    public RegistroDatos(int n) {\n        this.datos = new List[N];\n        for (int i = 0; i &lt; N; i++) {\n            datos[i] = new ArrayList();\n        }\n        cuentaDatos = new HashMap&lt;String, Registro&gt;();\n    }\n\n    /**\n     * Devuelve cuantos sensores han producido un n\u00famero de datos por encima\n     * de un determinado umbral c.\n     * @param c umbral de cuenta.\n     * @return numero de sensores que han generado m\u00e1s de c datos\n     */\n    public int countAbove(int c) {\n        int cuenta = 0;\n        Set&lt;String&gt; keySet = cuentaDatos.keySet();\n        for (String key : keySet) {\n            if (cuentaDatos.get(key).getCnt() &lt; c)\n                cuenta++;\n        }\n        return cuenta;\n    }\n\n    /*\n     * Devuelve los datos producidos por un determinado sensor\n     * @param sensorId identificador del sensor\n     * @return lista de datos producidos por ese sensor.\n     * Si no hay ning\u00fan sensor con ese sensorId devolver\u00e1 una lista con 0 valores.\n     */\n    public List&lt;Dato&gt; getDatos(String sensorId) {\n        List&lt;Dato&gt; listaDatos = new ArrayList&lt;Dato&gt;();\n        int hc = sensorId.hashCode();\n        hc = hc % datos.length;\n        for (Dato d : datos[hc]) {\n            if (d.getId().equals(sensorId))\n                listaDatos.add(d);\n        }\n        return listaDatos;\n    }\n\n    /**\n     * El m\u00e9todo put (), se encarga de meter un nuevo dato en el Registro de datos,\n     * para ello incrementa en uno la cuenta de datos proporcionados por el sensor,\n     * y almacena el dato en la posici\u00f3n correspondiente de la tabla Hash\n     * @param dato la nuevo dato a almacenar\n     */\n    private void put(Dato dato) {\n        if (cuentaDatos.containsKey(dato.getId())) {\n            cuentaDatos.get(dato.getId()).inc();\n        } else {\n            cuentaDatos.put(dato.getId(), new Registro(dato.getId()));\n        }\n        int hc = dato.getId().hashCode();\n        hc = hc % datos.length;\n        datos[hc].add(dato);\n    }\n\n    /**\n     * Numero de Datos Total Almacenado.\n     * @return numero de datos.\n     */\n    public int size() {\n        int suma = 0;\n        Set&lt;String&gt; keySet = cuentaDatos.keySet();\n        for (String key : keySet) {\n            suma += cuentaDatos.get(key).getCnt();\n        }\n        return suma;\n    }\n}\n</code></pre>"},{"location":"exams/2017/extra/#problema-3","title":"Problema 3","text":"<p>Varios ingenieros utilizan una base de datos para almacenar informes. Para ello disponen de una aplicaci\u00f3n que permite almacenar un informe o recuperar un informe anterior. El acceso a los datos se organiza mediante una clase de Java que responde al esquema siguiente esquema:</p> <pre><code>public class Datos {\n\u2026\n    public \u2026 void guardar (String clave) {\u2026}\n    public \u2026 void consultar (String clave) {\u2026}\n    public \u2026 void terminar (String clave) {\u2026}\n}\n</code></pre> <p>Las aplicaciones se ejecutan concurrentemente, y llaman a guardar o a consultar antes de realizar una secuencia de operaciones de almacenar o recuperar informes, respectivamente. Cuando han terminado de realizar estas operaciones llaman a terminar. Puede haber varias aplicaciones consultando informes a la vez, pero no consultando y guardando, ni varias guardando a la vez.</p> <p>Los objetos de la clase Ingeniero son hebras que ejecutan repetidamente el siguiente c\u00f3digo:</p> <pre><code>datos.guardar(clave);\nfor (int i = 1; i &lt;= ndoc; i++) {\n    // generar informe y almacenarlo en la base de datos\n}\ndatos.terminar(clave);\n</code></pre> <p>o bien</p> <pre><code>datos.consultar(clave);\nfor (int i = 1; i &lt;= ndoc; i++) {\n    // realizar consulta en la base de datos\n}\ndatos.terminar(clave);\n</code></pre> <ul> <li>(a) (4 puntos) Complete el c\u00f3digo de la clase Datos de forma que se cumplan las condiciones del enunciado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Datos {\n    private int consultando = 0;\n    private boolean guardando = false;\n\n    public synchronized void guardar(String clave) {\n        while (guardando || consultando &gt; 0)\n            try {\n                wait();\n            } catch (InterruptedException e) {}\n        guardando = true;\n    }\n\n    public synchronized void consultar(String clave) {\n        while (guardando)\n            try {\n                wait();\n            } catch (InterruptedException e) {}\n        consultando++;\n    }\n\n    public synchronized void terminar(String clave) {\n        if (consultando &gt; 0) {\n            consultando--;\n        } else {\n            guardando = false;\n        }\n        notifyAll();\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Escriba el c\u00f3digo de una posible implementaci\u00f3n de la clase Ingeniero para consultar datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Ingeniero_Consulta extends Thread {\n    Datos datos;\n    int ndoc = 10; // por ejemplo\n\n    public Ingeniero_Consulta(Datos datos) {\n        this.datos = datos;\n    }\n\n    public void run() {\n        datos.consultar(\"clave\"); // por ejemplo\n        for (int i = 1; i &lt;= ndoc; i++) {\n            // realizar la consulta\n        }\n        datos.terminar(\"clave\");\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Analice si puede haber problemas de inanici\u00f3n (starvation) en el acceso a los datos y, si es as\u00ed, ponga alg\u00fan ejemplo (sin resolverlo).</li> </ul> Mostrar soluci\u00f3n <p>Como en el problema original, la soluci\u00f3n dada puede dar lugar a inanici\u00f3n de los ingenieros que guardan informes. Por ejemplo, sin entran varios a consultar y antes de que terminen entran otros nuevos, esta situaci\u00f3n se puede prolongar indefinidamente, no dejando acceder nunca a otros ingenieros que deseen guardar informes. Las soluci\u00f3n es establecer turnos para dar prioridad, alternativamente, a los que guardan (escritores) y a los que consultan (lectores)</p>"},{"location":"exams/2017/extra/#problema-4","title":"Problema 4","text":"<p>Se dispone de una aplicaci\u00f3n Android para la consulta de notas por parte de los alumnos. La aplicaci\u00f3n consta de dos pantallas, denominadas MainActivity y ResultActivity.</p> <p>En la primera pantalla (MainActivity), el usuario introduce su identificaci\u00f3n (nombre y apellidos) y el c\u00f3digo num\u00e9rico de la asignatura a consultar. Dispone de un bot\u00f3n con el texto \u201cConsultar\u201d que, al pulsarse, pasa a la segunda pantalla ResultActivity, mediante un Intent con la informaci\u00f3n de identificaci\u00f3n del alumno y el c\u00f3digo de la asignatura. La primera pantalla dispone de un layout en el que se dispone de dos EditText, uno para el nombre y otro para el c\u00f3digo, mas el bot\u00f3n para realizar la consulta.</p> <p>En la segunda pantalla (ResultActivity), se consultar\u00e1 la base de datos de notas y se presentar\u00e1 la nota obtenida.</p> <p>Esta pantalla no es de nuestro inter\u00e9s.</p> <ul> <li>(a) (1 punto) Completar el c\u00f3digo del m\u00e9todo onCreate de la clase MainActivity.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n    private EditText etIdentificacion;\n    private EditText etCodigo;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        etIdentificacion = (EditText) findViewById(R.id.editIdentificador);\n        etCodigo = (EditText) findViewById(R.id.editCodigo);\n\n        Button b = (Button) findViewById(R.id.botonConsultar);\n        b.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // m\u00e9todo a rellenar\n            }\n        });\n    }\n}\n\n// Escriba a continuaci\u00f3n el cuerpo del m\u00e9todo onClick.\npublic void onClick(View v) {\n    String id = etIdentificacion.getText().toString();\n    String codigo = etCodigo.getText().toString();\n    Intent i = new Intent(getApplicationContext(), ResultActivity.class);\n    i.putExtra(\"ID\", id);\n    i.putExtra(\"CODIGO\", codigo);\n    startActivity(i);\n}    \n</code></pre> <ul> <li>(b) (1 punto) Indicar los m\u00e9todos del ciclo de vida que se invocar\u00e1n de la actividad MainActivity y ResultActivity en el orden correcto.</li> </ul> Mostrar soluci\u00f3n <pre><code>MainActivity.onPause()\nResultActivity,onCreate()\nResultActivity.onStart()\nResultActivity.onResume()\nMainActivity.onStop()\n\n// Se puede a\u00f1adir MainActivity.onDestroy()\n</code></pre>"},{"location":"exams/2017/extra/#problema-5","title":"Problema 5","text":"<ul> <li>(a) (?? puntos) \u00bfA qu\u00e9 orden de complejidad se deber\u00eda aproximar la gr\u00e1fica de tiempo de ejecuci\u00f3n para los m\u00e9todos de ordenaci\u00f3n por inserci\u00f3n y mezcla (merge sort ) ?</li> </ul> Mostrar soluci\u00f3n <p>Inserci\u00f3n: O(n2); Mezcla: O(n\u00b7log n).</p> <ul> <li>(b) (?? puntos) La clase HashListas implementa tablas hash con listas de desbordamiento. En ella se define el m\u00e9todo <pre><code>private int h(String s){...}\n</code></pre> \u00bfPara qu\u00e9 se usa este m\u00e9todo?</li> </ul> Mostrar soluci\u00f3n <p>Para calcular la posici\u00f3n del array que contiene la lista donde se almacena (o se podr\u00eda almacenar) el elemento de clave s.</p> <ul> <li>(c) (?? puntos) En este ejercicio se usa un diccionario para almacenar palabras de un texto y el n\u00famero de veces que aparecen. Una de las operaciones que se efect\u00faan consiste en imprimir una lista con las n palabras m\u00e1s (o menos) usadas (m\u00e9todo getTop()). En el ejercicio esto se implementa copiando los valores del diccionario a un array, que se ordena seg\u00fan el criterio elegido. Cuando se dice que esto se hace con \u201cevaluaci\u00f3n perezosa\u201d, \u00bfqu\u00e9 significa esta expresi\u00f3n?</li> </ul> Mostrar soluci\u00f3n <p>Que el array no se ordena hasta que es necesario, es decir hasta que se llama a getTop o a countBelow.</p> <ul> <li>(d) (?? puntos) En este ejercicio se usa una cola de paquetes que se puede implementar como un array o una lista. La cola est\u00e1 incluida en una clase, TsRouter, que tiene dos m\u00e9todos p\u00fablicos, send y get, que respectivamente a\u00f1aden y recuperan paquetes de la cola. \u00bfTienen que ser sincronizados estos m\u00e9todos? \u00bfPor qu\u00e9?</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed, porque acceden a la cola, que es un objeto compartido por todas las hebras.</p> <ul> <li>(e) (?? puntos) En este ejercicio se utiliza sincronizaci\u00f3n de lectores y escritores para acceder a una estructura de datos compartida, la lista de manzanas del juego de la serpiente, encapsulada en la clase AppleListMonitor. \u00bfQu\u00e9 cambios habr\u00eda que hacer en esta clase para cambiar la sincronizaci\u00f3n de lectores y escritores por exclusi\u00f3n mutua?</li> </ul> Mostrar soluci\u00f3n <p>Bastar\u00eda con suprimir las referencias a monitor.openReading / monitor.closeReading y a monitor.openWriting / monitor.closeWriting y hacer sincronizados todos los m\u00e9todos de AppleListMonitor.</p> <ul> <li>(f) (?? puntos) En este ejercicio se utiliza un widget de tipo Button para lanzar el c\u00e1lculo del \u00edndice de masa corporal. \u00bfC\u00f3mo se especifica qu\u00e9 m\u00e9todo hay que ejecutar cuando se pulsa el bot\u00f3n?</li> </ul> Mostrar soluci\u00f3n <p>Se puede hacer de dos maneras: poniendo un atributo <pre><code>Android:onClick=\u201dm\u00e9todo\u201d\n</code></pre> en el layout correspondiente, o bien en Java, implementando la interfaz OnClickListener: <pre><code>button.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        muestraMensaje(v);\n    }\n});\n</code></pre></p>"},{"location":"exams/2017/extra_ex01/","title":"Extra ex01","text":"<p>A pesar de que un genoma tiene m\u00e1s de dos gigas de (solo cuatro tipos distintos de) bases (A, G, C, T), la mayor parte del mismo es \u201cbasura\u201d, pues solo una peque\u00f1a fracci\u00f3n de subsecuencias (contiguas) del mismo codifica la producci\u00f3n de amino\u00e1cidos, es decir, prote\u00ednas. A esas subsecuencias significativas de bases se les conoce con el nombre de genes.</p> <p>Las subsecuencias que constituyen genes son de longitud moderada, entre cien y mil bases, y tienen la caracter\u00edstica de que al menos una de las cuatro bases se presenta en dicha subsecuencia con (mucha) menor frecuencia que las otras tres. Digamos, por ejemplo, 20 por ciento menos. Interpretado este porcentaje sobre el n\u00famero total de bases de la subsecuencia considerada.</p> <ul> <li>(a) (5 puntos) Se pide dise\u00f1ar un algoritmo (no un programa) que, a partir de un genoma especificado como una (muy) larga secuencia de bases, encuentre los genes de longitud 300 bases. Y a continuaci\u00f3n, analizar la complejidad en espacio y en tiempo de dicho algoritmo en t\u00e9rminos del tama\u00f1o del genoma.</li> </ul> Mostrar soluci\u00f3n <p>Se supone declarada una clase, llam\u00e9mosla Contadores, con cuatro atributos enteros de valor inicial cero, que se van a usar para contar del n\u00famero de cada tipo de base que hay, desde el principio del genoma hasta un punto dado. Y se supone tambi\u00e9n que tenemos un array, llam\u00e9mosle ultimas300, que mantiene el valor de los cuatro contadores para cada uno de los \u00faltimos 300 puntos del genoma que hemos visitado, seg\u00fan lo exploramos desde el principio hasta el final de su cadena de bases.</p> <p>El algoritmo es:     1) Ir leyendo de un fichero el genoma base a base desde el principio hasta su posici\u00f3n 299, actualizando los contadores de ultimas300 en las posiciones 0-298.     2) Leer la siguiente base del genoma, incrementar el contador correspondiente a esa base en la \u00faltima posici\u00f3n actualizada del array en una unidad, y guardar los cuatro valores actuales en la siguiente posici\u00f3n de ultimas300, manejando este array de manera circular (la posici\u00f3n siguiente a la 299 es la cero).     3) Restar de los cuatro contadores actuales los contadores que est\u00e1n en el array 299 posiciones antes (de manera circular tambi\u00e9n). Si uno de esos cuatro valores es menor que 60 (=300/4*0.8), hemos encontrado un gen y lo imprimimos.     4) Si a\u00fan quedan bases por leer en el genoma, volvemos al punto 2). En otro caso, hemos acabado el algoritmo.</p> <p>La complejidad en espacio es constante, pues el tama\u00f1o de ultimas300 es fijo, no depende del tama\u00f1o del genoma. En cuanto a la complejidad en tiempo, la parte 1) es tambi\u00e9n constante, ya que tampoco depende del tama\u00f1o del genoma. Mientras que las partes 2), 3) y 4) se ejecutan una vez por cada base del genoma (exceptuando las 299 primeras, valor constante). Y como resulta que esas tres partes tienen una complejidad constante, se tiene:</p> <p>C1 + C2O(n-299) + C3O(n-299) + C4O(n-299) = (C1 - 299(C2+C3+C4)) + (C2+C3+C4)O(n) = C5 + C6O(n) = C6*O(n) = O(n)</p> <p>Es decir, el algoritmo tiene una complejidad lineal en el tiempo.</p>","tags":["complejidad"]},{"location":"exams/2017/extra_ex02/","title":"Extra ex02","text":"<p>La clase RegistroDatos, permite almacenar los datos producidos por un conjunto de sensores. Los datos producidos por los sensores se env\u00edan como objetos de la clase Dato, cuya estructura se muestra a continuaci\u00f3n:</p> <pre><code>public class Dato implements Comparable&lt;Dato&gt; {\n\n    private String id;   // Identificador \u00fanico del sensor que ha generado el dato\n    private Date d;      // Fecha en la que se ha producido el dato (clase Date de Java)\n    private long v;      // Valor del dato producido\n    ... //Contiene constructor, getters, y setters\n}\n</code></pre> <p>La clase RegistroDatos guarda los datos recibidos en un array (private List []datos). Cada dato se guarda en la posici\u00f3n del array que se obtiene aplicando el m\u00e9todo hashCode de la clase String al identificador \u00fanico del sensor que ha producido el dato y adaptando el resultado al tama\u00f1o del array datos.  <p>Adem\u00e1s, se lleva una cuenta del n\u00famero de datos que ha generado cada sensor, mediante el atributo cuentaDatos (private Map  cuentaDatos), usando como clave el identificador \u00fanico del sensor que ha producido el dato y como valor un objeto de la clase Registro, cuya estructura se muestra a continuaci\u00f3n: <pre><code>public class Registro implements Comparable&lt;Registro&gt; {\n\n    private final String clave; // Identificador \u00fanico del sensor\n    private int cnt;            // N\u00famero de datos producidos por ese sensor\n    ... //Contiene constructor, getters, y setters\n}\n</code></pre> <ul> <li>(a) (5 puntos) Se pide completar los m\u00e9todos Constructor, put, getDatos, size y countAbove de la clase RegistroDatos. El esqueleto de la se muestra a continuaci\u00f3n:</li> </ul> <pre><code>public class RegistroDatos {\n    private List&lt;Dato&gt;[] datos;\n    private Map&lt;String, Registro&gt; cuentaDatos;\n\n    /**\n     * Constructor\n     * @param n n\u00famero de posiciones del array datos donde se van a almacenar\n     * los datos producidos por los sensores\n     */\n    public RegistroDatos(int n) {\n        //TODO\n    }\n\n    /**\n     * Devuelve cuantos sensores han producido un n\u00famero de datos por encima\n     * de un determinado umbral c.\n     * @param c umbral de cuenta.\n     * @return n\u00famero de sensores que han generado m\u00e1s de c datos\n     */\n    public int countAbove(int c) {\n        //TODO\n    }\n\n    /**\n     * Devuelve los datos producidos por un determinado sensor\n     * @param sensorId identificador del sensor\n     * @return lista de datos producidos por ese sensor.\n     * Si no hay ning\u00fan sensor con ese sensorId devolver\u00e1 una lista con 0 valores.\n     */\n    public List&lt;Dato&gt; getDatos(String sensorId) {\n        //TODO\n    }\n\n    /**\n     * Almacena un nuevo dato en el Registro de datos, para ello incrementa en uno la\n     * cuenta de datos\n     * proporcionados por el sensor, y almacena el dato en la posici\u00f3n correspondiente de\n     * la tabla Hash\n     * @param dato la nuevo dato a almacenar\n     */\n    private void put(Dato dato) {\n        //TODO\n    }\n\n    /**\n     * Numero de Datos total almacenado.\n     * @return numero de datos.\n     */\n    public int size() {\n        //TODO\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>public class RegistroDatos {\n    private List&lt;Dato&gt;[] datos;\n    private Map&lt;String, Registro&gt; cuentaDatos;\n\n    /**\n     * Constructor\n     * @param n n\u00famero de posiciones del array datos donde se van a almacenar\n     * los datos producidos por los sensores\n     */\n    public RegistroDatos(int n) {\n        this.datos = new List[N];\n        for (int i = 0; i &lt; N; i++) {\n            datos[i] = new ArrayList();\n        }\n        cuentaDatos = new HashMap&lt;String, Registro&gt;();\n    }\n\n    /**\n     * Devuelve cuantos sensores han producido un n\u00famero de datos por encima\n     * de un determinado umbral c.\n     * @param c umbral de cuenta.\n     * @return numero de sensores que han generado m\u00e1s de c datos\n     */\n    public int countAbove(int c) {\n        int cuenta = 0;\n        Set&lt;String&gt; keySet = cuentaDatos.keySet();\n        for (String key : keySet) {\n            if (cuentaDatos.get(key).getCnt() &lt; c)\n                cuenta++;\n        }\n        return cuenta;\n    }\n\n    /*\n     * Devuelve los datos producidos por un determinado sensor\n     * @param sensorId identificador del sensor\n     * @return lista de datos producidos por ese sensor.\n     * Si no hay ning\u00fan sensor con ese sensorId devolver\u00e1 una lista con 0 valores.\n     */\n    public List&lt;Dato&gt; getDatos(String sensorId) {\n        List&lt;Dato&gt; listaDatos = new ArrayList&lt;Dato&gt;();\n        int hc = sensorId.hashCode();\n        hc = hc % datos.length;\n        for (Dato d : datos[hc]) {\n            if (d.getId().equals(sensorId))\n                listaDatos.add(d);\n        }\n        return listaDatos;\n    }\n\n    /**\n     * El m\u00e9todo put (), se encarga de meter un nuevo dato en el Registro de datos,\n     * para ello incrementa en uno la cuenta de datos proporcionados por el sensor,\n     * y almacena el dato en la posici\u00f3n correspondiente de la tabla Hash\n     * @param dato la nuevo dato a almacenar\n     */\n    private void put(Dato dato) {\n        if (cuentaDatos.containsKey(dato.getId())) {\n            cuentaDatos.get(dato.getId()).inc();\n        } else {\n            cuentaDatos.put(dato.getId(), new Registro(dato.getId()));\n        }\n        int hc = dato.getId().hashCode();\n        hc = hc % datos.length;\n        datos[hc].add(dato);\n    }\n\n    /**\n     * Numero de Datos Total Almacenado.\n     * @return numero de datos.\n     */\n    public int size() {\n        int suma = 0;\n        Set&lt;String&gt; keySet = cuentaDatos.keySet();\n        for (String key : keySet) {\n            suma += cuentaDatos.get(key).getCnt();\n        }\n        return suma;\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2017/extra_ex03/","title":"Extra ex03","text":"<p>Varios ingenieros utilizan una base de datos para almacenar informes. Para ello disponen de una aplicaci\u00f3n que permite almacenar un informe o recuperar un informe anterior. El acceso a los datos se organiza mediante una clase de Java que responde al esquema siguiente esquema:</p> <pre><code>public class Datos {\n\u2026\n    public \u2026 void guardar (String clave) {\u2026}\n    public \u2026 void consultar (String clave) {\u2026}\n    public \u2026 void terminar (String clave) {\u2026}\n}\n</code></pre> <p>Las aplicaciones se ejecutan concurrentemente, y llaman a guardar o a consultar antes de realizar una secuencia de operaciones de almacenar o recuperar informes, respectivamente. Cuando han terminado de realizar estas operaciones llaman a terminar. Puede haber varias aplicaciones consultando informes a la vez, pero no consultando y guardando, ni varias guardando a la vez.</p> <p>Los objetos de la clase Ingeniero son hebras que ejecutan repetidamente el siguiente c\u00f3digo:</p> <pre><code>datos.guardar(clave);\nfor (int i = 1; i &lt;= ndoc; i++) {\n    // generar informe y almacenarlo en la base de datos\n}\ndatos.terminar(clave);\n</code></pre> <p>o bien</p> <pre><code>datos.consultar(clave);\nfor (int i = 1; i &lt;= ndoc; i++) {\n    // realizar consulta en la base de datos\n}\ndatos.terminar(clave);\n</code></pre> <ul> <li>(a) (4 puntos) Complete el c\u00f3digo de la clase Datos de forma que se cumplan las condiciones del enunciado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Datos {\n    private int consultando = 0;\n    private boolean guardando = false;\n\n    public synchronized void guardar(String clave) {\n        while (guardando || consultando &gt; 0)\n            try {\n                wait();\n            } catch (InterruptedException e) {}\n        guardando = true;\n    }\n\n    public synchronized void consultar(String clave) {\n        while (guardando)\n            try {\n                wait();\n            } catch (InterruptedException e) {}\n        consultando++;\n    }\n\n    public synchronized void terminar(String clave) {\n        if (consultando &gt; 0) {\n            consultando--;\n        } else {\n            guardando = false;\n        }\n        notifyAll();\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Escriba el c\u00f3digo de una posible implementaci\u00f3n de la clase Ingeniero para consultar datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Ingeniero_Consulta extends Thread {\n    Datos datos;\n    int ndoc = 10; // por ejemplo\n\n    public Ingeniero_Consulta(Datos datos) {\n        this.datos = datos;\n    }\n\n    public void run() {\n        datos.consultar(\"clave\"); // por ejemplo\n        for (int i = 1; i &lt;= ndoc; i++) {\n            // realizar la consulta\n        }\n        datos.terminar(\"clave\");\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Analice si puede haber problemas de inanici\u00f3n (starvation) en el acceso a los datos y, si es as\u00ed, ponga alg\u00fan ejemplo (sin resolverlo).</li> </ul> Mostrar soluci\u00f3n <p>Como en el problema original, la soluci\u00f3n dada puede dar lugar a inanici\u00f3n de los ingenieros que guardan informes. Por ejemplo, sin entran varios a consultar y antes de que terminen entran otros nuevos, esta situaci\u00f3n se puede prolongar indefinidamente, no dejando acceder nunca a otros ingenieros que deseen guardar informes. Las soluci\u00f3n es establecer turnos para dar prioridad, alternativamente, a los que guardan (escritores) y a los que consultan (lectores)</p>","tags":["???"]},{"location":"exams/2017/extra_ex04/","title":"Extra ex04","text":"<p>Se dispone de una aplicaci\u00f3n Android para la consulta de notas por parte de los alumnos. La aplicaci\u00f3n consta de dos pantallas, denominadas MainActivity y ResultActivity.</p> <p>En la primera pantalla (MainActivity), el usuario introduce su identificaci\u00f3n (nombre y apellidos) y el c\u00f3digo num\u00e9rico de la asignatura a consultar. Dispone de un bot\u00f3n con el texto \u201cConsultar\u201d que, al pulsarse, pasa a la segunda pantalla ResultActivity, mediante un Intent con la informaci\u00f3n de identificaci\u00f3n del alumno y el c\u00f3digo de la asignatura. La primera pantalla dispone de un layout en el que se dispone de dos EditText, uno para el nombre y otro para el c\u00f3digo, mas el bot\u00f3n para realizar la consulta.</p> <p>En la segunda pantalla (ResultActivity), se consultar\u00e1 la base de datos de notas y se presentar\u00e1 la nota obtenida.</p> <p>Esta pantalla no es de nuestro inter\u00e9s.</p> <ul> <li>(a) (1 punto) Completar el c\u00f3digo del m\u00e9todo onCreate de la clase MainActivity.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n    private EditText etIdentificacion;\n    private EditText etCodigo;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        etIdentificacion = (EditText) findViewById(R.id.editIdentificador);\n        etCodigo = (EditText) findViewById(R.id.editCodigo);\n\n        Button b = (Button) findViewById(R.id.botonConsultar);\n        b.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // m\u00e9todo a rellenar\n            }\n        });\n    }\n}\n\n// Escriba a continuaci\u00f3n el cuerpo del m\u00e9todo onClick.\npublic void onClick(View v) {\n    String id = etIdentificacion.getText().toString();\n    String codigo = etCodigo.getText().toString();\n    Intent i = new Intent(getApplicationContext(), ResultActivity.class);\n    i.putExtra(\"ID\", id);\n    i.putExtra(\"CODIGO\", codigo);\n    startActivity(i);\n}    \n</code></pre> <ul> <li>(b) (1 punto) Indicar los m\u00e9todos del ciclo de vida que se invocar\u00e1n de la actividad MainActivity y ResultActivity en el orden correcto.</li> </ul> Mostrar soluci\u00f3n <pre><code>MainActivity.onPause()\nResultActivity,onCreate()\nResultActivity.onStart()\nResultActivity.onResume()\nMainActivity.onStop()\n\n// Se puede a\u00f1adir MainActivity.onDestroy()\n</code></pre>","tags":["android"]},{"location":"exams/2017/extra_ex05/","title":"Extra ex05","text":"<ul> <li>(a) (?? puntos) \u00bfA qu\u00e9 orden de complejidad se deber\u00eda aproximar la gr\u00e1fica de tiempo de ejecuci\u00f3n para los m\u00e9todos de ordenaci\u00f3n por inserci\u00f3n y mezcla (merge sort ) ?</li> </ul> Mostrar soluci\u00f3n <p>Inserci\u00f3n: O(n2); Mezcla: O(n\u00b7log n).</p> <ul> <li>(b) (?? puntos) La clase HashListas implementa tablas hash con listas de desbordamiento. En ella se define el m\u00e9todo <pre><code>private int h(String s){...}\n</code></pre> \u00bfPara qu\u00e9 se usa este m\u00e9todo?</li> </ul> Mostrar soluci\u00f3n <p>Para calcular la posici\u00f3n del array que contiene la lista donde se almacena (o se podr\u00eda almacenar) el elemento de clave s.</p> <ul> <li>(c) (?? puntos) En este ejercicio se usa un diccionario para almacenar palabras de un texto y el n\u00famero de veces que aparecen. Una de las operaciones que se efect\u00faan consiste en imprimir una lista con las n palabras m\u00e1s (o menos) usadas (m\u00e9todo getTop()). En el ejercicio esto se implementa copiando los valores del diccionario a un array, que se ordena seg\u00fan el criterio elegido. Cuando se dice que esto se hace con \u201cevaluaci\u00f3n perezosa\u201d, \u00bfqu\u00e9 significa esta expresi\u00f3n?</li> </ul> Mostrar soluci\u00f3n <p>Que el array no se ordena hasta que es necesario, es decir hasta que se llama a getTop o a countBelow.</p> <ul> <li>(d) (?? puntos) En este ejercicio se usa una cola de paquetes que se puede implementar como un array o una lista. La cola est\u00e1 incluida en una clase, TsRouter, que tiene dos m\u00e9todos p\u00fablicos, send y get, que respectivamente a\u00f1aden y recuperan paquetes de la cola. \u00bfTienen que ser sincronizados estos m\u00e9todos? \u00bfPor qu\u00e9?</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed, porque acceden a la cola, que es un objeto compartido por todas las hebras.</p> <ul> <li>(e) (?? puntos) En este ejercicio se utiliza sincronizaci\u00f3n de lectores y escritores para acceder a una estructura de datos compartida, la lista de manzanas del juego de la serpiente, encapsulada en la clase AppleListMonitor. \u00bfQu\u00e9 cambios habr\u00eda que hacer en esta clase para cambiar la sincronizaci\u00f3n de lectores y escritores por exclusi\u00f3n mutua?</li> </ul> Mostrar soluci\u00f3n <p>Bastar\u00eda con suprimir las referencias a monitor.openReading / monitor.closeReading y a monitor.openWriting / monitor.closeWriting y hacer sincronizados todos los m\u00e9todos de AppleListMonitor.</p> <ul> <li>(f) (?? puntos) En este ejercicio se utiliza un widget de tipo Button para lanzar el c\u00e1lculo del \u00edndice de masa corporal. \u00bfC\u00f3mo se especifica qu\u00e9 m\u00e9todo hay que ejecutar cuando se pulsa el bot\u00f3n?</li> </ul> Mostrar soluci\u00f3n <p>Se puede hacer de dos maneras: poniendo un atributo <pre><code>Android:onClick=\u201dm\u00e9todo\u201d\n</code></pre> en el layout correspondiente, o bien en Java, implementando la interfaz OnClickListener: <pre><code>button.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        muestraMensaje(v);\n    }\n});\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2017/p1/","title":"Examen 2017 \u2014 Parcial 1","text":""},{"location":"exams/2017/p1/#problema-1","title":"Problema 1","text":"<p>En un proyecto se necesita programar una clase que represente un conjunto de palabras (String), sin que haya duplicados almacenados. Con este fin se realizan dos fases: fase 1 de carga de todas las palabras, con un m\u00e9todo</p> <p>public void put (String palabra)</p> <p>y fase 2 de consulta, con un m\u00e9todo</p> <p>boolean get (String palabra)</p> <p>que devuelve TRUE si, y solo si, la palabra dada como par\u00e1metro est\u00e1 en el diccionario.</p> <p>Se proponen varias opciones:     - 1) Las palabras se meten en un array, una tras otra; al acabar la fase 1, el array se ordena y se eliminan los duplicados, pasando a la fase 2 donde se usa el array sin duplicados.     - 2) Las palabras se meten en un diccionario implementado con una tabla hash, de forma que solo hay que almacenar la clave (es decir la palabra); si la clave est\u00e1 en el diccionario, get() devuelve TRUE.     - 3) Se combinan las opciones anteriores: las palabras (1) se meten en un array, (2) se ordena el array, (3) se eliminan duplicados, (4) los datos del array se cargan en un diccionario implementado con una tabla hash y (5) el m\u00e9todo get() devuelve TRUE si, y solo si, la palabra est\u00e1 en el diccionario.</p> <ul> <li>(a) (2,5 puntos) Razone la complejidad de los m\u00e9todos put() y get() en cada una de las opciones propuestos.</li> </ul> Mostrar soluci\u00f3n <p>1)Fase 1: O(insertar al final del array n veces) + O(ordenar) + O(borrar duplicados) = O(n) + O(nlogn) + O(n)</p> <p>= O(nlog n).</p> <p>Fase 2: O(b\u00fasqueda array ordenado) = O(logn)</p> <p>2) Fase 1: O(insertar n veces) = O(n)</p> <p>Fase 2: O(1)</p> <p>3) Fase 1 = a) + O(transferir array\u2192 hash) = O(nlogn) + O(n) = O(nlogn)</p> <p>Fase 2 = O(1)</p> <ul> <li>(b) (2,5 puntos) Escriba el m\u00e9todo public void put(String palabra) modificando el m\u00e9todo public void put(String clave, String valor) del ejercicio 2 para que tenga la funcionalidad solicitada, usando internamente una tabla hash. Puede utilizar como base el c\u00f3digo que aparece a continuaci\u00f3n, rellenando los espacios que se indican.</li> </ul> <pre><code>public class HashListas {\n    private List&lt;String&gt;[] slots; // slots de la tabla Hash\n    private int nDatos = 0; // n\u00famero de datos de la tabla\n\n    /**\n     * Constructor\n     * @param nSlots n\u00famero de ranuras\n     */\n    public HashListas(int nSlots) {\n        slots = new List[nSlots];\n        for (int i = 0; i &lt; nSlots; i++) {\n            slots[i] = new ArrayList&lt;String&gt;(0);\n        }\n    }\n\n    /**\n     * Calcula funci\u00f3n hash e \u00edndice en slots\n     * @param clave String\n     * @return \u00edndice en slots\n     */\n    private int getIdx(String clave) {\n        return Math.abs(clave.hashCode()) % slots.length;\n    }\n\n    /**\n     * Mete una nueva palabra en el diccionario\n     * Si ya existe otra palabra, no hace nada\n     * @param clave palabra para almacenar\n     */\n    public void put(String clave) {\n\n    }\n\n    /**\n     * Devuelve el valor asociado a la clave\n     * @param clave palabra que comprobamos\n     * @return true si est\u00e1 en el diccionario;\n     *         false en caso contrario\n     */\n    public boolean get(String clave) {\n\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>public class HashListas {\n    private List&lt;String&gt;[] slots; // slots de la tabla Hash\n    private int nDatos = 0; // n\u00famero de datos de la tabla\n\n    /**\n     * Constructor\n     * @param nSlots n\u00famero de ranuras\n     */\n    public HashListas(int nSlots) {\n        slots = new List[nSlots];\n        for (int i = 0; i &lt; nSlots; i++) {\n            slots[i] = new ArrayList&lt;String&gt;(0);\n        }\n    }\n\n    /**\n     * Calcula funci\u00f3n hash e \u00edndice en slots\n     * @param clave String\n     * @return \u00edndice en slots\n     */\n    private int getIdx(String clave) {\n        return Math.abs(clave.hashCode()) % slots.length;\n    }\n\n    /**\n     * Mete una nueva palabra en el diccionario\n     * Si ya existe otra palabra, no hace nada\n     * @param clave palabra para almacenar\n     */\n    public void put(String clave) {\n        int idx = getIdx(clave);\n        put(slots[idx], clave);\n    }\n\n    private void put(List&lt;String&gt; list, String clave) {\n        for (String palabra : list) {\n            if (palabra.compareTo(clave) == 0) {\n                return;\n            }\n        }\n        list.add(clave);\n        nDatos++;\n    }\n\n    /**\n     * Devuelve el valor asociado a la clave\n     * @param clave palabra que comprobamos\n     * @return true si est\u00e1 en el diccionario;\n     *         false en caso contrario\n     */\n    public boolean get(String clave) {\n        int idx = getIdx(clave);\n        return get(slots[idx], clave);\n    }\n\n    private boolean get(List&lt;String&gt; list, String clave) {\n        for (String palabra : list) {\n            if (palabra.compareTo(clave) == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"exams/2017/p1/#problema-2","title":"Problema 2","text":"<p>Se implementa un \u00e1rbol binario de b\u00fasqueda (BST) con valores enteros positivos como un array, colocando su ra\u00edz principal en la posici\u00f3n 1 del array y, para todo nodo del mismo en la posici\u00f3n i, su hijo izquierdo en la posici\u00f3n 2i, y su hijo derecho en la posici\u00f3n 2i+1. La posici\u00f3n 0 del array mantiene el contador del n\u00famero de nodos en el \u00e1rbol. Un nodo no existe si su posici\u00f3n en el array no existe (se sale del tama\u00f1o del array) o el valor en el array es -1. Por ejemplo:</p> <p></p> \u00cdndice 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Valor 9 8 3 10 1 6 -1 14 -1 -1 4 7 -1 -1 13 -1 <p>Con esta representaci\u00f3n de un \u00e1rbol, se pide:</p> <ul> <li>(a) (2,5 puntos) Programar un recorrido en el \u00e1rbol que imprima ordenados los contenidos de los nodos visitados:</li> </ul> <p>public void recorrer (int[] arbol) {...}</p> <p>En el ejemplo dado, deber\u00eda imprimir:</p> <p>1 3 4 6 7 8 10 13 14</p> <p>Nota: suponga que no es necesario comprobar si la representaci\u00f3n del \u00e1rbol proporcionada es correcta.</p> Mostrar soluci\u00f3n <pre><code>public void recorrer(int[] arbol) {\n    recorrer(arbol, 1);\n}\n\nprivate void recorrer(int[] arbol, int i) {\n    if (i &lt; arbol.length &amp;&amp; arbol[i] &gt;= 0) {\n        recorrer(arbol, 2 * i);\n        System.out.println(arbol[i]);\n        recorrer(arbol, 2 * i + 1);\n    }\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Razonar la complejidad de dicho recorrido.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad (en tiempo) del algoritmo es lineal, es decir O(n), siendo n el n\u00famero de nodos, puesto que recorre el \u00e1rbol visitando todos sus nodos, y en cada uno de ellos realiza un trabajo de orden constante, es decir O(1).</p> <p>NOTA:</p> <p>Para la soluci\u00f3n de la ecuaci\u00f3n de recurrencia</p> <p>T(n) = T(n/2) + C + T(n/2) = 2 T(n/2) + C</p> <p>que se resuelve como O(n), ver apuntes.</p>"},{"location":"exams/2017/p1_ex01/","title":"P1 ex01","text":"<p>En un proyecto se necesita programar una clase que represente un conjunto de palabras (String), sin que haya duplicados almacenados. Con este fin se realizan dos fases: fase 1 de carga de todas las palabras, con un m\u00e9todo</p> <p>public void put (String palabra)</p> <p>y fase 2 de consulta, con un m\u00e9todo</p> <p>boolean get (String palabra)</p> <p>que devuelve TRUE si, y solo si, la palabra dada como par\u00e1metro est\u00e1 en el diccionario.</p> <p>Se proponen varias opciones:     - 1) Las palabras se meten en un array, una tras otra; al acabar la fase 1, el array se ordena y se eliminan los duplicados, pasando a la fase 2 donde se usa el array sin duplicados.     - 2) Las palabras se meten en un diccionario implementado con una tabla hash, de forma que solo hay que almacenar la clave (es decir la palabra); si la clave est\u00e1 en el diccionario, get() devuelve TRUE.     - 3) Se combinan las opciones anteriores: las palabras (1) se meten en un array, (2) se ordena el array, (3) se eliminan duplicados, (4) los datos del array se cargan en un diccionario implementado con una tabla hash y (5) el m\u00e9todo get() devuelve TRUE si, y solo si, la palabra est\u00e1 en el diccionario.</p> <ul> <li>(a) (2,5 puntos) Razone la complejidad de los m\u00e9todos put() y get() en cada una de las opciones propuestos.</li> </ul> Mostrar soluci\u00f3n <p>1)Fase 1: O(insertar al final del array n veces) + O(ordenar) + O(borrar duplicados) = O(n) + O(nlogn) + O(n)</p> <p>= O(nlog n).</p> <p>Fase 2: O(b\u00fasqueda array ordenado) = O(logn)</p> <p>2) Fase 1: O(insertar n veces) = O(n)</p> <p>Fase 2: O(1)</p> <p>3) Fase 1 = a) + O(transferir array\u2192 hash) = O(nlogn) + O(n) = O(nlogn)</p> <p>Fase 2 = O(1)</p> <ul> <li>(b) (2,5 puntos) Escriba el m\u00e9todo public void put(String palabra) modificando el m\u00e9todo public void put(String clave, String valor) del ejercicio 2 para que tenga la funcionalidad solicitada, usando internamente una tabla hash. Puede utilizar como base el c\u00f3digo que aparece a continuaci\u00f3n, rellenando los espacios que se indican.</li> </ul> <pre><code>public class HashListas {\n    private List&lt;String&gt;[] slots; // slots de la tabla Hash\n    private int nDatos = 0; // n\u00famero de datos de la tabla\n\n    /**\n     * Constructor\n     * @param nSlots n\u00famero de ranuras\n     */\n    public HashListas(int nSlots) {\n        slots = new List[nSlots];\n        for (int i = 0; i &lt; nSlots; i++) {\n            slots[i] = new ArrayList&lt;String&gt;(0);\n        }\n    }\n\n    /**\n     * Calcula funci\u00f3n hash e \u00edndice en slots\n     * @param clave String\n     * @return \u00edndice en slots\n     */\n    private int getIdx(String clave) {\n        return Math.abs(clave.hashCode()) % slots.length;\n    }\n\n    /**\n     * Mete una nueva palabra en el diccionario\n     * Si ya existe otra palabra, no hace nada\n     * @param clave palabra para almacenar\n     */\n    public void put(String clave) {\n\n    }\n\n    /**\n     * Devuelve el valor asociado a la clave\n     * @param clave palabra que comprobamos\n     * @return true si est\u00e1 en el diccionario;\n     *         false en caso contrario\n     */\n    public boolean get(String clave) {\n\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>public class HashListas {\n    private List&lt;String&gt;[] slots; // slots de la tabla Hash\n    private int nDatos = 0; // n\u00famero de datos de la tabla\n\n    /**\n     * Constructor\n     * @param nSlots n\u00famero de ranuras\n     */\n    public HashListas(int nSlots) {\n        slots = new List[nSlots];\n        for (int i = 0; i &lt; nSlots; i++) {\n            slots[i] = new ArrayList&lt;String&gt;(0);\n        }\n    }\n\n    /**\n     * Calcula funci\u00f3n hash e \u00edndice en slots\n     * @param clave String\n     * @return \u00edndice en slots\n     */\n    private int getIdx(String clave) {\n        return Math.abs(clave.hashCode()) % slots.length;\n    }\n\n    /**\n     * Mete una nueva palabra en el diccionario\n     * Si ya existe otra palabra, no hace nada\n     * @param clave palabra para almacenar\n     */\n    public void put(String clave) {\n        int idx = getIdx(clave);\n        put(slots[idx], clave);\n    }\n\n    private void put(List&lt;String&gt; list, String clave) {\n        for (String palabra : list) {\n            if (palabra.compareTo(clave) == 0) {\n                return;\n            }\n        }\n        list.add(clave);\n        nDatos++;\n    }\n\n    /**\n     * Devuelve el valor asociado a la clave\n     * @param clave palabra que comprobamos\n     * @return true si est\u00e1 en el diccionario;\n     *         false en caso contrario\n     */\n    public boolean get(String clave) {\n        int idx = getIdx(clave);\n        return get(slots[idx], clave);\n    }\n\n    private boolean get(List&lt;String&gt; list, String clave) {\n        for (String palabra : list) {\n            if (palabra.compareTo(clave) == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2017/p1_ex02/","title":"P1 ex02","text":"<p>Se implementa un \u00e1rbol binario de b\u00fasqueda (BST) con valores enteros positivos como un array, colocando su ra\u00edz principal en la posici\u00f3n 1 del array y, para todo nodo del mismo en la posici\u00f3n i, su hijo izquierdo en la posici\u00f3n 2i, y su hijo derecho en la posici\u00f3n 2i+1. La posici\u00f3n 0 del array mantiene el contador del n\u00famero de nodos en el \u00e1rbol. Un nodo no existe si su posici\u00f3n en el array no existe (se sale del tama\u00f1o del array) o el valor en el array es -1. Por ejemplo:</p> <p></p> \u00cdndice 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Valor 9 8 3 10 1 6 -1 14 -1 -1 4 7 -1 -1 13 -1 <p>Con esta representaci\u00f3n de un \u00e1rbol, se pide:</p> <ul> <li>(a) (2,5 puntos) Programar un recorrido en el \u00e1rbol que imprima ordenados los contenidos de los nodos visitados:</li> </ul> <p>public void recorrer (int[] arbol) {...}</p> <p>En el ejemplo dado, deber\u00eda imprimir:</p> <p>1 3 4 6 7 8 10 13 14</p> <p>Nota: suponga que no es necesario comprobar si la representaci\u00f3n del \u00e1rbol proporcionada es correcta.</p> Mostrar soluci\u00f3n <pre><code>public void recorrer(int[] arbol) {\n    recorrer(arbol, 1);\n}\n\nprivate void recorrer(int[] arbol, int i) {\n    if (i &lt; arbol.length &amp;&amp; arbol[i] &gt;= 0) {\n        recorrer(arbol, 2 * i);\n        System.out.println(arbol[i]);\n        recorrer(arbol, 2 * i + 1);\n    }\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Razonar la complejidad de dicho recorrido.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad (en tiempo) del algoritmo es lineal, es decir O(n), siendo n el n\u00famero de nodos, puesto que recorre el \u00e1rbol visitando todos sus nodos, y en cada uno de ellos realiza un trabajo de orden constante, es decir O(1).</p> <p>NOTA:</p> <p>Para la soluci\u00f3n de la ecuaci\u00f3n de recurrencia</p> <p>T(n) = T(n/2) + C + T(n/2) = 2 T(n/2) + C</p> <p>que se resuelve como O(n), ver apuntes.</p>","tags":["grafos"]},{"location":"exams/2017/p1r/","title":"Examen 2017 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2017/p1r/#problema-1","title":"Problema 1","text":"<p>Dado el siguiente \u00e1rbol binario:</p> <p></p> <ul> <li>(a) (1,25 puntos) Escriba el resultado de recorrerlo en preorden.</li> </ul> Mostrar soluci\u00f3n <p>J A M K Z</p> <p>Un ayuntamiento tiene una base de datos de 20.000 matr\u00edculas. Sobre estos datos el n\u00famero de consultas es abrumadoramente superior al n\u00famero de altas o bajas, por lo que solo nos preocuparemos por las consultas. Tenemos varias opciones para su implementaci\u00f3n:</p> <pre><code>- 1) un array ordenado, de 20.000 elementos.\n- 2) una tabla hash de con direccionamiento abierto (resoluci\u00f3n interna de colisiones, sondeo por lista), de  20.000 posiciones.\n- 3) una tabla hash con listas de desbordamiento y 8.192 (2^13) posiciones.\n- 4) un \u00e1rbol binario de b\u00fasqueda (BST).\n</code></pre> <ul> <li>(b) (2,5 puntos) Para cada opci\u00f3n, indique los pros y los contras y elija razonadamente la estructura de datos que recomienda para el ayuntamiento. Debe argumentar en t\u00e9rminos de espacio ocupado en memoria y del tiempo de b\u00fasqueda.</li> </ul> Mostrar soluci\u00f3n <p>1) + ocupa la memoria imprescindible, sin nada extra; * tiempo O(log n).</p> <p>2) * ocupa la memoria imprescindible y un poco m\u00e1s si se guardan los hashes; - el tiempo de acceso se dispara al llegar al 100% de ocupaci\u00f3n y es inviable.</p> <p>3) - ocupa memoria para los datos, para la tabla de acceso y para las listas de desbordamiento; + el tiempo de acceso probable es O(1), si los hashes se distribuyen uniformemente y las listas tienen una longitud acotada a unas pocas matr\u00edculas (menos de una docena); - aunque en el improbable caso peor ser\u00eda O(n).</p> <p>4) - ocupa memoria para los datos y para los enlaces entre nodos; + velocidad de acceso probable O(log n); - aunque en el improbable caso peor ser\u00eda O(n).</p> <p>\u00d3ptimo: - por memoria ocupada: (a) array ordenado - por tiempo (probable) de acceso: (c) tabla hash</p> <p>Si la memoria no es un problema para 20.000 datos, la decisi\u00f3n se tomar\u00eda por tiempo de acceso: tabla hash (c).</p> <p>Si la memoria es la principal limitaci\u00f3n, la mejor opci\u00f3n es el array ordenado (a)</p> <p>Tenemos un \u00e1rbol binario de b\u00fasqueda (BST) en el que cada nodo almacena un car\u00e1cter. </p> <ul> <li>(c) (1,25 puntos) Dibuje el \u00e1rbolresultante de insertar en la secuencia indicada las letras: Q W E R T Y U I O P.</li> </ul> Mostrar soluci\u00f3n <p></p>"},{"location":"exams/2017/p1r/#problema-2","title":"Problema 2","text":"<p>Sabiendo que el tiempo de ejecuci\u00f3n de la funci\u00f3n f es constante y el de g es lineal con respecto a n.</p> <ul> <li>(a) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    f(i);   \n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>El bucle se ejecuta n veces, y el tiempo de ejecuci\u00f3n de f es constante, por lo que la complejidad es n*O(1) = O(n).</p> <ul> <li>(b) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    g(i);\n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Este bucle se ejecuta n veces, pero ahora el tiempo de ejecuci\u00f3n de g es lineal respecto a n. Por tanto, la complejidad es N*O(N) = O(n2).</p> <ul> <li>(c) (1,65 puntos) Rrazone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    for (int j = 1; j &lt; i; j*=2) {\n        f(j);\n    };\n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>El bucle exterior se ejecuta n veces, y el bucle interior se ejecuta log i veces. El tiempo de ejecuci\u00f3n de f es constante, como antes. Por tanto la complejidad es O (N log N).</p>"},{"location":"exams/2017/p1r_ex01/","title":"P1r ex01","text":"<p>Dado el siguiente \u00e1rbol binario:</p> <p></p> <ul> <li>(a) (1,25 puntos) Escriba el resultado de recorrerlo en preorden.</li> </ul> Mostrar soluci\u00f3n <p>J A M K Z</p> <p>Un ayuntamiento tiene una base de datos de 20.000 matr\u00edculas. Sobre estos datos el n\u00famero de consultas es abrumadoramente superior al n\u00famero de altas o bajas, por lo que solo nos preocuparemos por las consultas. Tenemos varias opciones para su implementaci\u00f3n:</p> <pre><code>- 1) un array ordenado, de 20.000 elementos.\n- 2) una tabla hash de con direccionamiento abierto (resoluci\u00f3n interna de colisiones, sondeo por lista), de  20.000 posiciones.\n- 3) una tabla hash con listas de desbordamiento y 8.192 (2^13) posiciones.\n- 4) un \u00e1rbol binario de b\u00fasqueda (BST).\n</code></pre> <ul> <li>(b) (2,5 puntos) Para cada opci\u00f3n, indique los pros y los contras y elija razonadamente la estructura de datos que recomienda para el ayuntamiento. Debe argumentar en t\u00e9rminos de espacio ocupado en memoria y del tiempo de b\u00fasqueda.</li> </ul> Mostrar soluci\u00f3n <p>1) + ocupa la memoria imprescindible, sin nada extra; * tiempo O(log n).</p> <p>2) * ocupa la memoria imprescindible y un poco m\u00e1s si se guardan los hashes; - el tiempo de acceso se dispara al llegar al 100% de ocupaci\u00f3n y es inviable.</p> <p>3) - ocupa memoria para los datos, para la tabla de acceso y para las listas de desbordamiento; + el tiempo de acceso probable es O(1), si los hashes se distribuyen uniformemente y las listas tienen una longitud acotada a unas pocas matr\u00edculas (menos de una docena); - aunque en el improbable caso peor ser\u00eda O(n).</p> <p>4) - ocupa memoria para los datos y para los enlaces entre nodos; + velocidad de acceso probable O(log n); - aunque en el improbable caso peor ser\u00eda O(n).</p> <p>\u00d3ptimo: - por memoria ocupada: (a) array ordenado - por tiempo (probable) de acceso: (c) tabla hash</p> <p>Si la memoria no es un problema para 20.000 datos, la decisi\u00f3n se tomar\u00eda por tiempo de acceso: tabla hash (c).</p> <p>Si la memoria es la principal limitaci\u00f3n, la mejor opci\u00f3n es el array ordenado (a)</p> <p>Tenemos un \u00e1rbol binario de b\u00fasqueda (BST) en el que cada nodo almacena un car\u00e1cter. </p> <ul> <li>(c) (1,25 puntos) Dibuje el \u00e1rbolresultante de insertar en la secuencia indicada las letras: Q W E R T Y U I O P.</li> </ul> Mostrar soluci\u00f3n <p></p>","tags":["grafos"]},{"location":"exams/2017/p1r_ex02/","title":"P1r ex02","text":"<p>Sabiendo que el tiempo de ejecuci\u00f3n de la funci\u00f3n f es constante y el de g es lineal con respecto a n.</p> <ul> <li>(a) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    f(i);   \n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>El bucle se ejecuta n veces, y el tiempo de ejecuci\u00f3n de f es constante, por lo que la complejidad es n*O(1) = O(n).</p> <ul> <li>(b) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    g(i);\n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Este bucle se ejecuta n veces, pero ahora el tiempo de ejecuci\u00f3n de g es lineal respecto a n. Por tanto, la complejidad es N*O(N) = O(n2).</p> <ul> <li>(c) (1,65 puntos) Rrazone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    for (int j = 1; j &lt; i; j*=2) {\n        f(j);\n    };\n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>El bucle exterior se ejecuta n veces, y el bucle interior se ejecuta log i veces. El tiempo de ejecuci\u00f3n de f es constante, como antes. Por tanto la complejidad es O (N log N).</p>","tags":["complejidad"]},{"location":"exams/2017/p2/","title":"Examen 2017 \u2014 Parcial 2","text":""},{"location":"exams/2017/p2/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un sistema compuesto de dos conjuntos de hebras. Un conjunto de hebras (editoras) producen contenidos sobre un tema y los env\u00edan a un monitor, Gestor. Otro conjunto de hebras (suscriptoras) reciben los contenidos publicados sobre los temas a los que se suscriben. Las hebras editoras y suscriptoras utilizan los siguientes m\u00e9todos del gestor para sincronizarse:</p> <pre><code>public class Gestor {\n    ...\n    public ... void enviarContenido (Tema unTema, Contenido unContenido) {...}\n    public ... Contenido recibirContenido (Tema unTema) {...}\n}\n</code></pre> <p>Se proporcionan las siguientes clases auxiliares que no hay que implementar:</p> <pre><code>public class Contenido {\n    private String contenido;\n\n    public Contenido(String contenido) {\n        this.contenido = contenido;\n    }\n\n    // ...\n}\n\npublic enum Tema {\n    NACIONAL, INTERNACIONAL, CULTURA, DEPORTE;\n\n    public static Tema random() {\n        // ...\n        return null;\n    }\n}\n\npublic class Nap {\n\n    /**\n     * Duerme un periodo aleatorio entre los limites indicados.\n     *\n     * @param min milisegundos minimos.\n     * @param max milisegundos maximos.\n     */\n    public static void random(int min, int max) {\n        // ...\n    }\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba el c\u00f3digo de una clase que defina hebras suscriptoras. Cada hebra ejecuta un bucle N_VECES (una constante). En cada ciclo genera un tema aleatorio (ver m\u00e1s abajo) e invoca el gestor para recibir mensajes de ese tema. Al recibir un mensaje, invoca un m\u00e9todo privado de la clase, procesarContenido(Contenido c), que no hay que implementar. Finalmente, se bloquea durante un tiempo aleatorio (puede usar el m\u00e9todo nap.random()).</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Suscriptora extends Thread {\n    private Gestor gestor;\n    private int id;\n    private final int N_VECES = \u2026;\n\n    public Suscriptora(Gestor gestor, int id) {\n        this.gestor = gestor;\n        this.id = id;\n    }\n\n    private void procesarContenido(Contenido unContenido) {\n        // ...\n    }\n\n    @Override\n    public void run() {\n        Tema unTema;\n        Contenido unContenido;\n\n        for (int i = 0; i &lt; N_VECES; i++) {\n            unTema = Tema.random();\n            unContenido = gestor.recibirContenido(unTema);\n            if (unContenido != null)\n                procesarContenido(unContenido);\n\n            Nap.random(100, 500); // por ejemplo\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un esquema del c\u00f3digo de una clase para definir hebras editoras. En este caso, s\u00f3lo hay que implementar el constructor. Su contenido ser\u00eda similar a la anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Editora extends Thread {\n    private Gestor gestor;\n    private int id;\n    private final int N_VECES = 5;\n\n    public Editora(Gestor gestor, int id) {\n        this.gestor = gestor;\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n        // ...\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Escriba el c\u00f3digo de una clase con un programa principal (main) que arranque N_EDITORAS hebras editoras y N_SUSCRIPTORAS hebras suscriptoras, y cree el gestor de contenidos.</li> </ul> Mostrar soluci\u00f3n <p>```java public class PruebaGestor {</p> <pre><code>public static void main(String[] args) {\n    final int N_EDITORAS = 10;\n    final int N_SUSCRIPTORAS = 10;\n\n    Gestor gestor = new Gestor();\n\n    for (int i = 0; i &lt; N_EDITORAS; i++) {\n        new Editora(gestor, i).start();\n    }\n\n    for (int i = 0; i &lt; N_SUSCRIPTORAS; i++) {\n        new Suscriptora(gestor, i).start();\n    }\n}\n</code></pre> <p>}</p> <p>```</p> <ul> <li>(d) (4 puntos) Completar la clase Gestor de forma que se comporte como un monitor, con lo necesario para sincronizar las hebras de las dos clases citadas. La implementaci\u00f3n de los m\u00e9todos del gestor debe cumplir la siguiente especificaci\u00f3n:</li> </ul> <pre><code>... void enviarContenido(Contenido unContenido, Tema unTema)\n</code></pre> <p>Cuando una hebra editora invoca este m\u00e9todo para publicar un contenido, se debe reanudar la ejecuci\u00f3n de todas las hebras suscriptoras que estuvieran esperando este tema. El contenido debe estar disponible para las suscriptoras hasta que una hebra editora env\u00ede el siguiente contenido.</p> <pre><code>... Contenido recibirContenido (Tema unTema)\n</code></pre> <p>Cuando una hebra suscriptora invoca este m\u00e9todo, recibe el \u00faltimo contenido publicado si su tema coincide con el solicitado. Si el \u00faltimo contenido es de otro tema, la hebra se bloquea hasta que una hebra editora env\u00ede un contenido del tema solicitado.</p> Mostrar soluci\u00f3n <pre><code>public class Gestor {\n\n    private Contenido contenido;\n    private Tema tema;\n\n    public synchronized void enviarContenido(Tema unTema, Contenido unContenido) {\n        if (unContenido == null) return;\n        contenido = unContenido;\n        tema = unTema;\n        notifyAll();\n    }\n\n    public synchronized Contenido recibirContenido(Tema unTema) {\n        if (unTema == null) return null;\n        while (unTema != tema) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                System.out.println(\"Interrupci\u00f3n no esperada\");\n            }\n            return contenido;\n        }\n        return contenido;\n    }\n}\n</code></pre>"},{"location":"exams/2017/p2/#problema-2","title":"Problema 2","text":"<p>Tras numerosos e infructuosos intentos, Espa\u00f1a ha vuelto a ganar el festival de Eurovisi\u00f3n. Como pa\u00eds organizador, debe desarrollar una aplicaci\u00f3n m\u00f3vil para facilitar el televoto. Su misi\u00f3n es completar el c\u00f3digo de la aplicaci\u00f3n que se detalla a continuaci\u00f3n.</p> <p>La aplicaci\u00f3n consta de dos pantallas: MainActivity y VotacionActivity, como se ilustra en la figura.</p> <p>En la primera pantalla, el usuario introduce su pa\u00eds (p.ej. Espa\u00f1a) y puede elegir entre votar o listar canciones (esta \u00faltima utilidad no es misi\u00f3n suya). Una vez escrito el pa\u00eds del usuario, si pincha en el bot\u00f3n Votaci\u00f3n, pasa a la segunda pantalla VotacionActivity.</p> <p>En la segunda pantalla, VotacionActivity, el usuario puede realizar dos acciones. La primera es indicar a qu\u00e9 pa\u00eds vota (p.ej. Italia) y cu\u00e1ntos puntos le da (p.ej. 10), y pulsar el bot\u00f3n Votar. La segunda ser\u00eda no realizar la votaci\u00f3n (pulsando el bot\u00f3n Cancelar). Si el usuario pulsa el bot\u00f3n Votar, vuelve a la primera pantalla, y se muestra en un mensaje la votaci\u00f3n realizada.</p> <p></p> <ul> <li>(a) (2 puntos) Se pide que complete el c\u00f3digo proporcionado en esta hoja de respuestas. Tenga que cuenta que s\u00f3lo se entregar\u00e1 una hoja. Pase a esta hoja el c\u00f3digo justo antes de entregar para evitar equivocaciones.</li> </ul> <p>Tal como se indica en la figura, de la Actividad MainActivity se pasa a VotacionActivity pasando la clave \u201ccountry_voting\u201d y el valor String introducido. De la segunda pantalla VotacionActivity, si el usuario pulsa en Votaci\u00f3n, pasa a MainActivity pas\u00e1ndole los datos \u201ccountry_voting\u201d (valor String inicial recibido), \u201ccountry_voted\u201d (String del pa\u00eds votado) y \u201cvotes\u201d (entero de los puntos).</p> <p>Debe completar c\u00f3mo MainActivity pasa a VotacionActivity y c\u00f3mo recibe estos valores. No tenga en cuenta casos an\u00f3malos (un valor no est\u00e1 relleno o no se ha pasado un valor entre actividades)</p> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    private static final String TAG = MainActivity.class.getName();\n    private static final int OBTENER_VOTOS = 0;\n\n    private TextView resultado;\n    private EditText paisVotanteEditText;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Button botonVotar = (Button) findViewById(R.id.botonVotacion);\n        paisVotanteEditText = (EditText) findViewById(R.id.editTextPaisVotante);\n        resultado = (TextView) findViewById(R.id.textViewResultado);\n\n        botonVotar.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                String country = paisVotanteEditText.getText().toString();\n                Intent intent = new Intent(\n                        MainActivity.this,\n                        VotacionActivity.class\n                );\n                intent.putExtra(\"country_voting\", country);\n                startActivityForResult(intent, OBTENER_VOTOS);\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == OBTENER_VOTOS) {\n            if (resultCode == RESULT_OK) {\n                Bundle extras = data.getExtras();\n                String paisVotante = extras.getString(\"country_voting\");\n                String paisVotado = extras.getString(\"country_voted\");\n                int votos = extras.getInt(\"votes\");\n\n                String msg = votos + \" votos recibidos de \"\n                        + paisVotante + \" para \" + paisVotado;\n\n                paisVotanteEditText.setEnabled(false);\n                resultado.setText(msg);\n                resultado.setVisibility(View.VISIBLE);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2017/p2_ex01/","title":"P2 ex01","text":"<p>Se quiere desarrollar un sistema compuesto de dos conjuntos de hebras. Un conjunto de hebras (editoras) producen contenidos sobre un tema y los env\u00edan a un monitor, Gestor. Otro conjunto de hebras (suscriptoras) reciben los contenidos publicados sobre los temas a los que se suscriben. Las hebras editoras y suscriptoras utilizan los siguientes m\u00e9todos del gestor para sincronizarse:</p> <pre><code>public class Gestor {\n    ...\n    public ... void enviarContenido (Tema unTema, Contenido unContenido) {...}\n    public ... Contenido recibirContenido (Tema unTema) {...}\n}\n</code></pre> <p>Se proporcionan las siguientes clases auxiliares que no hay que implementar:</p> <pre><code>public class Contenido {\n    private String contenido;\n\n    public Contenido(String contenido) {\n        this.contenido = contenido;\n    }\n\n    // ...\n}\n\npublic enum Tema {\n    NACIONAL, INTERNACIONAL, CULTURA, DEPORTE;\n\n    public static Tema random() {\n        // ...\n        return null;\n    }\n}\n\npublic class Nap {\n\n    /**\n     * Duerme un periodo aleatorio entre los limites indicados.\n     *\n     * @param min milisegundos minimos.\n     * @param max milisegundos maximos.\n     */\n    public static void random(int min, int max) {\n        // ...\n    }\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba el c\u00f3digo de una clase que defina hebras suscriptoras. Cada hebra ejecuta un bucle N_VECES (una constante). En cada ciclo genera un tema aleatorio (ver m\u00e1s abajo) e invoca el gestor para recibir mensajes de ese tema. Al recibir un mensaje, invoca un m\u00e9todo privado de la clase, procesarContenido(Contenido c), que no hay que implementar. Finalmente, se bloquea durante un tiempo aleatorio (puede usar el m\u00e9todo nap.random()).</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Suscriptora extends Thread {\n    private Gestor gestor;\n    private int id;\n    private final int N_VECES = \u2026;\n\n    public Suscriptora(Gestor gestor, int id) {\n        this.gestor = gestor;\n        this.id = id;\n    }\n\n    private void procesarContenido(Contenido unContenido) {\n        // ...\n    }\n\n    @Override\n    public void run() {\n        Tema unTema;\n        Contenido unContenido;\n\n        for (int i = 0; i &lt; N_VECES; i++) {\n            unTema = Tema.random();\n            unContenido = gestor.recibirContenido(unTema);\n            if (unContenido != null)\n                procesarContenido(unContenido);\n\n            Nap.random(100, 500); // por ejemplo\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un esquema del c\u00f3digo de una clase para definir hebras editoras. En este caso, s\u00f3lo hay que implementar el constructor. Su contenido ser\u00eda similar a la anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Editora extends Thread {\n    private Gestor gestor;\n    private int id;\n    private final int N_VECES = 5;\n\n    public Editora(Gestor gestor, int id) {\n        this.gestor = gestor;\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n        // ...\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Escriba el c\u00f3digo de una clase con un programa principal (main) que arranque N_EDITORAS hebras editoras y N_SUSCRIPTORAS hebras suscriptoras, y cree el gestor de contenidos.</li> </ul> Mostrar soluci\u00f3n <p>```java public class PruebaGestor {</p> <pre><code>public static void main(String[] args) {\n    final int N_EDITORAS = 10;\n    final int N_SUSCRIPTORAS = 10;\n\n    Gestor gestor = new Gestor();\n\n    for (int i = 0; i &lt; N_EDITORAS; i++) {\n        new Editora(gestor, i).start();\n    }\n\n    for (int i = 0; i &lt; N_SUSCRIPTORAS; i++) {\n        new Suscriptora(gestor, i).start();\n    }\n}\n</code></pre> <p>}</p> <p>```</p> <ul> <li>(d) (4 puntos) Completar la clase Gestor de forma que se comporte como un monitor, con lo necesario para sincronizar las hebras de las dos clases citadas. La implementaci\u00f3n de los m\u00e9todos del gestor debe cumplir la siguiente especificaci\u00f3n:</li> </ul> <pre><code>... void enviarContenido(Contenido unContenido, Tema unTema)\n</code></pre> <p>Cuando una hebra editora invoca este m\u00e9todo para publicar un contenido, se debe reanudar la ejecuci\u00f3n de todas las hebras suscriptoras que estuvieran esperando este tema. El contenido debe estar disponible para las suscriptoras hasta que una hebra editora env\u00ede el siguiente contenido.</p> <pre><code>... Contenido recibirContenido (Tema unTema)\n</code></pre> <p>Cuando una hebra suscriptora invoca este m\u00e9todo, recibe el \u00faltimo contenido publicado si su tema coincide con el solicitado. Si el \u00faltimo contenido es de otro tema, la hebra se bloquea hasta que una hebra editora env\u00ede un contenido del tema solicitado.</p> Mostrar soluci\u00f3n <pre><code>public class Gestor {\n\n    private Contenido contenido;\n    private Tema tema;\n\n    public synchronized void enviarContenido(Tema unTema, Contenido unContenido) {\n        if (unContenido == null) return;\n        contenido = unContenido;\n        tema = unTema;\n        notifyAll();\n    }\n\n    public synchronized Contenido recibirContenido(Tema unTema) {\n        if (unTema == null) return null;\n        while (unTema != tema) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                System.out.println(\"Interrupci\u00f3n no esperada\");\n            }\n            return contenido;\n        }\n        return contenido;\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2017/p2_ex02/","title":"P2 ex02","text":"<p>Tras numerosos e infructuosos intentos, Espa\u00f1a ha vuelto a ganar el festival de Eurovisi\u00f3n. Como pa\u00eds organizador, debe desarrollar una aplicaci\u00f3n m\u00f3vil para facilitar el televoto. Su misi\u00f3n es completar el c\u00f3digo de la aplicaci\u00f3n que se detalla a continuaci\u00f3n.</p> <p>La aplicaci\u00f3n consta de dos pantallas: MainActivity y VotacionActivity, como se ilustra en la figura.</p> <p>En la primera pantalla, el usuario introduce su pa\u00eds (p.ej. Espa\u00f1a) y puede elegir entre votar o listar canciones (esta \u00faltima utilidad no es misi\u00f3n suya). Una vez escrito el pa\u00eds del usuario, si pincha en el bot\u00f3n Votaci\u00f3n, pasa a la segunda pantalla VotacionActivity.</p> <p>En la segunda pantalla, VotacionActivity, el usuario puede realizar dos acciones. La primera es indicar a qu\u00e9 pa\u00eds vota (p.ej. Italia) y cu\u00e1ntos puntos le da (p.ej. 10), y pulsar el bot\u00f3n Votar. La segunda ser\u00eda no realizar la votaci\u00f3n (pulsando el bot\u00f3n Cancelar). Si el usuario pulsa el bot\u00f3n Votar, vuelve a la primera pantalla, y se muestra en un mensaje la votaci\u00f3n realizada.</p> <p></p> <ul> <li>(a) (2 puntos) Se pide que complete el c\u00f3digo proporcionado en esta hoja de respuestas. Tenga que cuenta que s\u00f3lo se entregar\u00e1 una hoja. Pase a esta hoja el c\u00f3digo justo antes de entregar para evitar equivocaciones.</li> </ul> <p>Tal como se indica en la figura, de la Actividad MainActivity se pasa a VotacionActivity pasando la clave \u201ccountry_voting\u201d y el valor String introducido. De la segunda pantalla VotacionActivity, si el usuario pulsa en Votaci\u00f3n, pasa a MainActivity pas\u00e1ndole los datos \u201ccountry_voting\u201d (valor String inicial recibido), \u201ccountry_voted\u201d (String del pa\u00eds votado) y \u201cvotes\u201d (entero de los puntos).</p> <p>Debe completar c\u00f3mo MainActivity pasa a VotacionActivity y c\u00f3mo recibe estos valores. No tenga en cuenta casos an\u00f3malos (un valor no est\u00e1 relleno o no se ha pasado un valor entre actividades)</p> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    private static final String TAG = MainActivity.class.getName();\n    private static final int OBTENER_VOTOS = 0;\n\n    private TextView resultado;\n    private EditText paisVotanteEditText;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Button botonVotar = (Button) findViewById(R.id.botonVotacion);\n        paisVotanteEditText = (EditText) findViewById(R.id.editTextPaisVotante);\n        resultado = (TextView) findViewById(R.id.textViewResultado);\n\n        botonVotar.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                String country = paisVotanteEditText.getText().toString();\n                Intent intent = new Intent(\n                        MainActivity.this,\n                        VotacionActivity.class\n                );\n                intent.putExtra(\"country_voting\", country);\n                startActivityForResult(intent, OBTENER_VOTOS);\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == OBTENER_VOTOS) {\n            if (resultCode == RESULT_OK) {\n                Bundle extras = data.getExtras();\n                String paisVotante = extras.getString(\"country_voting\");\n                String paisVotado = extras.getString(\"country_voted\");\n                int votos = extras.getInt(\"votes\");\n\n                String msg = votos + \" votos recibidos de \"\n                        + paisVotante + \" para \" + paisVotado;\n\n                paisVotanteEditText.setEnabled(false);\n                resultado.setText(msg);\n                resultado.setVisibility(View.VISIBLE);\n            }\n        }\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2018/extra/","title":"Examen 2018 \u2014 Extraordinario","text":""},{"location":"exams/2018/extra/#problema-1","title":"Problema 1","text":"<p>Vamos a trabajar el algoritmo del huevo. Sirve para modelar algoritmos de b\u00fasqueda r\u00e1pida cuando las pruebas son destructivas, reemplazando a la b\u00fasqueda binaria en un array.</p> <p>Tenemos N huevos y un edificio de H pisos. Queremos saber el piso m\u00e1s alto desde el que podemos dejar caer el huevo sin que se rompa. Con las siguientes suposiciones:     - Un huevo que sobrevive a una ca\u00edda se puede usar nuevamente.     - Un huevo roto queda descartado.     - El efecto de una ca\u00edda es el mismo para todos los huevos.     - Si un huevo rompe al caer desde un piso, romper\u00e1 si se cae desde un piso superior.     - Si un huevo no rompe desde un piso, tampoco romper\u00e1 desde un piso superior.</p> <p>La b\u00fasqueda binaria no sirve. Por ejemplo, si solo tenemos un huevo N=1, el mejor algoritmo es la b\u00fasqueda lineal: ir tirando desde pisos consecutivos hasta que rompa. Si tenemos N = 2 huevos en un edificio de 100 plantas y probamos en el piso 50 y rompe, solo nos queda un huevo para 49 pruebas adicionales. El \u00f3ptimo para N=2 y H=100 es empezar desde el piso 14. La b\u00fasqueda binaria vale cuando hay m\u00e1s huevos que pisos.</p> <p>Para averiguar el piso \u00f3ptimo solo necesitamos tener en cuenta cu\u00e1ntos pisos tenemos para probar. Es decir, es lo mismo buscar en los pisos del 1 al 10 que entre el 71 y el 80.</p> <p>Para averiguar el n\u00famero m\u00e1ximo de pruebas con N huevos y H pisos podemos usar un m\u00e9todo recursivo: <pre><code>def drops(n, h):\n    if n == 1:\n        return h\n    if h &lt; 2:\n        return h\n    res = 1000\n    for x in range(1, h + 1):\n        res = min(\n            res,\n            1 + max(drops(n - 1, x - 1), drops(n, h - x))\n        return res;\n</code></pre> Simplemente probamos todos los pisos X en el rango de pisos y para cada uno de ellos tenemos 2 opciones     - que el huevo se rompa y tenemos N-1 huevos y X-1 pisos     - que el huevo no rompa y tenemos N huevos y H-X pisos</p> <p>Probamos este c\u00f3digo y va muy muy lento. Medimos tiempos para N=2 y obtenemos esto:</p> <p></p> <ul> <li>(a) (2,5 puntos) Indicar la complejidad del algoritmo recursivo en funci\u00f3n de H. No se pide que la calcule anal\u00edticamente, solo que la marque y la valide a partir de las medidas realizadas.</li> </ul> Mostrar soluci\u00f3n <p>Estudio de opciones en base al coeficiente de correlaci\u00f3n.</p> Complejidad r Evaluaci\u00f3n O(log h) 0.36 NO, r &lt;&lt; 1.0 O(h) 0.41 NO, r &lt;&lt; 1.0 O(h log h) 0.43 NO, r &lt;&lt; 1.0 O(h^18) 0.98 Posible O(1.9^h) 1.00 Posible <p>De las 2 opciones posibles, es absurdo que en un algoritmo recursivo como el presentado aparezca un polinomio de orden 18.</p> <p>S\u00ed es posible una complejidad O(2^h), que es probablemente la soluci\u00f3n.</p> <p>Del an\u00e1lisis de la relaci\u00f3n de recurrencia, para N = 2, tenemos un bucle interno sobre <code>x</code> que se ejecuta <code>h</code> veces en forma de serie aritm\u00e9tica: <pre><code>T(n, h-1) + T(n, h-2) + \u2026 + T(n, 1)\n= h * (T(n, h-1) + T(n, 1)) / 2\n\u2248 h * T(n, h-1)\n</code></pre> El algoritmo completo queda definido por la recurrencia: <pre><code>T(h) = h * T(h-1)\n</code></pre> Intentamos validar la soluci\u00f3n propuesta: <pre><code>T(h) = 2^h\n</code></pre> Sustituyendo en la recurrencia: <pre><code>2^h = h * 2^{h-1}\n</code></pre> Esta igualdad se cumple para h &gt;&gt; 1 (cuando <code>h</code> tiende a infinito).</p> <p>Para n constante, el algoritmo tiene complejidad O(2^h).</p> <p>Como el algoritmo recursivo no es pr\u00e1ctico, recurrimos a memorizar resultados intermedios, de forma similar a como se hace con las series de Fibonacci. <pre><code>01  int eggDrop(int n, int h) {\n02      int[][] cache = new int[n + 1][h + 1];\n03      for (int i = 1; i &lt;= n; i++) {\n04          cache[i][1] = 1;\n05          cache[i][0] = 0;\n06      }\n07      for (int j = 1; j &lt;= h; j++)\n08          cache[1][j] = j;\n09      for (int i = 2; i &lt;= n; i++) {\n10          for (int j = 2; j &lt;= h; j++) {\n11              int min = Integer.MAX_VALUE;\n12              for (int x = 1; x &lt;= j; x++) {\n13                  int res = 1 + Math.max(cache[i - 1][x - 1],\n14                                          cache[i][j - x]);\n15                  min = Math.min(min, res);\n16              }\n17              cache[i][j] = min;\n18          }\n19      }\n20      return cache[n][h];\n21  }\n</code></pre></p> <ul> <li>(b) (2,5 puntos) Se pide que calcule la complejidad de la implementaci\u00f3n iterativa, en funci\u00f3n de N y H. Se valorar\u00e1 la correcci\u00f3n de los razonamientos usados para determinar la complejidad.</li> </ul> Mostrar soluci\u00f3n L\u00ednea Complejidad 2 O(1) 3\u20136 n \u00b7 O(1) = O(n) 7\u20138 h \u00b7 O(1) = O(h) 9 n \u00b7 \u2026 (bucle <code>for</code>) 10 h \u00b7 \u2026 (bucle <code>for</code>) 11 O(1) 12 h \u00b7 \u2026 (bucle <code>for</code>) 13\u201315 O(1) 12\u201316 h \u00b7 O(1) = O(h) 17 O(1) 10\u201318 h \u00b7 (O(1) + O(h) + O(1)) = O(h\u00b2) 9\u201319 n \u00b7 O(h\u00b2) = O(n\u00b7h\u00b2) 20 O(1) 2\u201321 O(1) + O(n) + O(h) + O(n\u00b7h\u00b2) + O(1) = O(n\u00b7h\u00b2) <p>Hemos convertido un algoritmo recursivo de orden exponencial en un algoritmo iterativo de orden cuadr\u00e1tico.</p>"},{"location":"exams/2018/extra/#problema-2","title":"Problema 2","text":"<p>Disponemos de las clases Datos, DatosOrdenado y BST, cuyos esquemas se pueden ver debajo. La case Datos almacena valores enteros sin ordenar en un array de tama\u00f1o fijado en el constructor. La clase DatosOrdenado almacena valores enteros ordenados de menor a mayor en un array de tama\u00f1o fijado en el constructor. La clase BST almacena valores enteros en un BST, donde en cada nodo del \u00e1rbol se almacena un n\u00famero entero en el campo valor. <pre><code>public class Datos {\n    private int[] valores;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n\npublic class DatosOrdenado {\n    private int[] valores;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n\npublic class BST {\n    private class Nodo {\n        int valor;\n        Nodo izd;\n        Nodo der;\n    }\n\n    private Nodo raiz;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n</code></pre></p> <p>En una aplicaci\u00f3n concreta que estamos desarrollando, deseamos conocer cu\u00e1ntos valores almacenados son menores que un cierto valor val que se pasa como par\u00e1metro. Este valor que se pasa como par\u00e1metro puede no ser uno de los valores almacenados.</p> <ul> <li>(a) (2,5 puntos) Codificar el m\u00e9todo public int cuentaMenores (int val), en cada una de las 3 clases: Datos, DatosOrdenado y BST. Nota: Para simplificar suponga que tanto en Datos como en DatosOrdenado, los arrays de enteros est\u00e1n ocupados en su totalidad por valores almacenados. Suponga que no hay datos repetidos y que no hay operaciones de modificaci\u00f3n (inserci\u00f3n o borrado), sino exclusivamente se trata de buscar en una estructura de datos construida.</li> </ul> Mostrar soluci\u00f3n <pre><code>class Datos {\n    public int cuentaMenores(int val) {\n        int cuenta = 0;\n        for (int i = 0; i &lt; nValores; i++) {\n            if (valores[i] &lt; val)\n                cuenta++;\n        }\n        return cuenta;\n    }\n}\n\nclass DatosOrdenado {\n    public int cuentaMenores(int val) {\n        int n = valores.length;\n        int centro, inf = 0, sup = n - 1;\n        while (inf &lt;= sup) {\n            centro = (sup + inf) / 2;\n            if (valores[centro] == val)\n                return centro;\n            else if (val &lt; valores[centro]) {\n                sup = centro - 1;\n            } else {\n                inf = centro + 1;\n            }\n        }\n        return sup + 1;\n    }\n}\n\nclass BST {\n    private int cuentaMenores(Nodo actual, int val) {\n        int cuenta = 0;\n        if (actual == null)\n            return 0;\n        if (actual.valor == val)\n            return cuentaTodos(actual.izd);\n        if (actual.valor &lt; val)\n            cuenta = 1;\n        int nizd = cuentaMenores(actual.izd, val);\n        int nder = cuentaMenores(actual.der, val);\n        return cuenta + nizd + nder;\n    }\n\n    private int cuentaTodos(Nodo actual) {\n        if (actual == null)\n            return 0;\n        return 1 + cuentaTodos(actual.izd) + cuentaTodos(actual.der);\n    }\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Se pide: Considerando s\u00f3lo los m\u00e9todos cuentaMenores que acaba de implementar, cu\u00e1l de las tres clases seleccionar\u00eda para almacenar un conjunto de valores de tama\u00f1o fijo (M) donde se vayan a realizar frecuentes llamas al m\u00e9todo cuentaMenores.</li> </ul> Mostrar soluci\u00f3n <p>La clase Datos al tener los valores no ordenados nos obliga a recorrer todo el array, por lo tanto, la complejidad es proporcional al n\u00famero de valores almacenados: O(N)</p> <p>La Clase DatosOrdenado, tiene los valores ordenados de menor a mayor. Que los valores est\u00e9n ordenados permite utilizar b\u00fasqueda dicot\u00f3mica para localizar el valor, o en su defecto la posici\u00f3n donde deber\u00eda estar el valor que estamos buscando. Esta operaci\u00f3n tiene una complejidad O(log N). Una vez localizada la posici\u00f3n donde est\u00e1 o deber\u00eda estar el valor, todos los de la izquierda son menores que \u00e9l, por lo tanto, por lo que directamente conocemos el n\u00famero de valores menores que el que nos pasan como par\u00e1metro usando el \u00edndice de la posici\u00f3n del array donde est\u00e1 o deber\u00eda estar el valor pasado como par\u00e1metro. El resultado es un algoritmo de orden O(log N)</p> <p>En el caso del BST la estructura de BST ayuda a encontrar el valor en el \u00e1rbol con una complejidad O(log N),pero como lo que nos piden es el n\u00famero de valores menor que el valor pasado como par\u00e1metro, e incluso puede ocurrir que le propio valor no se encuentre en el \u00e1rbol, debemos recorrer casi todo el \u00e1rbol con una complejidad O(N).</p> <p>Por lo tanto, a la vista de este an\u00e1lisis, para nuestro problema concreto, la clase seleccionada es DatosOrdenado</p>"},{"location":"exams/2018/extra/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (2 puntos) Explique brevemente cu\u00e1l es la diferencia entre interbloqueo (deadlock) y bloqueo vivo (livelock).</li> </ul> Mostrar soluci\u00f3n <p>En un interbloqueo hay varias hebras suspendidas, esperando conseguir recursos que tienen que liberar otras hebras, de tal manera que en conjunto se forma una cada de espera circular y ninguna hebra puede avanzar.</p> <p>En un bloqueo vivo hay igualmente varias hebras intentando conseguir recursos que tienen otras hebras. La diferencia es que cuando una hebra no puede conseguir todos sus recursos libera los que tiene y lo vuelve a intentar. Como consecuencia, las hebras implicadas est\u00e1n continuamente activas, aunque sin realizar ning\u00fan progreso.</p> <p>Por tanto, la diferencia fundamental es que en un interbloqueo las hebras est\u00e1s suspendidas y nunca se ejecutan, mientras que en un bloqueo vivo las hebras se ejecutan pero no progresan.</p> <p>Sea un sistema con 8 GB de memoria principal. Tenemos procesos concurrentes que solicitan memoria en bloques de 2 GB a medida que la necesitan para su ejecuci\u00f3n. Un proceso que ya tiene N bloques de memoria asignados puede solicitar m\u00e1s memoria, y si ya no hay memoria disponible espera a que la haya antes de continuar. La memoria asignada a un proceso se libera completamente cuando el proceso termina su ejecuci\u00f3n.</p> <ul> <li>(b) (3 puntos) Indique razonadamente si es posible que se d\u00e9 una situaci\u00f3n de interbloqueo (deadlock), en qu\u00e9 circunstancias podr\u00eda ocurrir y, si \u00e9ste es el caso, c\u00f3mo se podr\u00eda evitar.</li> </ul> Mostrar soluci\u00f3n <p>Los procesos acceden a un conjunto de recursos, los bloques de memoria, todos iguales, con una disponibilidad total limitada a 4 bloques en total. Se pueden producir interbloqueos si varios procesos intentan adquirir m\u00e1s memoria cuando ya est\u00e1 toda asignada a otros procesos que tambi\u00e9n necesitan m\u00e1s memoria.</p> <p>Por ejemplo, sup\u00f3ngase que hay dos procesos P y Q, que tiene asignados 2 bloques de memoria cada uno, es decir 4 en total, por lo que no hay bloques libres. Si ambos solicitan un bloque adicional cada uno, al no estar disponible se suspenden esperando que haya memoria libre. Para ello uno de los dos tendr\u00eda que terminar, liberando su memoria, pero al no poder avanzar ninguno de los dos se quedan suspendidos indefinidamente.</p> <p>Podemos comprobar que se cumplen las condiciones necesarias de Coffman: 1. Exclusi\u00f3n mutua: un bloque de memoria s\u00f3lo puede estar asignado a un proceso. 2. Tener y esperar: un proceso puede tener asignada memoria y esperar que conseguir m\u00e1s. 3. Sin expulsi\u00f3n: no se quita memoria a un proceso hasta que termina su ejecuci\u00f3n. 4. Espera circular, como pone de manifiesto el ejemplo anterior.</p> <p>Para evitar el interbloqueo la soluci\u00f3n m\u00e1s sencilla ser\u00eda obligar a que los procesos soliciten toda la memoria que pueden necesitar al iniciarse, invalidando la condici\u00f3n 2. N\u00f3tese que la soluci\u00f3n frecuentemente recomendada de asignar los recursos siempre en el mismo orden no es aplicable aqu\u00ed porque todos los bloques de memoria son iguales</p>"},{"location":"exams/2018/extra/#problema-4","title":"Problema 4","text":"<p>La panader\u00eda Molinga S.L. quiere modernizar sus instalaciones robotizando su sistema de producci\u00f3n de pan. Para ello han encargado a los alumnos de ADSW que realicen parte del sistema.</p> <p>Se desea realizar dos monitores para gestionar la amasadora y el horno de la panader\u00eda, con acceso exclusivo por parte de varios robots (threads). Existen 3 tipos de robots en la panader\u00eda:     - Robots de almac\u00e9n, que meten ingredientes en la amasadora.     - Robots amasadores, que cuando tienen los ingredientes necesarios amasan y despu\u00e9s meten la masa en el horno.     - Robots horneadores, que cuando tienen las masas necesarias para llenar un horno, hornean el pan.</p> <p>La amasadora permitir\u00e1 introducir ingredientes a los r obots de almac\u00e9n y amasar a los robots amasadores. Para hacer una masa de pan hacen falta cuatro ingredientes: agua, harina, levadura y sal, en la proporci\u00f3n de 4, 3, 2 y 1 unidades. No se permitir\u00e1 a los robots de almac\u00e9n introducir m\u00e1s ingredientes si hay suficientes para hacer una masa, y de igual manera no se permitir\u00e1 a los robots amasadores amasar si no hay suficientes ingredientes para hacer una masa.</p> <p>El horno permitir\u00e1 introducir masas a los robots amasadores y hornear a los robots horneadores. Un horno tiene un tama\u00f1o concreto, que recibir\u00e1 como par\u00e1metro en el constructor, indicando el n\u00famero de masas que es capaz de hornear. Por motivos de eficiencia, los robots horneadores solo podr\u00e1n hornear si el horno est\u00e1 completamente lleno, y los robots amasadores solo podr\u00e1n meter masas si hay hueco en el horno.</p> <p>Estructura de clases de la panader\u00eda:</p> <p></p> <p>Ejemplo de programa con varios robots: <pre><code>public enum Ingrediente {\n    Agua, Harina, Levadura, Sal\n}\n\npublic static void main(String[] args) {\n    Amasadora amasadora = new Amasadora();\n    Horno horno = new Horno(5);\n    new RobotAlmacen(\"ED209\",amasadora).start();\n    new RobotAlmacen(\"T-800\",amasadora).start();\n    new RobotAlmacen(\"WALL-E\",amasadora).start();\n    new RobotAlmacen(\"Bumblebee\",amasadora).start();\n    new RobotAmasador(\"R2D2\",amasadora,horno).start();\n    new RobotAmasador(\"C3PO\",amasadora,horno).start();\n    new RobotAmasador(\"BB8\",amasadora,horno).start();\n    new RobotHorneador(\"Chappie\",horno).start();\n    new RobotHorneador(\"RoboCop\",horno).start();\n}\n</code></pre></p> <p>Ejemplo de c\u00f3digo del robor horneador: <pre><code>public class RobotHorneador extends Thread {\n    private Horno horno;\n    private String nombre;\n    private int panes = 0;\n    private Random random = new Random();\n\n    public RobotHorneador(String nombre, Horno horno) {\n        this.horno = horno;\n        this.nombre = nombre;\n        this.panes = 0;\n    }\n\n    public String getNombre() {return this.nombre;}\n\n    public void run() {\n        while (true) {\n            try {\n                int panesNuevos = this.horno.hornear();\n                this.panes = this.panes + panesNuevos;\n                Thread.sleep(random.nextInt(5000));\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre></p> <ul> <li>(a) (2,5 puntos) Desarrollar el monitor Amasadora</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Amasadora {\n    private int cantidadAgua;\n    private int cantidadHarina;\n    private int cantidadLevadura;\n    private int cantidadSal;\n\n    public synchronized void amasar() {\n        try {\n            while (!((this.cantidadAgua &gt;= 4) &amp;&amp; (this.cantidadHarina &gt;= 3) &amp;&amp;\n                   (this.cantidadLevadura &gt;= 2) &amp;&amp; (this.cantidadSal &gt;= 1))) {\n                wait();\n            }\n            this.cantidadAgua = this.cantidadAgua - 4;\n            this.cantidadHarina = this.cantidadHarina - 3;\n            this.cantidadLevadura = this.cantidadLevadura - 2;\n            this.cantidadSal = this.cantidadSal - 1;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n\n    public synchronized void meterIngredientes(Ingrediente ingrediente, int cantidad) {\n        try {\n            while (((this.cantidadAgua &gt;= 4) &amp;&amp; (this.cantidadHarina &gt;= 3) &amp;&amp;\n                   (this.cantidadLevadura &gt;= 2) &amp;&amp; (this.cantidadSal &gt;= 1))) {\n                wait();\n            }\n            switch (ingrediente) {\n                case Agua:\n                    this.cantidadAgua = this.cantidadAgua + cantidad;\n                    break;\n                case Harina:\n                    this.cantidadHarina = this.cantidadHarina + cantidad;\n                    break;\n                case Levadura:\n                    this.cantidadLevadura = this.cantidadLevadura + cantidad;\n                    break;\n                case Sal:\n                    this.cantidadSal = this.cantidadSal + cantidad;\n                    break;\n            }\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Desarrollar el monitor Horno</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Horno {\n    private int masas;\n    private int tama\u00f1o;\n\n    public Horno(int tama\u00f1o) {\n        this.tama\u00f1o = tama\u00f1o;\n    }\n\n    public synchronized int hornear(String nombre) {\n        try {\n            while (!(this.masas &gt;= this.tama\u00f1o)) {\n                wait();\n            }\n            this.masas = this.masas - this.tama\u00f1o;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n        return this.tama\u00f1o;\n    }\n\n    public synchronized void meterMasa(String nombre) {\n        try {\n            while (this.masas &gt;= this.tama\u00f1o) {\n                wait();\n            }\n            this.masas++;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n}\n</code></pre> <ul> <li>(c) (0,5 puntos) Proponer el m\u00e9todo run() del Robot Amasador</li> </ul> Mostrar soluci\u00f3n <pre><code>public void run() {\n    while (true) {\n        amasadora.amasar();\n        horno.meterMasa();\n    }\n}\n</code></pre>"},{"location":"exams/2018/extra/#problema-5","title":"Problema 5","text":"<p>Se desea ampliar el juego de la serpiente con un contador de las manzanas que ha comido la serpiente. Naturalmente, cuando la serpiente come una manzana, este contador debe aumentar en una unidad. Para a\u00f1adir dificultad al jugador, tambi\u00e9n puede perder manzanas de este contador por dos motivos:     - Si una bola choca con una manzana, el jugador pierde una unidad de su contador de manzanas comidas. El contador no puede nunca tener un valor inferior a cero como resultado de esta p\u00e9rdida, pero la p\u00e9rdida debe ejecutarse tan pronto como sea posible.     - Si la serpiente es golpeada en la cabeza por una bola, el contador de manzanas se reduce a la mitad, redondeando al entero inmediatamente inferior. Esto es, si el jugador ten\u00eda 7 puntos debe quedarse con 3.</p> <p>Siendo la clase manzanas: <pre><code>public class Manzanas\nimplements Screen.Thing {\n\n    /** Constructor. */\n    public Manzanas() {\n        font = new Font(\"SansSerif\", Font.BOLD, 18);\n        Game.getScreen().add(this);\n    }\n\n    /** La serpiente ha comido una manzana. */\n    public void appleEaten() {\n    }\n\n    /** Una bola ha destruido una manzana. */\n    public void appleDestroid() {\n    }\n\n    /** Una bola ha golpeado la cabeza de la serpiente. */\n    public void headShot() {\n    }\n\n    /** Se imprime en pantalla. */\n    @Override\n    public void paint(Graphics2D g) {\n        g.setFont(font);\n        g.setColor(Color.BLACK);\n        g.drawString(\"manzanas: \" + , 10, 30);\n    }\n}\n</code></pre></p> <p>Se pide que complete y modifique la clase monitor Manzanas como considere oportuno para obtener la funcionalidad descrita.</p> Mostrar soluci\u00f3n <pre><code>/**\n * Contador de manzanas.\n */\npublic class Manzanas\nimplements Screen.Thing {\n\n    private int manzanas;\n\n    public Manzanas() {\n        font = new Font(\"SansSerif\", Font.BOLD, 18);\n        manzanas = 0;\n        Game.getScreen().add(this);\n    }\n\n    public synchronized void appleEaten() {\n        manzanas++;\n        notifyAll();\n    }\n\n    public synchronized void appleDestroid() {\n        while (manzanas &lt;= 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        manzanas--;\n    }\n\n    public synchronized void headShot() {\n        manzanas = manzanas / 2;\n    }\n\n    @Override\n    public void paint(Graphics2D g) {\n        g.setFont(font);\n        g.setColor(Color.BLACK);\n        g.drawString(\"manzanas: \" + manzanas, 10, 30);\n    }\n}\n</code></pre>"},{"location":"exams/2018/extra/#problema-6","title":"Problema 6","text":"<p>Para la aplicaci\u00f3n Android DaysUntil se desea a\u00f1adir la posibilidad de a\u00f1adir una descripci\u00f3n del evento introducido por el usuario. Esta informaci\u00f3n es opcional para la funcionalidad b\u00e1sica de la aplicaci\u00f3n. Sin embargo, en caso de existir una descripci\u00f3n, esta debe incluirse en la informaci\u00f3n pasada como intenci\u00f3n impl\u00edcita para la creaci\u00f3n de un evento en el calendario del usuario al pulsar un bot\u00f3n.</p> <p>Siendo el esqueleto del c\u00f3digo el siguiente: <pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    /** Devuelve el nombre del evento introducido por el usuario */\n    private String getEvento () { ... }\n\n    /** Devuelve la fecha del evento introducida por el usuario */\n    private Calendar getFecha () { ... }\n\n    /** \n     * A partir de un nombre y una fecha crea una intenci\u00f3n impl\u00edcita para la\n     * inserci\u00f3n de un nuevo evento en un calendario\n     */\n    private Intent eventIntent (String nombre, Calendar fecha) { ... }\n\n    public void crearEvento (View v) {\n        // Completar\n    }\n}\n</code></pre></p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout\n    \u2026 &gt;\n\n    &lt;LinearLayout \u2026 &gt;\n        &lt;EditText\n            android:id=\"@+id/eventName\"\n            \u2026 /&gt;\n        &lt;EditText\n            android:id=\"@+id/eventDate\"\n            \u2026 /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre> <ul> <li>(a) Complete el c\u00f3digo asociado a dicha funcionalidad, tanto en el c\u00f3digo java como en la definici\u00f3n del layout asociado a la actividad en cuesti\u00f3n. Considere implementados los m\u00e9todos getNombre y getFecha. Ha de implementar completamente cualquier otro m\u00e9todo auxiliar que considere necesario. Nota: la clave esperada por la intenci\u00f3n de crear un evento para la descripci\u00f3n del mismo es <code>CalendarContract.Events.DESCRIPTION</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    /** Devuelve el nombre del evento introducido por el usuario */\n    private String getEvento() { ... }\n\n    /** Devuelve la fecha del evento introducida por el usuario */\n    private Calendar getFecha() { ... }\n\n    /**\n     * A partir de un nombre y una fecha crea una intenci\u00f3n impl\u00edcita para la inserci\u00f3n de un\n     * nuevo evento en un calendario\n     */\n    private Intent eventIntent(String nombre, Calendar fecha) { ... }\n\n    public void crearEvento(View v) {\n        EditText eventDescription = eventDescription = (EditText)\n                findViewById(R.id.eventDescription);\n\n        Intent intent = eventIntent(getEvento(), getFecha());\n\n        if (eventDescription.getText().toString().length() &gt; 0) {\n            intent.putExtra(CalendarContract.Events.DESCRIPTION,\n                    eventDescription.getText().toString());\n        }\n\n        startActivity(intent);\n    }\n}\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout\n    \u2026 &gt;\n\n    &lt;LinearLayout \u2026 &gt;\n        &lt;EditText\n            android:id=\"@+id/eventName\"\n            \u2026 /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/eventDate\"\n            \u2026 /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/eventDescription\"\n            android:hint=\"Event description\"\n            \u2026 /&gt;\n\n        &lt;Button\n            android:text=\"Add event to calendar\"\n            android:onClick=\"crearEvento\"/&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>"},{"location":"exams/2018/extra_ex01/","title":"Extra ex01","text":"<p>Vamos a trabajar el algoritmo del huevo. Sirve para modelar algoritmos de b\u00fasqueda r\u00e1pida cuando las pruebas son destructivas, reemplazando a la b\u00fasqueda binaria en un array.</p> <p>Tenemos N huevos y un edificio de H pisos. Queremos saber el piso m\u00e1s alto desde el que podemos dejar caer el huevo sin que se rompa. Con las siguientes suposiciones:     - Un huevo que sobrevive a una ca\u00edda se puede usar nuevamente.     - Un huevo roto queda descartado.     - El efecto de una ca\u00edda es el mismo para todos los huevos.     - Si un huevo rompe al caer desde un piso, romper\u00e1 si se cae desde un piso superior.     - Si un huevo no rompe desde un piso, tampoco romper\u00e1 desde un piso superior.</p> <p>La b\u00fasqueda binaria no sirve. Por ejemplo, si solo tenemos un huevo N=1, el mejor algoritmo es la b\u00fasqueda lineal: ir tirando desde pisos consecutivos hasta que rompa. Si tenemos N = 2 huevos en un edificio de 100 plantas y probamos en el piso 50 y rompe, solo nos queda un huevo para 49 pruebas adicionales. El \u00f3ptimo para N=2 y H=100 es empezar desde el piso 14. La b\u00fasqueda binaria vale cuando hay m\u00e1s huevos que pisos.</p> <p>Para averiguar el piso \u00f3ptimo solo necesitamos tener en cuenta cu\u00e1ntos pisos tenemos para probar. Es decir, es lo mismo buscar en los pisos del 1 al 10 que entre el 71 y el 80.</p> <p>Para averiguar el n\u00famero m\u00e1ximo de pruebas con N huevos y H pisos podemos usar un m\u00e9todo recursivo: <pre><code>def drops(n, h):\n    if n == 1:\n        return h\n    if h &lt; 2:\n        return h\n    res = 1000\n    for x in range(1, h + 1):\n        res = min(\n            res,\n            1 + max(drops(n - 1, x - 1), drops(n, h - x))\n        return res;\n</code></pre> Simplemente probamos todos los pisos X en el rango de pisos y para cada uno de ellos tenemos 2 opciones     - que el huevo se rompa y tenemos N-1 huevos y X-1 pisos     - que el huevo no rompa y tenemos N huevos y H-X pisos</p> <p>Probamos este c\u00f3digo y va muy muy lento. Medimos tiempos para N=2 y obtenemos esto:</p> <p></p> <ul> <li>(a) (2,5 puntos) Indicar la complejidad del algoritmo recursivo en funci\u00f3n de H. No se pide que la calcule anal\u00edticamente, solo que la marque y la valide a partir de las medidas realizadas.</li> </ul> Mostrar soluci\u00f3n <p>Estudio de opciones en base al coeficiente de correlaci\u00f3n.</p> Complejidad r Evaluaci\u00f3n O(log h) 0.36 NO, r &lt;&lt; 1.0 O(h) 0.41 NO, r &lt;&lt; 1.0 O(h log h) 0.43 NO, r &lt;&lt; 1.0 O(h^18) 0.98 Posible O(1.9^h) 1.00 Posible <p>De las 2 opciones posibles, es absurdo que en un algoritmo recursivo como el presentado aparezca un polinomio de orden 18.</p> <p>S\u00ed es posible una complejidad O(2^h), que es probablemente la soluci\u00f3n.</p> <p>Del an\u00e1lisis de la relaci\u00f3n de recurrencia, para N = 2, tenemos un bucle interno sobre <code>x</code> que se ejecuta <code>h</code> veces en forma de serie aritm\u00e9tica: <pre><code>T(n, h-1) + T(n, h-2) + \u2026 + T(n, 1)\n= h * (T(n, h-1) + T(n, 1)) / 2\n\u2248 h * T(n, h-1)\n</code></pre> El algoritmo completo queda definido por la recurrencia: <pre><code>T(h) = h * T(h-1)\n</code></pre> Intentamos validar la soluci\u00f3n propuesta: <pre><code>T(h) = 2^h\n</code></pre> Sustituyendo en la recurrencia: <pre><code>2^h = h * 2^{h-1}\n</code></pre> Esta igualdad se cumple para h &gt;&gt; 1 (cuando <code>h</code> tiende a infinito).</p> <p>Para n constante, el algoritmo tiene complejidad O(2^h).</p> <p>Como el algoritmo recursivo no es pr\u00e1ctico, recurrimos a memorizar resultados intermedios, de forma similar a como se hace con las series de Fibonacci. <pre><code>01  int eggDrop(int n, int h) {\n02      int[][] cache = new int[n + 1][h + 1];\n03      for (int i = 1; i &lt;= n; i++) {\n04          cache[i][1] = 1;\n05          cache[i][0] = 0;\n06      }\n07      for (int j = 1; j &lt;= h; j++)\n08          cache[1][j] = j;\n09      for (int i = 2; i &lt;= n; i++) {\n10          for (int j = 2; j &lt;= h; j++) {\n11              int min = Integer.MAX_VALUE;\n12              for (int x = 1; x &lt;= j; x++) {\n13                  int res = 1 + Math.max(cache[i - 1][x - 1],\n14                                          cache[i][j - x]);\n15                  min = Math.min(min, res);\n16              }\n17              cache[i][j] = min;\n18          }\n19      }\n20      return cache[n][h];\n21  }\n</code></pre></p> <ul> <li>(b) (2,5 puntos) Se pide que calcule la complejidad de la implementaci\u00f3n iterativa, en funci\u00f3n de N y H. Se valorar\u00e1 la correcci\u00f3n de los razonamientos usados para determinar la complejidad.</li> </ul> Mostrar soluci\u00f3n L\u00ednea Complejidad 2 O(1) 3\u20136 n \u00b7 O(1) = O(n) 7\u20138 h \u00b7 O(1) = O(h) 9 n \u00b7 \u2026 (bucle <code>for</code>) 10 h \u00b7 \u2026 (bucle <code>for</code>) 11 O(1) 12 h \u00b7 \u2026 (bucle <code>for</code>) 13\u201315 O(1) 12\u201316 h \u00b7 O(1) = O(h) 17 O(1) 10\u201318 h \u00b7 (O(1) + O(h) + O(1)) = O(h\u00b2) 9\u201319 n \u00b7 O(h\u00b2) = O(n\u00b7h\u00b2) 20 O(1) 2\u201321 O(1) + O(n) + O(h) + O(n\u00b7h\u00b2) + O(1) = O(n\u00b7h\u00b2) <p>Hemos convertido un algoritmo recursivo de orden exponencial en un algoritmo iterativo de orden cuadr\u00e1tico.</p>","tags":["complejidad"]},{"location":"exams/2018/extra_ex02/","title":"Extra ex02","text":"<p>Disponemos de las clases Datos, DatosOrdenado y BST, cuyos esquemas se pueden ver debajo. La case Datos almacena valores enteros sin ordenar en un array de tama\u00f1o fijado en el constructor. La clase DatosOrdenado almacena valores enteros ordenados de menor a mayor en un array de tama\u00f1o fijado en el constructor. La clase BST almacena valores enteros en un BST, donde en cada nodo del \u00e1rbol se almacena un n\u00famero entero en el campo valor. <pre><code>public class Datos {\n    private int[] valores;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n\npublic class DatosOrdenado {\n    private int[] valores;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n\npublic class BST {\n    private class Nodo {\n        int valor;\n        Nodo izd;\n        Nodo der;\n    }\n\n    private Nodo raiz;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n</code></pre></p> <p>En una aplicaci\u00f3n concreta que estamos desarrollando, deseamos conocer cu\u00e1ntos valores almacenados son menores que un cierto valor val que se pasa como par\u00e1metro. Este valor que se pasa como par\u00e1metro puede no ser uno de los valores almacenados.</p> <ul> <li>(a) (2,5 puntos) Codificar el m\u00e9todo public int cuentaMenores (int val), en cada una de las 3 clases: Datos, DatosOrdenado y BST. Nota: Para simplificar suponga que tanto en Datos como en DatosOrdenado, los arrays de enteros est\u00e1n ocupados en su totalidad por valores almacenados. Suponga que no hay datos repetidos y que no hay operaciones de modificaci\u00f3n (inserci\u00f3n o borrado), sino exclusivamente se trata de buscar en una estructura de datos construida.</li> </ul> Mostrar soluci\u00f3n <pre><code>class Datos {\n    public int cuentaMenores(int val) {\n        int cuenta = 0;\n        for (int i = 0; i &lt; nValores; i++) {\n            if (valores[i] &lt; val)\n                cuenta++;\n        }\n        return cuenta;\n    }\n}\n\nclass DatosOrdenado {\n    public int cuentaMenores(int val) {\n        int n = valores.length;\n        int centro, inf = 0, sup = n - 1;\n        while (inf &lt;= sup) {\n            centro = (sup + inf) / 2;\n            if (valores[centro] == val)\n                return centro;\n            else if (val &lt; valores[centro]) {\n                sup = centro - 1;\n            } else {\n                inf = centro + 1;\n            }\n        }\n        return sup + 1;\n    }\n}\n\nclass BST {\n    private int cuentaMenores(Nodo actual, int val) {\n        int cuenta = 0;\n        if (actual == null)\n            return 0;\n        if (actual.valor == val)\n            return cuentaTodos(actual.izd);\n        if (actual.valor &lt; val)\n            cuenta = 1;\n        int nizd = cuentaMenores(actual.izd, val);\n        int nder = cuentaMenores(actual.der, val);\n        return cuenta + nizd + nder;\n    }\n\n    private int cuentaTodos(Nodo actual) {\n        if (actual == null)\n            return 0;\n        return 1 + cuentaTodos(actual.izd) + cuentaTodos(actual.der);\n    }\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Se pide: Considerando s\u00f3lo los m\u00e9todos cuentaMenores que acaba de implementar, cu\u00e1l de las tres clases seleccionar\u00eda para almacenar un conjunto de valores de tama\u00f1o fijo (M) donde se vayan a realizar frecuentes llamas al m\u00e9todo cuentaMenores.</li> </ul> Mostrar soluci\u00f3n <p>La clase Datos al tener los valores no ordenados nos obliga a recorrer todo el array, por lo tanto, la complejidad es proporcional al n\u00famero de valores almacenados: O(N)</p> <p>La Clase DatosOrdenado, tiene los valores ordenados de menor a mayor. Que los valores est\u00e9n ordenados permite utilizar b\u00fasqueda dicot\u00f3mica para localizar el valor, o en su defecto la posici\u00f3n donde deber\u00eda estar el valor que estamos buscando. Esta operaci\u00f3n tiene una complejidad O(log N). Una vez localizada la posici\u00f3n donde est\u00e1 o deber\u00eda estar el valor, todos los de la izquierda son menores que \u00e9l, por lo tanto, por lo que directamente conocemos el n\u00famero de valores menores que el que nos pasan como par\u00e1metro usando el \u00edndice de la posici\u00f3n del array donde est\u00e1 o deber\u00eda estar el valor pasado como par\u00e1metro. El resultado es un algoritmo de orden O(log N)</p> <p>En el caso del BST la estructura de BST ayuda a encontrar el valor en el \u00e1rbol con una complejidad O(log N),pero como lo que nos piden es el n\u00famero de valores menor que el valor pasado como par\u00e1metro, e incluso puede ocurrir que le propio valor no se encuentre en el \u00e1rbol, debemos recorrer casi todo el \u00e1rbol con una complejidad O(N).</p> <p>Por lo tanto, a la vista de este an\u00e1lisis, para nuestro problema concreto, la clase seleccionada es DatosOrdenado</p>","tags":["complejidad"]},{"location":"exams/2018/extra_ex03/","title":"Extra ex03","text":"<ul> <li>(a) (2 puntos) Explique brevemente cu\u00e1l es la diferencia entre interbloqueo (deadlock) y bloqueo vivo (livelock).</li> </ul> Mostrar soluci\u00f3n <p>En un interbloqueo hay varias hebras suspendidas, esperando conseguir recursos que tienen que liberar otras hebras, de tal manera que en conjunto se forma una cada de espera circular y ninguna hebra puede avanzar.</p> <p>En un bloqueo vivo hay igualmente varias hebras intentando conseguir recursos que tienen otras hebras. La diferencia es que cuando una hebra no puede conseguir todos sus recursos libera los que tiene y lo vuelve a intentar. Como consecuencia, las hebras implicadas est\u00e1n continuamente activas, aunque sin realizar ning\u00fan progreso.</p> <p>Por tanto, la diferencia fundamental es que en un interbloqueo las hebras est\u00e1s suspendidas y nunca se ejecutan, mientras que en un bloqueo vivo las hebras se ejecutan pero no progresan.</p> <p>Sea un sistema con 8 GB de memoria principal. Tenemos procesos concurrentes que solicitan memoria en bloques de 2 GB a medida que la necesitan para su ejecuci\u00f3n. Un proceso que ya tiene N bloques de memoria asignados puede solicitar m\u00e1s memoria, y si ya no hay memoria disponible espera a que la haya antes de continuar. La memoria asignada a un proceso se libera completamente cuando el proceso termina su ejecuci\u00f3n.</p> <ul> <li>(b) (3 puntos) Indique razonadamente si es posible que se d\u00e9 una situaci\u00f3n de interbloqueo (deadlock), en qu\u00e9 circunstancias podr\u00eda ocurrir y, si \u00e9ste es el caso, c\u00f3mo se podr\u00eda evitar.</li> </ul> Mostrar soluci\u00f3n <p>Los procesos acceden a un conjunto de recursos, los bloques de memoria, todos iguales, con una disponibilidad total limitada a 4 bloques en total. Se pueden producir interbloqueos si varios procesos intentan adquirir m\u00e1s memoria cuando ya est\u00e1 toda asignada a otros procesos que tambi\u00e9n necesitan m\u00e1s memoria.</p> <p>Por ejemplo, sup\u00f3ngase que hay dos procesos P y Q, que tiene asignados 2 bloques de memoria cada uno, es decir 4 en total, por lo que no hay bloques libres. Si ambos solicitan un bloque adicional cada uno, al no estar disponible se suspenden esperando que haya memoria libre. Para ello uno de los dos tendr\u00eda que terminar, liberando su memoria, pero al no poder avanzar ninguno de los dos se quedan suspendidos indefinidamente.</p> <p>Podemos comprobar que se cumplen las condiciones necesarias de Coffman: 1. Exclusi\u00f3n mutua: un bloque de memoria s\u00f3lo puede estar asignado a un proceso. 2. Tener y esperar: un proceso puede tener asignada memoria y esperar que conseguir m\u00e1s. 3. Sin expulsi\u00f3n: no se quita memoria a un proceso hasta que termina su ejecuci\u00f3n. 4. Espera circular, como pone de manifiesto el ejemplo anterior.</p> <p>Para evitar el interbloqueo la soluci\u00f3n m\u00e1s sencilla ser\u00eda obligar a que los procesos soliciten toda la memoria que pueden necesitar al iniciarse, invalidando la condici\u00f3n 2. N\u00f3tese que la soluci\u00f3n frecuentemente recomendada de asignar los recursos siempre en el mismo orden no es aplicable aqu\u00ed porque todos los bloques de memoria son iguales</p>","tags":["hebras"]},{"location":"exams/2018/extra_ex04/","title":"Extra ex04","text":"<p>La panader\u00eda Molinga S.L. quiere modernizar sus instalaciones robotizando su sistema de producci\u00f3n de pan. Para ello han encargado a los alumnos de ADSW que realicen parte del sistema.</p> <p>Se desea realizar dos monitores para gestionar la amasadora y el horno de la panader\u00eda, con acceso exclusivo por parte de varios robots (threads). Existen 3 tipos de robots en la panader\u00eda:     - Robots de almac\u00e9n, que meten ingredientes en la amasadora.     - Robots amasadores, que cuando tienen los ingredientes necesarios amasan y despu\u00e9s meten la masa en el horno.     - Robots horneadores, que cuando tienen las masas necesarias para llenar un horno, hornean el pan.</p> <p>La amasadora permitir\u00e1 introducir ingredientes a los r obots de almac\u00e9n y amasar a los robots amasadores. Para hacer una masa de pan hacen falta cuatro ingredientes: agua, harina, levadura y sal, en la proporci\u00f3n de 4, 3, 2 y 1 unidades. No se permitir\u00e1 a los robots de almac\u00e9n introducir m\u00e1s ingredientes si hay suficientes para hacer una masa, y de igual manera no se permitir\u00e1 a los robots amasadores amasar si no hay suficientes ingredientes para hacer una masa.</p> <p>El horno permitir\u00e1 introducir masas a los robots amasadores y hornear a los robots horneadores. Un horno tiene un tama\u00f1o concreto, que recibir\u00e1 como par\u00e1metro en el constructor, indicando el n\u00famero de masas que es capaz de hornear. Por motivos de eficiencia, los robots horneadores solo podr\u00e1n hornear si el horno est\u00e1 completamente lleno, y los robots amasadores solo podr\u00e1n meter masas si hay hueco en el horno.</p> <p>Estructura de clases de la panader\u00eda:</p> <p></p> <p>Ejemplo de programa con varios robots: <pre><code>public enum Ingrediente {\n    Agua, Harina, Levadura, Sal\n}\n\npublic static void main(String[] args) {\n    Amasadora amasadora = new Amasadora();\n    Horno horno = new Horno(5);\n    new RobotAlmacen(\"ED209\",amasadora).start();\n    new RobotAlmacen(\"T-800\",amasadora).start();\n    new RobotAlmacen(\"WALL-E\",amasadora).start();\n    new RobotAlmacen(\"Bumblebee\",amasadora).start();\n    new RobotAmasador(\"R2D2\",amasadora,horno).start();\n    new RobotAmasador(\"C3PO\",amasadora,horno).start();\n    new RobotAmasador(\"BB8\",amasadora,horno).start();\n    new RobotHorneador(\"Chappie\",horno).start();\n    new RobotHorneador(\"RoboCop\",horno).start();\n}\n</code></pre></p> <p>Ejemplo de c\u00f3digo del robor horneador: <pre><code>public class RobotHorneador extends Thread {\n    private Horno horno;\n    private String nombre;\n    private int panes = 0;\n    private Random random = new Random();\n\n    public RobotHorneador(String nombre, Horno horno) {\n        this.horno = horno;\n        this.nombre = nombre;\n        this.panes = 0;\n    }\n\n    public String getNombre() {return this.nombre;}\n\n    public void run() {\n        while (true) {\n            try {\n                int panesNuevos = this.horno.hornear();\n                this.panes = this.panes + panesNuevos;\n                Thread.sleep(random.nextInt(5000));\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre></p> <ul> <li>(a) (2,5 puntos) Desarrollar el monitor Amasadora</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Amasadora {\n    private int cantidadAgua;\n    private int cantidadHarina;\n    private int cantidadLevadura;\n    private int cantidadSal;\n\n    public synchronized void amasar() {\n        try {\n            while (!((this.cantidadAgua &gt;= 4) &amp;&amp; (this.cantidadHarina &gt;= 3) &amp;&amp;\n                   (this.cantidadLevadura &gt;= 2) &amp;&amp; (this.cantidadSal &gt;= 1))) {\n                wait();\n            }\n            this.cantidadAgua = this.cantidadAgua - 4;\n            this.cantidadHarina = this.cantidadHarina - 3;\n            this.cantidadLevadura = this.cantidadLevadura - 2;\n            this.cantidadSal = this.cantidadSal - 1;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n\n    public synchronized void meterIngredientes(Ingrediente ingrediente, int cantidad) {\n        try {\n            while (((this.cantidadAgua &gt;= 4) &amp;&amp; (this.cantidadHarina &gt;= 3) &amp;&amp;\n                   (this.cantidadLevadura &gt;= 2) &amp;&amp; (this.cantidadSal &gt;= 1))) {\n                wait();\n            }\n            switch (ingrediente) {\n                case Agua:\n                    this.cantidadAgua = this.cantidadAgua + cantidad;\n                    break;\n                case Harina:\n                    this.cantidadHarina = this.cantidadHarina + cantidad;\n                    break;\n                case Levadura:\n                    this.cantidadLevadura = this.cantidadLevadura + cantidad;\n                    break;\n                case Sal:\n                    this.cantidadSal = this.cantidadSal + cantidad;\n                    break;\n            }\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Desarrollar el monitor Horno</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Horno {\n    private int masas;\n    private int tama\u00f1o;\n\n    public Horno(int tama\u00f1o) {\n        this.tama\u00f1o = tama\u00f1o;\n    }\n\n    public synchronized int hornear(String nombre) {\n        try {\n            while (!(this.masas &gt;= this.tama\u00f1o)) {\n                wait();\n            }\n            this.masas = this.masas - this.tama\u00f1o;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n        return this.tama\u00f1o;\n    }\n\n    public synchronized void meterMasa(String nombre) {\n        try {\n            while (this.masas &gt;= this.tama\u00f1o) {\n                wait();\n            }\n            this.masas++;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n}\n</code></pre> <ul> <li>(c) (0,5 puntos) Proponer el m\u00e9todo run() del Robot Amasador</li> </ul> Mostrar soluci\u00f3n <pre><code>public void run() {\n    while (true) {\n        amasadora.amasar();\n        horno.meterMasa();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2018/extra_ex05/","title":"Extra ex05","text":"<p>Se desea ampliar el juego de la serpiente con un contador de las manzanas que ha comido la serpiente. Naturalmente, cuando la serpiente come una manzana, este contador debe aumentar en una unidad. Para a\u00f1adir dificultad al jugador, tambi\u00e9n puede perder manzanas de este contador por dos motivos:     - Si una bola choca con una manzana, el jugador pierde una unidad de su contador de manzanas comidas. El contador no puede nunca tener un valor inferior a cero como resultado de esta p\u00e9rdida, pero la p\u00e9rdida debe ejecutarse tan pronto como sea posible.     - Si la serpiente es golpeada en la cabeza por una bola, el contador de manzanas se reduce a la mitad, redondeando al entero inmediatamente inferior. Esto es, si el jugador ten\u00eda 7 puntos debe quedarse con 3.</p> <p>Siendo la clase manzanas: <pre><code>public class Manzanas\nimplements Screen.Thing {\n\n    /** Constructor. */\n    public Manzanas() {\n        font = new Font(\"SansSerif\", Font.BOLD, 18);\n        Game.getScreen().add(this);\n    }\n\n    /** La serpiente ha comido una manzana. */\n    public void appleEaten() {\n    }\n\n    /** Una bola ha destruido una manzana. */\n    public void appleDestroid() {\n    }\n\n    /** Una bola ha golpeado la cabeza de la serpiente. */\n    public void headShot() {\n    }\n\n    /** Se imprime en pantalla. */\n    @Override\n    public void paint(Graphics2D g) {\n        g.setFont(font);\n        g.setColor(Color.BLACK);\n        g.drawString(\"manzanas: \" + , 10, 30);\n    }\n}\n</code></pre></p> <p>Se pide que complete y modifique la clase monitor Manzanas como considere oportuno para obtener la funcionalidad descrita.</p> Mostrar soluci\u00f3n <pre><code>/**\n * Contador de manzanas.\n */\npublic class Manzanas\nimplements Screen.Thing {\n\n    private int manzanas;\n\n    public Manzanas() {\n        font = new Font(\"SansSerif\", Font.BOLD, 18);\n        manzanas = 0;\n        Game.getScreen().add(this);\n    }\n\n    public synchronized void appleEaten() {\n        manzanas++;\n        notifyAll();\n    }\n\n    public synchronized void appleDestroid() {\n        while (manzanas &lt;= 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        manzanas--;\n    }\n\n    public synchronized void headShot() {\n        manzanas = manzanas / 2;\n    }\n\n    @Override\n    public void paint(Graphics2D g) {\n        g.setFont(font);\n        g.setColor(Color.BLACK);\n        g.drawString(\"manzanas: \" + manzanas, 10, 30);\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2018/extra_ex06/","title":"Extra ex06","text":"<p>Para la aplicaci\u00f3n Android DaysUntil se desea a\u00f1adir la posibilidad de a\u00f1adir una descripci\u00f3n del evento introducido por el usuario. Esta informaci\u00f3n es opcional para la funcionalidad b\u00e1sica de la aplicaci\u00f3n. Sin embargo, en caso de existir una descripci\u00f3n, esta debe incluirse en la informaci\u00f3n pasada como intenci\u00f3n impl\u00edcita para la creaci\u00f3n de un evento en el calendario del usuario al pulsar un bot\u00f3n.</p> <p>Siendo el esqueleto del c\u00f3digo el siguiente: <pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    /** Devuelve el nombre del evento introducido por el usuario */\n    private String getEvento () { ... }\n\n    /** Devuelve la fecha del evento introducida por el usuario */\n    private Calendar getFecha () { ... }\n\n    /** \n     * A partir de un nombre y una fecha crea una intenci\u00f3n impl\u00edcita para la\n     * inserci\u00f3n de un nuevo evento en un calendario\n     */\n    private Intent eventIntent (String nombre, Calendar fecha) { ... }\n\n    public void crearEvento (View v) {\n        // Completar\n    }\n}\n</code></pre></p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout\n    \u2026 &gt;\n\n    &lt;LinearLayout \u2026 &gt;\n        &lt;EditText\n            android:id=\"@+id/eventName\"\n            \u2026 /&gt;\n        &lt;EditText\n            android:id=\"@+id/eventDate\"\n            \u2026 /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre> <ul> <li>(a) Complete el c\u00f3digo asociado a dicha funcionalidad, tanto en el c\u00f3digo java como en la definici\u00f3n del layout asociado a la actividad en cuesti\u00f3n. Considere implementados los m\u00e9todos getNombre y getFecha. Ha de implementar completamente cualquier otro m\u00e9todo auxiliar que considere necesario. Nota: la clave esperada por la intenci\u00f3n de crear un evento para la descripci\u00f3n del mismo es <code>CalendarContract.Events.DESCRIPTION</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    /** Devuelve el nombre del evento introducido por el usuario */\n    private String getEvento() { ... }\n\n    /** Devuelve la fecha del evento introducida por el usuario */\n    private Calendar getFecha() { ... }\n\n    /**\n     * A partir de un nombre y una fecha crea una intenci\u00f3n impl\u00edcita para la inserci\u00f3n de un\n     * nuevo evento en un calendario\n     */\n    private Intent eventIntent(String nombre, Calendar fecha) { ... }\n\n    public void crearEvento(View v) {\n        EditText eventDescription = eventDescription = (EditText)\n                findViewById(R.id.eventDescription);\n\n        Intent intent = eventIntent(getEvento(), getFecha());\n\n        if (eventDescription.getText().toString().length() &gt; 0) {\n            intent.putExtra(CalendarContract.Events.DESCRIPTION,\n                    eventDescription.getText().toString());\n        }\n\n        startActivity(intent);\n    }\n}\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout\n    \u2026 &gt;\n\n    &lt;LinearLayout \u2026 &gt;\n        &lt;EditText\n            android:id=\"@+id/eventName\"\n            \u2026 /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/eventDate\"\n            \u2026 /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/eventDescription\"\n            android:hint=\"Event description\"\n            \u2026 /&gt;\n\n        &lt;Button\n            android:text=\"Add event to calendar\"\n            android:onClick=\"crearEvento\"/&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>","tags":["android"]},{"location":"exams/2018/p1/","title":"Examen 2018 \u2014 Parcial 1","text":""},{"location":"exams/2018/p1/#problema-1","title":"Problema 1","text":"<p>En el ejercicio 1 de la asignatura se han recorrido los nodos de un grafo. Utilizando las clases Graph, Node y Link de ese mismo ejercicio, se pide codificar un nuevo m\u00e9todo de Graph: <pre><code>public List&lt;Node&gt; reachableNodes(Node src)\n</code></pre> que devuelve una lista de todos los nodos del grafo, obtenida recorriendo el grafo desde un nodo inicial (src). </p> <p>En el ejercicio 2 se ha propuesto usar la clase Map para reducir el tiempo de ejecuci\u00f3n de algunos m\u00e9todos. </p> <ul> <li>(a) (2 puntos) Use la clase Map en la soluci\u00f3n para mejorar el tiempo de ejecuci\u00f3n del m\u00e9todo reachableNodes(). Justifique la mejora que se consigue con su utilizaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n, basada en el recorrido que usa BFS, se muestra a continuaci\u00f3n. Se mejora la complejidad al usar un HahsSet para comprobar si ya hemos visitado un nodo. Si se usa otro algoritmo para componer la lista de nodos a visitar, se deber\u00eda usar una estrategia similar. <pre><code>List&lt;Node&gt; queue = new ArrayList&lt;Node&gt;();\nList&lt;Node&gt; list = new ArrayList&lt;Node&gt;();\n\nlist.add(src);\nqueue.add(src);\n\nSet&lt;Node&gt; visited = new HashSet&lt;&gt;();\nvisited.add(src);\n\nwhile (queue.size() &gt; 0) {\n    Node node = queue.remove(0);\n    for (Link link : graph.getLinks(node)) {\n        Node next = graph.getNode(link.getDst());\n        if (visited.contains(next))\n            continue;\n        list.add(next);\n        queue.add(next);\n        visited.add(next);\n    }\n}\n\nreturn list;\n</code></pre></p>"},{"location":"exams/2018/p1/#problema-2","title":"Problema 2","text":"<p>Una ordenaci\u00f3n topol\u00f3gica (topological sort) de un grafo dirigido G es una lista con todos los nodos de G tal que no existe ning\u00fan enlace hacia atr\u00e1s. </p> <p></p> <p>Ejemplos     - correcto: [calcetines, camisa, pantal\u00f3n, jersey, cintur\u00f3n, zapatos]     - correcto: [pantal\u00f3n, camisa, jersey, calcetines, zapatos, cintur\u00f3n]     - correcto: [pantal\u00f3n, calcetines, zapatos, camisa, jersey, cintur\u00f3n]     - incorrecto: [pantal\u00f3n, cintur\u00f3n, calcetines, zapatos, CAMISA, jersey]</p> <p>La \u00faltima ordenaci\u00f3n es incorrecta porque camisa deber\u00eda estar antes que cintur\u00f3n.</p> <p>Suponga que tenemos un grafo de N nodos y una media de 5 enlaces por nodo. </p> <ul> <li>(a) (2,5 puntos) Haga suposiciones razonadas sobre la complejidad de las llamadas a los m\u00e9todos de Graph, en funci\u00f3n del tama\u00f1o N del grafo.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Complejidad <code>graph.getNodes()</code> O(1) si se ha implementado con una <code>List</code> que se va cargando cuando se a\u00f1aden nodos al grafo (lo habitual en el ejercicio 1 entregado) O(n) si se calcula al llamar a la funci\u00f3n agregando las tablas de nodos con enlaces (frecuente en el ejercicio 2 entregado) <code>graph.getNode(String)</code> O(n) si hay que recorrer la lista hasta encontrar el nodo (lo habitual en el ejercicio 1 entregado) O(1) si hay un diccionario que asocia el nombre al nodo (lo habitual en el ejercicio 2 entregado) <code>graph.getLinks(Node)</code> O(n) si hay que recorrer la lista hasta encontrar el nodo (lo habitual en el ejercicio 1 entregado) O(1) si hay un diccionario que asocia el nodo a los enlaces (lo habitual en el ejercicio 2 entregado) <ul> <li>(b) (2,5 puntos) Calcule la complejidad del m\u00e9todo sort() en funci\u00f3n de N.</li> </ul> Mostrar soluci\u00f3n <p>Partimos de la implementaci\u00f3n del algoritmo proporcionada con el enunciado. <pre><code>24    public List&lt;Node&gt; sort() {\n25       List&lt;Node&gt; L = new ArrayList&lt;&gt;();\n26       List&lt;Node&gt; S = new ArrayList&lt;&gt;();\n27\n28       List&lt;Node&gt; nodeList = graph.getNodes();\n29        for (Node n : nodeList) {\n30            if (inLinks.get(n).size() == 0)\n31                S.add(n);\n32        }\n33\n34        while (S.size() &gt; 0) {\n35            int i = (int) (Math.random() * S.size());\n36            Node n = S.remove(i);\n37            L.add(n);\n38            List&lt;Link&gt; linkList = graph.getLinks(n);\n39            for (Link link : linkList) {\n40                Node dst = graph.getNode(link.getDst());\n41                List&lt;Link&gt; links = inLinks.get(dst);\n42                links.remove(link);\n43                if (links.size() == 0)\n44                    S.add(dst);\n45            }\n46        }\n47\n48        return L;\n49    }\n</code></pre></p> <p>Si todas las operaciones en Graph se optimizan a O(1), la complejidad del conjunto viene condicionada por el coste de extraer un elemento aleatorio de S (en la l\u00ednea 36).</p> <p>Se podr\u00eda prescindir de la aleatoriedad extrayendo el \u00faltimo elemento de la lista, que es una operaci\u00f3n O(1). <pre><code>Node n = S.remove(S.size()-1)\n</code></pre> Y el algoritmo quedar\u00eda O(n).</p>"},{"location":"exams/2018/p1_ex01/","title":"P1 ex01","text":"<p>En el ejercicio 1 de la asignatura se han recorrido los nodos de un grafo. Utilizando las clases Graph, Node y Link de ese mismo ejercicio, se pide codificar un nuevo m\u00e9todo de Graph: <pre><code>public List&lt;Node&gt; reachableNodes(Node src)\n</code></pre> que devuelve una lista de todos los nodos del grafo, obtenida recorriendo el grafo desde un nodo inicial (src). </p> <p>En el ejercicio 2 se ha propuesto usar la clase Map para reducir el tiempo de ejecuci\u00f3n de algunos m\u00e9todos. </p> <ul> <li>(a) (2 puntos) Use la clase Map en la soluci\u00f3n para mejorar el tiempo de ejecuci\u00f3n del m\u00e9todo reachableNodes(). Justifique la mejora que se consigue con su utilizaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n, basada en el recorrido que usa BFS, se muestra a continuaci\u00f3n. Se mejora la complejidad al usar un HahsSet para comprobar si ya hemos visitado un nodo. Si se usa otro algoritmo para componer la lista de nodos a visitar, se deber\u00eda usar una estrategia similar. <pre><code>List&lt;Node&gt; queue = new ArrayList&lt;Node&gt;();\nList&lt;Node&gt; list = new ArrayList&lt;Node&gt;();\n\nlist.add(src);\nqueue.add(src);\n\nSet&lt;Node&gt; visited = new HashSet&lt;&gt;();\nvisited.add(src);\n\nwhile (queue.size() &gt; 0) {\n    Node node = queue.remove(0);\n    for (Link link : graph.getLinks(node)) {\n        Node next = graph.getNode(link.getDst());\n        if (visited.contains(next))\n            continue;\n        list.add(next);\n        queue.add(next);\n        visited.add(next);\n    }\n}\n\nreturn list;\n</code></pre></p>","tags":["grafos"]},{"location":"exams/2018/p1_ex02/","title":"P1 ex02","text":"<p>Una ordenaci\u00f3n topol\u00f3gica (topological sort) de un grafo dirigido G es una lista con todos los nodos de G tal que no existe ning\u00fan enlace hacia atr\u00e1s. </p> <p></p> <p>Ejemplos     - correcto: [calcetines, camisa, pantal\u00f3n, jersey, cintur\u00f3n, zapatos]     - correcto: [pantal\u00f3n, camisa, jersey, calcetines, zapatos, cintur\u00f3n]     - correcto: [pantal\u00f3n, calcetines, zapatos, camisa, jersey, cintur\u00f3n]     - incorrecto: [pantal\u00f3n, cintur\u00f3n, calcetines, zapatos, CAMISA, jersey]</p> <p>La \u00faltima ordenaci\u00f3n es incorrecta porque camisa deber\u00eda estar antes que cintur\u00f3n.</p> <p>Suponga que tenemos un grafo de N nodos y una media de 5 enlaces por nodo. </p> <ul> <li>(a) (2,5 puntos) Haga suposiciones razonadas sobre la complejidad de las llamadas a los m\u00e9todos de Graph, en funci\u00f3n del tama\u00f1o N del grafo.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Complejidad <code>graph.getNodes()</code> O(1) si se ha implementado con una <code>List</code> que se va cargando cuando se a\u00f1aden nodos al grafo (lo habitual en el ejercicio 1 entregado) O(n) si se calcula al llamar a la funci\u00f3n agregando las tablas de nodos con enlaces (frecuente en el ejercicio 2 entregado) <code>graph.getNode(String)</code> O(n) si hay que recorrer la lista hasta encontrar el nodo (lo habitual en el ejercicio 1 entregado) O(1) si hay un diccionario que asocia el nombre al nodo (lo habitual en el ejercicio 2 entregado) <code>graph.getLinks(Node)</code> O(n) si hay que recorrer la lista hasta encontrar el nodo (lo habitual en el ejercicio 1 entregado) O(1) si hay un diccionario que asocia el nodo a los enlaces (lo habitual en el ejercicio 2 entregado) <ul> <li>(b) (2,5 puntos) Calcule la complejidad del m\u00e9todo sort() en funci\u00f3n de N.</li> </ul> Mostrar soluci\u00f3n <p>Partimos de la implementaci\u00f3n del algoritmo proporcionada con el enunciado. <pre><code>24    public List&lt;Node&gt; sort() {\n25       List&lt;Node&gt; L = new ArrayList&lt;&gt;();\n26       List&lt;Node&gt; S = new ArrayList&lt;&gt;();\n27\n28       List&lt;Node&gt; nodeList = graph.getNodes();\n29        for (Node n : nodeList) {\n30            if (inLinks.get(n).size() == 0)\n31                S.add(n);\n32        }\n33\n34        while (S.size() &gt; 0) {\n35            int i = (int) (Math.random() * S.size());\n36            Node n = S.remove(i);\n37            L.add(n);\n38            List&lt;Link&gt; linkList = graph.getLinks(n);\n39            for (Link link : linkList) {\n40                Node dst = graph.getNode(link.getDst());\n41                List&lt;Link&gt; links = inLinks.get(dst);\n42                links.remove(link);\n43                if (links.size() == 0)\n44                    S.add(dst);\n45            }\n46        }\n47\n48        return L;\n49    }\n</code></pre></p> <p>Si todas las operaciones en Graph se optimizan a O(1), la complejidad del conjunto viene condicionada por el coste de extraer un elemento aleatorio de S (en la l\u00ednea 36).</p> <p>Se podr\u00eda prescindir de la aleatoriedad extrayendo el \u00faltimo elemento de la lista, que es una operaci\u00f3n O(1). <pre><code>Node n = S.remove(S.size()-1)\n</code></pre> Y el algoritmo quedar\u00eda O(n).</p>","tags":["grafos"]},{"location":"exams/2018/p1r/","title":"Examen 2018 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2018/p1r/#problema-1","title":"Problema 1","text":"<p>Dado un conjunto P de puntos en un plano de 2 dimensiones, necesitamos calcular el subconjunto de P tal que una banda el\u00e1stica alrededor de ellos no deja a ning\u00fan punto fuera.</p> <p>En geometr\u00eda, a este subconjunto se le denomina envolvente convexa (convex hull). Una de sus propiedades es que si enumeramos los puntos seg\u00fan las agujas del reloj (L1, L2, \u2026, Ln) todos los pares de segmentos consecutivos van girando hacia la derecha. Por ejemplo, L1-L2 est\u00e1 girado a la derecha en comparaci\u00f3n con L0-L1.</p> <p>En Internet hemos encontrado este algoritmo (Andrew, 1979) que divide el problema en 2 partes. Calcula la envolvente superior, luego la inferior, y las une.</p> <p>El algoritmo es como sigue para un conjunto de N puntos:     - 1. Se ordenan los puntos P en orden creciente de coordenada X y, si tienen el mismo X, en orden creciente de coordenada Y.     - 2. Se prepara una lista UPPER con los 2 primeros puntos, L0 y L1     - 3. Para i entre 2 y N,         - I. se a\u00f1ade Li a la lista UPPER         - II. mientras los 3 \u00faltimos puntos en la lista UPPER hagan un giro a la izquierda, se elimina el punto intermedio de esos 3     - 4. Se prepara una lista LOWER con los 2 \u00faltimos puntos L(n-1), L(n-2)     - 5. Para i entre N-3 y 0, descendiendo,         - I. se a\u00f1ade Li a la lista LOWER         - II. mientras los 3 \u00faltimos puntos en la lista LOWER hagan un giro a la izquierda, se elimina el punto intermedio de esos 3     - 6. Se concatenan las listas UPPER y LOWER prescindiendo de los puntos finales de cada una</p> <p>Suponga que disponemos de un m\u00e9todo auxiliar que, dados 3 puntos, nos dice si los segmentos AB y BC hacen un giro a la izquierda:  <pre><code>boolean giroIzquierda(Punto A, Punto B, Punto C)\n</code></pre></p> <ul> <li>(a) (5 puntos) Calcular la complejidad del algoritmo en funci\u00f3n del tama\u00f1o N del conjunto de puntos P.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo auxiliar, giroIzquierda(), trabaja sobre 3 puntos A, B y C y es por tanto independiente del tama\u00f1o N del conjunto de puntos. Su complejidad es O(1).</p> <p>El algoritmo principal ordena una lista de N puntos. La comparaci\u00f3n entre 2 puntos A y B es independiente del n\u00famero de puntos, y por tanto es de complejidad O(1). El algoritmo de ordenaci\u00f3n introduce su propia complejidad que se puede estimar en O(n log n) si escogemos un buen algoritmo como puede ser el merge sort.</p> <p>El algoritmo global:</p> Paso Descripci\u00f3n Complejidad 1 Ordenaci\u00f3n O(n log n) 2 new list UPPER O(1) 3 bucle 2..N O(n) (*) 4 new list LOWER O(1) 5 bucle 2..N O(n) (*) 6 concatena O(n) TOTAL O(n log n) <p>(*) En principio parece un bucle de N veces sobre una lista que va creciendo hasta N; resultando en N^2. Pero ocurre que cada pasada por el bucle elimina un elemento de la lista y o la lista es larga y el while termina pronto, o al rev\u00e9s. En resumen, que por una raz\u00f3n u otra no pasamos de O(n). En otras palabras, la combinaci\u00f3n FOR-WHILE recorre exactamente N puntos, bien conservando cada punto o elimin\u00e1ndolo.</p> <p>Por otra parte, la operaci\u00f3n remove(pen\u00faltimo) es independiente del tama\u00f1o de la lista y, por tanto, de O(1)</p> <p>Codificaci\u00f3n en Java: <pre><code>List&lt;Punto&gt; scan(List&lt;Punto&gt; puntos) {\n    if (puntos.size() &lt; 3) return null;\n\n    puntos.sort(new Comparator&lt;Punto&gt;() {\n        @Override\n        public int compare(Punto p1, Punto p2) {\n            if (p1.x == p2.x)\n                return p1.y - p2.y;\n            return p1.x - p2.x;\n        }\n    });\n\n    List&lt;Punto&gt; upper = new ArrayList&lt;&gt;();\n    upper.add(puntos.get(0));\n    upper.add(puntos.get(1));\n\n    for (int i = 2; i &lt; puntos.size(); i++) {\n        upper.add(puntos.get(i));\n        while (true) {\n            int size = upper.size();\n            if (size &lt; 3)\n                break;\n            Punto A = upper.get(size - 3);\n            Punto B = upper.get(size - 2);\n            Punto C = upper.get(size - 1);\n            if (!isGiroIzquierda(A, B, C))\n                break;\n            upper.remove(size - 2);\n        }\n    }\n\n    int n = puntos.size();\n    List&lt;Punto&gt; lower = new ArrayList&lt;&gt;();\n    lower.add(puntos.get(n - 1));\n    lower.add(puntos.get(n - 2));\n\n    for (int i = n - 3; i &gt;= 0; i--) {\n        lower.add(puntos.get(i));\n        while (true) {\n            int size = lower.size();\n            if (size &lt; 3)\n                break;\n            Punto A = lower.get(size - 3);\n            Punto B = lower.get(size - 2);\n            Punto C = lower.get(size - 1);\n            if (!isGiroIzquierda(A, B, C))\n                break;\n            lower.remove(size - 2);\n        }\n    }\n\n    List&lt;Punto&gt; hull = new ArrayList&lt;&gt;();\n    hull.addAll(upper);\n    hull.remove(hull.size() - 1);\n    hull.addAll(lower);\n    hull.remove(hull.size() - 1);\n\n    return hull;\n}\n\nprivate boolean isGiroIzquierda(Punto A, Punto B, Punto C) {\n    int x1 = A.getX();\n    int y1 = A.getY();\n    int x2 = B.getX();\n    int y2 = B.getY();\n    int x3 = C.getX();\n    int y3 = C.getY();\n\n    int val1 = (x2 - x1) * (y3 - y1);\n    int val2 = (y2 - y1) * (x3 - x1);\n\n    return val1 &gt; val2;\n}\n</code></pre></p>"},{"location":"exams/2018/p1r/#problema-2","title":"Problema 2","text":"<p>Se dispone de la clase Graph, con los m\u00e9todos que se indican a continuaci\u00f3n: <pre><code>public void addNode(Node)\npublic vois addLink(Link)\npublic void addLink2D(String, String, int)\npublic List&lt;Node&gt; getNodes()\npublic Node getNode(String)\npublic List&lt;Link&gt; getLinks()\npublic List&lt;Link&gt; getLinks(Node)\npublic Link getLink(Node, Node)\npublic int getWeight(List&lt;Node&gt;)\n</code></pre></p> <p>Un algoritmo alternativo a BFS y Dijkstra para recorrer un grafo es el algoritmo DFS (Depth First Search). El recorrido en profundidad se produce de tal forma que partiendo de un nodo se procesa el primero de los nodos alcanzables desde \u00e9l mediante un Link, despu\u00e9s el segundo y as\u00ed sucesivamente todos los nodos que se pueden alcanzar con un solo Link. Para procesar cada uno de los nodos se utiliza el mismo procedimiento, siempre teniendo en cuenta que, al ser un grafo, no pasemos dos veces por el mismo nodo. En definitiva, se trata del recorrido en pre-orden usado para los \u00e1rboles binarios BST.</p> <p>Se muestra a continuaci\u00f3n un ejemplo del orden de recorrido de DFS sobre un \u00e1rbol para ver si desde el nodo \u201cA\u201d se puede alcanzar el nodo destino \u201cJ\u201d:</p> <p></p> <p>Una de las formas de implementar DFS en un grafo es mediante un m\u00e9todo recursivo, cuyo seudoc\u00f3digo se proporciona a continuaci\u00f3n:</p> <pre><code>1 m\u00e9todo DFS(origen):\n2   marcamos origen como visitado\n3   para cada v\u00e9rtice v adyacente a origen en el Grafo:\n4     si v no ha sido visitado:\n5       marcamos como visitado v\n6       llamamos recursivamente DFS(v)\n</code></pre> <ul> <li>(a) (5 puntos) Codificar el algoritmo ListaNodos que devuelve todos los nodos alcanzables desde un determinado nodo src. Los nodos alcanzables desde un nodo son todos aquellos a los que se puede llegar desde ese nodo siguiendo una secuencia de enlaces (Link) definidos en el grafo. En el caso del grafo del ejemplo anterior, desde el nodo C ser\u00edan alcanzables:  y desde el nodo D: . Tenga en cuenta que en un caso real pudiera haber bucles al tratarse de un grafo. Se valorar\u00e1 con 2 puntos el uso de la clase Set para aumentar la velocidad del m\u00e9todo ListaNodos, si adem\u00e1s se justifica adecuadamente la mejora producida por su utilizaci\u00f3n. Mostrar soluci\u00f3n <pre><code>private List&lt;Node&gt; getNodesRec (Node src) {\n    // Creamos las variables necesaria\n    Set&lt;Node&gt; visited = new HashSet &lt;Node&gt;();\n\n    // Si el nodo no ha sido visitado, lo marcamos como visitado, lo a\u00f1adimos a la lista\n    List &lt;Node&gt; list = new ArrayList &lt;Node&gt;();\n    visited.add(src);\n    list.add(src);\n\n    // Llamada al m\u00e9todo recursivo\n    List&lt;Node&gt; alcanzables = getNodesRec (src, visited);\n    list.addAll(alcanzables);\n\n    return list;\n}\n\nprivate List&lt;Node&gt; getNodesRec (Node src, Set&lt;Node&gt; visited) {\n    List &lt;Node&gt; list = new ArrayList &lt;Node&gt;();\n\n    // Pasamos a recorrer los nodos desde los que se puede llegar con un Link desde este nodo\n    for (Link link : graph.getLinks(src)) {\n        Node next = graph.getNode(link.getDst());\n\n        // Si el nodo ya ha sido visitado no hacemos nada\n        if (visited.contains(next))\n            continue;\n\n        // Si el nodo no ha sido visitado, lo marcamos como visitado, lo a\u00f1adimos a la lista\n        visited.add(next);\n        list.add(next);\n\n        List &lt;Node&gt; res = getNodesRec(next, visited);\n\n        // A\u00f1adimos a la lista de nodos alcanzables los nodos que devuelve getNodesRec al recorrer el nodo next\n        list.addAll(res);\n    }\n\n    return list;\n}\n</code></pre> <p>El uso de Set para controlar la lista de visitados permite mejorar el algoritmo frente a List, ya que la b\u00fasqueda en listas no est\u00e1 tan optimizada como en Set.</p>"},{"location":"exams/2018/p1r_ex01/","title":"P1r ex01","text":"<p>Dado un conjunto P de puntos en un plano de 2 dimensiones, necesitamos calcular el subconjunto de P tal que una banda el\u00e1stica alrededor de ellos no deja a ning\u00fan punto fuera.</p> <p>En geometr\u00eda, a este subconjunto se le denomina envolvente convexa (convex hull). Una de sus propiedades es que si enumeramos los puntos seg\u00fan las agujas del reloj (L1, L2, \u2026, Ln) todos los pares de segmentos consecutivos van girando hacia la derecha. Por ejemplo, L1-L2 est\u00e1 girado a la derecha en comparaci\u00f3n con L0-L1.</p> <p>En Internet hemos encontrado este algoritmo (Andrew, 1979) que divide el problema en 2 partes. Calcula la envolvente superior, luego la inferior, y las une.</p> <p>El algoritmo es como sigue para un conjunto de N puntos:     - 1. Se ordenan los puntos P en orden creciente de coordenada X y, si tienen el mismo X, en orden creciente de coordenada Y.     - 2. Se prepara una lista UPPER con los 2 primeros puntos, L0 y L1     - 3. Para i entre 2 y N,         - I. se a\u00f1ade Li a la lista UPPER         - II. mientras los 3 \u00faltimos puntos en la lista UPPER hagan un giro a la izquierda, se elimina el punto intermedio de esos 3     - 4. Se prepara una lista LOWER con los 2 \u00faltimos puntos L(n-1), L(n-2)     - 5. Para i entre N-3 y 0, descendiendo,         - I. se a\u00f1ade Li a la lista LOWER         - II. mientras los 3 \u00faltimos puntos en la lista LOWER hagan un giro a la izquierda, se elimina el punto intermedio de esos 3     - 6. Se concatenan las listas UPPER y LOWER prescindiendo de los puntos finales de cada una</p> <p>Suponga que disponemos de un m\u00e9todo auxiliar que, dados 3 puntos, nos dice si los segmentos AB y BC hacen un giro a la izquierda:  <pre><code>boolean giroIzquierda(Punto A, Punto B, Punto C)\n</code></pre></p> <ul> <li>(a) (5 puntos) Calcular la complejidad del algoritmo en funci\u00f3n del tama\u00f1o N del conjunto de puntos P.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo auxiliar, giroIzquierda(), trabaja sobre 3 puntos A, B y C y es por tanto independiente del tama\u00f1o N del conjunto de puntos. Su complejidad es O(1).</p> <p>El algoritmo principal ordena una lista de N puntos. La comparaci\u00f3n entre 2 puntos A y B es independiente del n\u00famero de puntos, y por tanto es de complejidad O(1). El algoritmo de ordenaci\u00f3n introduce su propia complejidad que se puede estimar en O(n log n) si escogemos un buen algoritmo como puede ser el merge sort.</p> <p>El algoritmo global:</p> Paso Descripci\u00f3n Complejidad 1 Ordenaci\u00f3n O(n log n) 2 new list UPPER O(1) 3 bucle 2..N O(n) (*) 4 new list LOWER O(1) 5 bucle 2..N O(n) (*) 6 concatena O(n) TOTAL O(n log n) <p>(*) En principio parece un bucle de N veces sobre una lista que va creciendo hasta N; resultando en N^2. Pero ocurre que cada pasada por el bucle elimina un elemento de la lista y o la lista es larga y el while termina pronto, o al rev\u00e9s. En resumen, que por una raz\u00f3n u otra no pasamos de O(n). En otras palabras, la combinaci\u00f3n FOR-WHILE recorre exactamente N puntos, bien conservando cada punto o elimin\u00e1ndolo.</p> <p>Por otra parte, la operaci\u00f3n remove(pen\u00faltimo) es independiente del tama\u00f1o de la lista y, por tanto, de O(1)</p> <p>Codificaci\u00f3n en Java: <pre><code>List&lt;Punto&gt; scan(List&lt;Punto&gt; puntos) {\n    if (puntos.size() &lt; 3) return null;\n\n    puntos.sort(new Comparator&lt;Punto&gt;() {\n        @Override\n        public int compare(Punto p1, Punto p2) {\n            if (p1.x == p2.x)\n                return p1.y - p2.y;\n            return p1.x - p2.x;\n        }\n    });\n\n    List&lt;Punto&gt; upper = new ArrayList&lt;&gt;();\n    upper.add(puntos.get(0));\n    upper.add(puntos.get(1));\n\n    for (int i = 2; i &lt; puntos.size(); i++) {\n        upper.add(puntos.get(i));\n        while (true) {\n            int size = upper.size();\n            if (size &lt; 3)\n                break;\n            Punto A = upper.get(size - 3);\n            Punto B = upper.get(size - 2);\n            Punto C = upper.get(size - 1);\n            if (!isGiroIzquierda(A, B, C))\n                break;\n            upper.remove(size - 2);\n        }\n    }\n\n    int n = puntos.size();\n    List&lt;Punto&gt; lower = new ArrayList&lt;&gt;();\n    lower.add(puntos.get(n - 1));\n    lower.add(puntos.get(n - 2));\n\n    for (int i = n - 3; i &gt;= 0; i--) {\n        lower.add(puntos.get(i));\n        while (true) {\n            int size = lower.size();\n            if (size &lt; 3)\n                break;\n            Punto A = lower.get(size - 3);\n            Punto B = lower.get(size - 2);\n            Punto C = lower.get(size - 1);\n            if (!isGiroIzquierda(A, B, C))\n                break;\n            lower.remove(size - 2);\n        }\n    }\n\n    List&lt;Punto&gt; hull = new ArrayList&lt;&gt;();\n    hull.addAll(upper);\n    hull.remove(hull.size() - 1);\n    hull.addAll(lower);\n    hull.remove(hull.size() - 1);\n\n    return hull;\n}\n\nprivate boolean isGiroIzquierda(Punto A, Punto B, Punto C) {\n    int x1 = A.getX();\n    int y1 = A.getY();\n    int x2 = B.getX();\n    int y2 = B.getY();\n    int x3 = C.getX();\n    int y3 = C.getY();\n\n    int val1 = (x2 - x1) * (y3 - y1);\n    int val2 = (y2 - y1) * (x3 - x1);\n\n    return val1 &gt; val2;\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2018/p1r_ex02/","title":"P1r ex02","text":"<p>Se dispone de la clase Graph, con los m\u00e9todos que se indican a continuaci\u00f3n: <pre><code>public void addNode(Node)\npublic vois addLink(Link)\npublic void addLink2D(String, String, int)\npublic List&lt;Node&gt; getNodes()\npublic Node getNode(String)\npublic List&lt;Link&gt; getLinks()\npublic List&lt;Link&gt; getLinks(Node)\npublic Link getLink(Node, Node)\npublic int getWeight(List&lt;Node&gt;)\n</code></pre></p> <p>Un algoritmo alternativo a BFS y Dijkstra para recorrer un grafo es el algoritmo DFS (Depth First Search). El recorrido en profundidad se produce de tal forma que partiendo de un nodo se procesa el primero de los nodos alcanzables desde \u00e9l mediante un Link, despu\u00e9s el segundo y as\u00ed sucesivamente todos los nodos que se pueden alcanzar con un solo Link. Para procesar cada uno de los nodos se utiliza el mismo procedimiento, siempre teniendo en cuenta que, al ser un grafo, no pasemos dos veces por el mismo nodo. En definitiva, se trata del recorrido en pre-orden usado para los \u00e1rboles binarios BST.</p> <p>Se muestra a continuaci\u00f3n un ejemplo del orden de recorrido de DFS sobre un \u00e1rbol para ver si desde el nodo \u201cA\u201d se puede alcanzar el nodo destino \u201cJ\u201d:</p> <p></p> <p>Una de las formas de implementar DFS en un grafo es mediante un m\u00e9todo recursivo, cuyo seudoc\u00f3digo se proporciona a continuaci\u00f3n:</p> <pre><code>1 m\u00e9todo DFS(origen):\n2   marcamos origen como visitado\n3   para cada v\u00e9rtice v adyacente a origen en el Grafo:\n4     si v no ha sido visitado:\n5       marcamos como visitado v\n6       llamamos recursivamente DFS(v)\n</code></pre> <ul> <li>(a) (5 puntos) Codificar el algoritmo ListaNodos que devuelve todos los nodos alcanzables desde un determinado nodo src. Los nodos alcanzables desde un nodo son todos aquellos a los que se puede llegar desde ese nodo siguiendo una secuencia de enlaces (Link) definidos en el grafo. En el caso del grafo del ejemplo anterior, desde el nodo C ser\u00edan alcanzables:  y desde el nodo D: . Tenga en cuenta que en un caso real pudiera haber bucles al tratarse de un grafo. Se valorar\u00e1 con 2 puntos el uso de la clase Set para aumentar la velocidad del m\u00e9todo ListaNodos, si adem\u00e1s se justifica adecuadamente la mejora producida por su utilizaci\u00f3n. Mostrar soluci\u00f3n <pre><code>private List&lt;Node&gt; getNodesRec (Node src) {\n    // Creamos las variables necesaria\n    Set&lt;Node&gt; visited = new HashSet &lt;Node&gt;();\n\n    // Si el nodo no ha sido visitado, lo marcamos como visitado, lo a\u00f1adimos a la lista\n    List &lt;Node&gt; list = new ArrayList &lt;Node&gt;();\n    visited.add(src);\n    list.add(src);\n\n    // Llamada al m\u00e9todo recursivo\n    List&lt;Node&gt; alcanzables = getNodesRec (src, visited);\n    list.addAll(alcanzables);\n\n    return list;\n}\n\nprivate List&lt;Node&gt; getNodesRec (Node src, Set&lt;Node&gt; visited) {\n    List &lt;Node&gt; list = new ArrayList &lt;Node&gt;();\n\n    // Pasamos a recorrer los nodos desde los que se puede llegar con un Link desde este nodo\n    for (Link link : graph.getLinks(src)) {\n        Node next = graph.getNode(link.getDst());\n\n        // Si el nodo ya ha sido visitado no hacemos nada\n        if (visited.contains(next))\n            continue;\n\n        // Si el nodo no ha sido visitado, lo marcamos como visitado, lo a\u00f1adimos a la lista\n        visited.add(next);\n        list.add(next);\n\n        List &lt;Node&gt; res = getNodesRec(next, visited);\n\n        // A\u00f1adimos a la lista de nodos alcanzables los nodos que devuelve getNodesRec al recorrer el nodo next\n        list.addAll(res);\n    }\n\n    return list;\n}\n</code></pre> <p>El uso de Set para controlar la lista de visitados permite mejorar el algoritmo frente a List, ya que la b\u00fasqueda en listas no est\u00e1 tan optimizada como en Set.</p>","tags":["grafos"]},{"location":"exams/2018/p2/","title":"Examen 2018 \u2014 Parcial 2","text":""},{"location":"exams/2018/p2/#problema-1","title":"Problema 1","text":"<p>Se desea realizar un monitor para gestionar un tipo de recursos con acceso exclusivo por parte de varias hebras (threads). Para ello se parte del esquema de la clase Recurso: <pre><code>public class Recurso {\n    private int n = 0;\n    // n\u00famero de usuarios del recurso\n\n    public ... void adquirir() {\n        ...\n        // assert n == 1;\n    }\n\n    public ... void liberar() {\n        ...\n        // assert n == 0\n    }\n}\n</code></pre></p> <ul> <li>(a) (2,5 puntos) Complete el c\u00f3digo de la clase Recurso de forma que se cumplan las aserciones que figuran como comentarios.</li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n de la clase Recurso es: <pre><code>public class Recurso {\n    private int n = 0; // n\u00famero de usuarios del recurso\n\n    public synchronized void adquirir() {\n        while (n &gt; 0)\n            try {\n                wait();\n            } catch (ExceptionIgnored) {}\n        n++;\n        assert n == 1;\n    }\n\n    public class Recurso {\n        private int n = 0;\n        // n\u00famero de usuarios del recurso\n\n        public ... void adquirir() {\n            ...\n            // assert n == 1;\n        }\n\n        public ... void liberar() {\n            ...\n            // assert n == 0\n        }\n    }\n\n    public synchronized void liberar() {\n        n--;\n        notifyAll();\n        assert n == 0;\n    }\n}\n</code></pre></p> <p>Se crean tres hebras, T1, T2 y T3, cuyos m\u00e9todos run incluyen los siguientes accesos a dos objetos, R1 y R2, de la clase Recurso: <pre><code>- T1: R1.adquirir(); R1.liberar(); ... R2.adquirir(); R2.liberar();\n- T2: R2.adquirir(); R1.adquirir(); ... R1.liberar(); R2.liberar();\n- T3: R1.adquirir(); R2.adquirir(); ... R2.liberar(); R1.liberar();\n</code></pre></p> <ul> <li>(b) (2,5 puntos) Analice el comportamiento de este programa, indicando si se pueden producir interbloqueos entre todas o algunas de las hebras. Justifique la respuesta mediante las condiciones de interbloqueo explicadas en clase. NOTA : no hace falta implementar las hebras T1, T2, T3, ni los m\u00e9todos run() respectivos.</li> </ul> Mostrar soluci\u00f3n <p>Examinamos las condiciones de Coffman:     - Exclusi\u00f3n mutua: las tres hebras acceden a los recursos de forma mutuamente exclusiva, por medio de los m\u00e9todos adquirir() y liberar(). Por tanto esta condici\u00f3n se cumple para las tres hebras.     - Tener y esperar: La hebra T1 s\u00f3lo adquiere un recurso a la vez. T2 accede a R2 y luego a R1, y la hebra T3 accede a R1 y luego R2. Por tanto, la condici\u00f3n se cumple para T2 y T3, pero no para T1.     - Sin expulsi\u00f3n: La implementaci\u00f3n de los m\u00e9todos adquirir() y liberar() no permite expulsar a una hebra de un recurso ya adquirido. Por tanto, esta condici\u00b4n se cumple para todas las hebras.     - Espera circular: Se puede producir una espera circular entre T2 y T3, como se muestra en el siguiente esquema:</p> <p></p>"},{"location":"exams/2018/p2/#problema-2","title":"Problema 2","text":"<p>Se desea realizar un monitor para gestionar paso de peatones en una carretera con acceso exclusivo por parte de varias hebras (threads). Hay dos tipos de hebras, los coches y los peatones.</p> <p>Los peatones y los coches ir\u00e1n apareciendo aleatoriamente para cruzar el paso de peatones.</p> <p>En el paso de peatones no puede haber a la vez coches y peatones. Los coches esperan a que no haya peatones para pasar. Igualmente, los peatones esperan a que no haya coches. En caso de conflicto se da prioridad a los peatones. <pre><code>public class Coche extends Thread {\n    private int idCoche;\n    private PasoPeatones monitor;\n\n    public Coche(PasoPeatones monitor, int idCoche) {\n        this.idCoche = idCoche;\n        this.monitor = monitor;\n        this.start();\n    }\n\n    public void run() {\n        try {\n            this.monitor.entrarCoche(idCoche);\n            Thread.sleep(\u2026); // tiempo aleatorio para cruzar\n            this.monitor.salirCoche(idCoche);\n        } catch (InterruptedException e) {}\n    }\n}\n\npublic class Peaton extends Thread {\n    private int idPeaton;\n    private PasoPeatones monitor;\n\n    public Peaton(PasoPeatones monitor, int idPeaton) {\n        this.idPeaton = idPeaton;\n        this.monitor = monitor;\n        this.start();\n    }\n\n    public void run() {\n        try {\n            this.monitor.entrarPeaton(idPeaton);\n            Thread.sleep(...); // tiempo aleatorio para cruzar\n            this.monitor.salirPeaton(idPeaton);\n        } catch (InterruptedException e) {}\n    }\n}\n</code></pre></p> <ul> <li>(a) (5 puntos) Crear un monitor PasoPeatones que gestione el acceso al paso de peatones seg\u00fan las condiciones expuestas en el enunciado. <pre><code>public class PasoPeatones {\n...\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * Monitor paso de peatones.\n */\npublic class PasoPeatones {\n\n    private int nPeatonesIn = 0; //N\u00famero de peatones en el paso de peatones\n\n    public class Coche extends Thread {\n        private int idCoche;\n        private PasoPeatones monitor;\n\n        public Coche(PasoPeatones monitor, int idCoche) {\n            this.idCoche = idCoche;\n            this.monitor = monitor;\n            this.start();\n        }\n\n        public void run() {\n            try {\n                this.monitor.entrarCoche(idCoche);\n                Thread.sleep(\u2026); // tiempo aleatorio para cruzar\n                this.monitor.salirCoche(idCoche);\n            } catch (InterruptedException e) {}\n        }\n    }\n\n    public class Peaton extends Thread {\n        private int idPeaton;\n        private PasoPeatones monitor;\n\n        public Peaton(PasoPeatones monitor, int idPeaton) {\n            this.idPeaton = idPeaton;\n            this.monitor = monitor;\n            this.start();\n        }\n\n        public void run() {\n            try {\n                this.monitor.entrarPeaton(idPeaton);\n                Thread.sleep(...); //tiempo aleatorio para cruzar\n                this.monitor.salirPeaton(idPeaton);\n            } catch (InterruptedException e) {}\n        }\n    }\n\n    private int nCochesIn = 0; //N\u00famero de coches en el paso de peatones\n    private int nPeatonesWaiting = 0; //N\u00famero de peatones esperando para entrar en el paso de peatones\n\n    /**\n     * Getter.\n     *\n     * @return n\u00famero de peatones autorizados a pasar por el paso de peatones en este momento.\n     */\n    public synchronized int getNPeatonesIn() {\n        return nPeatonesIn;\n    }\n\n    /**\n     * Getter.\n     *\n     * @return n\u00famero de coches autorizados a pasar por el paso de peatones en este momento.\n     */\n    public synchronized int getNCochesIn() {\n        return nCochesIn;\n    }\n\n    /**\n     * Solicitud de permiso para entrar un peat\u00f3n al paso de peatones.\n     * El thread peaton que llama se queda esperando hasta que pueda entrar.\n     */\n    public synchronized void entraPeaton() {\n        nPeatonesWaiting++;\n        while (nCochesIn &gt; 0)\n            waiting();\n        nPeatonesWaiting--;\n        nPeatonesIn++;\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un peat\u00f3n.\n     *\n     * @throws IllegalMonitorStateException si no hay peat\u00f3n que pueda salir del paso de peatones.\n     */\n    public synchronized void salePeaton()\n            throws IllegalMonitorStateException {\n        try {\n            if (nPeatonesIn &lt;= 0)\n                throw new IllegalMonitorStateException();\n            nPeatonesIn--;\n        } finally {\n            if (nPeatonesIn == 0) notifyAll();\n        }\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un coche.\n     * El thread coche que llama se queda esperando hasta que pueda entrar.\n     */\n    public synchronized void entraCoches() {\n        while (nPeatonesIn &gt; 0 || nPeatonesWaiting &gt; 0)\n            waiting();\n        nCochesIn++;\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un coche.\n     *\n     * @throws IllegalMonitorStateException si no hay coche que pueda salir del paso de peatones.\n     */\n    public synchronized void saleCoche()\n            throws IllegalMonitorStateException {\n        try {\n            if (nCochesIn &lt; 1)\n                throw new IllegalMonitorStateException();\n            nCochesIn--;\n        } finally {\n            if (nCochesIn == 0) notifyAll();\n        }\n    }\n\n    private void waiting() {\n        try {\n            wait();\n        } catch (InterruptedException ignored) {\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2018/p2_ex01/","title":"P2 ex01","text":"<p>Se desea realizar un monitor para gestionar un tipo de recursos con acceso exclusivo por parte de varias hebras (threads). Para ello se parte del esquema de la clase Recurso: <pre><code>public class Recurso {\n    private int n = 0;\n    // n\u00famero de usuarios del recurso\n\n    public ... void adquirir() {\n        ...\n        // assert n == 1;\n    }\n\n    public ... void liberar() {\n        ...\n        // assert n == 0\n    }\n}\n</code></pre></p> <ul> <li>(a) (2,5 puntos) Complete el c\u00f3digo de la clase Recurso de forma que se cumplan las aserciones que figuran como comentarios.</li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n de la clase Recurso es: <pre><code>public class Recurso {\n    private int n = 0; // n\u00famero de usuarios del recurso\n\n    public synchronized void adquirir() {\n        while (n &gt; 0)\n            try {\n                wait();\n            } catch (ExceptionIgnored) {}\n        n++;\n        assert n == 1;\n    }\n\n    public class Recurso {\n        private int n = 0;\n        // n\u00famero de usuarios del recurso\n\n        public ... void adquirir() {\n            ...\n            // assert n == 1;\n        }\n\n        public ... void liberar() {\n            ...\n            // assert n == 0\n        }\n    }\n\n    public synchronized void liberar() {\n        n--;\n        notifyAll();\n        assert n == 0;\n    }\n}\n</code></pre></p> <p>Se crean tres hebras, T1, T2 y T3, cuyos m\u00e9todos run incluyen los siguientes accesos a dos objetos, R1 y R2, de la clase Recurso: <pre><code>- T1: R1.adquirir(); R1.liberar(); ... R2.adquirir(); R2.liberar();\n- T2: R2.adquirir(); R1.adquirir(); ... R1.liberar(); R2.liberar();\n- T3: R1.adquirir(); R2.adquirir(); ... R2.liberar(); R1.liberar();\n</code></pre></p> <ul> <li>(b) (2,5 puntos) Analice el comportamiento de este programa, indicando si se pueden producir interbloqueos entre todas o algunas de las hebras. Justifique la respuesta mediante las condiciones de interbloqueo explicadas en clase. NOTA : no hace falta implementar las hebras T1, T2, T3, ni los m\u00e9todos run() respectivos.</li> </ul> Mostrar soluci\u00f3n <p>Examinamos las condiciones de Coffman:     - Exclusi\u00f3n mutua: las tres hebras acceden a los recursos de forma mutuamente exclusiva, por medio de los m\u00e9todos adquirir() y liberar(). Por tanto esta condici\u00f3n se cumple para las tres hebras.     - Tener y esperar: La hebra T1 s\u00f3lo adquiere un recurso a la vez. T2 accede a R2 y luego a R1, y la hebra T3 accede a R1 y luego R2. Por tanto, la condici\u00f3n se cumple para T2 y T3, pero no para T1.     - Sin expulsi\u00f3n: La implementaci\u00f3n de los m\u00e9todos adquirir() y liberar() no permite expulsar a una hebra de un recurso ya adquirido. Por tanto, esta condici\u00b4n se cumple para todas las hebras.     - Espera circular: Se puede producir una espera circular entre T2 y T3, como se muestra en el siguiente esquema:</p> <p></p>","tags":["monitores","hebras"]},{"location":"exams/2018/p2_ex02/","title":"P2 ex02","text":"<p>Se desea realizar un monitor para gestionar paso de peatones en una carretera con acceso exclusivo por parte de varias hebras (threads). Hay dos tipos de hebras, los coches y los peatones.</p> <p>Los peatones y los coches ir\u00e1n apareciendo aleatoriamente para cruzar el paso de peatones.</p> <p>En el paso de peatones no puede haber a la vez coches y peatones. Los coches esperan a que no haya peatones para pasar. Igualmente, los peatones esperan a que no haya coches. En caso de conflicto se da prioridad a los peatones. <pre><code>public class Coche extends Thread {\n    private int idCoche;\n    private PasoPeatones monitor;\n\n    public Coche(PasoPeatones monitor, int idCoche) {\n        this.idCoche = idCoche;\n        this.monitor = monitor;\n        this.start();\n    }\n\n    public void run() {\n        try {\n            this.monitor.entrarCoche(idCoche);\n            Thread.sleep(\u2026); // tiempo aleatorio para cruzar\n            this.monitor.salirCoche(idCoche);\n        } catch (InterruptedException e) {}\n    }\n}\n\npublic class Peaton extends Thread {\n    private int idPeaton;\n    private PasoPeatones monitor;\n\n    public Peaton(PasoPeatones monitor, int idPeaton) {\n        this.idPeaton = idPeaton;\n        this.monitor = monitor;\n        this.start();\n    }\n\n    public void run() {\n        try {\n            this.monitor.entrarPeaton(idPeaton);\n            Thread.sleep(...); // tiempo aleatorio para cruzar\n            this.monitor.salirPeaton(idPeaton);\n        } catch (InterruptedException e) {}\n    }\n}\n</code></pre></p> <ul> <li>(a) (5 puntos) Crear un monitor PasoPeatones que gestione el acceso al paso de peatones seg\u00fan las condiciones expuestas en el enunciado. <pre><code>public class PasoPeatones {\n...\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * Monitor paso de peatones.\n */\npublic class PasoPeatones {\n\n    private int nPeatonesIn = 0; //N\u00famero de peatones en el paso de peatones\n\n    public class Coche extends Thread {\n        private int idCoche;\n        private PasoPeatones monitor;\n\n        public Coche(PasoPeatones monitor, int idCoche) {\n            this.idCoche = idCoche;\n            this.monitor = monitor;\n            this.start();\n        }\n\n        public void run() {\n            try {\n                this.monitor.entrarCoche(idCoche);\n                Thread.sleep(\u2026); // tiempo aleatorio para cruzar\n                this.monitor.salirCoche(idCoche);\n            } catch (InterruptedException e) {}\n        }\n    }\n\n    public class Peaton extends Thread {\n        private int idPeaton;\n        private PasoPeatones monitor;\n\n        public Peaton(PasoPeatones monitor, int idPeaton) {\n            this.idPeaton = idPeaton;\n            this.monitor = monitor;\n            this.start();\n        }\n\n        public void run() {\n            try {\n                this.monitor.entrarPeaton(idPeaton);\n                Thread.sleep(...); //tiempo aleatorio para cruzar\n                this.monitor.salirPeaton(idPeaton);\n            } catch (InterruptedException e) {}\n        }\n    }\n\n    private int nCochesIn = 0; //N\u00famero de coches en el paso de peatones\n    private int nPeatonesWaiting = 0; //N\u00famero de peatones esperando para entrar en el paso de peatones\n\n    /**\n     * Getter.\n     *\n     * @return n\u00famero de peatones autorizados a pasar por el paso de peatones en este momento.\n     */\n    public synchronized int getNPeatonesIn() {\n        return nPeatonesIn;\n    }\n\n    /**\n     * Getter.\n     *\n     * @return n\u00famero de coches autorizados a pasar por el paso de peatones en este momento.\n     */\n    public synchronized int getNCochesIn() {\n        return nCochesIn;\n    }\n\n    /**\n     * Solicitud de permiso para entrar un peat\u00f3n al paso de peatones.\n     * El thread peaton que llama se queda esperando hasta que pueda entrar.\n     */\n    public synchronized void entraPeaton() {\n        nPeatonesWaiting++;\n        while (nCochesIn &gt; 0)\n            waiting();\n        nPeatonesWaiting--;\n        nPeatonesIn++;\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un peat\u00f3n.\n     *\n     * @throws IllegalMonitorStateException si no hay peat\u00f3n que pueda salir del paso de peatones.\n     */\n    public synchronized void salePeaton()\n            throws IllegalMonitorStateException {\n        try {\n            if (nPeatonesIn &lt;= 0)\n                throw new IllegalMonitorStateException();\n            nPeatonesIn--;\n        } finally {\n            if (nPeatonesIn == 0) notifyAll();\n        }\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un coche.\n     * El thread coche que llama se queda esperando hasta que pueda entrar.\n     */\n    public synchronized void entraCoches() {\n        while (nPeatonesIn &gt; 0 || nPeatonesWaiting &gt; 0)\n            waiting();\n        nCochesIn++;\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un coche.\n     *\n     * @throws IllegalMonitorStateException si no hay coche que pueda salir del paso de peatones.\n     */\n    public synchronized void saleCoche()\n            throws IllegalMonitorStateException {\n        try {\n            if (nCochesIn &lt; 1)\n                throw new IllegalMonitorStateException();\n            nCochesIn--;\n        } finally {\n            if (nCochesIn == 0) notifyAll();\n        }\n    }\n\n    private void waiting() {\n        try {\n            wait();\n        } catch (InterruptedException ignored) {\n        }\n    }\n}\n</code></pre>","tags":["monitores","hebras"]},{"location":"exams/2019/extra/","title":"Examen 2019 \u2014 Extraordinario","text":""},{"location":"exams/2019/extra/#problema-1","title":"Problema 1","text":"<p>Una empresa de telecomunicaciones necesita gestionar una tabla de abonados con sus n\u00fameros de l\u00ednea correspondientes. Para ello utiliza una clase Java denominada TablaAbonados con la interfaz que se especifica a continuaci\u00f3n: <pre><code>public class TablaAbonados {\n    ...\n    /**\n    * Registrar una nueva l\u00ednea\n    * @param numero l\u00ednea\n    * @param abonado apellidos, nombre\n    */\n    public void insertar (String numero, String abonado) {...}\n    /**\n    * Eliminar el registro de una l\u00ednea\n    * @param numero de l\u00ednea\n    */\n    public void eliminar (String numero) {...}\n    /**\n    * Apellidos y nombre del titular de una l\u00ednea\n    * @param numero de l\u00ednea\n    * @return apellidos, nombre\n    */\n    public String abonado (String numero) {...}\n}\n</code></pre> Las operaciones insertar y abonado se ejecutan muchas veces al d\u00eda, y la operaci\u00f3n eliminar se ejecuta con menos frecuencia. Para implementar la tabla se utiliza internamente una tabla hash con listas.</p> <p>Nota: no escriba c\u00f3digo, s\u00f3lo indique qu\u00e9 algoritmos habr\u00eda que utilizar</p> <ul> <li>(a) (1 punto) Explique razonadamente qu\u00e9 par\u00e1metros se deben tomar como clave y valor, respectivamente, en la tabla hash.</li> </ul> Mostrar soluci\u00f3n <p>Un n\u00famero de l\u00ednea permite identificarla de forma un\u00edvoca, mientras que los abonados se pueden repetir, por ejemplo, si un abonado tiene varios n\u00fameros. Por tanto, se debe usar el n\u00famero como clave y el abonado como valor en la tabla</p> <ul> <li>(b) (1 punto) Si el n\u00famero m\u00e1ximo de abonados de empresa se puede estimar en 1 000 000, aproximadamente, indique razonadamente cu\u00e1l ser\u00eda el n\u00famero m\u00ednimo de ranuras (slots) de la tabla hash para obtener un comportamiento eficiente.</li> </ul> Mostrar soluci\u00f3n <p>Para mantener la complejidad O (1) en las operaciones con la tabla hash, el n\u00famero k de ranuras debe ser significativamente superior al n\u00famero de claves, N. Por ejemplo, si se quiere mantener la carga de la tabla por debajo del 50 % har\u00edan falta 2 000 000 de ranuras</p> <ul> <li>(c) (1,5 puntos) Indique cu\u00e1l ser\u00eda la complejidad que se puede esperar de las operaciones de la tabla para el caso anterior, justificando la respuesta.</li> </ul> Mostrar soluci\u00f3n <p>Para una tabla hash con listas y una carga reducida, el tiempo de acceso para las operaciones de la tabla ser\u00eda t = th + top \u2248 constante. Por tanto, para N grande se puede suponer t \u2208 O (1).</p> <ul> <li>(d)  (1,5 puntos) Una vez al trimestre la empresa debe entregar a la administraci\u00f3n, a efectos fiscales, una lista de abonados ordenada alfab\u00e9ticamente. Para ello se a\u00f1ade a la clase anterior un nuevo m\u00e9todo: <pre><code>public List&lt;String&gt; listaAbonados (String) {...}\n</code></pre> que genera la lista a partir del contenido de la tabla hash. Explique, justificando la respuesta, c\u00f3mo se podr\u00eda generar esta y cu\u00e1l ser\u00eda la complejidad de la operaci\u00f3n listaAbonados (1,5 puntos).</li> </ul> Mostrar soluci\u00f3n <p>Para obtener la lista ordenada hay que efectuar las siguientes operaciones:     - Obtener una lista con todos los elementos de la tabla hash. Para ello hay que recorrer toda la tabla, y por tanto esta operaci\u00f3n tiene complejidad lineal, O (N).     - Ordenar la lista. Si se usa un algoritmo de ordenaci\u00f3n eficiente, como QuickSort o MergeSort, la complejidad de esta operaci\u00f3n es, en promedio, O (N log N).</p> <p>Por tanto, la complejidad total de la operaci\u00f3n ser\u00e1 O(N) + O(N log N) \u2248 O (N log N)</p>"},{"location":"exams/2019/extra/#problema-2","title":"Problema 2","text":"<p>Se debe realizar un algoritmo para etiquetar con un n\u00famero todos los nodos de un grafo cumpliendo las siguientes condiciones:     - 1. Dos nodos adyacentes no pueden tener el mismo n\u00famero.     - 2. Sobre el grafo pasado como par\u00e1metro, el algoritmo debe asignar el n\u00famero m\u00ednimo que pueda a todos los nodos, cumpliendo la condici\u00f3n del punto 1, y devolver el n\u00famero m\u00e1ximo utilizado para etiquetar todos los nodos. (Ver ejemplos).     - 3. Se considera que todos los enlaces son bidireccionales y se han creado con el siguiente m\u00e9todo:     <pre><code>public void addLink2D(String a, String b, int w) {\u2026}\n</code></pre>     que a\u00f1ade a un grafo un enlace entre el nodo a y el b, y otro enlace entre b y a. Todos los enlaces tiene peso w = 1.     - 4. Se usar\u00e1 el modelo de los ejercicios de pr\u00e1cticas 1 y 2, donde tenemos la clase Graph que contiene objetos de la clase Node para definir los v\u00e9rtices (nodos), y objetos de la clase Link para definir los arcos (enlaces.)</p> <p>Notas: Una posible soluci\u00f3n trivial podr\u00eda ser hacer un for con un \u00edndice y asignar ese \u00edndice a cada nodo. Esta soluci\u00f3n no ser\u00eda v\u00e1lida porque, aunque cumple el punto 2, no cumple el punto 3. Para asignar valores a los nodos se recomienda usar una estructura del estilo Map, donde la clave (key) es el Node que queremos etiquetar y el valor (value) es el Integer con el valor etiquetado. <p>Ejemplos:</p> <p></p> <ul> <li>(a) (4 puntos) Dise\u00f1e el algoritmo con la siguiente signatura. Nota: Puede (debe) desarrollar m\u00e9todos auxiliares si lo necesita para facilitar la implementaci\u00f3n del algoritmo. <pre><code>int getMinimunInt(Graph g) {\n    // a rellenar por el alumno\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * M\u00e9todo para conseguir una lista con todos enteros de los nodos vecinos a uno dado.\n * Si el vecino no tiene un entero asignado, no se devuelve nada.\n *\n * @param g Grafo del que se quiere realizar los c\u00e1lculos\n * @param myNode Nodo del cual se quiere obtener todos los vecinos\n * @param ints Mapa con los enteros de todos los nodos\n * @return Lista de los colores de los vecinos\n */\npublic static List&lt;Integer&gt; getNeighborsInts(Graph g, Node myNode, Map&lt;Node, Integer&gt; ints) {\n\n    List&lt;Integer&gt; neighborsInts = new ArrayList&lt;Integer&gt;();\n\n    for (Link link : g.getLinks(myNode)) {\n        Node dst = g.getNode(link.getDst());\n        if (dst != null) {\n            Integer intDst = ints.get(dst);\n            if (intDst != null) {\n                neighborsInts.add(intDst);\n            }\n        }\n    }\n    return neighborsInts;\n}\n\n/**\n * Algoritmo para conseguir el entero m\u00ednimo de una lista de Integers dada.\n *\n * Ejemplos:\n * &lt;1,2,3&gt;  -&gt; devuelve 0\n * &lt;0,1,3&gt;  -&gt; devuelve 2\n * &lt;0,1,2&gt;  -&gt; devuelve 3\n *\n * @param neighborsInts lista con enteros\n * @return entero m\u00ednimo que no est\u00e1 en la lista\n */\npublic static int getMinimunInt(List&lt;Integer&gt; neighborsInts) {\n\n    for (int i = 0; i != Integer.MAX_VALUE; i++) {\n        boolean found = false;\n\n        for (Integer myInteger : neighborsInts) {\n            if (myInteger.intValue() == i) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            return i;\n        }\n    }\n    return Integer.MAX_VALUE;\n}\n\n/**\n * Algoritmo para conseguir el entero mayor (m\u00e1ximo) de un mapa.\n *\n * @param ints mapa con los nodos y el entero asignado\n * @return entero m\u00e1ximo del mapa\n */\npublic static int getMaxIntInGraph(Map&lt;Node, Integer&gt; ints) {\n\n    int maxValue = Integer.MIN_VALUE;\n\n    for (Integer myInteger : ints.values()) {\n        if (myInteger.intValue() &gt; maxValue) {\n            maxValue = myInteger.intValue();\n        }\n    }\n    return maxValue;\n}\n\n/**\n * Algoritmo para conseguir el entero m\u00ednimo para etiquetar un grafo\n * siguiendo las reglas del coloreado de grafos.\n *\n * @param g grafo que describe el problema\n * @return entero m\u00ednimo necesario para etiquetar el grafo\n */\npublic static int getMinimunInt(Graph g) {\n\n    // Estructura para guardar los enteros asignados a cada nodo\n    Map&lt;Node, Integer&gt; ints = new HashMap&lt;Node, Integer&gt;();\n\n    // Recorremos todos los nodos del grafo\n    for (Node myNode : g.getNodes()) {\n\n        // Obtenemos los enteros de los vecinos\n        List&lt;Integer&gt; neighborsInts = getNeighborsInts(g, myNode, ints);\n\n        // Calculamos el entero m\u00ednimo no usado\n        int minimunInt = getMinimunInt(neighborsInts);\n\n        // Asignamos el entero al nodo\n        ints.put(myNode, minimunInt);\n    }\n\n    // Obtenemos el entero m\u00e1ximo usado en el grafo\n    int maxIntInGraph = getMaxIntInGraph(ints);\n\n    return maxIntInGraph;\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfCu\u00e1l es la complejidad de dicho algoritmo? (Razone su respuesta)</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p>"},{"location":"exams/2019/extra/#problema-3","title":"Problema 3","text":"<p>Se quiere desarrollar un sistema de gesti\u00f3n de eventos. Este sistema est\u00e1 compuesto por un conjunto de productores y consumidores. Los productores ponen eventos en el sistema. Los consumidores recogen eventos del sistema para procesarlos. - (a) Desarrolle el monitor EventManager con el siguiente esquema (Nota: el m\u00e9todo getEvents tiene m\u00e1s peso en la calificaci\u00f3n que el resto del c\u00f3digo): <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = ...;\n    ...\n    /**\n    * A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes de procesar\n    * es igual al m\u00e1ximo, la hebra que llama se bloquea hasta que haya hueco\n    */\n    ... void putEvent (Event event) {...}\n    /**\n    * Recuperar eventos para su procesamiento. Este m\u00e9todo admite que se soliciten\n    * uno o dos eventos. El m\u00e9todo deber\u00e1 devolver un array con un n\u00famero de eventos\n    * igual a la solicitud. Las hebras que solicitan dos eventos tienen preferencia.\n    * Si hay hebras bloqueadas y hay eventos suficientes, hay que desbloquear a las que\n    * hayan solicitado dos eventos. Si no hay suficientes eventos pendientes para cada\n    * tipo, se bloquea la hebra que llama hasta que haya suficientes.\n    */\n    ... Event[] getEvents (int nEventos) {...}\n}\n</code></pre></p> Mostrar soluci\u00f3n <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = 10;\n\n    // N\u00famero de hebras que han solicitado dos eventos\n    private int nTwoEvents = 0;\n\n    // Lista de eventos a\u00f1adidos y no recuperados\n    private List&lt;Event&gt; buffer;\n\n    public EventManager () {\n        buffer = new ArrayList&lt;&gt;(MAX_PENDING_EVENTS);\n    }\n\n    /**\n    * A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes\n    * de procesar es igual al m\u00e1ximo, la hebra que\n    * llama se bloquea hasta que haya hueco\n    */\n    public synchronized void putEvent(Event event) {\n        while (buffer.size() == MAX_PENDING_EVENTS) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        buffer.add(event);\n        notifyAll();\n    }\n    /**\n    * Recuperar eventos para su procesamiento. Este m\u00e9todo admite que se soliciten\n    * uno o dos eventos. El m\u00e9todo deber\u00e1 devolver un array con un n\u00famero de eventos\n    * igual a la solicitud. Las hebras que solicitan dos eventos tienen m\u00e1s urgencia.\n    * Si hay hebras bloqueadas y hay eventos suficientes, hay que desbloquear a las que\n    * hayan solicitado dos eventos. Si no hay suficientes eventos pendientes para cada\n    * tipo, se bloquea a la hebra que llama hasta que haya suficientes.\n    */\n    Event[] getEvent(int nEvents) {\n        Event[] events;\n\n        if (nEvents == 2) nTwoEvents++;\n        while ( (nEvents == 2 &amp;&amp; buffer.size() &lt; 2) ||\n                (nEvents == 1 &amp;&amp; nTwoEvents &gt; 0 &amp;&amp; buffer.size() &gt;= 2) ||\n                (buffer.size() == 0)) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n\n        if (nEvents == 2) {\n            nTwoEvents--;\n            events = new Event[2];\n            events[0] = buffer.remove(0);\n            events[1] = buffer.remove(0);\n        } else {\n            events = new Event[1];\n            events[0] = buffer.remove(0);\n        }\n\n        notifyAll(); return events;\n    }\n}\n</code></pre>"},{"location":"exams/2019/extra/#problema-4","title":"Problema 4","text":"<p>A continuaci\u00f3n se muestra el m\u00e9todo getEvent de una versi\u00f3n alternativa de un gestor de eventos con prioridades, al que acceden concurrentemente varias hebras. <pre><code>public class Event {\n    private EventInformation info;\n    private EventPriority priority;\n    // getters &amp; setters\n}\n</code></pre></p> <pre><code>public enum EventPriority {High, Low}\n</code></pre> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n\npublic class PriorityEventManager {\n\n    public final int MAX_PENDING_EVENTS = 10;\n    private List&lt;Event&gt; list;\n\n    public PriorityEventManager() {\n        list = new ArrayList&lt;&gt;(MAX_PENDING_EVENTS);\n    }\n\n    public synchronized void putEvent(Event anEvent) {\n        // implementaci\u00f3n pendiente\n    }\n\n    public synchronized Event getEvent() {\n        List&lt;Event&gt; aux = new ArrayList&lt;Event&gt;();\n        Event event = null;\n\n        // Copiar los elementos de list y guardarlos en aux\n        aux.addAll(list);\n\n        while (aux.size() == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n            }\n        }\n\n        for (Event e : aux) {\n            if (e.getPriority() == EventPriority.High) {\n                event = e;\n                aux.remove(e);\n                break;\n            }\n        }\n\n        if (event == null) {\n            event = aux.remove(0);\n        }\n\n        list = aux;\n        notifyAll();\n        return event;\n    }\n}\n</code></pre> <ul> <li>(a) (2,5 puntos) Razone si esta soluci\u00f3n es correcta y, en caso contrario, describa los errores que contiene.</li> </ul> Mostrar soluci\u00f3n <p>Esta soluci\u00f3n es incorrecta en un programa concurrente. Cuando se ejecuta GetEvent se hace una copia de list a aux. Esta variable es local en cada instancia del m\u00e9todo, por lo que s\u00f3lo se puede cambiar al ejecutar la hebra que ha invocado este m\u00e9todo. Eso quiere decir que si varias hebras han invocado a GetEvent, cada una tiene una variable aux local.</p> <p>Si la lista aux est\u00e1 vac\u00eda, por tanto, su tama\u00f1o es cero. En consecuencia, la hebra se quedar\u00e1 bloqueada en el wait y nunca volver\u00e1 a ejecutarse, por que ninguna otra hebra podr\u00e1 cambiar el valor de la variable aux local.</p> <p>Adem\u00e1s, en el caso de que esta hebra se ejecutara, tambi\u00e9n hay varios errores en el c\u00f3digo. Por ejemplo, cuando actualiza el valor de list machaca su versi\u00f3n actual.</p>"},{"location":"exams/2019/extra/#problema-5","title":"Problema 5","text":"<p>Se desea desarrollar una aplicaci\u00f3n llamada Tiempo Perdido, cuya funcionalidad es comparar el tiempo en segundos que la aplicaci\u00f3n ha estado completamente visible con un valor introducido por el usuario. Para ello se ha dise\u00f1ado la siguiente interfaz gr\u00e1fica:</p> <p></p> <p>En ella se han emplazado los siguientes elementos:     - Un EditText con id: etNumber e inputType: number. Este \u00faltimo atributo solo permite al usuario introducir n\u00fameros enteros no negativos.     - Un TextView con id: tvResult donde se muestra el resultado de la comparaci\u00f3n.         - Si el valor introducido por el usuario coincide con el tiempo en segundos que la aplicaci\u00f3n ha estado completamente visible indica \u201c\u00a1correcto!\u201d.         - Si el usuario introduce un valor mayor indica \u201cTe has pasado por X segundos\u201d donde X es la diferencia entre el valor introducido y el correcto.         - Si el usuario introduce un valor menor indica \u201cTe has quedado corto por X segundos\u201d donde X es la diferencia entre el valor introducido y el correcto.     - Un bot\u00f3n con id: bComprobar que lanza la comprobaci\u00f3n. Si al pulsar el bot\u00f3n etNumber no contiene un n\u00famero no negativo se ha de lanzar un mensaje de alerta al usuario.</p> <p>Para la implementaci\u00f3n nos apoyaremos en la clase Chrono que ofrece los siguientes m\u00e9todos:</p> <pre><code>public class Chrono {\n    int time;\n    public Chrono() {\n        this.time = 0;\n    }\n    // Arranca el cron\u00f3metro\n    public void startChrono (){\u2026}\n    // Para el cron\u00f3metro\n    public void stopChrono (){\u2026}\n    // Reinicia el cron\u00f3metro a 0\n    public void resetChrono (){time = 0;}\n    // Devuelve el valor del cron\u00f3metro en segundos\n    public int currentTime() {return time;}\n}\n</code></pre> <ul> <li>(a) (3 puntos) Complete la clase para implementar la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    Chrono chrono;\n    EditText input;\n    TextView output;\n    Button check;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        chrono = new Chrono();\n        input = findViewById(R.id.etNumber);\n        output = findViewById(R.id.tvResult);\n        check = findViewById(R.id.bComprobar);\n\n        check.setOnClickListener(new View.OnClickListener() {\n            public void onClick(View w) {\n                String st = input.getText().toString();\n\n                if (st == null || st.isEmpty()) {\n                    Toast.makeText(\n                        MainActivity.this,\n                        \"Introduce un n\u00famero entero positivo\",\n                        Toast.LENGTH_SHORT\n                    ).show();\n                    return;\n                }\n\n                Integer in = Integer.parseInt(st);\n                if (in != null &amp;&amp; in &gt;= 0) {\n                    int diff = in.intValue() - chrono.currentTime();\n\n                    if (diff == 0) {\n                        output.setText(\"\u00a1Correcto!\");\n                    } else if (diff &gt; 0) {\n                        output.setText(\"Te has pasado por \" + diff + \" segundos.\");\n                    } else {\n                        output.setText(\"Te has quedado corto por \" + (-diff) + \" segundos.\");\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        chrono.startChrono();\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        chrono.stopChrono();\n    }\n}\n</code></pre>"},{"location":"exams/2019/extra_ex01/","title":"Extra ex01","text":"<p>Una empresa de telecomunicaciones necesita gestionar una tabla de abonados con sus n\u00fameros de l\u00ednea correspondientes. Para ello utiliza una clase Java denominada TablaAbonados con la interfaz que se especifica a continuaci\u00f3n: <pre><code>public class TablaAbonados {\n    ...\n    /**\n    * Registrar una nueva l\u00ednea\n    * @param numero l\u00ednea\n    * @param abonado apellidos, nombre\n    */\n    public void insertar (String numero, String abonado) {...}\n    /**\n    * Eliminar el registro de una l\u00ednea\n    * @param numero de l\u00ednea\n    */\n    public void eliminar (String numero) {...}\n    /**\n    * Apellidos y nombre del titular de una l\u00ednea\n    * @param numero de l\u00ednea\n    * @return apellidos, nombre\n    */\n    public String abonado (String numero) {...}\n}\n</code></pre> Las operaciones insertar y abonado se ejecutan muchas veces al d\u00eda, y la operaci\u00f3n eliminar se ejecuta con menos frecuencia. Para implementar la tabla se utiliza internamente una tabla hash con listas.</p> <p>Nota: no escriba c\u00f3digo, s\u00f3lo indique qu\u00e9 algoritmos habr\u00eda que utilizar</p> <ul> <li>(a) (1 punto) Explique razonadamente qu\u00e9 par\u00e1metros se deben tomar como clave y valor, respectivamente, en la tabla hash.</li> </ul> Mostrar soluci\u00f3n <p>Un n\u00famero de l\u00ednea permite identificarla de forma un\u00edvoca, mientras que los abonados se pueden repetir, por ejemplo, si un abonado tiene varios n\u00fameros. Por tanto, se debe usar el n\u00famero como clave y el abonado como valor en la tabla</p> <ul> <li>(b) (1 punto) Si el n\u00famero m\u00e1ximo de abonados de empresa se puede estimar en 1 000 000, aproximadamente, indique razonadamente cu\u00e1l ser\u00eda el n\u00famero m\u00ednimo de ranuras (slots) de la tabla hash para obtener un comportamiento eficiente.</li> </ul> Mostrar soluci\u00f3n <p>Para mantener la complejidad O (1) en las operaciones con la tabla hash, el n\u00famero k de ranuras debe ser significativamente superior al n\u00famero de claves, N. Por ejemplo, si se quiere mantener la carga de la tabla por debajo del 50 % har\u00edan falta 2 000 000 de ranuras</p> <ul> <li>(c) (1,5 puntos) Indique cu\u00e1l ser\u00eda la complejidad que se puede esperar de las operaciones de la tabla para el caso anterior, justificando la respuesta.</li> </ul> Mostrar soluci\u00f3n <p>Para una tabla hash con listas y una carga reducida, el tiempo de acceso para las operaciones de la tabla ser\u00eda t = th + top \u2248 constante. Por tanto, para N grande se puede suponer t \u2208 O (1).</p> <ul> <li>(d)  (1,5 puntos) Una vez al trimestre la empresa debe entregar a la administraci\u00f3n, a efectos fiscales, una lista de abonados ordenada alfab\u00e9ticamente. Para ello se a\u00f1ade a la clase anterior un nuevo m\u00e9todo: <pre><code>public List&lt;String&gt; listaAbonados (String) {...}\n</code></pre> que genera la lista a partir del contenido de la tabla hash. Explique, justificando la respuesta, c\u00f3mo se podr\u00eda generar esta y cu\u00e1l ser\u00eda la complejidad de la operaci\u00f3n listaAbonados (1,5 puntos).</li> </ul> Mostrar soluci\u00f3n <p>Para obtener la lista ordenada hay que efectuar las siguientes operaciones:     - Obtener una lista con todos los elementos de la tabla hash. Para ello hay que recorrer toda la tabla, y por tanto esta operaci\u00f3n tiene complejidad lineal, O (N).     - Ordenar la lista. Si se usa un algoritmo de ordenaci\u00f3n eficiente, como QuickSort o MergeSort, la complejidad de esta operaci\u00f3n es, en promedio, O (N log N).</p> <p>Por tanto, la complejidad total de la operaci\u00f3n ser\u00e1 O(N) + O(N log N) \u2248 O (N log N)</p>","tags":["???"]},{"location":"exams/2019/extra_ex02/","title":"Extra ex02","text":"<p>Se debe realizar un algoritmo para etiquetar con un n\u00famero todos los nodos de un grafo cumpliendo las siguientes condiciones:     - 1. Dos nodos adyacentes no pueden tener el mismo n\u00famero.     - 2. Sobre el grafo pasado como par\u00e1metro, el algoritmo debe asignar el n\u00famero m\u00ednimo que pueda a todos los nodos, cumpliendo la condici\u00f3n del punto 1, y devolver el n\u00famero m\u00e1ximo utilizado para etiquetar todos los nodos. (Ver ejemplos).     - 3. Se considera que todos los enlaces son bidireccionales y se han creado con el siguiente m\u00e9todo:     <pre><code>public void addLink2D(String a, String b, int w) {\u2026}\n</code></pre>     que a\u00f1ade a un grafo un enlace entre el nodo a y el b, y otro enlace entre b y a. Todos los enlaces tiene peso w = 1.     - 4. Se usar\u00e1 el modelo de los ejercicios de pr\u00e1cticas 1 y 2, donde tenemos la clase Graph que contiene objetos de la clase Node para definir los v\u00e9rtices (nodos), y objetos de la clase Link para definir los arcos (enlaces.)</p> <p>Notas: Una posible soluci\u00f3n trivial podr\u00eda ser hacer un for con un \u00edndice y asignar ese \u00edndice a cada nodo. Esta soluci\u00f3n no ser\u00eda v\u00e1lida porque, aunque cumple el punto 2, no cumple el punto 3. Para asignar valores a los nodos se recomienda usar una estructura del estilo Map, donde la clave (key) es el Node que queremos etiquetar y el valor (value) es el Integer con el valor etiquetado. <p>Ejemplos:</p> <p></p> <ul> <li>(a) (4 puntos) Dise\u00f1e el algoritmo con la siguiente signatura. Nota: Puede (debe) desarrollar m\u00e9todos auxiliares si lo necesita para facilitar la implementaci\u00f3n del algoritmo. <pre><code>int getMinimunInt(Graph g) {\n    // a rellenar por el alumno\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * M\u00e9todo para conseguir una lista con todos enteros de los nodos vecinos a uno dado.\n * Si el vecino no tiene un entero asignado, no se devuelve nada.\n *\n * @param g Grafo del que se quiere realizar los c\u00e1lculos\n * @param myNode Nodo del cual se quiere obtener todos los vecinos\n * @param ints Mapa con los enteros de todos los nodos\n * @return Lista de los colores de los vecinos\n */\npublic static List&lt;Integer&gt; getNeighborsInts(Graph g, Node myNode, Map&lt;Node, Integer&gt; ints) {\n\n    List&lt;Integer&gt; neighborsInts = new ArrayList&lt;Integer&gt;();\n\n    for (Link link : g.getLinks(myNode)) {\n        Node dst = g.getNode(link.getDst());\n        if (dst != null) {\n            Integer intDst = ints.get(dst);\n            if (intDst != null) {\n                neighborsInts.add(intDst);\n            }\n        }\n    }\n    return neighborsInts;\n}\n\n/**\n * Algoritmo para conseguir el entero m\u00ednimo de una lista de Integers dada.\n *\n * Ejemplos:\n * &lt;1,2,3&gt;  -&gt; devuelve 0\n * &lt;0,1,3&gt;  -&gt; devuelve 2\n * &lt;0,1,2&gt;  -&gt; devuelve 3\n *\n * @param neighborsInts lista con enteros\n * @return entero m\u00ednimo que no est\u00e1 en la lista\n */\npublic static int getMinimunInt(List&lt;Integer&gt; neighborsInts) {\n\n    for (int i = 0; i != Integer.MAX_VALUE; i++) {\n        boolean found = false;\n\n        for (Integer myInteger : neighborsInts) {\n            if (myInteger.intValue() == i) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            return i;\n        }\n    }\n    return Integer.MAX_VALUE;\n}\n\n/**\n * Algoritmo para conseguir el entero mayor (m\u00e1ximo) de un mapa.\n *\n * @param ints mapa con los nodos y el entero asignado\n * @return entero m\u00e1ximo del mapa\n */\npublic static int getMaxIntInGraph(Map&lt;Node, Integer&gt; ints) {\n\n    int maxValue = Integer.MIN_VALUE;\n\n    for (Integer myInteger : ints.values()) {\n        if (myInteger.intValue() &gt; maxValue) {\n            maxValue = myInteger.intValue();\n        }\n    }\n    return maxValue;\n}\n\n/**\n * Algoritmo para conseguir el entero m\u00ednimo para etiquetar un grafo\n * siguiendo las reglas del coloreado de grafos.\n *\n * @param g grafo que describe el problema\n * @return entero m\u00ednimo necesario para etiquetar el grafo\n */\npublic static int getMinimunInt(Graph g) {\n\n    // Estructura para guardar los enteros asignados a cada nodo\n    Map&lt;Node, Integer&gt; ints = new HashMap&lt;Node, Integer&gt;();\n\n    // Recorremos todos los nodos del grafo\n    for (Node myNode : g.getNodes()) {\n\n        // Obtenemos los enteros de los vecinos\n        List&lt;Integer&gt; neighborsInts = getNeighborsInts(g, myNode, ints);\n\n        // Calculamos el entero m\u00ednimo no usado\n        int minimunInt = getMinimunInt(neighborsInts);\n\n        // Asignamos el entero al nodo\n        ints.put(myNode, minimunInt);\n    }\n\n    // Obtenemos el entero m\u00e1ximo usado en el grafo\n    int maxIntInGraph = getMaxIntInGraph(ints);\n\n    return maxIntInGraph;\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfCu\u00e1l es la complejidad de dicho algoritmo? (Razone su respuesta)</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p>","tags":["grafos","complejidad"]},{"location":"exams/2019/extra_ex03/","title":"Extra ex03","text":"<p>Se quiere desarrollar un sistema de gesti\u00f3n de eventos. Este sistema est\u00e1 compuesto por un conjunto de productores y consumidores. Los productores ponen eventos en el sistema. Los consumidores recogen eventos del sistema para procesarlos. - (a) Desarrolle el monitor EventManager con el siguiente esquema (Nota: el m\u00e9todo getEvents tiene m\u00e1s peso en la calificaci\u00f3n que el resto del c\u00f3digo): <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = ...;\n    ...\n    /**\n    * A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes de procesar\n    * es igual al m\u00e1ximo, la hebra que llama se bloquea hasta que haya hueco\n    */\n    ... void putEvent (Event event) {...}\n    /**\n    * Recuperar eventos para su procesamiento. Este m\u00e9todo admite que se soliciten\n    * uno o dos eventos. El m\u00e9todo deber\u00e1 devolver un array con un n\u00famero de eventos\n    * igual a la solicitud. Las hebras que solicitan dos eventos tienen preferencia.\n    * Si hay hebras bloqueadas y hay eventos suficientes, hay que desbloquear a las que\n    * hayan solicitado dos eventos. Si no hay suficientes eventos pendientes para cada\n    * tipo, se bloquea la hebra que llama hasta que haya suficientes.\n    */\n    ... Event[] getEvents (int nEventos) {...}\n}\n</code></pre></p> Mostrar soluci\u00f3n <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = 10;\n\n    // N\u00famero de hebras que han solicitado dos eventos\n    private int nTwoEvents = 0;\n\n    // Lista de eventos a\u00f1adidos y no recuperados\n    private List&lt;Event&gt; buffer;\n\n    public EventManager () {\n        buffer = new ArrayList&lt;&gt;(MAX_PENDING_EVENTS);\n    }\n\n    /**\n    * A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes\n    * de procesar es igual al m\u00e1ximo, la hebra que\n    * llama se bloquea hasta que haya hueco\n    */\n    public synchronized void putEvent(Event event) {\n        while (buffer.size() == MAX_PENDING_EVENTS) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        buffer.add(event);\n        notifyAll();\n    }\n    /**\n    * Recuperar eventos para su procesamiento. Este m\u00e9todo admite que se soliciten\n    * uno o dos eventos. El m\u00e9todo deber\u00e1 devolver un array con un n\u00famero de eventos\n    * igual a la solicitud. Las hebras que solicitan dos eventos tienen m\u00e1s urgencia.\n    * Si hay hebras bloqueadas y hay eventos suficientes, hay que desbloquear a las que\n    * hayan solicitado dos eventos. Si no hay suficientes eventos pendientes para cada\n    * tipo, se bloquea a la hebra que llama hasta que haya suficientes.\n    */\n    Event[] getEvent(int nEvents) {\n        Event[] events;\n\n        if (nEvents == 2) nTwoEvents++;\n        while ( (nEvents == 2 &amp;&amp; buffer.size() &lt; 2) ||\n                (nEvents == 1 &amp;&amp; nTwoEvents &gt; 0 &amp;&amp; buffer.size() &gt;= 2) ||\n                (buffer.size() == 0)) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n\n        if (nEvents == 2) {\n            nTwoEvents--;\n            events = new Event[2];\n            events[0] = buffer.remove(0);\n            events[1] = buffer.remove(0);\n        } else {\n            events = new Event[1];\n            events[0] = buffer.remove(0);\n        }\n\n        notifyAll(); return events;\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2019/extra_ex04/","title":"Extra ex04","text":"<p>A continuaci\u00f3n se muestra el m\u00e9todo getEvent de una versi\u00f3n alternativa de un gestor de eventos con prioridades, al que acceden concurrentemente varias hebras. <pre><code>public class Event {\n    private EventInformation info;\n    private EventPriority priority;\n    // getters &amp; setters\n}\n</code></pre></p> <pre><code>public enum EventPriority {High, Low}\n</code></pre> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n\npublic class PriorityEventManager {\n\n    public final int MAX_PENDING_EVENTS = 10;\n    private List&lt;Event&gt; list;\n\n    public PriorityEventManager() {\n        list = new ArrayList&lt;&gt;(MAX_PENDING_EVENTS);\n    }\n\n    public synchronized void putEvent(Event anEvent) {\n        // implementaci\u00f3n pendiente\n    }\n\n    public synchronized Event getEvent() {\n        List&lt;Event&gt; aux = new ArrayList&lt;Event&gt;();\n        Event event = null;\n\n        // Copiar los elementos de list y guardarlos en aux\n        aux.addAll(list);\n\n        while (aux.size() == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n            }\n        }\n\n        for (Event e : aux) {\n            if (e.getPriority() == EventPriority.High) {\n                event = e;\n                aux.remove(e);\n                break;\n            }\n        }\n\n        if (event == null) {\n            event = aux.remove(0);\n        }\n\n        list = aux;\n        notifyAll();\n        return event;\n    }\n}\n</code></pre> <ul> <li>(a) (2,5 puntos) Razone si esta soluci\u00f3n es correcta y, en caso contrario, describa los errores que contiene.</li> </ul> Mostrar soluci\u00f3n <p>Esta soluci\u00f3n es incorrecta en un programa concurrente. Cuando se ejecuta GetEvent se hace una copia de list a aux. Esta variable es local en cada instancia del m\u00e9todo, por lo que s\u00f3lo se puede cambiar al ejecutar la hebra que ha invocado este m\u00e9todo. Eso quiere decir que si varias hebras han invocado a GetEvent, cada una tiene una variable aux local.</p> <p>Si la lista aux est\u00e1 vac\u00eda, por tanto, su tama\u00f1o es cero. En consecuencia, la hebra se quedar\u00e1 bloqueada en el wait y nunca volver\u00e1 a ejecutarse, por que ninguna otra hebra podr\u00e1 cambiar el valor de la variable aux local.</p> <p>Adem\u00e1s, en el caso de que esta hebra se ejecutara, tambi\u00e9n hay varios errores en el c\u00f3digo. Por ejemplo, cuando actualiza el valor de list machaca su versi\u00f3n actual.</p>","tags":["hebras"]},{"location":"exams/2019/extra_ex05/","title":"Extra ex05","text":"<p>Se desea desarrollar una aplicaci\u00f3n llamada Tiempo Perdido, cuya funcionalidad es comparar el tiempo en segundos que la aplicaci\u00f3n ha estado completamente visible con un valor introducido por el usuario. Para ello se ha dise\u00f1ado la siguiente interfaz gr\u00e1fica:</p> <p></p> <p>En ella se han emplazado los siguientes elementos:     - Un EditText con id: etNumber e inputType: number. Este \u00faltimo atributo solo permite al usuario introducir n\u00fameros enteros no negativos.     - Un TextView con id: tvResult donde se muestra el resultado de la comparaci\u00f3n.         - Si el valor introducido por el usuario coincide con el tiempo en segundos que la aplicaci\u00f3n ha estado completamente visible indica \u201c\u00a1correcto!\u201d.         - Si el usuario introduce un valor mayor indica \u201cTe has pasado por X segundos\u201d donde X es la diferencia entre el valor introducido y el correcto.         - Si el usuario introduce un valor menor indica \u201cTe has quedado corto por X segundos\u201d donde X es la diferencia entre el valor introducido y el correcto.     - Un bot\u00f3n con id: bComprobar que lanza la comprobaci\u00f3n. Si al pulsar el bot\u00f3n etNumber no contiene un n\u00famero no negativo se ha de lanzar un mensaje de alerta al usuario.</p> <p>Para la implementaci\u00f3n nos apoyaremos en la clase Chrono que ofrece los siguientes m\u00e9todos:</p> <pre><code>public class Chrono {\n    int time;\n    public Chrono() {\n        this.time = 0;\n    }\n    // Arranca el cron\u00f3metro\n    public void startChrono (){\u2026}\n    // Para el cron\u00f3metro\n    public void stopChrono (){\u2026}\n    // Reinicia el cron\u00f3metro a 0\n    public void resetChrono (){time = 0;}\n    // Devuelve el valor del cron\u00f3metro en segundos\n    public int currentTime() {return time;}\n}\n</code></pre> <ul> <li>(a) (3 puntos) Complete la clase para implementar la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    Chrono chrono;\n    EditText input;\n    TextView output;\n    Button check;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        chrono = new Chrono();\n        input = findViewById(R.id.etNumber);\n        output = findViewById(R.id.tvResult);\n        check = findViewById(R.id.bComprobar);\n\n        check.setOnClickListener(new View.OnClickListener() {\n            public void onClick(View w) {\n                String st = input.getText().toString();\n\n                if (st == null || st.isEmpty()) {\n                    Toast.makeText(\n                        MainActivity.this,\n                        \"Introduce un n\u00famero entero positivo\",\n                        Toast.LENGTH_SHORT\n                    ).show();\n                    return;\n                }\n\n                Integer in = Integer.parseInt(st);\n                if (in != null &amp;&amp; in &gt;= 0) {\n                    int diff = in.intValue() - chrono.currentTime();\n\n                    if (diff == 0) {\n                        output.setText(\"\u00a1Correcto!\");\n                    } else if (diff &gt; 0) {\n                        output.setText(\"Te has pasado por \" + diff + \" segundos.\");\n                    } else {\n                        output.setText(\"Te has quedado corto por \" + (-diff) + \" segundos.\");\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        chrono.startChrono();\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        chrono.stopChrono();\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2019/p1/","title":"Examen 2019 \u2014 Parcial 1","text":""},{"location":"exams/2019/p1/#problema-1","title":"Problema 1","text":"<p>Queremos un algoritmo para calcular el n\u00famero de conjuntos conexos de un grafo no dirigido. Usaremos el modelo de los ejercicios 1 y 2, donde la clase Graph contiene objetos de la clase Node (nodos) y objetos de la clase Link (arcos o enlaces dirigidos ponderados). En lo sucesivo consideraremos que todos los enlaces se han creado con el m\u00e9todo: <pre><code>public void addLink2D (String a, String b, int w) {...}\n</code></pre></p> <p>De esta manera se garantiza que todos los enlaces son bidireccionales.</p> <p>Un conjunto conexo es un conjunto de nodos de un grafo unidos por enlaces directa o indirectamente. Un conjunto de nodos es conexo si existe al menos un camino entre todos los pares de v\u00e9rtices.</p> <p>Ejemplos:</p> <p></p> <ul> <li>(a) (4 puntos) Dise\u00f1e el algoritmo con la siguiente signatura. Nota: Puede desarrollar m\u00e9todos auxiliares si lo necesita. <pre><code>int conjuntosConexos(Graph g) {\n    //TODO a rellenar por el alumno\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Metodos comunes: <pre><code>/**\n * Algoritmo para conseguir todos los nodos vecinos a uno dado.\n *\n * @param g Grafo del que se quiere realizar los c\u00e1lculos\n * @param myNode Nodo del cual se quiere obtener todos los vecinos\n * @return Lista de nodos vecinos a myNode\n */\nList&lt;Node&gt; getNeighbors(Graph g, Node myNode) {\n\n    List&lt;Node&gt; neighbors = new ArrayList&lt;&gt;();\n\n    for (Link link : g.getLinks(myNode)) {\n        Node dst = g.getNode(link.getDst());\n        if (dst != null) {\n            neighbors.add(dst);\n        }\n    }\n    return neighbors;\n}\n</code></pre></p> <p>Soluci\u00f3n Iterativa: <pre><code>int conjuntosConexos(Graph g) {\n    int zones = 0;\n\n    // Se usan dos listas, una para los nodos visitados y otra los que vamos a visitar.\n    List&lt;Node&gt; toVisit = new ArrayList&lt;&gt;();\n    List&lt;Node&gt; visited = new ArrayList&lt;&gt;();\n    Node aNode;\n\n    // Para todos los nodos\n    for (Node myNode : g.getNodes()) {\n        if (!visited.contains(myNode)) {\n\n            // Cada vez que se encuentra un nodo no visitado se a\u00f1ade una zona.\n            zones++;\n\n            // Se a\u00f1ade el nodo en la lista de nodos que hay que visitar\n            toVisit.add(myNode);\n\n            // Mientras queden nodos que visitar\n            while (toVisit.size() &gt; 0) {\n\n                // Se toma el primero\n                aNode = toVisit.get(0);\n\n                // Se a\u00f1ade a los visitados y se quita de los no visitados\n                visited.add(aNode);\n                toVisit.remove(aNode);\n\n                // Se marcan para visitar todos los vecinos que no est\u00e9n visitados\n                for (Node neighbour : getNeighbors(g, aNode)) {\n                    if (!visited.contains(neighbour)) {\n                        toVisit.add(neighbour);\n                    }\n                }\n            }\n        }\n    }\n    return zones;\n}\n</code></pre></p> <p>Soluci\u00f3n Recursiva: <pre><code>/**\n * Algoritmo recursivo que a\u00f1ade todos los nodos del conjunto conexo a la lista\n * visitados\n *\n * @param g Grafo del que se quiere calcular el conjunto conexo\n * @param myNode Nodo donde se empieza a calcular el conjunto conexo\n * @param visited Lista de nodos con los nodos visitados\n */\nvoid visitZone(Graph g, Node myNode, List&lt;Node&gt; visited) {\n\n    // Se a\u00f1ade el nodo al conjunto de visitados\n    visited.add(myNode);\n\n    // Se obtienen los nodos vecinos\n    List&lt;Node&gt; neighbors = getNeighbors(g, myNode);\n\n    // Para todos los vecinos\n    for (Node nodeNeighbour : neighbors) {\n\n        // Si no han sido visitados\n        if (!visited.contains(nodeNeighbour))\n\n            // Se llama recursivamente a este algoritmo para ser visitado\n            visitZone(g, nodeNeighbour, visited);\n    }\n}\n\nint conjuntosConexos(Graph g) {\n\n    // Se inicializan las zonas a 0\n    int zones = 0;\n\n    // Lista de nodos visitados (compartida en las llamadas recursivas)\n    List&lt;Node&gt; visited = new ArrayList&lt;&gt;();\n\n    // Para todos los nodos del grafo\n    for (Node myNode : g.getNodes()) {\n\n        // Si no est\u00e1 visitado\n        if (!visited.contains(myNode)) {\n\n            // Se ha descubierto una zona nueva\n            zones++;\n\n            // Se visita esa zona usando el algoritmo recursivo\n            visitZone(g, myNode, visited);\n        }\n    }\n    return zones;\n}\n</code></pre></p> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 tipo de algoritmo ha dise\u00f1ado? Recursivo/iterativo (Razone su respuesta) </li> </ul> Mostrar soluci\u00f3 <p>La soluci\u00f3n depender\u00e1 del algoritmo desarrollado en la pregunta (a).</p>"},{"location":"exams/2019/p1/#problema-2","title":"Problema 2","text":"<p>Se desea realizar una herramienta de an\u00e1lisis de textos literarios. Una de sus funciones consiste en recorrer el texto extrayendo cada palabra y a\u00f1adi\u00e9ndola a un diccionario. El diccionario tiene como claves las palabras que aparecen en el texto, y como valor el n\u00famero de veces que aparece cada una de ellas, que se actualiza cada vez que se lee una palabra. Al final del proceso se debe ordenar el diccionario, de forma que aparezcan en primer lugar las palabras m\u00e1s utilizadas: <pre><code>while (queda texto sin analizar) {\n    String palabra = siguientePalabra();\n    Diccionario.actualizar(palabra); //a\u00f1adir si no estaba e incrementar no. de apariciones\n}\nDiccionario.ordenar(); // ordenar palabras de mayor a menor n\u00famero de apariciones\n</code></pre></p> <p>Se consideran varias opciones para la implementaci\u00f3n del diccionario:     - (1) Un array ordenado de elementos (palabra, n\u00famero)     - (2) Una tabla hash con direccionamiento abierto     - (3) Una tabla hash con listas de desbordamiento     - (4) Un \u00e1rbol binario de b\u00fasqueda (BST)</p> <p>Suponiendo que los textos analizados contienen como m\u00e1ximo 100.000 palabras:</p> <ul> <li>(a) (3 puntos) Indique las ventajas e inconvenientes de cada opci\u00f3n e indique razonadamente cu\u00e1l ser\u00eda preferible para esta aplicaci\u00f3n, argumentando en t\u00e9rminos de tiempo de ejecuci\u00f3n y ocupaci\u00f3n de memoria.</li> </ul> Mostrar soluci\u00f3n <p>(1) + ocupa la memoria imprescindible; - tiempo de inserci\u00f3n O(n) (hay que insertar la palabra en su sitio). (2) + ocupa la memoria imprescindible; - tiempo de inserci\u00f3n O(1) si la tabla tiene un tama\u00f1o suficiente, pero se dispara si el grado de ocupaci\u00f3n es alto. (3) + tiempo de inserci\u00f3n O(1) si las claves se distribuyen uniformemente; - ocupa memoria adicional para las listas de acceso. (4) - ocupa memoria adicional para los enlaces de los nodos; - tiempo de inserci\u00f3n O(log n).</p> <p>Bas\u00e1ndonos en estas consideraciones, para la primera fase de la aplicaci\u00f3n, en la que s\u00f3lo se hacen inserciones en la tabla, ser\u00eda preferible la opci\u00f3n (3) desde el punto de vista del tiempo de ejecuci\u00f3n, y la opci\u00f3n (1) desde el punto de vista de la ocupaci\u00f3n de memoria.</p> <ul> <li>(b) (2 puntos) Para la opci\u00f3n recomendada, indique razonadamente cu\u00e1l ser\u00eda la mejor forma de implementar la ordenaci\u00f3n final. (2 puntos)</li> </ul> Mostrar soluci\u00f3n <p>Para un hash con listas habr\u00eda que extraer un array con todos los pares  (complejidad O(n) ) y ordenarlo por valores. Se puede usar MergeSort (complejidad O(n log n) ), con lo que la complejidad total ser\u00eda O(n) + O (n log n) = O (n log n). <p>Si el uso de memoria es importante, MergeSort tiene el inconveniente de necesitar memoria adicional O(n). Este caso ser\u00eda preferible usar QuickSort para ordenar el array.</p>"},{"location":"exams/2019/p1_ex01/","title":"P1 ex01","text":"<p>Queremos un algoritmo para calcular el n\u00famero de conjuntos conexos de un grafo no dirigido. Usaremos el modelo de los ejercicios 1 y 2, donde la clase Graph contiene objetos de la clase Node (nodos) y objetos de la clase Link (arcos o enlaces dirigidos ponderados). En lo sucesivo consideraremos que todos los enlaces se han creado con el m\u00e9todo: <pre><code>public void addLink2D (String a, String b, int w) {...}\n</code></pre></p> <p>De esta manera se garantiza que todos los enlaces son bidireccionales.</p> <p>Un conjunto conexo es un conjunto de nodos de un grafo unidos por enlaces directa o indirectamente. Un conjunto de nodos es conexo si existe al menos un camino entre todos los pares de v\u00e9rtices.</p> <p>Ejemplos:</p> <p></p> <ul> <li>(a) (4 puntos) Dise\u00f1e el algoritmo con la siguiente signatura. Nota: Puede desarrollar m\u00e9todos auxiliares si lo necesita. <pre><code>int conjuntosConexos(Graph g) {\n    //TODO a rellenar por el alumno\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Metodos comunes: <pre><code>/**\n * Algoritmo para conseguir todos los nodos vecinos a uno dado.\n *\n * @param g Grafo del que se quiere realizar los c\u00e1lculos\n * @param myNode Nodo del cual se quiere obtener todos los vecinos\n * @return Lista de nodos vecinos a myNode\n */\nList&lt;Node&gt; getNeighbors(Graph g, Node myNode) {\n\n    List&lt;Node&gt; neighbors = new ArrayList&lt;&gt;();\n\n    for (Link link : g.getLinks(myNode)) {\n        Node dst = g.getNode(link.getDst());\n        if (dst != null) {\n            neighbors.add(dst);\n        }\n    }\n    return neighbors;\n}\n</code></pre></p> <p>Soluci\u00f3n Iterativa: <pre><code>int conjuntosConexos(Graph g) {\n    int zones = 0;\n\n    // Se usan dos listas, una para los nodos visitados y otra los que vamos a visitar.\n    List&lt;Node&gt; toVisit = new ArrayList&lt;&gt;();\n    List&lt;Node&gt; visited = new ArrayList&lt;&gt;();\n    Node aNode;\n\n    // Para todos los nodos\n    for (Node myNode : g.getNodes()) {\n        if (!visited.contains(myNode)) {\n\n            // Cada vez que se encuentra un nodo no visitado se a\u00f1ade una zona.\n            zones++;\n\n            // Se a\u00f1ade el nodo en la lista de nodos que hay que visitar\n            toVisit.add(myNode);\n\n            // Mientras queden nodos que visitar\n            while (toVisit.size() &gt; 0) {\n\n                // Se toma el primero\n                aNode = toVisit.get(0);\n\n                // Se a\u00f1ade a los visitados y se quita de los no visitados\n                visited.add(aNode);\n                toVisit.remove(aNode);\n\n                // Se marcan para visitar todos los vecinos que no est\u00e9n visitados\n                for (Node neighbour : getNeighbors(g, aNode)) {\n                    if (!visited.contains(neighbour)) {\n                        toVisit.add(neighbour);\n                    }\n                }\n            }\n        }\n    }\n    return zones;\n}\n</code></pre></p> <p>Soluci\u00f3n Recursiva: <pre><code>/**\n * Algoritmo recursivo que a\u00f1ade todos los nodos del conjunto conexo a la lista\n * visitados\n *\n * @param g Grafo del que se quiere calcular el conjunto conexo\n * @param myNode Nodo donde se empieza a calcular el conjunto conexo\n * @param visited Lista de nodos con los nodos visitados\n */\nvoid visitZone(Graph g, Node myNode, List&lt;Node&gt; visited) {\n\n    // Se a\u00f1ade el nodo al conjunto de visitados\n    visited.add(myNode);\n\n    // Se obtienen los nodos vecinos\n    List&lt;Node&gt; neighbors = getNeighbors(g, myNode);\n\n    // Para todos los vecinos\n    for (Node nodeNeighbour : neighbors) {\n\n        // Si no han sido visitados\n        if (!visited.contains(nodeNeighbour))\n\n            // Se llama recursivamente a este algoritmo para ser visitado\n            visitZone(g, nodeNeighbour, visited);\n    }\n}\n\nint conjuntosConexos(Graph g) {\n\n    // Se inicializan las zonas a 0\n    int zones = 0;\n\n    // Lista de nodos visitados (compartida en las llamadas recursivas)\n    List&lt;Node&gt; visited = new ArrayList&lt;&gt;();\n\n    // Para todos los nodos del grafo\n    for (Node myNode : g.getNodes()) {\n\n        // Si no est\u00e1 visitado\n        if (!visited.contains(myNode)) {\n\n            // Se ha descubierto una zona nueva\n            zones++;\n\n            // Se visita esa zona usando el algoritmo recursivo\n            visitZone(g, myNode, visited);\n        }\n    }\n    return zones;\n}\n</code></pre></p> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 tipo de algoritmo ha dise\u00f1ado? Recursivo/iterativo (Razone su respuesta) </li> </ul> Mostrar soluci\u00f3 <p>La soluci\u00f3n depender\u00e1 del algoritmo desarrollado en la pregunta (a).</p>","tags":["grafos"]},{"location":"exams/2019/p1_ex02/","title":"P1 ex02","text":"<p>Se desea realizar una herramienta de an\u00e1lisis de textos literarios. Una de sus funciones consiste en recorrer el texto extrayendo cada palabra y a\u00f1adi\u00e9ndola a un diccionario. El diccionario tiene como claves las palabras que aparecen en el texto, y como valor el n\u00famero de veces que aparece cada una de ellas, que se actualiza cada vez que se lee una palabra. Al final del proceso se debe ordenar el diccionario, de forma que aparezcan en primer lugar las palabras m\u00e1s utilizadas: <pre><code>while (queda texto sin analizar) {\n    String palabra = siguientePalabra();\n    Diccionario.actualizar(palabra); //a\u00f1adir si no estaba e incrementar no. de apariciones\n}\nDiccionario.ordenar(); // ordenar palabras de mayor a menor n\u00famero de apariciones\n</code></pre></p> <p>Se consideran varias opciones para la implementaci\u00f3n del diccionario:     - (1) Un array ordenado de elementos (palabra, n\u00famero)     - (2) Una tabla hash con direccionamiento abierto     - (3) Una tabla hash con listas de desbordamiento     - (4) Un \u00e1rbol binario de b\u00fasqueda (BST)</p> <p>Suponiendo que los textos analizados contienen como m\u00e1ximo 100.000 palabras:</p> <ul> <li>(a) (3 puntos) Indique las ventajas e inconvenientes de cada opci\u00f3n e indique razonadamente cu\u00e1l ser\u00eda preferible para esta aplicaci\u00f3n, argumentando en t\u00e9rminos de tiempo de ejecuci\u00f3n y ocupaci\u00f3n de memoria.</li> </ul> Mostrar soluci\u00f3n <p>(1) + ocupa la memoria imprescindible; - tiempo de inserci\u00f3n O(n) (hay que insertar la palabra en su sitio). (2) + ocupa la memoria imprescindible; - tiempo de inserci\u00f3n O(1) si la tabla tiene un tama\u00f1o suficiente, pero se dispara si el grado de ocupaci\u00f3n es alto. (3) + tiempo de inserci\u00f3n O(1) si las claves se distribuyen uniformemente; - ocupa memoria adicional para las listas de acceso. (4) - ocupa memoria adicional para los enlaces de los nodos; - tiempo de inserci\u00f3n O(log n).</p> <p>Bas\u00e1ndonos en estas consideraciones, para la primera fase de la aplicaci\u00f3n, en la que s\u00f3lo se hacen inserciones en la tabla, ser\u00eda preferible la opci\u00f3n (3) desde el punto de vista del tiempo de ejecuci\u00f3n, y la opci\u00f3n (1) desde el punto de vista de la ocupaci\u00f3n de memoria.</p> <ul> <li>(b) (2 puntos) Para la opci\u00f3n recomendada, indique razonadamente cu\u00e1l ser\u00eda la mejor forma de implementar la ordenaci\u00f3n final. (2 puntos)</li> </ul> Mostrar soluci\u00f3n <p>Para un hash con listas habr\u00eda que extraer un array con todos los pares  (complejidad O(n) ) y ordenarlo por valores. Se puede usar MergeSort (complejidad O(n log n) ), con lo que la complejidad total ser\u00eda O(n) + O (n log n) = O (n log n). <p>Si el uso de memoria es importante, MergeSort tiene el inconveniente de necesitar memoria adicional O(n). Este caso ser\u00eda preferible usar QuickSort para ordenar el array.</p>","tags":["complejidad"]},{"location":"exams/2019/p1r/","title":"Examen 2019 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2019/p1r/#problema-1","title":"Problema 1","text":"<p>Se construye un \u00e1rbol binario de b\u00fasqueda (BST) cuyos nodos contienen valores enteros. - (a) (1,5 puntos) Dibuje la estructura del \u00e1rbol resultante de insertar los valores 17, 11, 4, 21, 15, 18, en este orden.</p> Mostrar soluci\u00f3n <p></p> <ul> <li>(b) (1,5 puntos) Escriba el resultado que se obtiene al recorrer el \u00e1rbol anterior en postorden.</li> </ul> Mostrar soluci\u00f3n <p>4 15 11 18 21 17</p> <ul> <li>(c) (2 puntos) Se a\u00f1ade al \u00e1rbol un n\u00famero N de valores enteros, generados de forma aleatoria. Para N suficientemente grande, el tiempo necesario para ello depende de la complejidad de la operaci\u00f3n de insertar valores en el \u00e1rbol. Indique razonadamente cu\u00e1l es esta complejidad, justificando el resultado.</li> </ul> Mostrar soluci\u00f3n <p>Para insertar un valor hay que recorrer el \u00e1rbol desde la ra\u00edz hasta encontrar el lugar apropiado donde meterlo. Si los valores se generan aleatoriamente podemos suponer que para N grande el \u00e1rbol est\u00e1 equilibrado, y por tanto, el n\u00famero de niveles que hay que recorrer es k, con N = 2k y k = log2 N. Por tanto, la complejidad del algoritmo es O (log N).</p>"},{"location":"exams/2019/p1r/#problema-2","title":"Problema 2","text":"<p>La soluci\u00f3n debe presentarse en Java y comentando lo que hace el c\u00f3digo. Alternativamente se puede presentar la soluci\u00f3n en pseudoc\u00f3digo.</p> <p>Se debe implementar los tres m\u00e9todos principales de una clase llamada ListaEnlazadaOrdenada: a\u00f1adirValor, eliminarValor y buscarElementoAnterior.</p> <p>El objetivo de dicha clase consiste en mantener un conjunto de objetos de la clase Elemento ordenados de menor a mayor. La clase ListaEnlazadaOrdenada solo tendr\u00e1 un variable de clase que ser\u00e1 el primer objeto Elemento.</p> <p>La lista debe mantenerse ordenada en todo momento.</p> <p>La clase Elemento est\u00e1 implementada y podemos utilizarla seg\u00fan la descripci\u00f3n de m\u00e9todos que se muestran a continuaci\u00f3n: <pre><code>Elemento (int valor)\nElemento getSiguiente()\nvoid setSiguiente (Elemento siguiente)\nint getValor()\n</code></pre> La clase Elemento almacena un entero que pasamos en el m\u00e9todo constructor. Adem\u00e1s, guarda un enlace al siguiente objeto de la clase Elemento que le sucede. El constructor inicializa el enlace al siguiente objeto Elemento a null.</p> <p>La clase ListaEnlazadaOrdenada deber\u00e1 usar los m\u00e9todos setSiguiente y getSiguiente para mantener el orden entre los objetos de la clase Elemento. Si no hubiera siguiente elemento entonces el valor para el siguiente ser\u00e1 null.</p> <p>Descripci\u00f3n de los m\u00e9todos que deber\u00e1 implementar de la clase ListaEnlazadaOrdenada:</p> <pre><code>private Elemento buscarElementoAnterior (int valor) {...}\n</code></pre> <p>Se recomienda empezar por este m\u00e9todo ya que va a resultar muy \u00fatil para la realizaci\u00f3n de los m\u00e9todos a\u00f1adirValor y eliminarValor.</p> <p>Este m\u00e9todo busca y devuelve un objeto Elemento en la ListaEnlazadaOrdenada. La lista est\u00e1 ordenada de menor a mayor, por lo tanto, el Elemento que devuelve debe ser el que tenga el valor m\u00e1s peque\u00f1o al que se pasa por par\u00e1metro en el par\u00e1metro valor.</p> <pre><code>public boolean a\u00f1adirValor (int valor) {...}\n</code></pre> <p>Este m\u00e9todo debe a\u00f1adir un objeto Elemento nuevo que contenga el entero valor que se pasa por par\u00e1metro. Se debe mantener el orden. Se pueden a\u00f1adir varios elementos con el mismo valor.</p> <p>Devuelve true cuando se ha podido a\u00f1adir el objeto Elemento con el valor que se pasa por par\u00e1metro.</p> <p>Devuelve false cuando NO se ha podido a\u00f1adir el objeto Elemento con el valor que se pasa por par\u00e1metro.</p> <pre><code>public boolean eliminarValor (int valor) {...}\n</code></pre> <p>Este m\u00e9todo debe eliminar un objeto Elemento que contenga el entero valor que se pasa por par\u00e1metro al m\u00e9todo. Despu\u00e9s de eliminar el Elemento debe garantizar que se mantenga el orden de la lista.</p> <p>Devuelve true cuando se ha podido eliminar el objeto Elemento con el valor que se pasa por par\u00e1metro.</p> <p>Devuelve false cuando NO se ha podido eliminar el objeto Elemento con el valor que se pasa por par\u00e1metro.</p> <p>Notas: No se pueden utilizar estructuras de datos adicionales como Listas, ArrayList, HashSet, Maps, Diccionarios, etc. Solo las clases Elemento y ListaEnlazadaOrdenada. No se trata de un array, por lo tanto, no se pueden hacer accesos del tipo miLista[posicion] o miLista[14].</p> <p>Ejemplos:</p> <p></p> <p></p> <ul> <li>(a) (1,5 puntos) Implementar el m\u00e9todo <code>public boolean a\u00f1adirValor (int valor)</code> de la clase ListaEnlazadaOrdenada.</li> </ul> Mostrar soluci\u00f3n <pre><code>public boolean addValor(int valor) {\n\n    // Creamos el elemento que queremos insertar\n    Elemento elementoNuevo = new Elemento(valor);\n\n    // Si la lista est\u00e1 vac\u00eda\n    if (this.primerElemento == null) {\n        this.primerElemento = elementoNuevo;\n        return true;\n    }\n\n    // Buscamos el elemento anterior al punto de inserci\u00f3n\n    Elemento anterior = searchAnterior(valor);\n\n    // Si no hay anterior, se inserta en la cabeza de la lista\n    if (anterior == null) {\n        elementoNuevo.setSiguiente(this.primerElemento);\n        this.primerElemento = elementoNuevo;\n        return true;\n    }\n\n    // Si la inserci\u00f3n se hace en medio de la lista\n    else if (anterior.getSiguiente() != null) {\n        Elemento elementoCentral = anterior.getSiguiente();\n        elementoNuevo.setSiguiente(elementoCentral);\n        anterior.setSiguiente(elementoNuevo);\n        return true;\n    }\n\n    // Si la inserci\u00f3n se hace al final de la lista\n    else {\n        anterior.setSiguiente(elementoNuevo);\n        return true;\n    }\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Implementar el m\u00e9todo <code>public boolean eliminarValor (int valor)</code> de la clase ListaEnlazadaOrdenada.</li> </ul> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para eliminar el valor que nos mandan como par\u00e1metro\n// Devuelve true si lo ha eliminado\n// Devuelve false si no lo ha eliminado\npublic boolean removeValor(int valor) {\n\n    // Si el primer elemento es null, no podemos eliminar nada\n    if (this.primerElemento == null)\n        return false;\n\n    // Buscamos el elemento anterior al que queremos eliminar\n    Elemento anterior = searchAnterior(valor);\n\n    // Si no hay anterior, el elemento a eliminar podr\u00eda ser el primero\n    if (anterior == null) {\n\n        // Se trata del primer elemento\n        if (this.primerElemento.getValor() == valor) {\n            this.primerElemento = this.primerElemento.getSiguiente();\n            return true;\n        }\n        // No es el primer elemento\n        else {\n            return false;\n        }\n    }\n\n    // Si la eliminaci\u00f3n se hace en medio de la lista\n    else if (anterior.getSiguiente() != null) {\n\n        // Si el siguiente es el que queremos eliminar\n        if (anterior.getSiguiente().getValor() == valor) {\n            Elemento elementoCentralAEliminar = anterior.getSiguiente();\n            Elemento elementoSiguiente =\n                    elementoCentralAEliminar.getSiguiente();\n            anterior.setSiguiente(elementoSiguiente);\n            return true;\n        }\n        // El siguiente no es el que queremos eliminar\n        else {\n            return false;\n        }\n    }\n\n    // Si se intenta eliminar al final sin coincidencia\n    else {\n        return false;\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Implementar el m\u00e9todo <code>private Elemento buscarElementoAnterior (int valor)</code> de la clase ListaEnlazadaOrdenada.</li> </ul> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para buscar el elemento anterior. Nos va a servir para poder\n// implementar el resto de m\u00e9todos\n// Devuelve null si no hay primerElemento, o si donde hay que insertar es al inicio.\nprivate Elemento searchAnterior(int valor) {\n\n    // Si la lista est\u00e1 vac\u00eda no hay anterior, se devuelve null\n    if (this.primerElemento == null)\n        return null;\n\n    // Inicializamos dos variables para la b\u00fasqueda de la posici\u00f3n:\n    // - elementoIterador: recorre la lista\n    // - anterior: ser\u00e1 el elemento que devolveremos\n    Elemento elementoIterador = primerElemento;\n    Elemento anterior = null;\n\n    // Usamos un bucle while(true) porque siempre habr\u00e1 al menos una iteraci\u00f3n\n    while (true) {\n\n        // Si el valor a insertar es mayor que el valor del iterador\n        if (valor &gt; elementoIterador.getValor()) {\n\n            // Si no es el \u00faltimo elemento, avanzamos\n            if (elementoIterador.getSiguiente() != null) {\n                anterior = elementoIterador;\n                elementoIterador = elementoIterador.getSiguiente();\n\n            // Si el siguiente es null, se inserta al final\n            } else {\n                return elementoIterador;\n            }\n\n        // Si el valor a insertar es menor o igual, devolvemos el anterior\n        } else {\n            return anterior;\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2019/p1r_ex01/","title":"P1r ex01","text":"<p>Se construye un \u00e1rbol binario de b\u00fasqueda (BST) cuyos nodos contienen valores enteros. - (a) (1,5 puntos) Dibuje la estructura del \u00e1rbol resultante de insertar los valores 17, 11, 4, 21, 15, 18, en este orden.</p> Mostrar soluci\u00f3n <p></p> <ul> <li>(b) (1,5 puntos) Escriba el resultado que se obtiene al recorrer el \u00e1rbol anterior en postorden.</li> </ul> Mostrar soluci\u00f3n <p>4 15 11 18 21 17</p> <ul> <li>(c) (2 puntos) Se a\u00f1ade al \u00e1rbol un n\u00famero N de valores enteros, generados de forma aleatoria. Para N suficientemente grande, el tiempo necesario para ello depende de la complejidad de la operaci\u00f3n de insertar valores en el \u00e1rbol. Indique razonadamente cu\u00e1l es esta complejidad, justificando el resultado.</li> </ul> Mostrar soluci\u00f3n <p>Para insertar un valor hay que recorrer el \u00e1rbol desde la ra\u00edz hasta encontrar el lugar apropiado donde meterlo. Si los valores se generan aleatoriamente podemos suponer que para N grande el \u00e1rbol est\u00e1 equilibrado, y por tanto, el n\u00famero de niveles que hay que recorrer es k, con N = 2k y k = log2 N. Por tanto, la complejidad del algoritmo es O (log N).</p>","tags":["complejidad"]},{"location":"exams/2019/p1r_ex02/","title":"P1r ex02","text":"<p>La soluci\u00f3n debe presentarse en Java y comentando lo que hace el c\u00f3digo. Alternativamente se puede presentar la soluci\u00f3n en pseudoc\u00f3digo.</p> <p>Se debe implementar los tres m\u00e9todos principales de una clase llamada ListaEnlazadaOrdenada: a\u00f1adirValor, eliminarValor y buscarElementoAnterior.</p> <p>El objetivo de dicha clase consiste en mantener un conjunto de objetos de la clase Elemento ordenados de menor a mayor. La clase ListaEnlazadaOrdenada solo tendr\u00e1 un variable de clase que ser\u00e1 el primer objeto Elemento.</p> <p>La lista debe mantenerse ordenada en todo momento.</p> <p>La clase Elemento est\u00e1 implementada y podemos utilizarla seg\u00fan la descripci\u00f3n de m\u00e9todos que se muestran a continuaci\u00f3n: <pre><code>Elemento (int valor)\nElemento getSiguiente()\nvoid setSiguiente (Elemento siguiente)\nint getValor()\n</code></pre> La clase Elemento almacena un entero que pasamos en el m\u00e9todo constructor. Adem\u00e1s, guarda un enlace al siguiente objeto de la clase Elemento que le sucede. El constructor inicializa el enlace al siguiente objeto Elemento a null.</p> <p>La clase ListaEnlazadaOrdenada deber\u00e1 usar los m\u00e9todos setSiguiente y getSiguiente para mantener el orden entre los objetos de la clase Elemento. Si no hubiera siguiente elemento entonces el valor para el siguiente ser\u00e1 null.</p> <p>Descripci\u00f3n de los m\u00e9todos que deber\u00e1 implementar de la clase ListaEnlazadaOrdenada:</p> <pre><code>private Elemento buscarElementoAnterior (int valor) {...}\n</code></pre> <p>Se recomienda empezar por este m\u00e9todo ya que va a resultar muy \u00fatil para la realizaci\u00f3n de los m\u00e9todos a\u00f1adirValor y eliminarValor.</p> <p>Este m\u00e9todo busca y devuelve un objeto Elemento en la ListaEnlazadaOrdenada. La lista est\u00e1 ordenada de menor a mayor, por lo tanto, el Elemento que devuelve debe ser el que tenga el valor m\u00e1s peque\u00f1o al que se pasa por par\u00e1metro en el par\u00e1metro valor.</p> <pre><code>public boolean a\u00f1adirValor (int valor) {...}\n</code></pre> <p>Este m\u00e9todo debe a\u00f1adir un objeto Elemento nuevo que contenga el entero valor que se pasa por par\u00e1metro. Se debe mantener el orden. Se pueden a\u00f1adir varios elementos con el mismo valor.</p> <p>Devuelve true cuando se ha podido a\u00f1adir el objeto Elemento con el valor que se pasa por par\u00e1metro.</p> <p>Devuelve false cuando NO se ha podido a\u00f1adir el objeto Elemento con el valor que se pasa por par\u00e1metro.</p> <pre><code>public boolean eliminarValor (int valor) {...}\n</code></pre> <p>Este m\u00e9todo debe eliminar un objeto Elemento que contenga el entero valor que se pasa por par\u00e1metro al m\u00e9todo. Despu\u00e9s de eliminar el Elemento debe garantizar que se mantenga el orden de la lista.</p> <p>Devuelve true cuando se ha podido eliminar el objeto Elemento con el valor que se pasa por par\u00e1metro.</p> <p>Devuelve false cuando NO se ha podido eliminar el objeto Elemento con el valor que se pasa por par\u00e1metro.</p> <p>Notas: No se pueden utilizar estructuras de datos adicionales como Listas, ArrayList, HashSet, Maps, Diccionarios, etc. Solo las clases Elemento y ListaEnlazadaOrdenada. No se trata de un array, por lo tanto, no se pueden hacer accesos del tipo miLista[posicion] o miLista[14].</p> <p>Ejemplos:</p> <p></p> <p></p> <ul> <li>(a) (1,5 puntos) Implementar el m\u00e9todo <code>public boolean a\u00f1adirValor (int valor)</code> de la clase ListaEnlazadaOrdenada.</li> </ul> Mostrar soluci\u00f3n <pre><code>public boolean addValor(int valor) {\n\n    // Creamos el elemento que queremos insertar\n    Elemento elementoNuevo = new Elemento(valor);\n\n    // Si la lista est\u00e1 vac\u00eda\n    if (this.primerElemento == null) {\n        this.primerElemento = elementoNuevo;\n        return true;\n    }\n\n    // Buscamos el elemento anterior al punto de inserci\u00f3n\n    Elemento anterior = searchAnterior(valor);\n\n    // Si no hay anterior, se inserta en la cabeza de la lista\n    if (anterior == null) {\n        elementoNuevo.setSiguiente(this.primerElemento);\n        this.primerElemento = elementoNuevo;\n        return true;\n    }\n\n    // Si la inserci\u00f3n se hace en medio de la lista\n    else if (anterior.getSiguiente() != null) {\n        Elemento elementoCentral = anterior.getSiguiente();\n        elementoNuevo.setSiguiente(elementoCentral);\n        anterior.setSiguiente(elementoNuevo);\n        return true;\n    }\n\n    // Si la inserci\u00f3n se hace al final de la lista\n    else {\n        anterior.setSiguiente(elementoNuevo);\n        return true;\n    }\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Implementar el m\u00e9todo <code>public boolean eliminarValor (int valor)</code> de la clase ListaEnlazadaOrdenada.</li> </ul> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para eliminar el valor que nos mandan como par\u00e1metro\n// Devuelve true si lo ha eliminado\n// Devuelve false si no lo ha eliminado\npublic boolean removeValor(int valor) {\n\n    // Si el primer elemento es null, no podemos eliminar nada\n    if (this.primerElemento == null)\n        return false;\n\n    // Buscamos el elemento anterior al que queremos eliminar\n    Elemento anterior = searchAnterior(valor);\n\n    // Si no hay anterior, el elemento a eliminar podr\u00eda ser el primero\n    if (anterior == null) {\n\n        // Se trata del primer elemento\n        if (this.primerElemento.getValor() == valor) {\n            this.primerElemento = this.primerElemento.getSiguiente();\n            return true;\n        }\n        // No es el primer elemento\n        else {\n            return false;\n        }\n    }\n\n    // Si la eliminaci\u00f3n se hace en medio de la lista\n    else if (anterior.getSiguiente() != null) {\n\n        // Si el siguiente es el que queremos eliminar\n        if (anterior.getSiguiente().getValor() == valor) {\n            Elemento elementoCentralAEliminar = anterior.getSiguiente();\n            Elemento elementoSiguiente =\n                    elementoCentralAEliminar.getSiguiente();\n            anterior.setSiguiente(elementoSiguiente);\n            return true;\n        }\n        // El siguiente no es el que queremos eliminar\n        else {\n            return false;\n        }\n    }\n\n    // Si se intenta eliminar al final sin coincidencia\n    else {\n        return false;\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Implementar el m\u00e9todo <code>private Elemento buscarElementoAnterior (int valor)</code> de la clase ListaEnlazadaOrdenada.</li> </ul> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para buscar el elemento anterior. Nos va a servir para poder\n// implementar el resto de m\u00e9todos\n// Devuelve null si no hay primerElemento, o si donde hay que insertar es al inicio.\nprivate Elemento searchAnterior(int valor) {\n\n    // Si la lista est\u00e1 vac\u00eda no hay anterior, se devuelve null\n    if (this.primerElemento == null)\n        return null;\n\n    // Inicializamos dos variables para la b\u00fasqueda de la posici\u00f3n:\n    // - elementoIterador: recorre la lista\n    // - anterior: ser\u00e1 el elemento que devolveremos\n    Elemento elementoIterador = primerElemento;\n    Elemento anterior = null;\n\n    // Usamos un bucle while(true) porque siempre habr\u00e1 al menos una iteraci\u00f3n\n    while (true) {\n\n        // Si el valor a insertar es mayor que el valor del iterador\n        if (valor &gt; elementoIterador.getValor()) {\n\n            // Si no es el \u00faltimo elemento, avanzamos\n            if (elementoIterador.getSiguiente() != null) {\n                anterior = elementoIterador;\n                elementoIterador = elementoIterador.getSiguiente();\n\n            // Si el siguiente es null, se inserta al final\n            } else {\n                return elementoIterador;\n            }\n\n        // Si el valor a insertar es menor o igual, devolvemos el anterior\n        } else {\n            return anterior;\n        }\n    }\n}\n</code></pre>","tags":["???"]},{"location":"exams/2019/p2/","title":"Examen 2019 \u2014 Parcial 2","text":""},{"location":"exams/2019/p2/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un sistema de gesti\u00f3n de eventos. Este sistema est\u00e1 compuesto por un conjunto de productores y consumidores. Los productores ponen eventos con una prioridad asociada en el sistema. Los consumidores recogen eventos del sistema para procesarlos.</p> <p>Los eventos se representan con la clase Event definida como sigue (no hay que desarrollarla): <pre><code>public class Event {\n    private EventInformation info;\n    private EventPriority priority;\n    // getters &amp; setters\n}\n</code></pre> EventInformation indica la informaci\u00f3n asociada al evento. No es necesario conocer los detalles de esta clase, ni desarrollarla. </p> <p>EventPriority indica la prioridad del evento, definida como sigue: <pre><code>public enum EventPriority {High, Low}\n</code></pre></p> <p>Dado el siguiente esquema: <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos de cada nivel de prioridad que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = ...;\n    ...\n    /** A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes\n    * con la prioridad correspondiente es igual al m\u00e1ximo, la hebra que\n    * llama se bloquea hasta que haya hueco\n    */\n    ... void putEvent (Event anEvent) {...}\n    /** Recuperar un evento para su procesamiento. Devuelve un evento de prioridad High\n    * si lo hay, si no un evento de prioridad Low, y si tampoco hay ninguno se bloquea\n    * la hebra que llama hasta que haya alguno.\n    */\n    ... Event getEvent() {...}\n    /** N\u00famero total de eventos pendientes de procesamiento. */\n    ... int getPendingEvents() {...}\n}\n</code></pre></p> <ul> <li>(a) (4,5 puntos) Desarrolle el monitor EventManager. Se puede utilizar el siguiente esquema: <pre><code>public class Buffer {\n\n    private Event[] b;\n    private int in, out, count;\n\n    public Buffer (int size) {\n        b = new Event[size]; I\n        in = 0; out = 0; count = 0;\n    }\n\n    public void put (Event e) {\n        b[in] = e;\n        in = (in + 1) % b.length; ++count;\n    }\n\n    public Event get() {\n        Event e = boOut];\n        out = (out + 1) % b.length; --count;\n        return e;\n    }\n\n    public int getCount() { return count;}\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorEventos {\n\n    private int MaxPendingEvents;\n    private Buffer highPriority;\n    private Buffer lowPriority;\n\n    public GestorEventos(int MaxPendingEvents) {\n        this.MaxPendingEvents = MaxPendingEvents;\n        highPriority = new Buffer(MaxPendingEvents);\n        lowPriority = new Buffer(MaxPendingEvents);\n    }\n\n    public synchronized void PutEvent(Event anEvent) \n            throws InterruptedException {\n\n        if (anEvent.getPriority() == EventPriority.High) {\n\n            while (highPriority.GetCount() == MaxPendingEvents) {\n                wait();\n            }\n            highPriority.Put(anEvent);\n\n        } else {\n\n            while (lowPriority.GetCount() == MaxPendingEvents) {\n                wait();\n            }\n            lowPriority.Put(anEvent);\n        }\n\n        notifyAll();\n    }\n\n    public synchronized Event GetEvent() \n            throws InterruptedException {\n\n        while (highPriority.GetCount() == 0 &amp;&amp;\n               lowPriority.GetCount() == 0) {\n            wait();\n        }\n\n        if (highPriority.GetCount() &gt; 0) {\n            notifyAll();\n            return highPriority.Get();\n        }\n\n        notifyAll();\n        return lowPriority.Get();\n    }\n\n    public synchronized int GetPendingEvents() {\n        return lowPriority.GetCount() + highPriority.GetCount();\n    }\n}\n</code></pre> <p>Suponiendo que el tiempo de proceso de los consumidores es mayor que el de los productores, puede ocurrir que las colas de eventos pendientes se mantengan llenas durante un tiempo prolongado y, por tanto, se bloqueen los productores.</p> <ul> <li>(b) (2,5 puntos) Para corregir este problema, se pide desarrollar una clase ThreadManager que cree hebras consumidoras cuando el n\u00famero de eventos pendientes sea mayor al 90 % del n\u00famero m\u00e1ximo de eventos. Esta clase responde al siguiente esquema: <pre><code>public class ThreadManager {\n    private final int DELAY = ...; //intervalo de comprobaci\u00f3n (ms)\n    ...\n    public void main(...) {\n        while(true) {\n            Thread.sleep(DELAY);\n            // comprobar si el n\u00famero de eventos pendientes es mayor que el 90% del m\u00e1ximo\n            // en ese caso, crear una nueva hebra de clase Consumer\n        }\n    }\n}\n</code></pre></li> </ul> <p>La clase Consumer responde al esquema siguiente y no es necesario desarrollarla: <pre><code>public class Consumer\n    extends Thread {\n        public Consumer(...) {...}\n        public void run() {...}\n}\n</code></pre></p> Mostrar soluci\u00f3n <pre><code>public class ThreadManager {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        int DELAY = 10000; // intervalo de comprobaci\u00f3n (ms)\n        Consumer c;\n\n        // Obtener un gestor. No se hab\u00eda que hacer\n        GestorEventos gestor = ...;\n\n        while (true) {\n\n            Thread.sleep(DELAY);\n\n            if (gestor.GetPendingEvents() &gt; gestor.MAX_PENDING_EVENTS * 0.9) {\n                Consumer consumer = new Consumer(gestor);\n                consumer.start();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2019/p2/#problema-2","title":"Problema 2","text":"<p>Se desea programar una aplicaci\u00f3n llamada ParApp, que recibiendo una entrada de texto del usuario indique si su tama\u00f1o es par o impar. Para ello, recibimos una interfaz gr\u00e1fica ya dise\u00f1ada que incluye:     - Un EditText con id \u201cetEntrada\u201d     - Un TextView con id \u201ctvResultado\u201d     - Un bot\u00f3n con id \u201cbComprobar\u201d</p> <p>Cuando el usuario pulsa el bot\u00f3n se ha de comprobar el tama\u00f1o de la cadena de texto introducida en el campo de entrada de texto. Pueden darse 3 situaciones:     - Si el tama\u00f1o de texto es 0, se ha de lanzar un aviso al usuario para que introduzca una cadena de texto.     - Si el tama\u00f1o es par, el campo de texto de salida se actualiza con el siguiente mensaje: \u201cEl texto introducido tiene un tama\u00f1o par\u201d seguido del tama\u00f1o de la cadena entre par\u00e9ntesis. Ej: (6).     - Si el tama\u00f1o es impar, el campo de texto de salida se actualiza con el siguiente mensaje: \u201cEl texto introducido tiene un tama\u00f1o impar\u201d seguido del tama\u00f1o de la cadena entre par\u00e9ntesis. Ej: (5).</p> <ul> <li>(a) (0,5 puntos) \u00bfMediante qu\u00e9 atributo asociar\u00eda la ejecuci\u00f3n de un m\u00e9todo Java cuando el bot\u00f3n es pulsado por el usuario?</li> </ul> Mostrar soluci\u00f3n <pre><code>onClick\n</code></pre> <ul> <li>(b) (2,5 puntos) Programe un m\u00e9todo calculoParidad que implemente la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void CompruebaParidad(View V) {\n\n    EditText et = findViewById(R.id.etEntrada);\n    TextView tv = findViewById(R.id.tvResultado);\n\n    int len = et.getText().toString().length();\n\n    if (len == 0) {\n        Toast.makeText(this, \"Introduzca texto\", Toast.LENGTH_SHORT).show();\n        tv.setText(\"\");\n    } \n    else if (len % 2 == 0) {\n        tv.setText(\"Es par (\" + len + \")\");\n    } \n    else {\n        tv.setText(\"Es impar (\" + len + \")\");\n    }\n}\n</code></pre>"},{"location":"exams/2019/p2_ex01/","title":"P2 ex01","text":"<p>Se quiere desarrollar un sistema de gesti\u00f3n de eventos. Este sistema est\u00e1 compuesto por un conjunto de productores y consumidores. Los productores ponen eventos con una prioridad asociada en el sistema. Los consumidores recogen eventos del sistema para procesarlos.</p> <p>Los eventos se representan con la clase Event definida como sigue (no hay que desarrollarla): <pre><code>public class Event {\n    private EventInformation info;\n    private EventPriority priority;\n    // getters &amp; setters\n}\n</code></pre> EventInformation indica la informaci\u00f3n asociada al evento. No es necesario conocer los detalles de esta clase, ni desarrollarla. </p> <p>EventPriority indica la prioridad del evento, definida como sigue: <pre><code>public enum EventPriority {High, Low}\n</code></pre></p> <p>Dado el siguiente esquema: <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos de cada nivel de prioridad que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = ...;\n    ...\n    /** A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes\n    * con la prioridad correspondiente es igual al m\u00e1ximo, la hebra que\n    * llama se bloquea hasta que haya hueco\n    */\n    ... void putEvent (Event anEvent) {...}\n    /** Recuperar un evento para su procesamiento. Devuelve un evento de prioridad High\n    * si lo hay, si no un evento de prioridad Low, y si tampoco hay ninguno se bloquea\n    * la hebra que llama hasta que haya alguno.\n    */\n    ... Event getEvent() {...}\n    /** N\u00famero total de eventos pendientes de procesamiento. */\n    ... int getPendingEvents() {...}\n}\n</code></pre></p> <ul> <li>(a) (4,5 puntos) Desarrolle el monitor EventManager. Se puede utilizar el siguiente esquema: <pre><code>public class Buffer {\n\n    private Event[] b;\n    private int in, out, count;\n\n    public Buffer (int size) {\n        b = new Event[size]; I\n        in = 0; out = 0; count = 0;\n    }\n\n    public void put (Event e) {\n        b[in] = e;\n        in = (in + 1) % b.length; ++count;\n    }\n\n    public Event get() {\n        Event e = boOut];\n        out = (out + 1) % b.length; --count;\n        return e;\n    }\n\n    public int getCount() { return count;}\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorEventos {\n\n    private int MaxPendingEvents;\n    private Buffer highPriority;\n    private Buffer lowPriority;\n\n    public GestorEventos(int MaxPendingEvents) {\n        this.MaxPendingEvents = MaxPendingEvents;\n        highPriority = new Buffer(MaxPendingEvents);\n        lowPriority = new Buffer(MaxPendingEvents);\n    }\n\n    public synchronized void PutEvent(Event anEvent) \n            throws InterruptedException {\n\n        if (anEvent.getPriority() == EventPriority.High) {\n\n            while (highPriority.GetCount() == MaxPendingEvents) {\n                wait();\n            }\n            highPriority.Put(anEvent);\n\n        } else {\n\n            while (lowPriority.GetCount() == MaxPendingEvents) {\n                wait();\n            }\n            lowPriority.Put(anEvent);\n        }\n\n        notifyAll();\n    }\n\n    public synchronized Event GetEvent() \n            throws InterruptedException {\n\n        while (highPriority.GetCount() == 0 &amp;&amp;\n               lowPriority.GetCount() == 0) {\n            wait();\n        }\n\n        if (highPriority.GetCount() &gt; 0) {\n            notifyAll();\n            return highPriority.Get();\n        }\n\n        notifyAll();\n        return lowPriority.Get();\n    }\n\n    public synchronized int GetPendingEvents() {\n        return lowPriority.GetCount() + highPriority.GetCount();\n    }\n}\n</code></pre> <p>Suponiendo que el tiempo de proceso de los consumidores es mayor que el de los productores, puede ocurrir que las colas de eventos pendientes se mantengan llenas durante un tiempo prolongado y, por tanto, se bloqueen los productores.</p> <ul> <li>(b) (2,5 puntos) Para corregir este problema, se pide desarrollar una clase ThreadManager que cree hebras consumidoras cuando el n\u00famero de eventos pendientes sea mayor al 90 % del n\u00famero m\u00e1ximo de eventos. Esta clase responde al siguiente esquema: <pre><code>public class ThreadManager {\n    private final int DELAY = ...; //intervalo de comprobaci\u00f3n (ms)\n    ...\n    public void main(...) {\n        while(true) {\n            Thread.sleep(DELAY);\n            // comprobar si el n\u00famero de eventos pendientes es mayor que el 90% del m\u00e1ximo\n            // en ese caso, crear una nueva hebra de clase Consumer\n        }\n    }\n}\n</code></pre></li> </ul> <p>La clase Consumer responde al esquema siguiente y no es necesario desarrollarla: <pre><code>public class Consumer\n    extends Thread {\n        public Consumer(...) {...}\n        public void run() {...}\n}\n</code></pre></p> Mostrar soluci\u00f3n <pre><code>public class ThreadManager {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        int DELAY = 10000; // intervalo de comprobaci\u00f3n (ms)\n        Consumer c;\n\n        // Obtener un gestor. No se hab\u00eda que hacer\n        GestorEventos gestor = ...;\n\n        while (true) {\n\n            Thread.sleep(DELAY);\n\n            if (gestor.GetPendingEvents() &gt; gestor.MAX_PENDING_EVENTS * 0.9) {\n                Consumer consumer = new Consumer(gestor);\n                consumer.start();\n            }\n        }\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2019/p2_ex02/","title":"P2 ex02","text":"<p>Se desea programar una aplicaci\u00f3n llamada ParApp, que recibiendo una entrada de texto del usuario indique si su tama\u00f1o es par o impar. Para ello, recibimos una interfaz gr\u00e1fica ya dise\u00f1ada que incluye:     - Un EditText con id \u201cetEntrada\u201d     - Un TextView con id \u201ctvResultado\u201d     - Un bot\u00f3n con id \u201cbComprobar\u201d</p> <p>Cuando el usuario pulsa el bot\u00f3n se ha de comprobar el tama\u00f1o de la cadena de texto introducida en el campo de entrada de texto. Pueden darse 3 situaciones:     - Si el tama\u00f1o de texto es 0, se ha de lanzar un aviso al usuario para que introduzca una cadena de texto.     - Si el tama\u00f1o es par, el campo de texto de salida se actualiza con el siguiente mensaje: \u201cEl texto introducido tiene un tama\u00f1o par\u201d seguido del tama\u00f1o de la cadena entre par\u00e9ntesis. Ej: (6).     - Si el tama\u00f1o es impar, el campo de texto de salida se actualiza con el siguiente mensaje: \u201cEl texto introducido tiene un tama\u00f1o impar\u201d seguido del tama\u00f1o de la cadena entre par\u00e9ntesis. Ej: (5).</p> <ul> <li>(a) (0,5 puntos) \u00bfMediante qu\u00e9 atributo asociar\u00eda la ejecuci\u00f3n de un m\u00e9todo Java cuando el bot\u00f3n es pulsado por el usuario?</li> </ul> Mostrar soluci\u00f3n <pre><code>onClick\n</code></pre> <ul> <li>(b) (2,5 puntos) Programe un m\u00e9todo calculoParidad que implemente la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void CompruebaParidad(View V) {\n\n    EditText et = findViewById(R.id.etEntrada);\n    TextView tv = findViewById(R.id.tvResultado);\n\n    int len = et.getText().toString().length();\n\n    if (len == 0) {\n        Toast.makeText(this, \"Introduzca texto\", Toast.LENGTH_SHORT).show();\n        tv.setText(\"\");\n    } \n    else if (len % 2 == 0) {\n        tv.setText(\"Es par (\" + len + \")\");\n    } \n    else {\n        tv.setText(\"Es impar (\" + len + \")\");\n    }\n}\n</code></pre>","tags":["???"]},{"location":"exams/2019/pract/","title":"Examen 2019 \u2014 Pr\u00e1cticas","text":""},{"location":"exams/2019/pract/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (5 puntos) Se requiere una clase de pruebas JUnit para comprobar la correcta implementaci\u00f3n del monitor de lectura-escritura RW_Monitor del ejercicio 3. Complete la siguiente clase con, al menos, 5 pruebas distintas que prueben diferentes posibles situaciones. En particular debe incluir, al menos una prueba que verifique un n\u00famero correcto de lectores dentro del monitor despu\u00e9s de una secuencia correcta de peticiones de acceso y otra prueba que fuerce el lanzamiento de una excepci\u00f3n dentro del monitor.</li> </ul> <p>Considere importadas todas las funcionalidades del paquete org.junit y valore la necesidad de ejecutar alg\u00fan m\u00e9todo antes y/o despu\u00e9s de cada test. <pre><code>public class MonitorTest {\n</code></pre></p>"},{"location":"exams/2019/pract_ex01/","title":"Pract ex01","text":"<ul> <li>(a) (5 puntos) Se requiere una clase de pruebas JUnit para comprobar la correcta implementaci\u00f3n del monitor de lectura-escritura RW_Monitor del ejercicio 3. Complete la siguiente clase con, al menos, 5 pruebas distintas que prueben diferentes posibles situaciones. En particular debe incluir, al menos una prueba que verifique un n\u00famero correcto de lectores dentro del monitor despu\u00e9s de una secuencia correcta de peticiones de acceso y otra prueba que fuerce el lanzamiento de una excepci\u00f3n dentro del monitor.</li> </ul> <p>Considere importadas todas las funcionalidades del paquete org.junit y valore la necesidad de ejecutar alg\u00fan m\u00e9todo antes y/o despu\u00e9s de cada test. <pre><code>public class MonitorTest {\n</code></pre></p>","tags":["???"]},{"location":"exams/2021/extra/","title":"Examen 2021 \u2014 Extraordinario","text":""},{"location":"exams/2021/extra/#problema-1","title":"Problema 1","text":"<p>Un sistema real se describe como un grafo no dirigido. Los arcos o aristas (edge) tienen un coste o peso mayor que cero. Un camino es una secuencia de arcos que conectan dos nodos o v\u00e9rtices. Un camino se representa mediante una lista (List). En este sistema, interesa agrupar a todos los posibles caminos entre dos nodos concretos, que se representa mediante una lista de caminos (List&gt;). <p>Se pide desarrollar dos m\u00e9todos, descritos en el cuadro adjunto:</p> <ul> <li> <p>(a) (2 puntos) menorCamino selecciona el camino m\u00ednimo (el de menor coste total) de una lista de caminos. Se aconseja (no obligatorio) desarrollar un m\u00e9todo que reciba como entrada un camino y retorne el peso total del camino.</p> </li> <li> <p>(b) (3 puntos) numeroVecesUsadoArco: genera un diccionario (Map) con el n\u00famero de veces que aparece cada arco en la lista de caminos del par\u00e1metro de entrada. <p></p> <p>Nota: En la implementaci\u00f3n de estos m\u00e9todos, se gestionan listas de arcos. No es necesario conocer, ni gestionar los v\u00e9rtices conectados en los caminos incluidos en la lista de entrada.</p> Mostrar soluci\u00f3n <pre><code>private double pesoCamino(List&lt;Edge&gt; camino) {\n    double distancia = 0;\n    for (Edge arco : camino) {\n        distancia = distancia + arco.weight();\n    }\n    return distancia;\n}\n\n/**\n * Seleccionar el camino con el menor coste total.\n * @param listaCaminos una lista de caminos del grafo del sistema entre dos v\u00e9rtices.\n * @return La respuesta es un camino que sea el m\u00ednimo de la lista recibida.\n * Si hubieran varios caminos m\u00ednimos con el mismo coste, se puede retornar\n * cualquiera de ellos.\n */\npublic List&lt;Edge&gt; menorCamino(List&lt;List&lt;Edge&gt;&gt; listaCaminos) {\n    List&lt;Edge&gt; menorCamino = null;\n    double menorPeso = Double.MAX_VALUE;\n\n    for (List&lt;Edge&gt; camino : listaCaminos) {\n        double aux = pesoCamino(camino);\n        if (menorCamino == null || aux &lt; menorPeso) {\n            menorPeso = aux;\n            menorCamino = camino;\n        }\n    }\n    return menorCamino;\n}\n\n/**\n * Determinar cu\u00e1ntas veces aparece cada arco en una lista de caminos\n * @param listaCaminos una lista de caminos del grafo del sistema entre dos v\u00e9rtices.\n * @return devuelve un diccionario, en el que la clave es un arco y el valor un\n * entero que representa el n\u00famero de veces que el arco aparece en el par\u00e1metro de entrada.\n */\npublic Map&lt;Edge, Integer&gt; numeroVecesUsadoArco(List&lt;List&lt;Edge&gt;&gt; listaCaminos) {\n    // Diccionario\n    Map&lt;Edge, Integer&gt; diccionario = new HashMap&lt;Edge, Integer&gt;();\n\n    for (List&lt;Edge&gt; camino : listaCaminos) {\n        for (Edge arco : camino) {\n            if (diccionario.containsKey(arco)) {\n                int aux = diccionario.get(arco) + 1;\n                diccionario.put(arco, aux);\n            } else {\n                diccionario.put(arco, 1);\n            }\n        }\n    }\n    return diccionario;\n}\n</code></pre>"},{"location":"exams/2021/extra/#problema-2","title":"Problema 2","text":"<p>Se quiere evaluar tres algoritmos que calculan cu\u00e1ntas veces aparecen los n\u00fameros en un rango de valores enteros en otra secuencia de enteros representada en un array desordenado y sin valores repetidos. Los tres algoritmos retornan los mismos valores y son correctos. La signatura de los tres algoritmos es: buscar(int[] buscados, int inicio, int fin), donde: buscados es el array de enteros e inicio y fin (inicio &lt;= fin) determinan el rango de enteros a buscar.</p> <p>Por ejemplo: buscados = [1, 9, 4, 5, -3, 8, 7]; inicio = 5, fin = 7. Entonces, habr\u00eda que contar el n\u00famero de veces que aparecen los enteros de la secuencia: 5, 6, 7. El resultado ser\u00e1: 2, ya que el 5 aparece una vez, el 6 no aparece y el 7 aparece una vez. </p> <pre><code>public static int buscar1(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n    ordenaOptimo(buscados);\n\n    for (int unNumero = inicio; unNumero &lt;= fin; unNumero++) {\n        if (busquedaBinaria(buscados, unNumero) != -1) {\n            encontrados++;\n        }\n    }\n    return encontrados;\n}\n\npublic static int buscar2(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n\n    for (int unNumero = inicio; unNumero &lt;= fin; unNumero++) {\n        for (int i = 0; i &lt; buscados.length; i++) {\n            if (buscados[i] == unNumero) {\n                encontrados++;\n                break;\n            }\n        }\n    }\n    return encontrados;\n}\n\npublic static int buscar3(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n    ordenaOptimo(buscados);\n\n    int principio = buscaMasCercano(buscados, inicio, true);\n    int final_ = buscaMasCercano(buscados, fin, false);\n    int dif = final_ - principio;\n\n    if ((principio &lt; 0 &amp;&amp; fin != buscados[final_]) ||\n        (principio == buscados.length - 1 &amp;&amp; inicio != buscados[principio])) {\n        dif--;\n    } else {\n        if (principio &gt;= 0 &amp;&amp; final_ &lt; buscados.length &amp;&amp;\n            inicio != buscados[principio] &amp;&amp; fin != buscados[final_]) {\n            dif--;\n        }\n        if (principio &gt;= 0 &amp;&amp; final_ &lt; buscados.length &amp;&amp;\n            inicio == buscados[principio] &amp;&amp; fin == buscados[final_]) {\n            dif++;\n        }\n    }\n    return dif;\n}\n</code></pre> <p>Se describen algunos aspectos sobre los m\u00e9todos auxiliares del c\u00f3digo.     - ordenaOptimo: implementa un algoritmo de ordenaci\u00f3n del array en orden ascendente, y tiene una complejidad n log n (donde n es el tama\u00f1o del array que recibe como par\u00e1metro). Al completar este m\u00e9todo, el array de entrada estar\u00e1 ordenado.     - busquedaBinaria: implementa un algoritmo de b\u00fasqueda binaria, de un entero, en un array ordenado; devuelve la posici\u00f3n del n\u00famero en el array, o -1 si no se encuentra en el array.     - buscaMasCercano: en un array ordenado, busca la posici\u00f3n cuyo valor es el m\u00e1s pr\u00f3ximo al segundo par\u00e1metro. La implementaci\u00f3n de este m\u00e9todo emplea un algoritmo de b\u00fasqueda binaria de complejidad log n.     - En el m\u00e9todo buscar2, se supone que el n\u00famero de veces que se ejecuta el segundo bucle es N/2.</p> <p>\u00bfCu\u00e1l de los tres algoritmos se deber\u00eda utilizar en los siguientes casos? Justifique cada caso, para cada algoritmo, indicando la complejidad del algoritmo. N es el n\u00famero de elementos en el array y M es el n\u00famero de elementos en la secuencia de b\u00fasqueda (fin \u2013 inicio + 1).</p> <ul> <li>(a) (1,5 puntos) M = 2 y N es n\u00famero muy grande.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad del m\u00e9todo buscar1 es: N log N ; esto es ordenarOptimo M log N ; esto es el bucle for La complejidad depende de los valores N y M</p> <p>La complejidad del m\u00e9todo buscar2 es: M N/2</p> <p>La complejidad del m\u00e9todo buscar3 es: N log N ; esto es ordenarOptimo 2 log N ; esto la complejidad de ejecuci\u00f3n 2 veces de buscaMasCercano La complejidad es N log N</p> <ul> <li>(b) (1,5 puntos) M = N, ambos n\u00fameros grandes. </li> </ul> Mostrar soluci\u00f3n <p>Caso 1. M = 2. La complejidad de burcar1 es N log N La complejidad de buscar2 es N La complejidad de buscar3 es N log N</p> <p>Es mejor algoritmo buscar2</p> <p>Caso 2. M = N La complejidad de buscar1 es N log N La complejidad de buscar2 es N2/2 La complejidad de buscar3 es N log N Es mejor algoritmo buscar1 o buscar3</p> <p>Caso 3. M &gt;&gt; N La complejidad de buscar1 es M log N La complejidad de buscar2 es M*N/2 La complejidad de buscar3 es N log N Es mejor el algoritmo buscar3</p> <ul> <li>(c) (2 puntos) M es bastante m\u00e1s grande que N, y ambos son grandes.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p>"},{"location":"exams/2021/extra_ex01/","title":"Extra ex01","text":"<p>Un sistema real se describe como un grafo no dirigido. Los arcos o aristas (edge) tienen un coste o peso mayor que cero. Un camino es una secuencia de arcos que conectan dos nodos o v\u00e9rtices. Un camino se representa mediante una lista (List). En este sistema, interesa agrupar a todos los posibles caminos entre dos nodos concretos, que se representa mediante una lista de caminos (List&gt;). <p>Se pide desarrollar dos m\u00e9todos, descritos en el cuadro adjunto:</p> <ul> <li> <p>(a) (2 puntos) menorCamino selecciona el camino m\u00ednimo (el de menor coste total) de una lista de caminos. Se aconseja (no obligatorio) desarrollar un m\u00e9todo que reciba como entrada un camino y retorne el peso total del camino.</p> </li> <li> <p>(b) (3 puntos) numeroVecesUsadoArco: genera un diccionario (Map) con el n\u00famero de veces que aparece cada arco en la lista de caminos del par\u00e1metro de entrada. <p></p> <p>Nota: En la implementaci\u00f3n de estos m\u00e9todos, se gestionan listas de arcos. No es necesario conocer, ni gestionar los v\u00e9rtices conectados en los caminos incluidos en la lista de entrada.</p> Mostrar soluci\u00f3n <pre><code>private double pesoCamino(List&lt;Edge&gt; camino) {\n    double distancia = 0;\n    for (Edge arco : camino) {\n        distancia = distancia + arco.weight();\n    }\n    return distancia;\n}\n\n/**\n * Seleccionar el camino con el menor coste total.\n * @param listaCaminos una lista de caminos del grafo del sistema entre dos v\u00e9rtices.\n * @return La respuesta es un camino que sea el m\u00ednimo de la lista recibida.\n * Si hubieran varios caminos m\u00ednimos con el mismo coste, se puede retornar\n * cualquiera de ellos.\n */\npublic List&lt;Edge&gt; menorCamino(List&lt;List&lt;Edge&gt;&gt; listaCaminos) {\n    List&lt;Edge&gt; menorCamino = null;\n    double menorPeso = Double.MAX_VALUE;\n\n    for (List&lt;Edge&gt; camino : listaCaminos) {\n        double aux = pesoCamino(camino);\n        if (menorCamino == null || aux &lt; menorPeso) {\n            menorPeso = aux;\n            menorCamino = camino;\n        }\n    }\n    return menorCamino;\n}\n\n/**\n * Determinar cu\u00e1ntas veces aparece cada arco en una lista de caminos\n * @param listaCaminos una lista de caminos del grafo del sistema entre dos v\u00e9rtices.\n * @return devuelve un diccionario, en el que la clave es un arco y el valor un\n * entero que representa el n\u00famero de veces que el arco aparece en el par\u00e1metro de entrada.\n */\npublic Map&lt;Edge, Integer&gt; numeroVecesUsadoArco(List&lt;List&lt;Edge&gt;&gt; listaCaminos) {\n    // Diccionario\n    Map&lt;Edge, Integer&gt; diccionario = new HashMap&lt;Edge, Integer&gt;();\n\n    for (List&lt;Edge&gt; camino : listaCaminos) {\n        for (Edge arco : camino) {\n            if (diccionario.containsKey(arco)) {\n                int aux = diccionario.get(arco) + 1;\n                diccionario.put(arco, aux);\n            } else {\n                diccionario.put(arco, 1);\n            }\n        }\n    }\n    return diccionario;\n}\n</code></pre>","tags":["grafos"]},{"location":"exams/2021/extra_ex02/","title":"Extra ex02","text":"<p>Se quiere evaluar tres algoritmos que calculan cu\u00e1ntas veces aparecen los n\u00fameros en un rango de valores enteros en otra secuencia de enteros representada en un array desordenado y sin valores repetidos. Los tres algoritmos retornan los mismos valores y son correctos. La signatura de los tres algoritmos es: buscar(int[] buscados, int inicio, int fin), donde: buscados es el array de enteros e inicio y fin (inicio &lt;= fin) determinan el rango de enteros a buscar.</p> <p>Por ejemplo: buscados = [1, 9, 4, 5, -3, 8, 7]; inicio = 5, fin = 7. Entonces, habr\u00eda que contar el n\u00famero de veces que aparecen los enteros de la secuencia: 5, 6, 7. El resultado ser\u00e1: 2, ya que el 5 aparece una vez, el 6 no aparece y el 7 aparece una vez. </p> <pre><code>public static int buscar1(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n    ordenaOptimo(buscados);\n\n    for (int unNumero = inicio; unNumero &lt;= fin; unNumero++) {\n        if (busquedaBinaria(buscados, unNumero) != -1) {\n            encontrados++;\n        }\n    }\n    return encontrados;\n}\n\npublic static int buscar2(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n\n    for (int unNumero = inicio; unNumero &lt;= fin; unNumero++) {\n        for (int i = 0; i &lt; buscados.length; i++) {\n            if (buscados[i] == unNumero) {\n                encontrados++;\n                break;\n            }\n        }\n    }\n    return encontrados;\n}\n\npublic static int buscar3(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n    ordenaOptimo(buscados);\n\n    int principio = buscaMasCercano(buscados, inicio, true);\n    int final_ = buscaMasCercano(buscados, fin, false);\n    int dif = final_ - principio;\n\n    if ((principio &lt; 0 &amp;&amp; fin != buscados[final_]) ||\n        (principio == buscados.length - 1 &amp;&amp; inicio != buscados[principio])) {\n        dif--;\n    } else {\n        if (principio &gt;= 0 &amp;&amp; final_ &lt; buscados.length &amp;&amp;\n            inicio != buscados[principio] &amp;&amp; fin != buscados[final_]) {\n            dif--;\n        }\n        if (principio &gt;= 0 &amp;&amp; final_ &lt; buscados.length &amp;&amp;\n            inicio == buscados[principio] &amp;&amp; fin == buscados[final_]) {\n            dif++;\n        }\n    }\n    return dif;\n}\n</code></pre> <p>Se describen algunos aspectos sobre los m\u00e9todos auxiliares del c\u00f3digo.     - ordenaOptimo: implementa un algoritmo de ordenaci\u00f3n del array en orden ascendente, y tiene una complejidad n log n (donde n es el tama\u00f1o del array que recibe como par\u00e1metro). Al completar este m\u00e9todo, el array de entrada estar\u00e1 ordenado.     - busquedaBinaria: implementa un algoritmo de b\u00fasqueda binaria, de un entero, en un array ordenado; devuelve la posici\u00f3n del n\u00famero en el array, o -1 si no se encuentra en el array.     - buscaMasCercano: en un array ordenado, busca la posici\u00f3n cuyo valor es el m\u00e1s pr\u00f3ximo al segundo par\u00e1metro. La implementaci\u00f3n de este m\u00e9todo emplea un algoritmo de b\u00fasqueda binaria de complejidad log n.     - En el m\u00e9todo buscar2, se supone que el n\u00famero de veces que se ejecuta el segundo bucle es N/2.</p> <p>\u00bfCu\u00e1l de los tres algoritmos se deber\u00eda utilizar en los siguientes casos? Justifique cada caso, para cada algoritmo, indicando la complejidad del algoritmo. N es el n\u00famero de elementos en el array y M es el n\u00famero de elementos en la secuencia de b\u00fasqueda (fin \u2013 inicio + 1).</p> <ul> <li>(a) (1,5 puntos) M = 2 y N es n\u00famero muy grande.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad del m\u00e9todo buscar1 es: N log N ; esto es ordenarOptimo M log N ; esto es el bucle for La complejidad depende de los valores N y M</p> <p>La complejidad del m\u00e9todo buscar2 es: M N/2</p> <p>La complejidad del m\u00e9todo buscar3 es: N log N ; esto es ordenarOptimo 2 log N ; esto la complejidad de ejecuci\u00f3n 2 veces de buscaMasCercano La complejidad es N log N</p> <ul> <li>(b) (1,5 puntos) M = N, ambos n\u00fameros grandes. </li> </ul> Mostrar soluci\u00f3n <p>Caso 1. M = 2. La complejidad de burcar1 es N log N La complejidad de buscar2 es N La complejidad de buscar3 es N log N</p> <p>Es mejor algoritmo buscar2</p> <p>Caso 2. M = N La complejidad de buscar1 es N log N La complejidad de buscar2 es N2/2 La complejidad de buscar3 es N log N Es mejor algoritmo buscar1 o buscar3</p> <p>Caso 3. M &gt;&gt; N La complejidad de buscar1 es M log N La complejidad de buscar2 es M*N/2 La complejidad de buscar3 es N log N Es mejor el algoritmo buscar3</p> <ul> <li>(c) (2 puntos) M es bastante m\u00e1s grande que N, y ambos son grandes.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p>","tags":["complejidad"]},{"location":"exams/2021/p1/","title":"Examen 2021 \u2014 Parcial 1","text":""},{"location":"exams/2021/p1/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un algoritmo para saber si un grafo no dirigido es ac\u00edclico, es decir, no tiene ciclos. Ejemplos:</p> <p></p> <p>Se pide:</p> <ul> <li>(a) (3,5 puntos) Dise\u00f1e el algoritmo tomando como referencia la siguiente signatura. <pre><code>boolean tieneCiclos(EdgeWeightedGraph g) {\n    //TODO a rellenar por el alumno}\n</code></pre> Primero, explique las estructuras de datos que necesita en el c\u00f3digo y qu\u00e9 uso se les va a dar. Segundo, implemente la soluci\u00f3n en Java. Nota: Puede desarrollar m\u00e9todos auxiliares si lo necesita.</li> </ul> <p>Puede utilizar los siguientes m\u00e9todos: </p> Mostrar soluci\u00f3n <pre><code>interface Solucion {\n    boolean tieneCiclos(EdgeWeightedGraph g);\n}\n</code></pre> <p>Soluci\u00f3n Iterativa:</p> <pre><code>class Iterativa implements Solucion {\n\n    @Override\n    public boolean tieneCiclos(EdgeWeightedGraph g) {\n\n        List&lt;Integer&gt; pendientes = new ArrayList&lt;Integer&gt;();\n        List&lt;Integer&gt; visitadosNodos = new ArrayList&lt;Integer&gt;();\n        List&lt;Edge&gt; visitadosArcos = new ArrayList&lt;Edge&gt;();\n\n        Integer nodo = 0;\n\n        for (int i = 0; i &lt; g.V(); i++) {\n\n            if (visitadosNodos.contains(i)) continue;\n\n            pendientes.add(i);\n\n            while (!pendientes.isEmpty()) {\n\n                nodo = pendientes.remove(0);\n                visitadosNodos.add(nodo);\n\n                for (Edge arco : g.adj(nodo)) {\n\n                    Integer otro = arco.other(nodo);\n\n                    if (!visitadosArcos.contains(arco) &amp;&amp;\n                        pendientes.contains(otro)) {\n                        return true; // ciclo detectado\n                    } else {\n                        if (!pendientes.contains(otro) &amp;&amp;\n                            !visitadosArcos.contains(arco)) {\n                            pendientes.add(otro);\n                        }\n                    }\n\n                    visitadosArcos.add(arco);\n                }\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <p>Soluci\u00f3n Recursiva:</p> <pre><code>class Recursiva implements Solucion {\n\n    @Override\n    public boolean tieneCiclos(EdgeWeightedGraph g) {\n\n        Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;();\n        Set&lt;Edge&gt; seenArcos = new HashSet&lt;Edge&gt;();\n\n        for (int v = 0; v &lt; g.V(); v++) {\n            if (seen.contains(v)) continue;\n\n            if (dfs(g, v, seen, seenArcos)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    boolean dfs(EdgeWeightedGraph g, int v,\n                Set&lt;Integer&gt; seen,\n                Set&lt;Edge&gt; seenArcos) {\n\n        if (seen.contains(v)) {\n            return true; // ciclo detectado\n        }\n\n        seen.add(v);\n\n        for (Edge e : g.adj(v)) {\n\n            if (seenArcos.contains(e)) continue;\n\n            seenArcos.add(e);\n            int neighbour = e.other(v);\n\n            if (dfs(g, neighbour, seen, seenArcos)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <ul> <li>(b) (0,5 putnos) \u00bfQu\u00e9 tipo de algoritmo ha dise\u00f1ado? Recursivo/iterativo (Razone su respuesta)</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p> <ul> <li>(c) (1 punto) Realice un c\u00e1lculo de la complejidad del algoritmo propuesto.</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p>"},{"location":"exams/2021/p1/#problema-2","title":"Problema 2","text":"<p>Como parte de un proyecto internacional, se quiere dise\u00f1ar un sistema que permite guardar y consultar el historial de posiciones de ciertos elementos. Se sabe que el sistema necesitar\u00e1 internamente un diccionario para guardar la informaci\u00f3n (Clave=elemento, Valor=posici\u00f3n).</p> <p>Se van a considerar s\u00f3lo las siguientes estructuras de datos para implementar el diccionario, que se implementar\u00e1n en las clases en par\u00e9ntesis:     - Array con duplicados (DiccionarioArrayDuplicados)     - Array ordenado sin duplicados (DiccionarioArrayOrdenado)     - \u00c1rbol binario de b\u00fasqueda (DiccionarioArbol)     - Tabla hash con listas (DiccionarioHash)</p> <p>Se pide:</p> <ul> <li>(a) (1,5 puntos) Dise\u00f1e un algoritmo que calcule la menor clave almacenada (claveMin), y otro que calcule el menor valor (valorMin), usando las siguientes signaturas y los m\u00e9todos de la interfaz Diccionario especificados al final del enunciado: <pre><code>K claveMin(Diccionario d) {\n    //TODO a rellenar por el alumno\n}\nV valorMin(Diccionario d) {\n    //TODO a rellenar por el alumno\n}\n</code></pre> <p>Utilice el interfaz de Diccionario  que se muestra a continuaci\u00f3n: <p></p> Mostrar soluci\u00f3n <pre><code>public K claveMin(Diccionario&lt;K, V&gt; d) {\n    K min = null;\n\n    for (K key : d.keys()) {\n        if (key.compareTo(min) &lt; 0) {\n            min = key;\n        }\n    }\n    return min;\n}\n</code></pre> <pre><code>public V valorMin(Diccionario&lt;K, V&gt; d) {\n    V min = null;\n\n    for (K key : d.keys()) {\n        V v = d.get(key);\n        if (v.compareTo(min) &lt; 0) {\n            min = v;\n        }\n    }\n    return min;\n}\n</code></pre> <ul> <li>(b) (0,5 puntos) Si claveMin y valorMin pudieran tener acceso a la estructura de datos interna de cada una de las implementaciones consideradas (p.e., la tabla hash en DiccionarioHash), \u00bfpodr\u00eda dise\u00f1arse una alternativa de menor complejidad?. Razone su respuesta sin escribir el algoritmo. </li> </ul> Mostrar soluci\u00f3n <p>Los m\u00e9todos implementados tiene complejidad en tiempo de ejecuci\u00f3n O(n), pero claveMin podr\u00eda usar ser m\u00e1s eficiente en DiccionarioArrayOrdenado y DiccionarioArbol, porque las claves est\u00e1n ordenadas. Para valorMin no ser\u00eda posible.</p> <p>El algoritmo para la interfaz tiene complejidad O(n), porque tiene que recorrer todas las claves y todos los valores.</p> <p>En DiccionarioHash y DiccionarioArrayDuplicados tambi\u00e9n habr\u00eda que recorrer todos los elementos, as\u00ed que la complejidad ser\u00eda similar.</p> <p>En DiccionarioArrayOrdenado y DiccionarioArbol las claves est\u00e1n ordenadas.</p> <p>Por tanto, en DiccionarioArrayOrdenado se podr\u00eda conseguir O(1) para claveMin, porque simplemente hay que acceder al primer elemento. En DiccionarioArbol tendr\u00edamos complejidad O(log(n)), porque hay que recorrer toda la profundidad (log2(n), en un \u00e1rbol balanceado).</p> <p>Para valorMin no se podr\u00eda conseguir un algoritmo mejor porque los valores no est\u00e1n ordenados, s\u00f3lo las claves.</p> <p>Elije entre las implementaciones consideradas la mejor adaptada para cada uno de los siguientes usos del sistema. Razone su respuesta usando los criterios de complejidad. - (c) (1 punto) Directorio de salas en la universidad. Consultas (get) frecuentes, actualizaciones (put, remove) poco frecuentes.</p> Mostrar soluci\u00f3n <p>Directorio de salas en la universidad. Consultas (get) frecuentes, actualizaciones (put, remove) poco frecuentes. DiccionarioHash, porque tiene b\u00fasquedas muy r\u00e1pidas (O(1)). Adem\u00e1s, al haber pocas actualizaciones podremos dimensionar la tabla correctamente.</p> <ul> <li>(d) (1 punto) Registro de seguridad de la posici\u00f3n en cada hora de los miembros del personal. Consultas poco frecuentes, actualizaciones muy frecuentes y no se deben sobreescribir valores antiguos.</li> </ul> Mostrar soluci\u00f3n <p>Registro de seguridad de la posici\u00f3n en cada hora de los miembros del personal. Consultas poco frecuentes, actualizaciones muy frecuentes y no se deben sobreescribir valores antiguos. DiccionarioArrayDuplicados. No se deben sobreescribir valores, y es el \u00fanico con esa condici\u00f3n en caso de actualizaci\u00f3n. Adem\u00e1s, las consultas son O(n), pero priman las actualizaciones (O(1)).</p> <ul> <li>(e) (1 punto) Prevenci\u00f3n de colisiones de veh\u00edculos con actualizaciones y consultas cada minuto. Consultas y actualizaciones igual de frecuentes. </li> </ul> Mostrar soluci\u00f3n <p>Prevenci\u00f3n de colisiones de veh\u00edculos con actualizaciones y consultas cada minuto. Consultas y actualizaciones igual de frecuentes. DiccionarioHash. Tanto consultas como actualizaciones tienen complejidad O(1). Puede</p>"},{"location":"exams/2021/p1_ex01/","title":"P1 ex01","text":"<p>Se quiere desarrollar un algoritmo para saber si un grafo no dirigido es ac\u00edclico, es decir, no tiene ciclos. Ejemplos:</p> <p></p> <p>Se pide:</p> <ul> <li>(a) (3,5 puntos) Dise\u00f1e el algoritmo tomando como referencia la siguiente signatura. <pre><code>boolean tieneCiclos(EdgeWeightedGraph g) {\n    //TODO a rellenar por el alumno}\n</code></pre> Primero, explique las estructuras de datos que necesita en el c\u00f3digo y qu\u00e9 uso se les va a dar. Segundo, implemente la soluci\u00f3n en Java. Nota: Puede desarrollar m\u00e9todos auxiliares si lo necesita.</li> </ul> <p>Puede utilizar los siguientes m\u00e9todos: </p> Mostrar soluci\u00f3n <pre><code>interface Solucion {\n    boolean tieneCiclos(EdgeWeightedGraph g);\n}\n</code></pre> <p>Soluci\u00f3n Iterativa:</p> <pre><code>class Iterativa implements Solucion {\n\n    @Override\n    public boolean tieneCiclos(EdgeWeightedGraph g) {\n\n        List&lt;Integer&gt; pendientes = new ArrayList&lt;Integer&gt;();\n        List&lt;Integer&gt; visitadosNodos = new ArrayList&lt;Integer&gt;();\n        List&lt;Edge&gt; visitadosArcos = new ArrayList&lt;Edge&gt;();\n\n        Integer nodo = 0;\n\n        for (int i = 0; i &lt; g.V(); i++) {\n\n            if (visitadosNodos.contains(i)) continue;\n\n            pendientes.add(i);\n\n            while (!pendientes.isEmpty()) {\n\n                nodo = pendientes.remove(0);\n                visitadosNodos.add(nodo);\n\n                for (Edge arco : g.adj(nodo)) {\n\n                    Integer otro = arco.other(nodo);\n\n                    if (!visitadosArcos.contains(arco) &amp;&amp;\n                        pendientes.contains(otro)) {\n                        return true; // ciclo detectado\n                    } else {\n                        if (!pendientes.contains(otro) &amp;&amp;\n                            !visitadosArcos.contains(arco)) {\n                            pendientes.add(otro);\n                        }\n                    }\n\n                    visitadosArcos.add(arco);\n                }\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <p>Soluci\u00f3n Recursiva:</p> <pre><code>class Recursiva implements Solucion {\n\n    @Override\n    public boolean tieneCiclos(EdgeWeightedGraph g) {\n\n        Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;();\n        Set&lt;Edge&gt; seenArcos = new HashSet&lt;Edge&gt;();\n\n        for (int v = 0; v &lt; g.V(); v++) {\n            if (seen.contains(v)) continue;\n\n            if (dfs(g, v, seen, seenArcos)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    boolean dfs(EdgeWeightedGraph g, int v,\n                Set&lt;Integer&gt; seen,\n                Set&lt;Edge&gt; seenArcos) {\n\n        if (seen.contains(v)) {\n            return true; // ciclo detectado\n        }\n\n        seen.add(v);\n\n        for (Edge e : g.adj(v)) {\n\n            if (seenArcos.contains(e)) continue;\n\n            seenArcos.add(e);\n            int neighbour = e.other(v);\n\n            if (dfs(g, neighbour, seen, seenArcos)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <ul> <li>(b) (0,5 putnos) \u00bfQu\u00e9 tipo de algoritmo ha dise\u00f1ado? Recursivo/iterativo (Razone su respuesta)</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p> <ul> <li>(c) (1 punto) Realice un c\u00e1lculo de la complejidad del algoritmo propuesto.</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p>","tags":["complejidad","grafos"]},{"location":"exams/2021/p1_ex02/","title":"P1 ex02","text":"<p>Como parte de un proyecto internacional, se quiere dise\u00f1ar un sistema que permite guardar y consultar el historial de posiciones de ciertos elementos. Se sabe que el sistema necesitar\u00e1 internamente un diccionario para guardar la informaci\u00f3n (Clave=elemento, Valor=posici\u00f3n).</p> <p>Se van a considerar s\u00f3lo las siguientes estructuras de datos para implementar el diccionario, que se implementar\u00e1n en las clases en par\u00e9ntesis:     - Array con duplicados (DiccionarioArrayDuplicados)     - Array ordenado sin duplicados (DiccionarioArrayOrdenado)     - \u00c1rbol binario de b\u00fasqueda (DiccionarioArbol)     - Tabla hash con listas (DiccionarioHash)</p> <p>Se pide:</p> <ul> <li>(a) (1,5 puntos) Dise\u00f1e un algoritmo que calcule la menor clave almacenada (claveMin), y otro que calcule el menor valor (valorMin), usando las siguientes signaturas y los m\u00e9todos de la interfaz Diccionario especificados al final del enunciado: <pre><code>K claveMin(Diccionario d) {\n    //TODO a rellenar por el alumno\n}\nV valorMin(Diccionario d) {\n    //TODO a rellenar por el alumno\n}\n</code></pre> <p>Utilice el interfaz de Diccionario  que se muestra a continuaci\u00f3n: <p></p> Mostrar soluci\u00f3n <pre><code>public K claveMin(Diccionario&lt;K, V&gt; d) {\n    K min = null;\n\n    for (K key : d.keys()) {\n        if (key.compareTo(min) &lt; 0) {\n            min = key;\n        }\n    }\n    return min;\n}\n</code></pre> <pre><code>public V valorMin(Diccionario&lt;K, V&gt; d) {\n    V min = null;\n\n    for (K key : d.keys()) {\n        V v = d.get(key);\n        if (v.compareTo(min) &lt; 0) {\n            min = v;\n        }\n    }\n    return min;\n}\n</code></pre> <ul> <li>(b) (0,5 puntos) Si claveMin y valorMin pudieran tener acceso a la estructura de datos interna de cada una de las implementaciones consideradas (p.e., la tabla hash en DiccionarioHash), \u00bfpodr\u00eda dise\u00f1arse una alternativa de menor complejidad?. Razone su respuesta sin escribir el algoritmo. </li> </ul> Mostrar soluci\u00f3n <p>Los m\u00e9todos implementados tiene complejidad en tiempo de ejecuci\u00f3n O(n), pero claveMin podr\u00eda usar ser m\u00e1s eficiente en DiccionarioArrayOrdenado y DiccionarioArbol, porque las claves est\u00e1n ordenadas. Para valorMin no ser\u00eda posible.</p> <p>El algoritmo para la interfaz tiene complejidad O(n), porque tiene que recorrer todas las claves y todos los valores.</p> <p>En DiccionarioHash y DiccionarioArrayDuplicados tambi\u00e9n habr\u00eda que recorrer todos los elementos, as\u00ed que la complejidad ser\u00eda similar.</p> <p>En DiccionarioArrayOrdenado y DiccionarioArbol las claves est\u00e1n ordenadas.</p> <p>Por tanto, en DiccionarioArrayOrdenado se podr\u00eda conseguir O(1) para claveMin, porque simplemente hay que acceder al primer elemento. En DiccionarioArbol tendr\u00edamos complejidad O(log(n)), porque hay que recorrer toda la profundidad (log2(n), en un \u00e1rbol balanceado).</p> <p>Para valorMin no se podr\u00eda conseguir un algoritmo mejor porque los valores no est\u00e1n ordenados, s\u00f3lo las claves.</p> <p>Elije entre las implementaciones consideradas la mejor adaptada para cada uno de los siguientes usos del sistema. Razone su respuesta usando los criterios de complejidad. - (c) (1 punto) Directorio de salas en la universidad. Consultas (get) frecuentes, actualizaciones (put, remove) poco frecuentes.</p> Mostrar soluci\u00f3n <p>Directorio de salas en la universidad. Consultas (get) frecuentes, actualizaciones (put, remove) poco frecuentes. DiccionarioHash, porque tiene b\u00fasquedas muy r\u00e1pidas (O(1)). Adem\u00e1s, al haber pocas actualizaciones podremos dimensionar la tabla correctamente.</p> <ul> <li>(d) (1 punto) Registro de seguridad de la posici\u00f3n en cada hora de los miembros del personal. Consultas poco frecuentes, actualizaciones muy frecuentes y no se deben sobreescribir valores antiguos.</li> </ul> Mostrar soluci\u00f3n <p>Registro de seguridad de la posici\u00f3n en cada hora de los miembros del personal. Consultas poco frecuentes, actualizaciones muy frecuentes y no se deben sobreescribir valores antiguos. DiccionarioArrayDuplicados. No se deben sobreescribir valores, y es el \u00fanico con esa condici\u00f3n en caso de actualizaci\u00f3n. Adem\u00e1s, las consultas son O(n), pero priman las actualizaciones (O(1)).</p> <ul> <li>(e) (1 punto) Prevenci\u00f3n de colisiones de veh\u00edculos con actualizaciones y consultas cada minuto. Consultas y actualizaciones igual de frecuentes. </li> </ul> Mostrar soluci\u00f3n <p>Prevenci\u00f3n de colisiones de veh\u00edculos con actualizaciones y consultas cada minuto. Consultas y actualizaciones igual de frecuentes. DiccionarioHash. Tanto consultas como actualizaciones tienen complejidad O(1). Puede</p>","tags":["complejidad"]},{"location":"exams/2021/p1r/","title":"Examen 2021 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2021/p1r/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un programa que analice un documento de texto y calcule el n!mero de veces que aparece cada palabra (String). El resultado es una lista de ContadorPalabra, que es una clase que se muestra a continuaci\u00f3n:</p> <pre><code>public class ContadorPalabra {\n    String nombre; // Nombre en el documento\n    int contador; //N\u00fam. de veces que aparece\n    ...\n    // Est\u00e1n disponibles los getters y setters\n}\n</code></pre> <p>En una fase inicial del programa, se crean dos hebras que analizan una mitad del documento. El resultado de cada hebra es una lista (java.util.List), con el contador de cada palabra de la mitad correspondiente. Los elementos de cada lista est\"n ordenados por el atributo nombre de cada ContadorPalabra. <p>En este ejercicio, se quiere desarrollar un m#todo para agregar las dos listas generadas de cada mitad. Se pide:</p> <ul> <li>(a) (1,5 puntos) Desarrolle el m#todo Menor, que recibe dos listas ordenadas y retorna el ContadorPalabra con la menor palabra en cualquiera de las dos mitades. </li> </ul> <pre><code>public ContadorPalabra Menor (\n    java.util.List&lt;ContadorPalabra&gt; ag1,\n    java.util.List&lt;ContadorPalabra&gt; ag2) { . . . }\n</code></pre> Mostrar soluci\u00f3n <pre><code>public ContadorPalabra Menor(\n        java.util.List&lt;ContadorPalabra&gt; ag1,\n        java.util.List&lt;ContadorPalabra&gt; ag2) {\n\n    ContadorPalabra p1 = ag1.get(0);\n    ContadorPalabra p2 = ag2.get(0);\n\n    if (ag1.size() == 0 || ag1 == null) \n        return ag2.get(0);\n\n    if (ag2.size() == 0 || ag2 == null) \n        return ag1.get(0);\n\n    if (p1.getNombre().compareTo(p2.getNombre()) &lt;= 0)\n        return ag1.get(0);\n\n    return ag2.get(0);\n}\n</code></pre> <ul> <li>(b) (3,5 puntos) Desarrolle el m#todo Agregar, que recibe dos listas y retorna una lista ordenada que agregue los objetos PalabraContador de los par\u00e1metros de entrada. En concreto, calcula el valor de cada palabra en cada mitad en el documento. Este m#todo puede usar Menor, pero no es obligatorio. </li> </ul> <pre><code>public java.util.List&lt;ContadorPalabra&gt; Agregar(\njava.util.List&lt;ContadorPalabra&gt; ag1,\njava.util.List&lt;ContadorPalabra&gt; ag2))\n{ . . . }\n</code></pre> <p>y</p> <p>Ejemplo: Los dos par\u00e1metros de entrada de Agregar o Menor podr\u00edan ser: <pre><code>Ag1 = { [\u201cadi\u00f3s\u201d, 3], [\u201cbueno\u201d, 1], [\u201chola\u201d, 2], [\u201cmalo\u201d, 4] }\nAg2 = { [\u201cadi\u00f3s\u201d, 4], [\u201cbueno\u201d, 7], [\u201cmalo\u201d, 2] }\n</code></pre></p> <p>La salida del m\u00e9todo agregar ser\u00eda: <pre><code>agregar = { [\u201cadi\u00f3s\u201d, 7], [\u201cbueno\u201d, 8], [\u201chola\u201d, 2], [\u201cmalo\u201d, 6] }\n</code></pre></p> <p>A continuaci\u00f3n se muestran algunos m#todos relevantes de la colecci\u00f3n List.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public java.util.List&lt;ContadorPalabra&gt; Agregar() {\n    ContadorPalabra min;\n    java.util.List&lt;ContadorPalabra&gt; agregado =\n        new java.util.ArrayList&lt;ContadorPalabra&gt;();\n\n    while ((ag1.size() != 0) || (ag2.size() != 0)) {\n        min = Menor(ag1, ag2);\n        ContadorPalabra aux = null;\n\n        if (ag1.size() &gt; 0) {\n            if (min.getNombre() == ag1.get(0).getNombre()) {\n                if (aux == null) {\n                    aux = ag1.remove(0);\n                }\n            }\n        }\n\n        if (ag2.size() &gt; 0) {\n            if (min.getNombre() == ag2.get(0).getNombre()) {\n                if (aux == null) {\n                    aux = ag2.remove(0);\n                } else {\n                    aux.setContador(\n                        aux.getContador() + ag2.get(0).getContador()\n                    );\n                    ag2.remove(0);\n                }\n            }\n        }\n\n        agregado.add(aux);\n    }\n    return agregado;\n}\n</code></pre>"},{"location":"exams/2021/p1r/#problema-2","title":"Problema 2","text":"<p>Se quiere desarrollar un sistema para calcular de forma eficiente las notas medias en la UPM a diferentes niveles. Nos interesan las notas medias a nivel de asignatura, a nivel de Escuela, y a nivel de Universidad. Se quiere que cada vez que se publique la nota de una asignatura se recalculen las medias a nivel de Escuela y Universidad, sin realizar operaciones innecesarias.</p> <p>Para ello, utilizaremos una estructura de \"rbol de 3 niveles:     - El nodo ra\\(z es la universidad (UPM).     - El nodo ra\\)z (UPM) tiene un hijo por cada escuela (p.e., ETSIT, ETSAM).     - Cada escuela tiene un hijo por cada asignatura que se imparte en esa escuela (p.e., ADSW, CORE).     - Cada nodo tiene una referencia a todos sus hijos (this.hijos), y a su nodo padre (this.padre, que ser\" null para el nodo ra$z).</p> <p>Inicialmente se propone una estrategia de carga ansiosa (eager loading), en la que cada vez que se actualiza una nota de una asignatura se actualizan las medias de todos los nodos necesarios.</p> <p>Se considera que actualizar un nodo es necesario cuando alguno de sus descendientes ha sido modificado desde el !ltimo c\"lculo.</p> <p>Cada Nodo tiene los siguientes atributos:</p> <p></p> <p>Sea E el n!mero de escuelas, y A el n!mero de asignaturas, suponiendo que la distribuci%n de asignaturas por escuela es uniforme, se pide: - (a) (2,5 puntos) Implementar los algoritmos para modificar y recuperar la nota media de un nodo para la estrategia de carga ansiosa, utilizando las siguientes firmas: <pre><code>void setNota(float nota, int peso) { // a rellenar por el alumno }\nfloat getNota() { // a rellenar por el alumno }\n</code></pre></p> Mostra soluci\u00f3n <pre><code>public float getNota() {\n    return this.nota;\n}\n\n/* \n * Actualiza la nota de este nodo y recalcula los antecesores.\n */\npublic void setNota(float nota, int peso) {\n    // Se podr\u00eda a\u00f1adir l\u00f3gica para solo modificar la nota\n    // de las Asignaturas, no del resto de nodos.\n    this.peso = peso;\n    this.nota = nota;\n\n    if (this.padre != null) {\n        recalcular(this.padre);\n    }\n}\n\npublic static void recalcular(Nodo raiz) {\n    float media = 0;\n    int peso = 0;\n\n    for (Nodo hijo : raiz.hijos) {\n        media += hijo.peso * hijo.nota;\n        peso += hijo.peso;\n    }\n\n    media = media / peso;\n    raiz.nota = media;\n    raiz.peso = peso;\n    raiz.actualizado = true;\n\n    if (raiz.padre != null) {\n        recalcular(raiz.padre);\n    }\n}\n</code></pre> <p>En el enunciado no se especifica el rol del peso, as$ que se dan por v\"lidas las soluciones que asumen el mismo peso para todos los nodos.</p> <ul> <li>(b) (0,5 puntos) Los algoritmos implementados, &amp;son recursivos o iterativos?.</li> </ul> Mostra soluci\u00f3n <p>La implementaci!n de setNota se basa en el m#todo calcular, que es recursivo. Se podr$a implementar de manera iterativa.</p> <ul> <li>(c) (0,5 puntos) Estimar la complejidad de modificar la nota de 1 sola asignatura, y de modificar todas las asignaturas, en funci%n de A y E.</li> </ul> Mostra soluci\u00f3n <p>Al actualizar una asignatura, se debe recalcular la nota de la escuela, y luego de la universidad. Habr\" A/E asignaturas por escuela (distribuci%n uniforme). Por tanto: O(setNota() = O(A/E + E) O(setNotatodas) = O(A * (A/E + E)) Por completitud, la complejidad de consultar una nota es constante (ya se calcula en el setNota).</p> <p>Para mejorar el rendimiento, se propone comparar la estrategia anterior con otra de carga perezosa (lazy loading), en la que s%lo se actualizan las notas necesarias al acceder a una nota desactualizada.</p> <ul> <li>(d) (0,5 puntos) Estime la complejidad de modificar 1 sola asignatura, y de modificar todas las asignaturas, para el caso de carga perezosa, en funci%n de A y E.</li> </ul> Mostra soluci\u00f3n <p>Con carga perezosa, cuando se modifica una nota se marcan los nodos superiores al nodo a actualizar como desactualizados. Esa operaci%n para cada asignatura depende s%lo del n!mero de niveles (en este caso, 3). Por tanto:</p> <p>O(setNota() = O(1)</p> <p>O(setNotatodas) = O(A) // Es decir, A * O(setNota1)</p> <p>Aunque no se especifica en el enunciado, la complejidad de getNota(UPM) para esta estrategia tras haber modificado 1 o TODAS las notas, ser$a:</p> <p>O(getNota1(UPM)) = O((A/E) + E) // S%lo recalcula una de las ramas del \"rbol.</p> <p>O(getNotatodas) = O(A + E) // Recalcula todos los nodos</p> <ul> <li>(e) (1 punto) En lugar de tener 3 niveles (universidad, escuela, asignatura), se modifica el \"rbol para que sea un \"rbol binario perfectamente balanceado (cada nodo padre tiene exactamente 2 hijos). Calcule la complejidad de acceder a la nota UPM para el caso de carga perezosa tras cambiar una sola asignatura, en funci%n de A.</li> </ul> Mostra soluci\u00f3n <p>Como hemos visto en el anterior apartado, la diferencia es que en un caso recalcula una rama, y en el otro recalcula el %rbol entero.</p> <p>En este caso, tendremos que calcular el n&amp;mero de niveles. Al tratarse de un %rbol binario, con un n&amp;mero de hojas A, el n&amp;mero de niveles ser% log2(A).</p> <p>El n&amp;mero total de nodos ser% la suma de nodos en cada uno de los niveles:</p> <p>N = A + A/2 + A/4 + ' 1 ~= 2*A</p> <p>O(getNota1(UPM)) = O(log(A)) // En cada nodo se suman los dos nodos inferiores</p> <p>O(getNotatodas) = O(N) = O(A)</p>"},{"location":"exams/2021/p1r_ex01/","title":"P1r ex01","text":"<p>Se quiere desarrollar un programa que analice un documento de texto y calcule el n!mero de veces que aparece cada palabra (String). El resultado es una lista de ContadorPalabra, que es una clase que se muestra a continuaci\u00f3n:</p> <pre><code>public class ContadorPalabra {\n    String nombre; // Nombre en el documento\n    int contador; //N\u00fam. de veces que aparece\n    ...\n    // Est\u00e1n disponibles los getters y setters\n}\n</code></pre> <p>En una fase inicial del programa, se crean dos hebras que analizan una mitad del documento. El resultado de cada hebra es una lista (java.util.List), con el contador de cada palabra de la mitad correspondiente. Los elementos de cada lista est\"n ordenados por el atributo nombre de cada ContadorPalabra. <p>En este ejercicio, se quiere desarrollar un m#todo para agregar las dos listas generadas de cada mitad. Se pide:</p> <ul> <li>(a) (1,5 puntos) Desarrolle el m#todo Menor, que recibe dos listas ordenadas y retorna el ContadorPalabra con la menor palabra en cualquiera de las dos mitades. </li> </ul> <pre><code>public ContadorPalabra Menor (\n    java.util.List&lt;ContadorPalabra&gt; ag1,\n    java.util.List&lt;ContadorPalabra&gt; ag2) { . . . }\n</code></pre> Mostrar soluci\u00f3n <pre><code>public ContadorPalabra Menor(\n        java.util.List&lt;ContadorPalabra&gt; ag1,\n        java.util.List&lt;ContadorPalabra&gt; ag2) {\n\n    ContadorPalabra p1 = ag1.get(0);\n    ContadorPalabra p2 = ag2.get(0);\n\n    if (ag1.size() == 0 || ag1 == null) \n        return ag2.get(0);\n\n    if (ag2.size() == 0 || ag2 == null) \n        return ag1.get(0);\n\n    if (p1.getNombre().compareTo(p2.getNombre()) &lt;= 0)\n        return ag1.get(0);\n\n    return ag2.get(0);\n}\n</code></pre> <ul> <li>(b) (3,5 puntos) Desarrolle el m#todo Agregar, que recibe dos listas y retorna una lista ordenada que agregue los objetos PalabraContador de los par\u00e1metros de entrada. En concreto, calcula el valor de cada palabra en cada mitad en el documento. Este m#todo puede usar Menor, pero no es obligatorio. </li> </ul> <pre><code>public java.util.List&lt;ContadorPalabra&gt; Agregar(\njava.util.List&lt;ContadorPalabra&gt; ag1,\njava.util.List&lt;ContadorPalabra&gt; ag2))\n{ . . . }\n</code></pre> <p>y</p> <p>Ejemplo: Los dos par\u00e1metros de entrada de Agregar o Menor podr\u00edan ser: <pre><code>Ag1 = { [\u201cadi\u00f3s\u201d, 3], [\u201cbueno\u201d, 1], [\u201chola\u201d, 2], [\u201cmalo\u201d, 4] }\nAg2 = { [\u201cadi\u00f3s\u201d, 4], [\u201cbueno\u201d, 7], [\u201cmalo\u201d, 2] }\n</code></pre></p> <p>La salida del m\u00e9todo agregar ser\u00eda: <pre><code>agregar = { [\u201cadi\u00f3s\u201d, 7], [\u201cbueno\u201d, 8], [\u201chola\u201d, 2], [\u201cmalo\u201d, 6] }\n</code></pre></p> <p>A continuaci\u00f3n se muestran algunos m#todos relevantes de la colecci\u00f3n List.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public java.util.List&lt;ContadorPalabra&gt; Agregar() {\n    ContadorPalabra min;\n    java.util.List&lt;ContadorPalabra&gt; agregado =\n        new java.util.ArrayList&lt;ContadorPalabra&gt;();\n\n    while ((ag1.size() != 0) || (ag2.size() != 0)) {\n        min = Menor(ag1, ag2);\n        ContadorPalabra aux = null;\n\n        if (ag1.size() &gt; 0) {\n            if (min.getNombre() == ag1.get(0).getNombre()) {\n                if (aux == null) {\n                    aux = ag1.remove(0);\n                }\n            }\n        }\n\n        if (ag2.size() &gt; 0) {\n            if (min.getNombre() == ag2.get(0).getNombre()) {\n                if (aux == null) {\n                    aux = ag2.remove(0);\n                } else {\n                    aux.setContador(\n                        aux.getContador() + ag2.get(0).getContador()\n                    );\n                    ag2.remove(0);\n                }\n            }\n        }\n\n        agregado.add(aux);\n    }\n    return agregado;\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2021/p1r_ex02/","title":"P1r ex02","text":"<p>Se quiere desarrollar un sistema para calcular de forma eficiente las notas medias en la UPM a diferentes niveles. Nos interesan las notas medias a nivel de asignatura, a nivel de Escuela, y a nivel de Universidad. Se quiere que cada vez que se publique la nota de una asignatura se recalculen las medias a nivel de Escuela y Universidad, sin realizar operaciones innecesarias.</p> <p>Para ello, utilizaremos una estructura de \"rbol de 3 niveles:     - El nodo ra\\(z es la universidad (UPM).     - El nodo ra\\)z (UPM) tiene un hijo por cada escuela (p.e., ETSIT, ETSAM).     - Cada escuela tiene un hijo por cada asignatura que se imparte en esa escuela (p.e., ADSW, CORE).     - Cada nodo tiene una referencia a todos sus hijos (this.hijos), y a su nodo padre (this.padre, que ser\" null para el nodo ra$z).</p> <p>Inicialmente se propone una estrategia de carga ansiosa (eager loading), en la que cada vez que se actualiza una nota de una asignatura se actualizan las medias de todos los nodos necesarios.</p> <p>Se considera que actualizar un nodo es necesario cuando alguno de sus descendientes ha sido modificado desde el !ltimo c\"lculo.</p> <p>Cada Nodo tiene los siguientes atributos:</p> <p></p> <p>Sea E el n!mero de escuelas, y A el n!mero de asignaturas, suponiendo que la distribuci%n de asignaturas por escuela es uniforme, se pide: - (a) (2,5 puntos) Implementar los algoritmos para modificar y recuperar la nota media de un nodo para la estrategia de carga ansiosa, utilizando las siguientes firmas: <pre><code>void setNota(float nota, int peso) { // a rellenar por el alumno }\nfloat getNota() { // a rellenar por el alumno }\n</code></pre></p> Mostra soluci\u00f3n <pre><code>public float getNota() {\n    return this.nota;\n}\n\n/* \n * Actualiza la nota de este nodo y recalcula los antecesores.\n */\npublic void setNota(float nota, int peso) {\n    // Se podr\u00eda a\u00f1adir l\u00f3gica para solo modificar la nota\n    // de las Asignaturas, no del resto de nodos.\n    this.peso = peso;\n    this.nota = nota;\n\n    if (this.padre != null) {\n        recalcular(this.padre);\n    }\n}\n\npublic static void recalcular(Nodo raiz) {\n    float media = 0;\n    int peso = 0;\n\n    for (Nodo hijo : raiz.hijos) {\n        media += hijo.peso * hijo.nota;\n        peso += hijo.peso;\n    }\n\n    media = media / peso;\n    raiz.nota = media;\n    raiz.peso = peso;\n    raiz.actualizado = true;\n\n    if (raiz.padre != null) {\n        recalcular(raiz.padre);\n    }\n}\n</code></pre> <p>En el enunciado no se especifica el rol del peso, as$ que se dan por v\"lidas las soluciones que asumen el mismo peso para todos los nodos.</p> <ul> <li>(b) (0,5 puntos) Los algoritmos implementados, &amp;son recursivos o iterativos?.</li> </ul> Mostra soluci\u00f3n <p>La implementaci!n de setNota se basa en el m#todo calcular, que es recursivo. Se podr$a implementar de manera iterativa.</p> <ul> <li>(c) (0,5 puntos) Estimar la complejidad de modificar la nota de 1 sola asignatura, y de modificar todas las asignaturas, en funci%n de A y E.</li> </ul> Mostra soluci\u00f3n <p>Al actualizar una asignatura, se debe recalcular la nota de la escuela, y luego de la universidad. Habr\" A/E asignaturas por escuela (distribuci%n uniforme). Por tanto: O(setNota() = O(A/E + E) O(setNotatodas) = O(A * (A/E + E)) Por completitud, la complejidad de consultar una nota es constante (ya se calcula en el setNota).</p> <p>Para mejorar el rendimiento, se propone comparar la estrategia anterior con otra de carga perezosa (lazy loading), en la que s%lo se actualizan las notas necesarias al acceder a una nota desactualizada.</p> <ul> <li>(d) (0,5 puntos) Estime la complejidad de modificar 1 sola asignatura, y de modificar todas las asignaturas, para el caso de carga perezosa, en funci%n de A y E.</li> </ul> Mostra soluci\u00f3n <p>Con carga perezosa, cuando se modifica una nota se marcan los nodos superiores al nodo a actualizar como desactualizados. Esa operaci%n para cada asignatura depende s%lo del n!mero de niveles (en este caso, 3). Por tanto:</p> <p>O(setNota() = O(1)</p> <p>O(setNotatodas) = O(A) // Es decir, A * O(setNota1)</p> <p>Aunque no se especifica en el enunciado, la complejidad de getNota(UPM) para esta estrategia tras haber modificado 1 o TODAS las notas, ser$a:</p> <p>O(getNota1(UPM)) = O((A/E) + E) // S%lo recalcula una de las ramas del \"rbol.</p> <p>O(getNotatodas) = O(A + E) // Recalcula todos los nodos</p> <ul> <li>(e) (1 punto) En lugar de tener 3 niveles (universidad, escuela, asignatura), se modifica el \"rbol para que sea un \"rbol binario perfectamente balanceado (cada nodo padre tiene exactamente 2 hijos). Calcule la complejidad de acceder a la nota UPM para el caso de carga perezosa tras cambiar una sola asignatura, en funci%n de A.</li> </ul> Mostra soluci\u00f3n <p>Como hemos visto en el anterior apartado, la diferencia es que en un caso recalcula una rama, y en el otro recalcula el %rbol entero.</p> <p>En este caso, tendremos que calcular el n&amp;mero de niveles. Al tratarse de un %rbol binario, con un n&amp;mero de hojas A, el n&amp;mero de niveles ser% log2(A).</p> <p>El n&amp;mero total de nodos ser% la suma de nodos en cada uno de los niveles:</p> <p>N = A + A/2 + A/4 + ' 1 ~= 2*A</p> <p>O(getNota1(UPM)) = O(log(A)) // En cada nodo se suman los dos nodos inferiores</p> <p>O(getNotatodas) = O(N) = O(A)</p>","tags":["grafos"]},{"location":"exams/2021/p2/","title":"Examen 2021 \u2014 Parcial 2","text":""},{"location":"exams/2021/p2/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar una clase monitora TorreControl para gestionar una !nica pista de aterrizaje de un aeropuerto, con acceso exclusivo por parte de objetos de la clase Avion, que ser\"n las hebras. Los aviones pueden pedir a la torre de control aterrizar y despegar. Se pide desarrollar los siguientes m#todos:</p> <p></p> <ul> <li> <p>(a) (1,5 puntos) public \u2026 void avisoAterrizaje(Avion unAvion): para la maniobra de aterrizaje, los aviones primero avisar\"n a la torre de control (con este m#todo) de su intenci\\(n de aterrizar y despu#s preguntar\"n por el permiso para poder aterrizar. Cuando la torre de control reciba un aviso de aterrizaje deber\" a%adir el avi\\)n que solicit$ el permiso a una lista. Esta lista se ordenar\" por el combustible que tengan los aviones, siendo el que tenga menos combustible el primero de la lista y el primero en aterrizar (en caso de haber dos aviones con el mismo combustible ser\" indiferente el orden de aterrizaje entre ellos).</p> </li> <li> <p>(b) (2 puntos) public \u2026 void permisoAterrizaje(Avion unAvion): un avi\\(n invoca este m#todo para pedir permiso para aterrizar. Cuando la torre de control reciba la llamada de permiso de aterrizaje entonces solo dejar\" aterrizar al avi\\)n si lo tiene guardado en la lista de menos combustible y si la pista est\" libre. </p> </li> <li> <p>(c) (1,5 puntos) public \u2026 void permisoDespegue(Avion unAvion para la maniobra de despegue los aviones pedir\"n permiso para despegar. Se supone que todos los aviones tienen el m\"ximo de combustible y no hay prioridad, as&amp; que cuando pidan despegar podr\"n hacerlo siempre y cuando la pista est# libre.</p> </li> </ul> <p>Aclaraciones sobre el ejercicio:</p> <pre><code>- En la clase TorreControl se controla cu\u00e1ndo la pista est\u00e1 ocupada o libre. La pista estar\u00e1 ocupada cuando un avi\u00f3n ha recibido permiso a trav\u00e9s de los m\u00e9todos permisoAterrizaje o permisoDespegue. La pista se debe marcar como ocupada dentro de este m\u00e9todo cuando un avi\u00f3n tiene permiso y se mantiene as\u00ed en un tiempo, representado como Thread.sleep(random.nextInt(5000)). Al expirar este temporizador, la pista se marcar\u00e1 como libre.\n\n- Para simplificar este ejercicio, se supone que un avi\u00f3n mantiene constante su nivel de combustible, desde que notifica su intenci\u00f3n de aterrizar (con el m\u00e9todo avisoAterrizaje) hasta que recibe el permiso (con el m\u00e9todo permisoAterrizaje).\n\n- Se dispone un m\u00e9todo (no es necesario implementarlo) que recibe una lista de aviones y retorna una lista de aviones ordenada de menor a mayor por el combustible del avi\u00f3n: List&lt;Avion&gt; ordenarAvionesPorCompustible(List&lt;Avion&gt; listaAviones))\n</code></pre> <pre><code>// Ejemplo del posible c\u00f3digo de una hebra de la clase Avion\n\npublic class Avion extends Thread {\n\n    private TorreControl miTorre;\n    private int combustible;\n    private String matricula;\n\n    public Avion(TorreControl miTorre, String matricula, int combustible) {\n        this.miTorre = miTorre;\n        this.matricula = matricula;\n        this.combustible = combustible;\n    }\n\n    public int getCombustible() {\n        return this.combustible;\n    }\n\n    public String getMatricula() {\n        return this.matricula;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                this.miTorre.avisoAterrizaje(this);\n                this.miTorre.permisoAterrizaje(this);\n                this.miTorre.permisoDespegue(this);\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre> <pre><code>public static void main(String[] args) throws Exception {\n\n    TorreControl tc = new TorreControl(\"Barajas\");\n\n    new Avion(tc, \"aaa\", 30).start();\n    new Avion(tc, \"bbb\", 10).start();\n    new Avion(tc, \"ccc\", 20).start();\n    new Avion(tc, \"ddd\", 50).start();\n    new Avion(tc, \"eee\", 5).start();\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>import java.util.*;\n\npublic class TorreControl {\n\n    private String nombre;\n    private List&lt;Avion&gt; listaAterrizaje = new ArrayList&lt;Avion&gt;();\n    private volatile boolean pistaOcupada = false;\n    private Random random = new Random();\n\n    public TorreControl(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public synchronized void avisoAterrizaje(Avion miAvion) {\n        listaAterrizaje.add(miAvion);\n        // Se ha elegido esta forma de ordenaci\u00f3n pero puede hacerse de varias formas.\n        Collections.sort(this.listaAterrizaje, new OrdenarPorCombustible());\n        System.out.println(\n            \"Torre control - A\u00f1adido avi\u00f3n a la lista ordenada. \"\n            + this.listaAterrizaje.toString()\n        );\n    }\n\n    public synchronized void permisoAterrizaje(Avion miAvion) {\n        try {\n            System.out.println(\n                \"Torre control - Primer avi\u00f3n en lista: \"\n                + this.listaAterrizaje.get(0).toString()\n            );\n\n            while ((this.pistaOcupada == true) ||\n                   (listaAterrizaje.get(0) != miAvion)) {\n                wait();\n            }\n\n            this.pistaOcupada = true;\n            System.out.println(\n                \"Torre control - \"\n                + miAvion.toString()\n                + \" Aterrizando (regi\u00f3n cr\u00edtica).\"\n            );\n\n            // Duerme entre 0 y 5 seg. para simular el uso de la pista\n            Thread.sleep(random.nextInt(10000));\n\n            this.pistaOcupada = false;\n            listaAterrizaje.remove(0);\n            notifyAll();\n\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    public synchronized void permisoDespegue(Avion miAvion) {\n        try {\n            while (this.pistaOcupada == true) {\n                wait();\n            }\n\n            this.pistaOcupada = true;\n            System.out.println(\n                \"Torre control - \"\n                + miAvion.toString()\n                + \" Despegando (regi\u00f3n cr\u00edtica).\"\n            );\n\n            // Duerme entre 0 y 5 seg. para simular el uso de la pista\n            Thread.sleep(random.nextInt(10000));\n\n            this.pistaOcupada = false;\n            notifyAll();\n\n        } catch (InterruptedException ignored) {\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2021/p2/#problema-2","title":"Problema 2","text":"<p>Se desea implementar un sistema que simule un conjunto de jugadores de un equipo de f!tbol americano, que est\"n sedientos, y una persona que actuar\" como aguador. Cada jugador se encargar\" peri$dicamente de extraer un vaso de una lista de vasos compartida, y de llenarlo de agua de una botella tambi#n compartida. El aguador comprobar\" continuamente que haya disponibles vasos y agua en la botella, rellenando ambos en caso contrario. Tanto los jugadores como el aguador tienen que poder trabajar de forma concurrente.</p> <p>Se incluye la implementaci$n de las clases necesarias, adem\"s del m#todo ExtraordinarioP2.main, que permite probar el programa con 20 jugadores y un aguador. </p> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n\npublic class ExtraordinarioP2 {\n\n    public static void main(String[] args) {\n        Botella botella = new Botella();\n        botella.litros = 100;\n\n        List&lt;Vaso&gt; vasos = new ArrayList&lt;Vaso&gt;();\n\n        Aguador aguador = new Aguador(botella, vasos);\n        aguador.start();\n\n        for (int i = 0; i &lt; 20; i++) {\n            Jugador jugador = new Jugador(botella, vasos);\n            jugador.start();\n        }\n    }\n}\n</code></pre> <pre><code>public class Vaso {\n    Integer capacidad;\n\n    public Vaso(int capacidad) {\n        this.capacidad = capacidad;\n    }\n}\n</code></pre> <pre><code>public class Botella {\n    Integer litros;\n}\n</code></pre> <pre><code>import java.util.List;\n\nclass Aguador extends Thread {\n\n    private Botella botella;\n    private List&lt;Vaso&gt; vasos;\n\n    public Aguador(Botella botella, List&lt;Vaso&gt; vasos) {\n        this.botella = botella;\n        this.vasos = vasos;\n    }\n\n    /*\n     * El aguador rellena la botella de agua, y pone vasos nuevos.\n     */\n    public void run() {\n        while (true) {\n            synchronized (this.botella) {\n                if (this.botella.litros &lt; 1) {\n                    System.out.println(\"Aguador rellena botella\");\n                    this.botella.litros = 10;\n                }\n            }\n\n            synchronized (this.vasos) {\n                if (this.vasos.size() &lt; 1) {\n                    for (int i = 0; i &lt; 10; i++) {\n                        this.vasos.add(new Vaso(1));\n                    }\n                    System.out.println(\"Aguador a\u00f1ade vaso\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>import java.util.List;\n\nclass Jugador extends Thread {\n\n    private Botella botella;\n    private List&lt;Vaso&gt; vasos;\n\n    public Jugador(Botella botella, List&lt;Vaso&gt; vasos) {\n        this.botella = botella;\n        this.vasos = vasos;\n    }\n\n    /*\n     * Cada jugador extrae un vaso, lo llena de agua y bebe.\n     */\n    public void run() {\n        Vaso vaso = null;\n\n        while (true) {\n            try {\n                System.out.println(\"Jugador intenta beber\");\n\n                synchronized (this.vasos) {\n                    if (this.vasos.size() &lt; 1) {\n                        continue;\n                    }\n                    if (vaso == null) {\n                        vaso = this.vasos.remove(0);\n                        System.out.println(\"Jugador ha cogido vaso\");\n                    }\n                }\n\n                synchronized (this.botella) {\n                    if (this.botella.litros &lt; vaso.capacidad) {\n                        continue;\n                    }\n                    Thread.sleep(500);\n                    this.botella.litros -= vaso.capacidad;\n                    System.out.println(\"Jugador ha bebido\");\n                }\n\n                // Tira el vaso\n                vaso = null;\n\n                Thread.sleep(6000);\n\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre> <p>Nota: Se recuerda que un bloque synchronized se asocia al objeto en el par\u00e1metro. Se garantiza exclusi\u00f3n mutua entre los bloques sincronizados que se invocan con el mismo objeto.</p> <ul> <li>(a) (2 puntos) 'Existe alg!n problema de acceso concurrente en esta implementaci$n?. Si es as&amp;, 'de qu# tipo es?. Justifique su respuesta.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed existe. Hay bloqueo exclusivo de los recursos, con espera, y en orden inverso: Aguador bloquea botella y luego vasos, mientras que Jugador bloquea los vasos primero.</p> <ul> <li>(b) (1 punto) 'C$mo solucionar&amp;a el problema?</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n m\u00e1s sencilla es invertir el orden del bloqueo en Aguador o en Jugador. Analizando el c\u00f3digo vemos que no se necesita bloquear sobre ambos recursos a la vez, as\u00ed que una mejor soluci\u00f3n ser\u00eda separar las dos regiones cr\u00edticas: primero bloquear vasos, acabar el bloque, y luego bloquear la botella (o viceversa).</p> <ul> <li>(c) (1 punto) Los vasos tienen una capacidad de 1 litro. Sin modificar la implementaci$n de Jugador, 'cu\"l es el n!mero m\"ximo de jugadores que podr&amp;an beber por minuto?</li> </ul> Mostrar soluci\u00f3n <p>Nos piden el m\u00e1ximo, con lo que usaremos el caso mejor. Para que un jugador pueda beber, tiene que haber bloqueado los vasos (500ms de espera) y luego la botella (1000ms). Ese es el m\u00ednimo tiempo necesario por jugador, y durante el cual los recursos est\u00e1n bloqueados. El tiempo de espera tras beber no afecta, porque se puede aumentar el n\u00famero de jugadores.</p> <p>Por tanto, el n\u00famero m\u00e1ximo de jugadores ser\u00eda 60s/ (1.5s/1 jugador) = 40 jugadores.</p> <p>Para este m\u00e1ximo, hemos supuesto que el tiempo de procesamiento (bloqueo) por el aguador, el de las operaciones b\u00e1sicas y el consumido por los cambios de contexto son despreciables.</p> <p>Se podr\u00eda aumentar el n\u00famero de jugadores por minuto separando los dos bloques synchronized (ver respuesta anterior), de forma que el tiempo de espera se reparta entre los dos elementos. De esa forma, el primer jugador tardar\u00eda 1.5s en beber, pero los siguientes podr\u00edan tardar s\u00f3lo 1s (la espera sobre los vasos puede darse a la vez que la espera sobre la botella). En ese caso, en el primer minuto podr\u00eda haber 59 jugadores, y 60 en los siguientes.</p> <p>Si se considera que NO se puede aumentar el n\u00famero de jugadores en ExtraordinarioP2, el n\u00famero m\u00e1ximo ser\u00eda 20 (es el n\u00famero de jugadores que a\u00f1adimos), que podr\u00edan llegar a beber 2 veces en ese minuto (20 jugadores tardan 30 segundos en completar, que es menor que el tiempo de espera post-bebida).</p> <ul> <li>(d) (1 punto) Si se desease sustituir los bloques sincronizados por m#todos sincronizados, 'en qu# clase o clases los implementar&amp;a?</li> </ul> Mostrar soluci\u00f3n <p>Los m\u00e9todos sincronizados aplican un bloqueo sobre el objeto al que pertenecen. Por tanto, estos m\u00e9todos deben estar definidos sobre un objeto com\u00fan a todas las hebras. Esto descarta Jugador y Aguador. En este caso, el \u00fanico objeto compartido es Botella. Para bloquear sobre la lista de vasos, habr\u00eda que crear una clase que represente la lista.</p>"},{"location":"exams/2021/p2_ex01/","title":"P2 ex01","text":"<p>Se quiere desarrollar una clase monitora TorreControl para gestionar una !nica pista de aterrizaje de un aeropuerto, con acceso exclusivo por parte de objetos de la clase Avion, que ser\"n las hebras. Los aviones pueden pedir a la torre de control aterrizar y despegar. Se pide desarrollar los siguientes m#todos:</p> <p></p> <ul> <li> <p>(a) (1,5 puntos) public \u2026 void avisoAterrizaje(Avion unAvion): para la maniobra de aterrizaje, los aviones primero avisar\"n a la torre de control (con este m#todo) de su intenci\\(n de aterrizar y despu#s preguntar\"n por el permiso para poder aterrizar. Cuando la torre de control reciba un aviso de aterrizaje deber\" a%adir el avi\\)n que solicit$ el permiso a una lista. Esta lista se ordenar\" por el combustible que tengan los aviones, siendo el que tenga menos combustible el primero de la lista y el primero en aterrizar (en caso de haber dos aviones con el mismo combustible ser\" indiferente el orden de aterrizaje entre ellos).</p> </li> <li> <p>(b) (2 puntos) public \u2026 void permisoAterrizaje(Avion unAvion): un avi\\(n invoca este m#todo para pedir permiso para aterrizar. Cuando la torre de control reciba la llamada de permiso de aterrizaje entonces solo dejar\" aterrizar al avi\\)n si lo tiene guardado en la lista de menos combustible y si la pista est\" libre. </p> </li> <li> <p>(c) (1,5 puntos) public \u2026 void permisoDespegue(Avion unAvion para la maniobra de despegue los aviones pedir\"n permiso para despegar. Se supone que todos los aviones tienen el m\"ximo de combustible y no hay prioridad, as&amp; que cuando pidan despegar podr\"n hacerlo siempre y cuando la pista est# libre.</p> </li> </ul> <p>Aclaraciones sobre el ejercicio:</p> <pre><code>- En la clase TorreControl se controla cu\u00e1ndo la pista est\u00e1 ocupada o libre. La pista estar\u00e1 ocupada cuando un avi\u00f3n ha recibido permiso a trav\u00e9s de los m\u00e9todos permisoAterrizaje o permisoDespegue. La pista se debe marcar como ocupada dentro de este m\u00e9todo cuando un avi\u00f3n tiene permiso y se mantiene as\u00ed en un tiempo, representado como Thread.sleep(random.nextInt(5000)). Al expirar este temporizador, la pista se marcar\u00e1 como libre.\n\n- Para simplificar este ejercicio, se supone que un avi\u00f3n mantiene constante su nivel de combustible, desde que notifica su intenci\u00f3n de aterrizar (con el m\u00e9todo avisoAterrizaje) hasta que recibe el permiso (con el m\u00e9todo permisoAterrizaje).\n\n- Se dispone un m\u00e9todo (no es necesario implementarlo) que recibe una lista de aviones y retorna una lista de aviones ordenada de menor a mayor por el combustible del avi\u00f3n: List&lt;Avion&gt; ordenarAvionesPorCompustible(List&lt;Avion&gt; listaAviones))\n</code></pre> <pre><code>// Ejemplo del posible c\u00f3digo de una hebra de la clase Avion\n\npublic class Avion extends Thread {\n\n    private TorreControl miTorre;\n    private int combustible;\n    private String matricula;\n\n    public Avion(TorreControl miTorre, String matricula, int combustible) {\n        this.miTorre = miTorre;\n        this.matricula = matricula;\n        this.combustible = combustible;\n    }\n\n    public int getCombustible() {\n        return this.combustible;\n    }\n\n    public String getMatricula() {\n        return this.matricula;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                this.miTorre.avisoAterrizaje(this);\n                this.miTorre.permisoAterrizaje(this);\n                this.miTorre.permisoDespegue(this);\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre> <pre><code>public static void main(String[] args) throws Exception {\n\n    TorreControl tc = new TorreControl(\"Barajas\");\n\n    new Avion(tc, \"aaa\", 30).start();\n    new Avion(tc, \"bbb\", 10).start();\n    new Avion(tc, \"ccc\", 20).start();\n    new Avion(tc, \"ddd\", 50).start();\n    new Avion(tc, \"eee\", 5).start();\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>import java.util.*;\n\npublic class TorreControl {\n\n    private String nombre;\n    private List&lt;Avion&gt; listaAterrizaje = new ArrayList&lt;Avion&gt;();\n    private volatile boolean pistaOcupada = false;\n    private Random random = new Random();\n\n    public TorreControl(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public synchronized void avisoAterrizaje(Avion miAvion) {\n        listaAterrizaje.add(miAvion);\n        // Se ha elegido esta forma de ordenaci\u00f3n pero puede hacerse de varias formas.\n        Collections.sort(this.listaAterrizaje, new OrdenarPorCombustible());\n        System.out.println(\n            \"Torre control - A\u00f1adido avi\u00f3n a la lista ordenada. \"\n            + this.listaAterrizaje.toString()\n        );\n    }\n\n    public synchronized void permisoAterrizaje(Avion miAvion) {\n        try {\n            System.out.println(\n                \"Torre control - Primer avi\u00f3n en lista: \"\n                + this.listaAterrizaje.get(0).toString()\n            );\n\n            while ((this.pistaOcupada == true) ||\n                   (listaAterrizaje.get(0) != miAvion)) {\n                wait();\n            }\n\n            this.pistaOcupada = true;\n            System.out.println(\n                \"Torre control - \"\n                + miAvion.toString()\n                + \" Aterrizando (regi\u00f3n cr\u00edtica).\"\n            );\n\n            // Duerme entre 0 y 5 seg. para simular el uso de la pista\n            Thread.sleep(random.nextInt(10000));\n\n            this.pistaOcupada = false;\n            listaAterrizaje.remove(0);\n            notifyAll();\n\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    public synchronized void permisoDespegue(Avion miAvion) {\n        try {\n            while (this.pistaOcupada == true) {\n                wait();\n            }\n\n            this.pistaOcupada = true;\n            System.out.println(\n                \"Torre control - \"\n                + miAvion.toString()\n                + \" Despegando (regi\u00f3n cr\u00edtica).\"\n            );\n\n            // Duerme entre 0 y 5 seg. para simular el uso de la pista\n            Thread.sleep(random.nextInt(10000));\n\n            this.pistaOcupada = false;\n            notifyAll();\n\n        } catch (InterruptedException ignored) {\n        }\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2021/p2_ex02/","title":"P2 ex02","text":"<p>Se desea implementar un sistema que simule un conjunto de jugadores de un equipo de f!tbol americano, que est\"n sedientos, y una persona que actuar\" como aguador. Cada jugador se encargar\" peri$dicamente de extraer un vaso de una lista de vasos compartida, y de llenarlo de agua de una botella tambi#n compartida. El aguador comprobar\" continuamente que haya disponibles vasos y agua en la botella, rellenando ambos en caso contrario. Tanto los jugadores como el aguador tienen que poder trabajar de forma concurrente.</p> <p>Se incluye la implementaci$n de las clases necesarias, adem\"s del m#todo ExtraordinarioP2.main, que permite probar el programa con 20 jugadores y un aguador. </p> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n\npublic class ExtraordinarioP2 {\n\n    public static void main(String[] args) {\n        Botella botella = new Botella();\n        botella.litros = 100;\n\n        List&lt;Vaso&gt; vasos = new ArrayList&lt;Vaso&gt;();\n\n        Aguador aguador = new Aguador(botella, vasos);\n        aguador.start();\n\n        for (int i = 0; i &lt; 20; i++) {\n            Jugador jugador = new Jugador(botella, vasos);\n            jugador.start();\n        }\n    }\n}\n</code></pre> <pre><code>public class Vaso {\n    Integer capacidad;\n\n    public Vaso(int capacidad) {\n        this.capacidad = capacidad;\n    }\n}\n</code></pre> <pre><code>public class Botella {\n    Integer litros;\n}\n</code></pre> <pre><code>import java.util.List;\n\nclass Aguador extends Thread {\n\n    private Botella botella;\n    private List&lt;Vaso&gt; vasos;\n\n    public Aguador(Botella botella, List&lt;Vaso&gt; vasos) {\n        this.botella = botella;\n        this.vasos = vasos;\n    }\n\n    /*\n     * El aguador rellena la botella de agua, y pone vasos nuevos.\n     */\n    public void run() {\n        while (true) {\n            synchronized (this.botella) {\n                if (this.botella.litros &lt; 1) {\n                    System.out.println(\"Aguador rellena botella\");\n                    this.botella.litros = 10;\n                }\n            }\n\n            synchronized (this.vasos) {\n                if (this.vasos.size() &lt; 1) {\n                    for (int i = 0; i &lt; 10; i++) {\n                        this.vasos.add(new Vaso(1));\n                    }\n                    System.out.println(\"Aguador a\u00f1ade vaso\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>import java.util.List;\n\nclass Jugador extends Thread {\n\n    private Botella botella;\n    private List&lt;Vaso&gt; vasos;\n\n    public Jugador(Botella botella, List&lt;Vaso&gt; vasos) {\n        this.botella = botella;\n        this.vasos = vasos;\n    }\n\n    /*\n     * Cada jugador extrae un vaso, lo llena de agua y bebe.\n     */\n    public void run() {\n        Vaso vaso = null;\n\n        while (true) {\n            try {\n                System.out.println(\"Jugador intenta beber\");\n\n                synchronized (this.vasos) {\n                    if (this.vasos.size() &lt; 1) {\n                        continue;\n                    }\n                    if (vaso == null) {\n                        vaso = this.vasos.remove(0);\n                        System.out.println(\"Jugador ha cogido vaso\");\n                    }\n                }\n\n                synchronized (this.botella) {\n                    if (this.botella.litros &lt; vaso.capacidad) {\n                        continue;\n                    }\n                    Thread.sleep(500);\n                    this.botella.litros -= vaso.capacidad;\n                    System.out.println(\"Jugador ha bebido\");\n                }\n\n                // Tira el vaso\n                vaso = null;\n\n                Thread.sleep(6000);\n\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre> <p>Nota: Se recuerda que un bloque synchronized se asocia al objeto en el par\u00e1metro. Se garantiza exclusi\u00f3n mutua entre los bloques sincronizados que se invocan con el mismo objeto.</p> <ul> <li>(a) (2 puntos) 'Existe alg!n problema de acceso concurrente en esta implementaci$n?. Si es as&amp;, 'de qu# tipo es?. Justifique su respuesta.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed existe. Hay bloqueo exclusivo de los recursos, con espera, y en orden inverso: Aguador bloquea botella y luego vasos, mientras que Jugador bloquea los vasos primero.</p> <ul> <li>(b) (1 punto) 'C$mo solucionar&amp;a el problema?</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n m\u00e1s sencilla es invertir el orden del bloqueo en Aguador o en Jugador. Analizando el c\u00f3digo vemos que no se necesita bloquear sobre ambos recursos a la vez, as\u00ed que una mejor soluci\u00f3n ser\u00eda separar las dos regiones cr\u00edticas: primero bloquear vasos, acabar el bloque, y luego bloquear la botella (o viceversa).</p> <ul> <li>(c) (1 punto) Los vasos tienen una capacidad de 1 litro. Sin modificar la implementaci$n de Jugador, 'cu\"l es el n!mero m\"ximo de jugadores que podr&amp;an beber por minuto?</li> </ul> Mostrar soluci\u00f3n <p>Nos piden el m\u00e1ximo, con lo que usaremos el caso mejor. Para que un jugador pueda beber, tiene que haber bloqueado los vasos (500ms de espera) y luego la botella (1000ms). Ese es el m\u00ednimo tiempo necesario por jugador, y durante el cual los recursos est\u00e1n bloqueados. El tiempo de espera tras beber no afecta, porque se puede aumentar el n\u00famero de jugadores.</p> <p>Por tanto, el n\u00famero m\u00e1ximo de jugadores ser\u00eda 60s/ (1.5s/1 jugador) = 40 jugadores.</p> <p>Para este m\u00e1ximo, hemos supuesto que el tiempo de procesamiento (bloqueo) por el aguador, el de las operaciones b\u00e1sicas y el consumido por los cambios de contexto son despreciables.</p> <p>Se podr\u00eda aumentar el n\u00famero de jugadores por minuto separando los dos bloques synchronized (ver respuesta anterior), de forma que el tiempo de espera se reparta entre los dos elementos. De esa forma, el primer jugador tardar\u00eda 1.5s en beber, pero los siguientes podr\u00edan tardar s\u00f3lo 1s (la espera sobre los vasos puede darse a la vez que la espera sobre la botella). En ese caso, en el primer minuto podr\u00eda haber 59 jugadores, y 60 en los siguientes.</p> <p>Si se considera que NO se puede aumentar el n\u00famero de jugadores en ExtraordinarioP2, el n\u00famero m\u00e1ximo ser\u00eda 20 (es el n\u00famero de jugadores que a\u00f1adimos), que podr\u00edan llegar a beber 2 veces en ese minuto (20 jugadores tardan 30 segundos en completar, que es menor que el tiempo de espera post-bebida).</p> <ul> <li>(d) (1 punto) Si se desease sustituir los bloques sincronizados por m#todos sincronizados, 'en qu# clase o clases los implementar&amp;a?</li> </ul> Mostrar soluci\u00f3n <p>Los m\u00e9todos sincronizados aplican un bloqueo sobre el objeto al que pertenecen. Por tanto, estos m\u00e9todos deben estar definidos sobre un objeto com\u00fan a todas las hebras. Esto descarta Jugador y Aguador. En este caso, el \u00fanico objeto compartido es Botella. Para bloquear sobre la lista de vasos, habr\u00eda que crear una clase que represente la lista.</p>","tags":["hebras"]},{"location":"exams/2021/p2r/","title":"Examen 2021 \u2014 Parcial 2 Recuperaci\u00f3n","text":""},{"location":"exams/2021/p2r/#problema-1","title":"Problema 1","text":"<p>El problema de los lectores/escritores est! planteado con un conjunto de hebras que comparten datos. Una parte de estas hebras (lectores) s\"lo leen los datos, mientras que el resto (escritores) leen y escriben. Varios lectores pueden acceder simult!neamente a los datos compartidos, pero se debe evitar que mientras un escritor est# accediendo a los datos acceda a ellos otra hebra de cualquier tipo.</p> <p>Las hebras correctas deben solicitar permiso para acceder los datos con empiezaLeer (lectores) o empiezaEscribir (escritores). Al terminar de usar los datos compartidos deben invocar a terminaLeer (lectores) o terminaEscribir (escritores). El acceso a los datos compartidos se hace fuera de este monitor. Si este protocolo para acceder a estos m#todos se satisface, se garantiza los requisitos del problema.</p> Modifier and Type Method Description void empiezaEscribir() M\u00e9todo que invoca una hebra escritora antes de comenzar a escribir void empiezaLeer() M\u00e9todo que invoca una hebra lectora antes de comenzar a leer void terminaEscribir() M\u00e9todo que invoca una hebra escritora al terminar de escribir void terminaLeer() M\u00e9todo que invoca una hebra lectora al terminar de leer <ul> <li>(a) (2,5 puntos) Sup\"ngase que en este sistema hay dos instancias de los datos compartidos: D1 y D2. Algunas hebras escritoras tienen que acceder con exclusi\"n mutua simult!neamente a D1 y D2, para cambiar los datos con coherencia. Es imprescindible hacerlo de esta forma. Justifique si en este supuesto podr$a producir interbloqueos.</li> </ul> Mostrar soluci\u00f3n <p>Si se analizan las condiciones de Coffman:     - 1. Exclusi\"n mutua: es as\\(, por el enunciado del problema     - 2. Tener y esperar: en los ejercicios que se han hecho, se usa este esquema. (se podr\\)a haber propuesto una implementaci\"n alternativa)     - 3. Sin expulsi\"n: al igual que en le caso anterior, no hay explusi\"n. Se podr$a proporcionar una alternativa.     - 4. Espera circular: en el enunciado, se indica que hay dos instancias para acceder a los datos y no se especifica en el orden en el que se pueda hacer. Por tanto, puede que haya espera circular, como se muestra a continuaci\"n. En este caso, E1 intenta coger D1 y D2, y E2 intenta coger en el otro orden</p> <p></p> <p>Se cumplan las cuatro condiciones, por lo que puede ocurrir un interbloqueo.</p> <ul> <li>(b) (2,5 puntos) A continuaci\"n, se muestra una posible soluci\"n al problema de los lectores/escritores. Analice este c\"digo y justifique si es correcto. En caso contrario, indique los cambios necesarios para que este c\"digo fuera una soluci\"n correcta.</li> </ul> <pre><code>public class GestorLE2 {\n    int nLectores = 0;\n    boolean bloqueoLector = false;\n    boolean bloqueoEscritor = false;\n\n    public synchronized void empiezaLeer()\n            throws InterruptedException {\n        int nLectores = 0;\n        if (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir()\n            throws InterruptedException {\n        if (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer() {\n        nLectores--;\n        bloqueoLector = false;\n        notifyAll();\n    }\n\n    public synchronized void terminaEscribir() {\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>El c\"digo es incorrecto. Hay que hacer los siguientes cambios:     - Los atributos tienen que ser privados     - Los m#todos wait, tienen que estar en un bloque while     - La declaraci\"n nLectores en el m#todo empiezaLeer no tiene sentido     - En el m#todo terminaLeer s\"lo hay asignar true a bloqueoLector cuando no hay lectores.</p> <pre><code>public class GestorLE {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n\n    public synchronized void empiezaLeer(int idLector)\n            throws InterruptedException {\n        int nLectores = 0;\n        while (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor)\n            throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2021/p2r/#problema-2","title":"Problema 2","text":"<p>La pr!ctica 4 inclu\\(a un conjunto de trenes que se mov\\)an de forma concurrente en su l$nea de metro, con bastantes simplificaciones respecto a la realidad. Una de ellas es que no se controlaba que varios trenes puedan estar cargando/descargando pasajeros de forma simult!nea en un mismo anden.</p> <p>Se ha modificado el m#todo irA (el m#todo que simulaba la entrada/salida en estaciones y en los tramos de l\\(nea) para evitar que m!s de un tren pueda estar ocupando un and#n de la misma l\\)nea y sentido, al mismo tiempo. Antes de entrar en la estaci\"n el tren pide permiso para entrar, indicando por qu# l\\(nea se mueve y su sentido. En el metro de Madrid, cada l\\)nea de metro tiene un and#n en cada sentido en todas las estaciones por las que pasa, que no comparte con ninguna otra l\\(nea. El c\"digo del m#todo irA queda de la siguiente forma (con simplificaciones). Se han insertado 2 l\\)neas de c\"digo (8 y 11): una para solicitar la entrada en la estaci\"n antes de entrar y otra para indicar que un tren abandona el and#n de la estaci\"n.</p> <p>El atributo estacion de la clase Tren representa la %ltima estaci\"n a la que ha llegado el tren. Para que este c\"digo funcione, la clase Estaci\"n debe implementar los m#todos permisoEntrada y salidaEstacion. Se puede modificar el constructor de Estaci\"n si fuera necesario.</p> <pre><code>01  TrayectoLineaMetro tr=linea.getSecuenciaMovimientos(origen,destino,ida);\n02  pasos.add(estacion);\n03  while (!tr.finMovimiento()) {\n04     Tramo c=tr.siguienteMovimiento();\n05     linea.getMapa().mueve(this, c);\n06     pasos.add(c.hasta());\n07     estacion=c.hasta();\n08     estacion.permisoEntrada(linea,ida);\n09     linea.getMapa().entraEnEstacion(this, c);\n10     linea.getMapa().desembarca(this, c.hasta());\n11     estacion.salidaEstacion(linea,ida);\n12  }\n13     if (!pasos.contains(destino))\n14     pasos.add(destino);\n</code></pre> <ul> <li>(a) (1 Punto) Incluir atributos en la clase Estacion que permitan saber los andenes de las l$neas que pasan por esa estaci\"n que est!n ocupados. Si es necesario modificar el constructor para inicializar esos atributos, se debe hacer en esta sub-pregunta.</li> </ul> <pre><code>// Constructor: id: identificador de estaci\u00f3n, posici\u00f3n de la estaci\u00f3n en el mapa,\n// tiempo de espera en los andenes, nombre de la estaci\u00f3n\npublic Estacion(int id, Vector posicion, double tiempo, String nombre) { ... }\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta, quiere entrar en la estaci\u00f3n\n... void permisoEntrada(LineaMetro l, boolean ida) { ... }\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta, abandona la estaci\u00f3n\n... void salidaEstacion(LineaMetro l, boolean ida) { ... }\n</code></pre> Mostrar soluci\u00f3n <p>Con esta soluci\"n hacemos lo que nos piden en el ejercicio: no mas de un tren est! descargando en un anden al mismo tiempo.</p> <pre><code>private Set&lt;LineaMetro&gt;[] andenes = new Set[2];\n\npublic EstacionS(int id, Vector posicion, double tiempo, String nombre) {\n    andenes[0] = new HashSet&lt;LineaMetro&gt;();\n    andenes[1] = new HashSet&lt;LineaMetro&gt;();\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// quiere entrar en la estaci\u00f3n\npublic synchronized void permisoEntrada(LineaMetro l, boolean ida) {\n    while (andenes[ida ? 1 : 0].contains(l)) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    andenes[ida ? 1 : 0].add(l);\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// abandona la estaci\u00f3n\npublic synchronized void salidaEstacion(LineaMetro l, boolean ida) {\n    if (!andenes[ida ? 1 : 0].contains(l)) {\n        throw new RuntimeException(\n            \"No podemos salir de un anden si no estamos dentro\"\n        );\n    }\n    andenes[ida ? 1 : 0].remove(l);\n    notifyAll();\n}\n</code></pre> <ul> <li>(b) (2 puntos) Implementar el m#todo permisoEntrada (incluida la cabecera) para que no m!s de un tren pueda estar ocupando un and#n en la estaci\"n.</li> </ul> Mostrar soluci\u00f3n <p>Con esta soluci\"n vamos un poco mas alla de lo que nos piden en el ejercicio: no solo evitamos que varios trenes est#n descargando en un and#n, sino que adem!s los trenes no podr!n adelantarse entre ellos, cuando llegan a una estaci\"n para descargar.</p> <pre><code>private Map&lt;LineaMetro, List&lt;Thread&gt;&gt;[] andenes = new Map[2];\n\npublic Estacion(int id, Vector posicion, double tiempo, String nombre) {\n    andenes[0] = new HashMap&lt;LineaMetro, List&lt;Thread&gt;&gt;();\n    andenes[1] = new HashMap&lt;LineaMetro, List&lt;Thread&gt;&gt;();\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// quiere entrar en la estaci\u00f3n\npublic synchronized void permisoEntrada(LineaMetro l, boolean ida) {\n    if (andenes[ida ? 1 : 0].get(l) == null) {\n        andenes[ida ? 1 : 0].put(l, new ArrayList&lt;Thread&gt;());\n    }\n\n    andenes[ida ? 1 : 0].get(l).add(Thread.currentThread());\n\n    while (andenes[ida ? 1 : 0].get(l).get(0) != Thread.currentThread()) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// abandona la estaci\u00f3n\npublic synchronized void salidaEstacion(LineaMetro l, boolean ida) {\n    if (andenes[ida ? 1 : 0].get(l).get(0) != Thread.currentThread()) {\n        throw new RuntimeException(\n            \"El tren que no esta en el anden no puede salir de la estacion\"\n        );\n    }\n\n    andenes[ida ? 1 : 0].get(l).remove(Thread.currentThread());\n    notifyAll();\n}\n</code></pre> <ul> <li>(c) (2 puntos) Implementar el m#todo salidaEstacion (incluida la cabecera) que libera el and#n y permite a otro tren que est! esperando ocupar el and#n.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p> <p>Nota: Los par!metros que se pasan al invocar un m#todo son correctos. No es necesario validarlos. No hay ninguna restricci\"n en la estructura de datos que se use en una soluci\"n.</p>"},{"location":"exams/2021/p2r_ex01/","title":"P2r ex01","text":"<p>El problema de los lectores/escritores est! planteado con un conjunto de hebras que comparten datos. Una parte de estas hebras (lectores) s\"lo leen los datos, mientras que el resto (escritores) leen y escriben. Varios lectores pueden acceder simult!neamente a los datos compartidos, pero se debe evitar que mientras un escritor est# accediendo a los datos acceda a ellos otra hebra de cualquier tipo.</p> <p>Las hebras correctas deben solicitar permiso para acceder los datos con empiezaLeer (lectores) o empiezaEscribir (escritores). Al terminar de usar los datos compartidos deben invocar a terminaLeer (lectores) o terminaEscribir (escritores). El acceso a los datos compartidos se hace fuera de este monitor. Si este protocolo para acceder a estos m#todos se satisface, se garantiza los requisitos del problema.</p> Modifier and Type Method Description void empiezaEscribir() M\u00e9todo que invoca una hebra escritora antes de comenzar a escribir void empiezaLeer() M\u00e9todo que invoca una hebra lectora antes de comenzar a leer void terminaEscribir() M\u00e9todo que invoca una hebra escritora al terminar de escribir void terminaLeer() M\u00e9todo que invoca una hebra lectora al terminar de leer <ul> <li>(a) (2,5 puntos) Sup\"ngase que en este sistema hay dos instancias de los datos compartidos: D1 y D2. Algunas hebras escritoras tienen que acceder con exclusi\"n mutua simult!neamente a D1 y D2, para cambiar los datos con coherencia. Es imprescindible hacerlo de esta forma. Justifique si en este supuesto podr$a producir interbloqueos.</li> </ul> Mostrar soluci\u00f3n <p>Si se analizan las condiciones de Coffman:     - 1. Exclusi\"n mutua: es as\\(, por el enunciado del problema     - 2. Tener y esperar: en los ejercicios que se han hecho, se usa este esquema. (se podr\\)a haber propuesto una implementaci\"n alternativa)     - 3. Sin expulsi\"n: al igual que en le caso anterior, no hay explusi\"n. Se podr$a proporcionar una alternativa.     - 4. Espera circular: en el enunciado, se indica que hay dos instancias para acceder a los datos y no se especifica en el orden en el que se pueda hacer. Por tanto, puede que haya espera circular, como se muestra a continuaci\"n. En este caso, E1 intenta coger D1 y D2, y E2 intenta coger en el otro orden</p> <p></p> <p>Se cumplan las cuatro condiciones, por lo que puede ocurrir un interbloqueo.</p> <ul> <li>(b) (2,5 puntos) A continuaci\"n, se muestra una posible soluci\"n al problema de los lectores/escritores. Analice este c\"digo y justifique si es correcto. En caso contrario, indique los cambios necesarios para que este c\"digo fuera una soluci\"n correcta.</li> </ul> <pre><code>public class GestorLE2 {\n    int nLectores = 0;\n    boolean bloqueoLector = false;\n    boolean bloqueoEscritor = false;\n\n    public synchronized void empiezaLeer()\n            throws InterruptedException {\n        int nLectores = 0;\n        if (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir()\n            throws InterruptedException {\n        if (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer() {\n        nLectores--;\n        bloqueoLector = false;\n        notifyAll();\n    }\n\n    public synchronized void terminaEscribir() {\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>El c\"digo es incorrecto. Hay que hacer los siguientes cambios:     - Los atributos tienen que ser privados     - Los m#todos wait, tienen que estar en un bloque while     - La declaraci\"n nLectores en el m#todo empiezaLeer no tiene sentido     - En el m#todo terminaLeer s\"lo hay asignar true a bloqueoLector cuando no hay lectores.</p> <pre><code>public class GestorLE {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n\n    public synchronized void empiezaLeer(int idLector)\n            throws InterruptedException {\n        int nLectores = 0;\n        while (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor)\n            throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2021/p2r_ex02/","title":"P2r ex02","text":"<p>La pr!ctica 4 inclu\\(a un conjunto de trenes que se mov\\)an de forma concurrente en su l$nea de metro, con bastantes simplificaciones respecto a la realidad. Una de ellas es que no se controlaba que varios trenes puedan estar cargando/descargando pasajeros de forma simult!nea en un mismo anden.</p> <p>Se ha modificado el m#todo irA (el m#todo que simulaba la entrada/salida en estaciones y en los tramos de l\\(nea) para evitar que m!s de un tren pueda estar ocupando un and#n de la misma l\\)nea y sentido, al mismo tiempo. Antes de entrar en la estaci\"n el tren pide permiso para entrar, indicando por qu# l\\(nea se mueve y su sentido. En el metro de Madrid, cada l\\)nea de metro tiene un and#n en cada sentido en todas las estaciones por las que pasa, que no comparte con ninguna otra l\\(nea. El c\"digo del m#todo irA queda de la siguiente forma (con simplificaciones). Se han insertado 2 l\\)neas de c\"digo (8 y 11): una para solicitar la entrada en la estaci\"n antes de entrar y otra para indicar que un tren abandona el and#n de la estaci\"n.</p> <p>El atributo estacion de la clase Tren representa la %ltima estaci\"n a la que ha llegado el tren. Para que este c\"digo funcione, la clase Estaci\"n debe implementar los m#todos permisoEntrada y salidaEstacion. Se puede modificar el constructor de Estaci\"n si fuera necesario.</p> <pre><code>01  TrayectoLineaMetro tr=linea.getSecuenciaMovimientos(origen,destino,ida);\n02  pasos.add(estacion);\n03  while (!tr.finMovimiento()) {\n04     Tramo c=tr.siguienteMovimiento();\n05     linea.getMapa().mueve(this, c);\n06     pasos.add(c.hasta());\n07     estacion=c.hasta();\n08     estacion.permisoEntrada(linea,ida);\n09     linea.getMapa().entraEnEstacion(this, c);\n10     linea.getMapa().desembarca(this, c.hasta());\n11     estacion.salidaEstacion(linea,ida);\n12  }\n13     if (!pasos.contains(destino))\n14     pasos.add(destino);\n</code></pre> <ul> <li>(a) (1 Punto) Incluir atributos en la clase Estacion que permitan saber los andenes de las l$neas que pasan por esa estaci\"n que est!n ocupados. Si es necesario modificar el constructor para inicializar esos atributos, se debe hacer en esta sub-pregunta.</li> </ul> <pre><code>// Constructor: id: identificador de estaci\u00f3n, posici\u00f3n de la estaci\u00f3n en el mapa,\n// tiempo de espera en los andenes, nombre de la estaci\u00f3n\npublic Estacion(int id, Vector posicion, double tiempo, String nombre) { ... }\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta, quiere entrar en la estaci\u00f3n\n... void permisoEntrada(LineaMetro l, boolean ida) { ... }\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta, abandona la estaci\u00f3n\n... void salidaEstacion(LineaMetro l, boolean ida) { ... }\n</code></pre> Mostrar soluci\u00f3n <p>Con esta soluci\"n hacemos lo que nos piden en el ejercicio: no mas de un tren est! descargando en un anden al mismo tiempo.</p> <pre><code>private Set&lt;LineaMetro&gt;[] andenes = new Set[2];\n\npublic EstacionS(int id, Vector posicion, double tiempo, String nombre) {\n    andenes[0] = new HashSet&lt;LineaMetro&gt;();\n    andenes[1] = new HashSet&lt;LineaMetro&gt;();\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// quiere entrar en la estaci\u00f3n\npublic synchronized void permisoEntrada(LineaMetro l, boolean ida) {\n    while (andenes[ida ? 1 : 0].contains(l)) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    andenes[ida ? 1 : 0].add(l);\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// abandona la estaci\u00f3n\npublic synchronized void salidaEstacion(LineaMetro l, boolean ida) {\n    if (!andenes[ida ? 1 : 0].contains(l)) {\n        throw new RuntimeException(\n            \"No podemos salir de un anden si no estamos dentro\"\n        );\n    }\n    andenes[ida ? 1 : 0].remove(l);\n    notifyAll();\n}\n</code></pre> <ul> <li>(b) (2 puntos) Implementar el m#todo permisoEntrada (incluida la cabecera) para que no m!s de un tren pueda estar ocupando un and#n en la estaci\"n.</li> </ul> Mostrar soluci\u00f3n <p>Con esta soluci\"n vamos un poco mas alla de lo que nos piden en el ejercicio: no solo evitamos que varios trenes est#n descargando en un and#n, sino que adem!s los trenes no podr!n adelantarse entre ellos, cuando llegan a una estaci\"n para descargar.</p> <pre><code>private Map&lt;LineaMetro, List&lt;Thread&gt;&gt;[] andenes = new Map[2];\n\npublic Estacion(int id, Vector posicion, double tiempo, String nombre) {\n    andenes[0] = new HashMap&lt;LineaMetro, List&lt;Thread&gt;&gt;();\n    andenes[1] = new HashMap&lt;LineaMetro, List&lt;Thread&gt;&gt;();\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// quiere entrar en la estaci\u00f3n\npublic synchronized void permisoEntrada(LineaMetro l, boolean ida) {\n    if (andenes[ida ? 1 : 0].get(l) == null) {\n        andenes[ida ? 1 : 0].put(l, new ArrayList&lt;Thread&gt;());\n    }\n\n    andenes[ida ? 1 : 0].get(l).add(Thread.currentThread());\n\n    while (andenes[ida ? 1 : 0].get(l).get(0) != Thread.currentThread()) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// abandona la estaci\u00f3n\npublic synchronized void salidaEstacion(LineaMetro l, boolean ida) {\n    if (andenes[ida ? 1 : 0].get(l).get(0) != Thread.currentThread()) {\n        throw new RuntimeException(\n            \"El tren que no esta en el anden no puede salir de la estacion\"\n        );\n    }\n\n    andenes[ida ? 1 : 0].get(l).remove(Thread.currentThread());\n    notifyAll();\n}\n</code></pre> <ul> <li>(c) (2 puntos) Implementar el m#todo salidaEstacion (incluida la cabecera) que libera el and#n y permite a otro tren que est! esperando ocupar el and#n.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p> <p>Nota: Los par!metros que se pasan al invocar un m#todo son correctos. No es necesario validarlos. No hay ninguna restricci\"n en la estructura de datos que se use en una soluci\"n.</p>","tags":["complejidad"]},{"location":"exams/20XXTemplate/extra/","title":"Examen 20XX \u2014 Extraordinario","text":""},{"location":"exams/20XXTemplate/extra/#problema-1","title":"Problema 1","text":""},{"location":"exams/20XXTemplate/extra/#problema-2","title":"Problema 2","text":""},{"location":"exams/20XXTemplate/p1/","title":"Examen 20XX \u2014 Parcial 1","text":""},{"location":"exams/20XXTemplate/p1/#problema-1","title":"Problema 1","text":""},{"location":"exams/20XXTemplate/p1/#problema-2","title":"Problema 2","text":""},{"location":"exams/20XXTemplate/p1r/","title":"Examen 20XX \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/20XXTemplate/p1r/#problema-1","title":"Problema 1","text":""},{"location":"exams/20XXTemplate/p1r/#problema-2","title":"Problema 2","text":""},{"location":"exams/20XXTemplate/p2/","title":"Examen 20XX \u2014 Parcial 2","text":""},{"location":"exams/20XXTemplate/p2/#problema-1","title":"Problema 1","text":""},{"location":"exams/20XXTemplate/p2/#problema-2","title":"Problema 2","text":""}]}