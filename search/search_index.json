{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cat\u00e1logo de Ejercicios","text":"<p>Bienvenido al cat\u00e1logo.</p>"},{"location":"tags/","title":"Tags","text":"<p> Listado de tags</p> <p>La siguiente p\u00e1gina muestra autom\u00e1ticamente todos los ejercicios agrupados por tag.</p>"},{"location":"tags/#_1","title":"???","text":"<p>9 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2015-03 2015 parcial 1 ex-2015-02 2015 parcial 1 recuperacion ex-2016-06 2016 extraordinario ex-2016-02 2016 parcial 1 recuperacion ex-2019-01 2019 extraordinario ex-2019-02 2019 parcial 1 recuperacion ex-2019-02 2019 practicas ex-2025-01 2023 parcial 1 ex-2025-01 2025 parcial 1"},{"location":"tags/#android","title":"Android","text":"<p>1 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2019-02 2019 parcial 2"},{"location":"tags/#actividades","title":"Actividades","text":"<p>1 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-03 2012 final"},{"location":"tags/#android_1","title":"Android","text":"<p>20 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-03 2012 extraordinario ex-2012-03 2012 final ex-2013-04 2013 extraordinario ex-2013-03 2013 extraordinario ex-2013-02 2013 parcial 2 ex-2014-04 2014 extraordinario ex-2014-03 2014 extraordinario ex-2014-02 2014 parcial 2 ex-2014-01 2014 parcial 2 ex-2015-04 2015 extraordinario ex-2015-05 2015 extraordinario ex-2015-02 2015 parcial 2 ex-2015-01 2015 parcial 2 ex-2016-05 2016 extraordinario ex-2016-07 2016 extraordinario ex-2016-01 2016 parcial 2 ex-2017-01 2017 extraordinario ex-2017-02 2017 parcial 2 ex-2018-06 2018 extraordinario ex-2019-05 2019 extraordinario"},{"location":"tags/#complejidad","title":"Complejidad","text":"<p>65 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-01 2012 final ex-2012-01 2012 parcial 1 ex-2012-02 2012 parcial 1 ex-2012-02 2012 parcial 2 ex-2013-01 2013 extraordinario ex-2013-01 2013 parcial 1 ex-2013-01 2013 parcial 1 recuperacion ex-2014-01 2014 extraordinario ex-2014-01 2014 parcial 1 ex-2014-01 2014 parcial 1 recuperacion ex-2015-01 2015 extraordinario ex-2015-01 2015 parcial 1 ex-2015-01 2015 parcial 1 recuperacion ex-2016-02 2016 extraordinario ex-2016-01 2016 extraordinario ex-2016-01 2016 parcial 1 ex-2016-03 2016 parcial 1 ex-2016-01 2016 parcial 1 recuperacion ex-2017-02 2017 extraordinario ex-2017-01 2017 extraordinario ex-2017-01 2017 extraordinario ex-2017-01 2017 parcial 1 ex-2017-01 2017 parcial 1 ex-2017-01 2017 parcial 1 recuperacion ex-2018-02 2018 extraordinario ex-2018-01 2018 extraordinario ex-2018-01 2018 parcial 1 recuperacion ex-2019-02 2019 extraordinario ex-2019-02 2019 parcial 1 ex-2019-01 2019 parcial 1 recuperacion ex-2021-02 2021 extraordinario ex-2021-01 2021 parcial 1 ex-2021-02 2021 parcial 1 ex-2021-02 2021 parcial 2 ex-2022-02 2022 extraordinario ex-2022-02 2022 parcial 1 ex-2022-01 2022 parcial 1 recuperacion ex-2022-02 2022 parcial 1 recuperacion ex-2024-02 2024 extraordinario ex-2024-01 2024 extraordinario ex-2024-01 2024 parcial 1 ex-2024-02 2024 parcial 1 ex-2024-01 2024 parcial 1 recuperacion ex-2024-02 2024 parcial 1 recuperacion ex-2024-05 2024 practicas ex-2024-02 2024 practicas ex-2024-01 2024 practicas ex-2025-02 2025 extraordinario ex-2025-03 2025 extraordinario ex-2025-06 2025 extraordinario ex-2025-01 2025 extraordinario ex-2025-04 2025 extraordinario ex-2025-05 2025 extraordinario ex-2025-01 2025 parcial 1 recuperacion ex-2025-02 2025 parcial 1 recuperacion ex-2025-01 2025 practicas ex-20XX-02 20XX extraordinario ex-20XX-02 20XX extraordinario ex-20XX-01 20XX extraordinario ex-20XX-01 20XX parcial 1 ex-20XX-02 20XX parcial 1 ex-20XX-01 20XX parcial 1 recuperacion ex-20XX-02 20XX parcial 1 recuperacion ex-20XX-02 20XX parcial 2 ex-20XX-01 20XX parcial 2"},{"location":"tags/#concurrencia","title":"Concurrencia","text":"<p>3 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-02 2012 final ex-2023-01 2023 parcial 2 ex-2025-01 2025 parcial 2"},{"location":"tags/#grafos","title":"Grafos","text":"<p>20 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2017-02 2017 parcial 1 ex-2017-01 2017 parcial 1 recuperacion ex-2018-01 2018 parcial 1 ex-2018-02 2018 parcial 1 ex-2018-02 2018 parcial 1 recuperacion ex-2019-02 2019 extraordinario ex-2019-01 2019 parcial 1 ex-2021-01 2021 extraordinario ex-2021-01 2021 parcial 1 ex-2021-02 2021 parcial 1 recuperacion ex-2022-01 2022 extraordinario ex-2022-01 2022 parcial 1 ex-2023-01 2023 parcial 1 ex-2023-01 2023 parcial 1 ex-2023-01 2023 parcial 1 ex-2023-01 2023 parcial 1 ex-2024-04 2024 extraordinario ex-2024-02 2024 parcial 2 ex-2024-04 2024 practicas ex-2025-02 2025 parcial 2"},{"location":"tags/#hebras","title":"Hebras","text":"<p>21 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-02 2012 parcial 2 ex-2012-02 2012 parcial 2 ex-2016-03 2016 extraordinario ex-2016-01 2016 parcial 2 ex-2017-01 2017 extraordinario ex-2017-01 2017 parcial 2 ex-2018-03 2018 extraordinario ex-2018-02 2018 parcial 2 ex-2018-01 2018 parcial 2 ex-2019-03 2019 extraordinario extra_ex04 2019 extraordinario ex-2021-01 2021 parcial 1 recuperacion ex-2021-01 2021 parcial 2 ex-2021-02 2021 parcial 2 recuperacion ex-2021-01 2021 parcial 2 recuperacion ex-2022-02 2022 parcial 2 ex-2022-01 2022 parcial 2 ex-2024-03 2024 extraordinario ex-2024-01 2024 parcial 2 ex-2024-03 2024 practicas ex-2025-03 2025 practicas"},{"location":"tags/#monitores","title":"Monitores","text":"<p>18 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-02 2012 final ex-2013-02 2013 extraordinario ex-2013-02 2013 parcial 1 ex-2013-02 2013 parcial 1 recuperacion ex-2014-02 2014 extraordinario ex-2014-02 2014 parcial 1 ex-2014-02 2014 parcial 1 recuperacion ex-2015-03 2015 extraordinario ex-2015-02 2015 extraordinario ex-2015-02 2015 parcial 1 ex-2015-02 2015 parcial 1 recuperacion ex-2016-04 2016 extraordinario ex-2016-03 2016 parcial 1 recuperacion ex-2018-04 2018 extraordinario ex-2018-05 2018 extraordinario ex-2018-02 2018 parcial 2 ex-2018-01 2018 parcial 2 ex-2019-01 2019 parcial 2"},{"location":"tags/#ordenacion","title":"Ordenaci\u00f3n","text":"<p>1 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2012-01 2012 final"},{"location":"tags/#princeton","title":"Princeton","text":"<p>4 ejercicio(s)</p> Ejercicio A\u00f1o Examen ex-2022-01 2022 parcial 1 ex-2023-01 2023 parcial 1 ex-2023-01 2023 parcial 1 ex-2023-01 2023 parcial 1"},{"location":"exams/2012/ex01/","title":"Ex01","text":"<ul> <li>(a) (1,5 puntos) Se pide escribir un algoritmo de ordenaci\u00f3n con la siguiente interfaz</li> </ul> <pre><code>int[] ordena(long[] datos)\n</code></pre> <p>de tal forma que los datos de entrada no se modifican y el m\u00e9todo devuelve un array que contiene en qu\u00e9 posici\u00f3n deber\u00eda ir del dato correspondiente para estar en orden ascendente. Por ejemplo:</p> <pre><code>datos:   [8, 42, 46, 24, 29, 7]\nindices: [1,  4,  5,  2,  3, 0]\n</code></pre> <p>que se lee como que     - datos[0] se ordenar\u00eda en la posici\u00f3n 1     - datos[1] se ordenar\u00eda en la posici\u00f3n 4     - datos[2] se ordenar\u00eda en la posici\u00f3n 5     - etc.</p> <p>NOTA: Si hubiera 2 datos de igual valor, da igual cual de ellos va antes o despu\u00e9s. Elija lo que le sea m\u00e1s c\u00f3modo.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre></p> <ul> <li>(b) (1,5 puntos) Estime la complejidad del  algoritmo  del  punto anterior,  contando  el  n\u00famero  de  comparaciones entre datos (enteros <code>long</code>) que hay que hacer en el caso peor.</li> </ul> Mostrar soluci\u00f3n <p>Hay 2 bucles, uno dentro del otro.</p> <p>El bucle exterior se hace \\(N\\) veces.</p> <p>En el bucle interior, la primera vez se hacen \\(N-1\\) comparaciones; la segunda vez, \\(N-2\\); la tercera \\(N-3\\), etc. </p> <p>En total \\((N-1) + (N-2) + ... + 1 \\leftarrow \\mathcal{O}(N^2)\\)</p>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex02/","title":"Ex02","text":"<p>Sea un puente con capacidad para un veh\u00edculo y dos accesos: norte y sur. En caso de que haya veh\u00edculos intentando entrar por los dos accesos, debe entrar un veh\u00edculo por el extremo en el que haya m\u00e1s esperando (si el n\u00famero de veh\u00edculos esperando en cada extremo es el mismo, no es necesario imponer un orden). En el caso de que intente entrar una ambulancia, tendr\u00e1 prioridad sobre el resto de veh\u00edculos. No es necesario considerar el caso en que dos ambulancias intenten acceder simult\u00e1neamente al puente. </p> <ul> <li>(a) (3 puntos) Se  pide  desarrollar  una  clase  monitor  <code>GestorPuente</code>  que  gestione  el  acceso  al  puente,  seg\u00fan  la especificaci\u00f3n  previa.  Los  m\u00e9todos  de  esta  clase  no  retornan  valores.  El  esqueleto  de  la  clase  es  el siguiente:</li> </ul> <pre><code>public class GestorPuente {\n    ... void entrarNorte () { ...}\n    ... void entrarSur () { ...}\n    ... void entrarAmbulancia () { ...}\n    ... void salirPuente(){...}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>package es.upm.dit.adsw.puenteTurnoEspera;\n/**\n* Monitor que gestiona la entrada a un puente de coches\n* por sus dos extremos (norte y sur). Dentro el puente s\u00f3lo puede\n* haber un coche. Si hay coches esperando en sus dos extremos, entra\n* uno por el extremos con m\u00e1s coches esperando. Si intenta entrar una\n* ambulancia, tendr\u00e1 prioridad. No pueden intentar dos ambulancias\n* simultaneamente.\n*/\npublic class GestorPuente { // monitor\n/**\n* Indica si hay un coche dentro del puente\n*/\nprivate boolean hayCocheEnPuente = false;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Norte\n*/\nprivate int nCochesNorte = 0;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Sur\n*/\nprivate int nCochesSur = 0;\n/**\n    Indica si hay una ambulancia esperando.\n\n*/\nprivate boolean hayAmbulancia = false;\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el norte.\n*  El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n*  coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarNorte() throws InterruptedException {\n    nCochesNorte++;\n    !!while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur)\n        wait();\n    hayCocheEnPuente = true;\n    nCochesNorte--;\n}\n\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el sur.\n* El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n* coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarSur() throws InterruptedException {\n    nCochesSur++;\n    while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte)\n    wait();\n    hayCocheEnPuente = true;\n    nCochesSur--;\n}\n/**\n* M\u00e9todo que ejecutan las ambulancias\n*/\npublic synchronized void entrarAmbulancia() throws InterruptedException {\n    hayAmbulancia = true;\n    while (hayCocheEnPuente) wait();\n    hayCocheEnPuente = true;\n    hayAmbulancia = false;\n}\n\n/**\n* M\u00e9todo que invoca un coche que est\u00e1 en el puente al salir de \u00e9l.\n*/\npublic synchronized void salirPuente() {\n    hayCocheEnPuente = false;\n    notifyAll();\n}\n}\n</code></pre></p>","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex03/","title":"Ex03","text":"<p>Tenemos una aplicaci\u00f3n de Android que calcula la nota de ADSW como se muestra a continuaci\u00f3n.</p> <p>Como hemos visto, la aplicaci\u00f3n consta de dos pantallas, un formulario inicial (<code>NotaMediaActivity</code>) y  una pantalla que muestra  una foto y  el resultado (<code>ResultadoActivity</code>). Ambas clases est\u00e1n en el paquete <code>es.upm.dit.adsw</code>.</p> <p>El c\u00e1lculo de  la nota media se realiza de la siguiente forma:     - S\u00f3lo se hace media si ambas notas  son mayores o iguales a 4.      - La nota es 0.6 \\(\\cdot\\) * nota de de examen + 0.4 * nota de trabajo</p> <ul> <li> <p>(a) (1 punto) Complete el c\u00f3digo del fichero de manifiesto del listado 1 para que la aplicaci\u00f3n muestre la pantalla inicial (formulario) y pueda pasar a la segunda de resultado con la media.</p> </li> <li> <p>(b)(2 puntos) Programe la actividad <code>NotaMediaActivity</code>. Debe tener en cuenta:</p> <ul> <li>Si el usuario no rellena un campo o introduce un valor no num\u00e9rico, debe mostrar un mensaje indic\u00e1ndole que debe introducir valores num\u00e9ricos (use un <code>Toast</code>).</li> <li>La actividad <code>ResultadoActivity</code> espera recibir una intenci\u00f3n con dos par\u00e1metros extra: <ul> <li>un primer par\u00e1metro de tipo boolean denominado <code>aprobado</code> (<code>true</code> si cumple umbrales y media &gt; = 5; <code>false</code> en caso contrario)</li> <li>un segundo par\u00e1metro de tipo <code>String</code> denominado <code>valor</code> (contiene un mensaje indicando qu\u00e9 umbral no se ha superado si no se puede hacer la media, o bien el valor de la nota media).</li> </ul> </li> <li>Los listados 2 y 3 le proporcionan informaci\u00f3n del layout de <code>NotaMediaActivity</code> y las cadenas string.xml de la aplicaci\u00f3n.</li> </ul> </li> </ul> <p>Listado 1. C\u00f3digo de AndroidManifest.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"COMPLETAR POR EL ALUMMNO\" &lt;!-- COMPLETAR --&gt;\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n     &gt;\n       &lt;!-- COMPLETAR POR EL ALUMNO --&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>Listado 2.  C\u00f3digo de layout/ notamedia_final.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;TableLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" \n    android:background=\"@drawable/notebook\"\n    android:paddingLeft=\"40dp\"\n    android:paddingRight=\"5dp\" &gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_examen\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_examen_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n            &lt;requestFocus /&gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_trabajo\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_trabajo_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow\n        android:gravity=\"center\"&gt;\n        &lt;Button\n            android:id=\"@+id/button_calcular\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/calcular\" /&gt;\n    &lt;/TableRow&gt;\n&lt;/TableLayout&gt;\n</code></pre></p> <p>Listado 3. C\u00f3digo de values/strings.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;NotaMediaADSW&lt;/string&gt;\n    &lt;string name=\"nota_trabajo\"&gt;Nota trabajo final&lt;/string&gt;\n    &lt;string name=\"nota_examen\"&gt;Nota examen final&lt;/string&gt;\n    &lt;string name=\"nota_media\"&gt;Nota media&lt;/string&gt;\n    &lt;string name=\"calcular\"&gt;Calcular&lt;/string&gt;\n    &lt;string name=\"error_numero\"&gt;Los campos deben ser num\u00e9ricos&lt;/string&gt;\n    &lt;string name=\"umbral_trabajo\"&gt;No has superado el umbral de 4.0 en la pr\u00e1ctica&lt;/string&gt;\n    &lt;string name=\"umbral_examen\"&gt;No has superado el umbral de 4.0 en el examen&lt;/string&gt;        \n     &lt;string name=\"enhorabuena\"&gt;Enhorabuena, que pases un buen verano.&lt;/string&gt;\n    &lt;string name=\"julio\"&gt;Hay otra oportunidad en julio. &lt;/string&gt;\n    &lt;string name=\"nota\"&gt;La nota es &lt;/string&gt;\n    &lt;string name=\"problema_nota\"&gt;Hay un problema para mostrar la nota&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre></p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n    &gt;\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\" &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <pre><code>public class NotaMediaActivity extends Activity {\npublic static final String APROBADO = \"nota\";\npublic static final String VALOR = \"valor\";\nprivate static final String TAG = NotaMediaActivity.class.getSimpleName();\nprivate EditText editNotaFinal;\nprivate EditText editTrabajoFinal;\nprivate Button buttonGuardar;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    Log.d(TAG, \"onCreate\");\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.notamedia_final);\n    editNotaFinal = (EditText) findViewById(R.id.editText_examen_final);\n    editTrabajoFinal = (EditText) findViewById(R.id.editText_trabajo_final);\n    buttonGuardar = (Button) findViewById(R.id.button_calcular);\n    buttonGuardar.setOnClickListener(new ProcesaMedia());\n}\n\nprivate class ProcesaMedia implements OnClickListener {\n    @Override\n    public void onClick(View v) {\n    try {\n        float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n        float notaTrabajo =\n            Float.parseFloat(editTrabajoFinal.getText().toString());\n        if ((notaFinal &lt; 0) || (notaFinal &gt; 10) || (notaTrabajo &lt; 0)\n            || (notaTrabajo &gt; 10)) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n        return;\n        }\n        float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String mediaString = df.format(media);\n        boolean aprobado = false;\n        String valor = \"\";\n        if ((notaTrabajo &lt; 4) || (notaFinal &lt; 4)) {\n        aprobado = false;\n        if (notaTrabajo &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_trabajo);\n        }\n        if (notaFinal &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_examen);\n        }\n        } else {\n        valor = mediaString;\n        aprobado = (media &gt;= 5);\n        }\n        Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n        intent.putExtra(APROBADO, aprobado);\n        intent.putExtra(VALOR, valor);\n        Log.d(TAG, \"Nota \" + aprobado + \" \" + valor);\n        startActivity(intent);\n    } catch (NumberFormatException e) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n    }\n    }\n}\n}\n</code></pre>","tags":["android","actividades"]},{"location":"exams/2012/exam/","title":"Examen 2012 \u2014 Final","text":""},{"location":"exams/2012/exam/#ejercicio-1","title":"Ejercicio 1","text":"<ul> <li>(a) (1,5 puntos) Se pide escribir un algoritmo de ordenaci\u00f3n con la siguiente interfaz</li> </ul> <pre><code>int[] ordena(long[] datos)\n</code></pre> <p>de tal forma que los datos de entrada no se modifican y el m\u00e9todo devuelve un array que contiene en qu\u00e9 posici\u00f3n deber\u00eda ir del dato correspondiente para estar en orden ascendente. Por ejemplo:</p> <pre><code>datos:   [8, 42, 46, 24, 29, 7]\nindices: [1,  4,  5,  2,  3, 0]\n</code></pre> <p>que se lee como que     - datos[0] se ordenar\u00eda en la posici\u00f3n 1     - datos[1] se ordenar\u00eda en la posici\u00f3n 4     - datos[2] se ordenar\u00eda en la posici\u00f3n 5     - etc.</p> <p>NOTA: Si hubiera 2 datos de igual valor, da igual cual de ellos va antes o despu\u00e9s. Elija lo que le sea m\u00e1s c\u00f3modo.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre></p> <ul> <li>(b) (1,5 puntos) Estime la complejidad del  algoritmo  del  punto anterior,  contando  el  n\u00famero  de  comparaciones entre datos (enteros <code>long</code>) que hay que hacer en el caso peor.</li> </ul> Mostrar soluci\u00f3n <p>Hay 2 bucles, uno dentro del otro.</p> <p>El bucle exterior se hace \\(N\\) veces.</p> <p>En el bucle interior, la primera vez se hacen \\(N-1\\) comparaciones; la segunda vez, \\(N-2\\); la tercera \\(N-3\\), etc. </p> <p>En total \\((N-1) + (N-2) + ... + 1 \\leftarrow \\mathcal{O}(N^2)\\)</p>"},{"location":"exams/2012/exam/#ejercicio-2","title":"Ejercicio 2","text":"<p>Sea un puente con capacidad para un veh\u00edculo y dos accesos: norte y sur. En caso de que haya veh\u00edculos intentando entrar por los dos accesos, debe entrar un veh\u00edculo por el extremo en el que haya m\u00e1s esperando (si el n\u00famero de veh\u00edculos esperando en cada extremo es el mismo, no es necesario imponer un orden). En el caso de que intente entrar una ambulancia, tendr\u00e1 prioridad sobre el resto de veh\u00edculos. No es necesario considerar el caso en que dos ambulancias intenten acceder simult\u00e1neamente al puente. </p> <ul> <li>(a) (3 puntos) Se  pide  desarrollar  una  clase  monitor  <code>GestorPuente</code>  que  gestione  el  acceso  al  puente,  seg\u00fan  la especificaci\u00f3n  previa.  Los  m\u00e9todos  de  esta  clase  no  retornan  valores.  El  esqueleto  de  la  clase  es  el siguiente:</li> </ul> <pre><code>public class GestorPuente {\n    ... void entrarNorte () { ...}\n    ... void entrarSur () { ...}\n    ... void entrarAmbulancia () { ...}\n    ... void salirPuente(){...}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>package es.upm.dit.adsw.puenteTurnoEspera;\n/**\n* Monitor que gestiona la entrada a un puente de coches\n* por sus dos extremos (norte y sur). Dentro el puente s\u00f3lo puede\n* haber un coche. Si hay coches esperando en sus dos extremos, entra\n* uno por el extremos con m\u00e1s coches esperando. Si intenta entrar una\n* ambulancia, tendr\u00e1 prioridad. No pueden intentar dos ambulancias\n* simultaneamente.\n*/\npublic class GestorPuente { // monitor\n/**\n* Indica si hay un coche dentro del puente\n*/\nprivate boolean hayCocheEnPuente = false;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Norte\n*/\nprivate int nCochesNorte = 0;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Sur\n*/\nprivate int nCochesSur = 0;\n/**\n    Indica si hay una ambulancia esperando.\n\n*/\nprivate boolean hayAmbulancia = false;\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el norte.\n*  El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n*  coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarNorte() throws InterruptedException {\n    nCochesNorte++;\n    !!while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur)\n        wait();\n    hayCocheEnPuente = true;\n    nCochesNorte--;\n}\n\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el sur.\n* El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n* coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarSur() throws InterruptedException {\n    nCochesSur++;\n    while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte)\n    wait();\n    hayCocheEnPuente = true;\n    nCochesSur--;\n}\n/**\n* M\u00e9todo que ejecutan las ambulancias\n*/\npublic synchronized void entrarAmbulancia() throws InterruptedException {\n    hayAmbulancia = true;\n    while (hayCocheEnPuente) wait();\n    hayCocheEnPuente = true;\n    hayAmbulancia = false;\n}\n\n/**\n* M\u00e9todo que invoca un coche que est\u00e1 en el puente al salir de \u00e9l.\n*/\npublic synchronized void salirPuente() {\n    hayCocheEnPuente = false;\n    notifyAll();\n}\n}\n</code></pre></p>"},{"location":"exams/2012/exam/#ejercicio-3","title":"Ejercicio 3","text":"<p>Tenemos una aplicaci\u00f3n de Android que calcula la nota de ADSW como se muestra a continuaci\u00f3n.</p> <p>Como hemos visto, la aplicaci\u00f3n consta de dos pantallas, un formulario inicial (<code>NotaMediaActivity</code>) y  una pantalla que muestra  una foto y  el resultado (<code>ResultadoActivity</code>). Ambas clases est\u00e1n en el paquete <code>es.upm.dit.adsw</code>.</p> <p>El c\u00e1lculo de  la nota media se realiza de la siguiente forma:     - S\u00f3lo se hace media si ambas notas  son mayores o iguales a 4.      - La nota es 0.6 \\(\\cdot\\) * nota de de examen + 0.4 * nota de trabajo</p> <ul> <li> <p>(a) (1 punto) Complete el c\u00f3digo del fichero de manifiesto del listado 1 para que la aplicaci\u00f3n muestre la pantalla inicial (formulario) y pueda pasar a la segunda de resultado con la media.</p> </li> <li> <p>(b)(2 puntos) Programe la actividad <code>NotaMediaActivity</code>. Debe tener en cuenta:</p> <ul> <li>Si el usuario no rellena un campo o introduce un valor no num\u00e9rico, debe mostrar un mensaje indic\u00e1ndole que debe introducir valores num\u00e9ricos (use un <code>Toast</code>).</li> <li>La actividad <code>ResultadoActivity</code> espera recibir una intenci\u00f3n con dos par\u00e1metros extra: <ul> <li>un primer par\u00e1metro de tipo boolean denominado <code>aprobado</code> (<code>true</code> si cumple umbrales y media &gt; = 5; <code>false</code> en caso contrario)</li> <li>un segundo par\u00e1metro de tipo <code>String</code> denominado <code>valor</code> (contiene un mensaje indicando qu\u00e9 umbral no se ha superado si no se puede hacer la media, o bien el valor de la nota media).</li> </ul> </li> <li>Los listados 2 y 3 le proporcionan informaci\u00f3n del layout de <code>NotaMediaActivity</code> y las cadenas string.xml de la aplicaci\u00f3n.</li> </ul> </li> </ul> <p>Listado 1. C\u00f3digo de AndroidManifest.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"COMPLETAR POR EL ALUMMNO\" &lt;!-- COMPLETAR --&gt;\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n     &gt;\n       &lt;!-- COMPLETAR POR EL ALUMNO --&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>Listado 2.  C\u00f3digo de layout/ notamedia_final.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;TableLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" \n    android:background=\"@drawable/notebook\"\n    android:paddingLeft=\"40dp\"\n    android:paddingRight=\"5dp\" &gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_examen\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_examen_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n            &lt;requestFocus /&gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_trabajo\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_trabajo_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow\n        android:gravity=\"center\"&gt;\n        &lt;Button\n            android:id=\"@+id/button_calcular\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/calcular\" /&gt;\n    &lt;/TableRow&gt;\n&lt;/TableLayout&gt;\n</code></pre></p> <p>Listado 3. C\u00f3digo de values/strings.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;NotaMediaADSW&lt;/string&gt;\n    &lt;string name=\"nota_trabajo\"&gt;Nota trabajo final&lt;/string&gt;\n    &lt;string name=\"nota_examen\"&gt;Nota examen final&lt;/string&gt;\n    &lt;string name=\"nota_media\"&gt;Nota media&lt;/string&gt;\n    &lt;string name=\"calcular\"&gt;Calcular&lt;/string&gt;\n    &lt;string name=\"error_numero\"&gt;Los campos deben ser num\u00e9ricos&lt;/string&gt;\n    &lt;string name=\"umbral_trabajo\"&gt;No has superado el umbral de 4.0 en la pr\u00e1ctica&lt;/string&gt;\n    &lt;string name=\"umbral_examen\"&gt;No has superado el umbral de 4.0 en el examen&lt;/string&gt;        \n     &lt;string name=\"enhorabuena\"&gt;Enhorabuena, que pases un buen verano.&lt;/string&gt;\n    &lt;string name=\"julio\"&gt;Hay otra oportunidad en julio. &lt;/string&gt;\n    &lt;string name=\"nota\"&gt;La nota es &lt;/string&gt;\n    &lt;string name=\"problema_nota\"&gt;Hay un problema para mostrar la nota&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre></p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n    &gt;\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\" &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <pre><code>public class NotaMediaActivity extends Activity {\npublic static final String APROBADO = \"nota\";\npublic static final String VALOR = \"valor\";\nprivate static final String TAG = NotaMediaActivity.class.getSimpleName();\nprivate EditText editNotaFinal;\nprivate EditText editTrabajoFinal;\nprivate Button buttonGuardar;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    Log.d(TAG, \"onCreate\");\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.notamedia_final);\n    editNotaFinal = (EditText) findViewById(R.id.editText_examen_final);\n    editTrabajoFinal = (EditText) findViewById(R.id.editText_trabajo_final);\n    buttonGuardar = (Button) findViewById(R.id.button_calcular);\n    buttonGuardar.setOnClickListener(new ProcesaMedia());\n}\n\nprivate class ProcesaMedia implements OnClickListener {\n    @Override\n    public void onClick(View v) {\n    try {\n        float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n        float notaTrabajo =\n            Float.parseFloat(editTrabajoFinal.getText().toString());\n        if ((notaFinal &lt; 0) || (notaFinal &gt; 10) || (notaTrabajo &lt; 0)\n            || (notaTrabajo &gt; 10)) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n        return;\n        }\n        float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String mediaString = df.format(media);\n        boolean aprobado = false;\n        String valor = \"\";\n        if ((notaTrabajo &lt; 4) || (notaFinal &lt; 4)) {\n        aprobado = false;\n        if (notaTrabajo &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_trabajo);\n        }\n        if (notaFinal &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_examen);\n        }\n        } else {\n        valor = mediaString;\n        aprobado = (media &gt;= 5);\n        }\n        Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n        intent.putExtra(APROBADO, aprobado);\n        intent.putExtra(VALOR, valor);\n        Log.d(TAG, \"Nota \" + aprobado + \" \" + valor);\n        startActivity(intent);\n    } catch (NumberFormatException e) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n    }\n    }\n}\n}\n</code></pre>"},{"location":"exams/2012/extra/","title":"Examen 2012 \u2014 Extraordinario","text":""},{"location":"exams/2012/extra/#ejercicio-1","title":"Ejercicio 1","text":"<p>Se pide escribir un algoritmo para extraer la mediana de los valores de un array. Si un array de \\(N\\) datos est\u00e1 ordenado, la mediana es el valor del medio, \\(\\text{array}[N/2]\\).</p> <p>El objetivo es preparar un m\u00e9todo:</p> <pre><code>public long mediana(long[] datos)\n</code></pre> <p>que devuelve la mediana del array que se le pasa.</p> <p>Debe partir del algoritmo de quicksort y modificarlo de forma que, cuando se separan los datos en dos partes, solo se siga procesando la parte que contiene la mediana, sin ordenar la otra.</p> <p>Se pide:</p> <ul> <li>(a) (1 punto) Escribir el algoritmo de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana1(long[] datos, int a, int z) {\n        long pivote = datos[(a + z) / 2];\n        int inf = a;\n        int sup = z;\n        while (inf &lt; sup) {\n            while (datos[inf] &lt; pivote)\n                inf++;\n            while (pivote &lt; datos[sup - 1])\n                sup--;\n            if (inf &lt; sup) {\n                long tmp = datos[inf];\n                datos[inf] = datos[sup - 1];\n                datos[sup - 1] = tmp;\n                inf++;\n                sup--;\n            }\n        }\n        int mitad = datos.length / 2;\n        if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n            mediana1(datos, a, sup);\n        if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n            mediana1(datos, inf, z);\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escribir el algoritmo de forma iterativa.</li> </ul> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana2(long[] datos, int a, int z) {\n        while (a &lt; z) {\n            long pivote = datos[(a + z) / 2];\n            int inf = a;\n            int sup = z;\n            while (inf &lt; sup) {\n                while (datos[inf] &lt; pivote)\n                    inf++;\n                while (pivote &lt; datos[sup - 1])\n                    sup--;\n                if (inf &lt; sup) {\n                    long tmp = datos[inf];\n                    datos[inf] = datos[sup - 1];\n                    datos[sup - 1] = tmp;\n                    inf++;\n                    sup--;\n                }\n            }\n            int mitad = datos.length / 2;\n            if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n                z = sup;\n            else if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n                a = inf;\n            else\n                return;\n        }\n    }\n}\n</code></pre> <ul> <li>(c) (1 punto) Calcular la complejidad razonando el por qu\u00e9.</li> </ul> Mostrar soluci\u00f3n <ul> <li> <p>Caso peor: el comportamiento es equivalente a quicksort cuando siempre se elige un pivote p\u00e9simo. La partici\u00f3n genera tama\u00f1os \\(1\\) y \\(n-1\\), por lo que el coste es:</p> <p>\\(n + (n-1) + (n-2) + \\dots + 1 = O(n^2)\\)</p> </li> <li> <p>Caso medio: cada paso divide el array aproximadamente por la mitad, y solo se sigue por la parte donde est\u00e1 la mediana:</p> <p>\\(n + \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} + \\dots = 2n = O(n)\\)</p> </li> </ul> <p>Por tanto:</p> <ul> <li> <p>Caso peor: \\(O(n^2)\\)</p> </li> <li> <p>Caso medio: \\(O(n)\\)</p> </li> </ul>"},{"location":"exams/2012/extra01/","title":"Extra01","text":"<p>Se pide escribir un algoritmo para extraer la mediana de los valores de un array. Si un array de \\(N\\) datos est\u00e1 ordenado, la mediana es el valor del medio, \\(\\text{array}[N/2]\\).</p> <p>El objetivo es preparar un m\u00e9todo:</p> <pre><code>public long mediana(long[] datos)\n</code></pre> <p>que devuelve la mediana del array que se le pasa.</p> <p>Debe partir del algoritmo de quicksort y modificarlo de forma que, cuando se separan los datos en dos partes, solo se siga procesando la parte que contiene la mediana, sin ordenar la otra.</p> <p>Se pide:</p> <ul> <li>(a) (1 punto) Escribir el algoritmo de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana1(long[] datos, int a, int z) {\n        long pivote = datos[(a + z) / 2];\n        int inf = a;\n        int sup = z;\n        while (inf &lt; sup) {\n            while (datos[inf] &lt; pivote)\n                inf++;\n            while (pivote &lt; datos[sup - 1])\n                sup--;\n            if (inf &lt; sup) {\n                long tmp = datos[inf];\n                datos[inf] = datos[sup - 1];\n                datos[sup - 1] = tmp;\n                inf++;\n                sup--;\n            }\n        }\n        int mitad = datos.length / 2;\n        if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n            mediana1(datos, a, sup);\n        if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n            mediana1(datos, inf, z);\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escribir el algoritmo de forma iterativa.</li> </ul> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana2(long[] datos, int a, int z) {\n        while (a &lt; z) {\n            long pivote = datos[(a + z) / 2];\n            int inf = a;\n            int sup = z;\n            while (inf &lt; sup) {\n                while (datos[inf] &lt; pivote)\n                    inf++;\n                while (pivote &lt; datos[sup - 1])\n                    sup--;\n                if (inf &lt; sup) {\n                    long tmp = datos[inf];\n                    datos[inf] = datos[sup - 1];\n                    datos[sup - 1] = tmp;\n                    inf++;\n                    sup--;\n                }\n            }\n            int mitad = datos.length / 2;\n            if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n                z = sup;\n            else if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n                a = inf;\n            else\n                return;\n        }\n    }\n}\n</code></pre> <ul> <li>(c) (1 punto) Calcular la complejidad razonando el por qu\u00e9.</li> </ul> Mostrar soluci\u00f3n <ul> <li> <p>Caso peor: el comportamiento es equivalente a quicksort cuando siempre se elige un pivote p\u00e9simo. La partici\u00f3n genera tama\u00f1os \\(1\\) y \\(n-1\\), por lo que el coste es:</p> <p>\\(n + (n-1) + (n-2) + \\dots + 1 = O(n^2)\\)</p> </li> <li> <p>Caso medio: cada paso divide el array aproximadamente por la mitad, y solo se sigue por la parte donde est\u00e1 la mediana:</p> <p>\\(n + \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} + \\dots = 2n = O(n)\\)</p> </li> </ul> <p>Por tanto:</p> <ul> <li> <p>Caso peor: \\(O(n^2)\\)</p> </li> <li> <p>Caso medio: \\(O(n)\\)</p> </li> </ul>","tags":["android"]},{"location":"exams/2012/p1/","title":"Examen 2012 \u2014 Parcial 1","text":""},{"location":"exams/2012/p1/#problema-1","title":"Problema 1","text":"<p>A continuaci\u00f3n se describe el m\u00e9todo <code>cuantasVeces</code> de la clase <code>P1</code>. No programe la clase <code>P1</code>. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo <code>cuantasVeces</code>. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo <code>cuantasVeces</code>. Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo <code>cuantasVeces</code> invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p>"},{"location":"exams/2012/p1/#problema-2","title":"Problema 2","text":"<p>Dado el siguiente algoritmo de ordenaci\u00f3n:</p> <pre><code>01 public void sort(long[] datos) {\n02     for (int i = 1; i &lt; datos.length; i++) {\n03         long x = datos[i];\n04         int j = i;\n05         while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n06             datos[j] = datos[j - 1];\n07             j--;\n08         }\n09         datos[j] = x;\n10     }\n11 }\n</code></pre> <ul> <li>(a) (0.5 puntos) Indique el nombre del algoritmo.</li> </ul> Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00f3n por inserci\u00f3n.</p> <ul> <li>(b) (3 puntos) Indique qu\u00e9 cambios har\u00eda en el c\u00f3digo, indicando el n\u00famero de l\u00ednea, para conseguir que el m\u00e9todo devolviera el n\u00famero de veces que compara dos elementos del array.</li> </ul> Mostrar soluci\u00f3n <p>La comparaci\u00f3n se efect\u00faa al comprobar la condici\u00f3n del bucle en la l\u00ednea <code>5</code>. El cuerpo del bucle se ejecuta si <code>j &gt; 0</code> y adem\u00e1s <code>x &lt; datos[j - 1]</code>. Por tanto, en ese caso se ha efectuado una comparaci\u00f3n entre <code>x</code> y un elemento del array.</p> <p>Sin embargo, si el bucle no se ejecuta puede ser por dos causas:</p> <ol> <li> <p><code>j == 0</code>, en cuyo caso no se llega a efectuar la comparaci\u00f3n, ya que el operador <code>&amp;&amp;</code> no eval\u00faa el segundo t\u00e9rmino.  </p> </li> <li> <p><code>j &gt; 0</code> y <code>x &gt;= datos[j - 1]</code>, en cuyo caso s\u00ed se efect\u00faa la comparaci\u00f3n.</p> </li> </ol> <p>Para contar correctamente las comparaciones, hay que desdoblar la condici\u00f3n del bucle.  </p> <p>Una forma de hacerlo es:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                break;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <p>Con respecto a las modificaciones tenemos que la l\u00ednea 1 es sustituida por:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n</code></pre> <p>Las l\u00edneas 5\u20138 son sustituidas por:</p> <pre><code>while (j &gt; 0) {\n    ++numeroComparaciones;\n    if (x &lt; datos[j - 1]) {\n        datos[j] = datos[j - 1];\n        j--;\n    } else {\n        break;\n    }\n}\n</code></pre> <p>Y despu\u00e9s de la l\u00ednea 10 se a\u00f1ade:</p> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00f3n alternativa con una variable auxiliar:</p> <pre><code>public int sort2(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        boolean menor = true;\n        while (j &gt; 0 &amp;&amp; menor) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                menor = false;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <ul> <li>(c) (1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00f3n realizada en el apartado (b), para el caso <code>{3, 1, 2}</code>.</li> </ul> Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es:</p> <pre><code>public void test() {\n    long[] datos = {3, 1, 2};\n    P2 algoritmo = new P2();\n    assertEquals(3, algoritmo.sort(datos));\n}\n</code></pre>"},{"location":"exams/2012/p1_ex01/","title":"P1 ex01","text":"<p>A continuaci\u00f3n se describe el m\u00e9todo <code>cuantasVeces</code> de la clase <code>P1</code>. No programe la clase <code>P1</code>. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo <code>cuantasVeces</code>. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo <code>cuantasVeces</code>. Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo <code>cuantasVeces</code> invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/","title":"P1 ex02","text":"<p>Dado el siguiente algoritmo de ordenaci\u00f3n:</p> <pre><code>01 public void sort(long[] datos) {\n02     for (int i = 1; i &lt; datos.length; i++) {\n03         long x = datos[i];\n04         int j = i;\n05         while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n06             datos[j] = datos[j - 1];\n07             j--;\n08         }\n09         datos[j] = x;\n10     }\n11 }\n</code></pre> <ul> <li>(a) (0.5 puntos) Indique el nombre del algoritmo.</li> </ul> Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00f3n por inserci\u00f3n.</p> <ul> <li>(b) (3 puntos) Indique qu\u00e9 cambios har\u00eda en el c\u00f3digo, indicando el n\u00famero de l\u00ednea, para conseguir que el m\u00e9todo devolviera el n\u00famero de veces que compara dos elementos del array.</li> </ul> Mostrar soluci\u00f3n <p>La comparaci\u00f3n se efect\u00faa al comprobar la condici\u00f3n del bucle en la l\u00ednea <code>5</code>. El cuerpo del bucle se ejecuta si <code>j &gt; 0</code> y adem\u00e1s <code>x &lt; datos[j - 1]</code>. Por tanto, en ese caso se ha efectuado una comparaci\u00f3n entre <code>x</code> y un elemento del array.</p> <p>Sin embargo, si el bucle no se ejecuta puede ser por dos causas:</p> <ol> <li> <p><code>j == 0</code>, en cuyo caso no se llega a efectuar la comparaci\u00f3n, ya que el operador <code>&amp;&amp;</code> no eval\u00faa el segundo t\u00e9rmino.  </p> </li> <li> <p><code>j &gt; 0</code> y <code>x &gt;= datos[j - 1]</code>, en cuyo caso s\u00ed se efect\u00faa la comparaci\u00f3n.</p> </li> </ol> <p>Para contar correctamente las comparaciones, hay que desdoblar la condici\u00f3n del bucle.  </p> <p>Una forma de hacerlo es:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                break;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <p>Con respecto a las modificaciones tenemos que la l\u00ednea 1 es sustituida por:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n</code></pre> <p>Las l\u00edneas 5\u20138 son sustituidas por:</p> <pre><code>while (j &gt; 0) {\n    ++numeroComparaciones;\n    if (x &lt; datos[j - 1]) {\n        datos[j] = datos[j - 1];\n        j--;\n    } else {\n        break;\n    }\n}\n</code></pre> <p>Y despu\u00e9s de la l\u00ednea 10 se a\u00f1ade:</p> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00f3n alternativa con una variable auxiliar:</p> <pre><code>public int sort2(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        boolean menor = true;\n        while (j &gt; 0 &amp;&amp; menor) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                menor = false;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <ul> <li>(c) (1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00f3n realizada en el apartado (b), para el caso <code>{3, 1, 2}</code>.</li> </ul> Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es:</p> <pre><code>public void test() {\n    long[] datos = {3, 1, 2};\n    P2 algoritmo = new P2();\n    assertEquals(3, algoritmo.sort(datos));\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p2/","title":"Examen 2012 \u2014 Parcial 2","text":""},{"location":"exams/2012/p2/#problema-1","title":"Problema 1","text":"<p>Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. </p> <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre> <ul> <li>(a) (2 puntos) Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads).</li> </ul> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase <code>Swap1</code> pueden utilizar simult\u00e1neamente la variable <code>aux</code> al invocar el m\u00e9todo <code>swap</code>. Por tanto, <code>swap</code> deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a <code>aux</code>.</p> <p>Por el contrario, en <code>Swap2</code> la variable <code>aux</code> es local al m\u00e9todo <code>swap</code>, y cada hebra que lo invoca usa su propia copia de <code>aux</code>. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p>"},{"location":"exams/2012/p2/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (4 puntos) Escriba una clase con un contador interno, que se incrementa cada vez que se invoca el m\u00e9todo <code>siguiente()</code>. La clase debe poderse utilizar en un programa concurrente. Adem\u00e1s, la clase proporciona otros dos m\u00e9todos, <code>esperarPar()</code> y <code>esperarImpar()</code>, que hacen que la hebra (thread) que los invoca se quede bloqueada hasta que el valor del contador sea par o impar, respectivamente.</li> </ul> <p>Se supone que el intervalo entre dos invocaciones consecutivas de <code>siguiente()</code> es suficiente para que todas las hebras que estuvieran bloqueadas puedan continuar.</p> <p>El esquema de la clase es el siguiente:</p> <pre><code>public class Secuenciador  {\n    private int numero = 0;\n\n    public int siguiente() {...}\n    // devuelve 1 la primera vez que se invoca, 2 la segunda, etc.\n\n    public void esperarPar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea par\n\n    public void esperarImpar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea impar\n}\n</code></pre> Mostrar soluci\u00f3n <p>Los m\u00e9todos deben ser todos sincronizados. Adem\u00e1s, se deben incluir esperas condicionales en <code>esperarPar</code> y <code>esperarImpar</code>. Como el \u00fanico m\u00e9todo que modifica el valor del contador es <code>siguiente</code>, el aviso (<code>notifyAll</code>) para que las hebras bloqueadas vuelvan a comprobar la condici\u00f3n debe estar en este m\u00e9todo.</p> <p>Una posible implementaci\u00f3n es:</p> <pre><code>public class Secuenciador {\n    private int numero = 0;\n\n    public synchronized int siguiente() {\n        numero++;\n        notifyAll();\n        return numero;\n    }\n\n    public synchronized void esperarPar() {\n        while (numero % 2 != 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n\n    public synchronized void esperarImpar() {\n        while (numero % 2 == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2012/p2/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (4 puntos) Modifique la clase <code>Monitor.java</code> de la pr\u00e1ctica 1 donde se han definido una serie de celdas como zona exclusiva en la que s\u00f3lo puede haber una pieza dentro (o un marciano, o un jugador). Por ejemplo,</li> </ul> <p>Suponga que las celdas tienen un m\u00e9todo:</p> <pre><code>public boolean isZonaExclusiva()\n</code></pre> <p>El comportamiento de las piezas del juego es as\u00ed:</p> <p>Cuando un jugador intenta pasar a una celda exclusiva:     - si la zona exclusiva est\u00e1 vac\u00eda, entra;     - si est\u00e1 ocupada, debe buscar otra celda.</p> <p>Cuando un marciano intenta pasar a una celda exclusiva:     - si la zona exclusiva est\u00e1 vac\u00eda, entra;     - si est\u00e1 ocupada, espera a que se libere.</p> <p>Tanto marcianos como jugador, cuando salen de la zona exclusiva hacia una celda que no lo es, liberan a los marcianos que pudieran estar esperando.</p> <p>Sugerencia: se recomienda disponer de un campo</p> <pre><code>private Object ocupado;\n</code></pre> <p>que se inicia a <code>null</code> y sirve para indicar qu\u00e9 objeto (jugador o marciano) est\u00e1 dentro de la zona. Sirve para comprobar si hay alguien dentro:</p> <pre><code>private boolean estaZonaOcupada() { return ocupado != null; }\n</code></pre> <p>y para saber si salen:</p> <pre><code>private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n    return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n}\n\nprivate boolean estoySaliendo(Marciano marciano, Celda celda2) {\n    return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.pract1;\npublic class MonitorExtendido extends Monitor {\n\n    private final Laberinto laberinto;\n    private Object ocupado;\n\n    public MonitorExtendido(Laberinto laberinto) {\n        super(laberinto);\n        this.laberinto = laberinto;\n    }\n\n    public synchronized void mueveJugador(Jugador jugador, Celda celda2)\n            throws JugadorComido {\n\n        if (celda2.isZonaExclusiva()) {\n            if (estaZonaOcupada() &amp;&amp; ocupado != jugador)\n                return;\n            else\n                ocupado = jugador;\n        }\n\n        if (estoySaliendo(jugador, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            throw new JugadorComido();\n        }\n\n        jugador.setCelda(celda2);\n\n        if (celda2.getTipo() == Tipo.LLAVE) {\n            laberinto.limpiaCepos();\n            notifyAll();\n        }\n    }\n\n    public synchronized void mueveMarciano(Marciano marciano, Celda celda2)\n            throws JugadorComido, InterruptedException {\n\n        if (celda2.isZonaExclusiva()) {\n            while (estaZonaOcupada() &amp;&amp; ocupado != marciano)\n                wait();\n            ocupado = marciano;\n        }\n\n        if (estoySaliendo(marciano, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            return;\n        }\n\n        if (celda2.getEstado() == Estado.JUGADOR) {\n            throw new JugadorComido();\n        }\n\n        marciano.setCelda(celda2);\n\n        while (celda2.getTipo() == Tipo.CEPO) {\n            wait();\n        }\n    }\n\n    private boolean estaZonaOcupada() {\n        return ocupado != null;\n    }\n\n    private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n        return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n    }\n\n    private boolean estoySaliendo(Marciano marciano, Celda celda2) {\n        return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n    }\n}\n</code></pre></p>"},{"location":"exams/2012/p2_ex01/","title":"P2 ex01","text":"<p>Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. </p> <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre> <ul> <li>(a) (2 puntos) Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads).</li> </ul> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase <code>Swap1</code> pueden utilizar simult\u00e1neamente la variable <code>aux</code> al invocar el m\u00e9todo <code>swap</code>. Por tanto, <code>swap</code> deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a <code>aux</code>.</p> <p>Por el contrario, en <code>Swap2</code> la variable <code>aux</code> es local al m\u00e9todo <code>swap</code>, y cada hebra que lo invoca usa su propia copia de <code>aux</code>. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p>","tags":["hebras"]},{"location":"exams/2012/p2_ex02/","title":"P2 ex02","text":"<ul> <li>(a) (4 puntos) Escriba una clase con un contador interno, que se incrementa cada vez que se invoca el m\u00e9todo <code>siguiente()</code>. La clase debe poderse utilizar en un programa concurrente. Adem\u00e1s, la clase proporciona otros dos m\u00e9todos, <code>esperarPar()</code> y <code>esperarImpar()</code>, que hacen que la hebra (thread) que los invoca se quede bloqueada hasta que el valor del contador sea par o impar, respectivamente.</li> </ul> <p>Se supone que el intervalo entre dos invocaciones consecutivas de <code>siguiente()</code> es suficiente para que todas las hebras que estuvieran bloqueadas puedan continuar.</p> <p>El esquema de la clase es el siguiente:</p> <pre><code>public class Secuenciador  {\n    private int numero = 0;\n\n    public int siguiente() {...}\n    // devuelve 1 la primera vez que se invoca, 2 la segunda, etc.\n\n    public void esperarPar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea par\n\n    public void esperarImpar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea impar\n}\n</code></pre> Mostrar soluci\u00f3n <p>Los m\u00e9todos deben ser todos sincronizados. Adem\u00e1s, se deben incluir esperas condicionales en <code>esperarPar</code> y <code>esperarImpar</code>. Como el \u00fanico m\u00e9todo que modifica el valor del contador es <code>siguiente</code>, el aviso (<code>notifyAll</code>) para que las hebras bloqueadas vuelvan a comprobar la condici\u00f3n debe estar en este m\u00e9todo.</p> <p>Una posible implementaci\u00f3n es:</p> <pre><code>public class Secuenciador {\n    private int numero = 0;\n\n    public synchronized int siguiente() {\n        numero++;\n        notifyAll();\n        return numero;\n    }\n\n    public synchronized void esperarPar() {\n        while (numero % 2 != 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n\n    public synchronized void esperarImpar() {\n        while (numero % 2 == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2012/p2_ex03/","title":"P2 ex03","text":"<ul> <li>(a) (4 puntos) Modifique la clase <code>Monitor.java</code> de la pr\u00e1ctica 1 donde se han definido una serie de celdas como zona exclusiva en la que s\u00f3lo puede haber una pieza dentro (o un marciano, o un jugador). Por ejemplo,</li> </ul> <p>Suponga que las celdas tienen un m\u00e9todo:</p> <pre><code>public boolean isZonaExclusiva()\n</code></pre> <p>El comportamiento de las piezas del juego es as\u00ed:</p> <p>Cuando un jugador intenta pasar a una celda exclusiva:     - si la zona exclusiva est\u00e1 vac\u00eda, entra;     - si est\u00e1 ocupada, debe buscar otra celda.</p> <p>Cuando un marciano intenta pasar a una celda exclusiva:     - si la zona exclusiva est\u00e1 vac\u00eda, entra;     - si est\u00e1 ocupada, espera a que se libere.</p> <p>Tanto marcianos como jugador, cuando salen de la zona exclusiva hacia una celda que no lo es, liberan a los marcianos que pudieran estar esperando.</p> <p>Sugerencia: se recomienda disponer de un campo</p> <pre><code>private Object ocupado;\n</code></pre> <p>que se inicia a <code>null</code> y sirve para indicar qu\u00e9 objeto (jugador o marciano) est\u00e1 dentro de la zona. Sirve para comprobar si hay alguien dentro:</p> <pre><code>private boolean estaZonaOcupada() { return ocupado != null; }\n</code></pre> <p>y para saber si salen:</p> <pre><code>private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n    return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n}\n\nprivate boolean estoySaliendo(Marciano marciano, Celda celda2) {\n    return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.pract1;\npublic class MonitorExtendido extends Monitor {\n\n    private final Laberinto laberinto;\n    private Object ocupado;\n\n    public MonitorExtendido(Laberinto laberinto) {\n        super(laberinto);\n        this.laberinto = laberinto;\n    }\n\n    public synchronized void mueveJugador(Jugador jugador, Celda celda2)\n            throws JugadorComido {\n\n        if (celda2.isZonaExclusiva()) {\n            if (estaZonaOcupada() &amp;&amp; ocupado != jugador)\n                return;\n            else\n                ocupado = jugador;\n        }\n\n        if (estoySaliendo(jugador, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            throw new JugadorComido();\n        }\n\n        jugador.setCelda(celda2);\n\n        if (celda2.getTipo() == Tipo.LLAVE) {\n            laberinto.limpiaCepos();\n            notifyAll();\n        }\n    }\n\n    public synchronized void mueveMarciano(Marciano marciano, Celda celda2)\n            throws JugadorComido, InterruptedException {\n\n        if (celda2.isZonaExclusiva()) {\n            while (estaZonaOcupada() &amp;&amp; ocupado != marciano)\n                wait();\n            ocupado = marciano;\n        }\n\n        if (estoySaliendo(marciano, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            return;\n        }\n\n        if (celda2.getEstado() == Estado.JUGADOR) {\n            throw new JugadorComido();\n        }\n\n        marciano.setCelda(celda2);\n\n        while (celda2.getTipo() == Tipo.CEPO) {\n            wait();\n        }\n    }\n\n    private boolean estaZonaOcupada() {\n        return ocupado != null;\n    }\n\n    private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n        return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n    }\n\n    private boolean estoySaliendo(Marciano marciano, Celda celda2) {\n        return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n    }\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2013/extra/","title":"Examen 2013 \u2014 Extraordinario","text":""},{"location":"exams/2013/extra/#ejercicio-1","title":"Ejercicio 1","text":"<p>La siguiente clase implementa un conjunto de enteros ordenados mediante un \u00e1rbol binario. El \u00e1rbol no contiene datos duplicados.</p> <pre><code>public class Arbol {\n    private class Nodo {\n        int valor;\n        Nodo izq, der;\n    }\n\n    private Nodo raiz;\n    private int n; // n\u00famero de datos almacenados en el \u00e1rbol\n    ...\n    public int cuenta(int x) {...} // n\u00famero de valores &lt;= x\n    ...\n}\n</code></pre> <ul> <li>(a) (1,5 puntos) Escriba el m\u00e9todo <code>int cuenta(int x)</code> de forma que devuelva el n\u00famero de valores menores o iguales que <code>x</code> en el \u00e1rbol.</li> </ul> <p>Ejemplo:</p> <p>Si el \u00e1rbol contiene los valores (1,3,4,6,10,14), obtendremos</p> <ul> <li> <p>cuenta(1) = 1</p> </li> <li> <p>cuenta(6) = 4</p> </li> <li> <p>cuenta(9) = 4</p> </li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo, utilizando un m\u00e9todo auxiliar recursivo, es la siguiente:</p> <p><pre><code>public int cuenta(int x) {\n    return cuenta(raiz, x);\n}\n\nprivate int cuenta(Nodo nodo, int x) {\n    if (nodo == null) {\n        return 0;\n    }\n\n    if (nodo.valor == x) { \n        // suma 1 y sigue buscando por la izquierda\n        return 1 + cuenta(nodo.izq, x);\n    } else if (nodo.valor &lt; x) { \n        // suma 1 y sigue buscando por los dos lados\n        return 1 + cuenta(nodo.izq, x) + cuenta(nodo.der, x);\n    } else { \n        // no suma y sigue buscando por la izquierda\n        return cuenta(nodo.izq, x);\n    }\n}\n</code></pre> El algoritmo usa la propiedad del \u00e1rbol binario de b\u00fasqueda de que todos los nodos que est\u00e1n en el sub\u00e1rbol izquierdo de uno dado tienen un valor menor que \u00e9ste. Por tanto, si se encuentra el valor <code>x</code> ya no hay que seguir buscando por su derecha. Si el valor del nodo es menor que <code>x</code>, puede haber nodos menores tanto a la izquierda como a la derecha. Por \u00faltimo, si el valor del nodo es mayor que <code>x</code>, basta con seguir contando por la izquierda, ya que los nodos que haya a la derecha ser\u00e1n tambi\u00e9n mayores que <code>x</code>.</p> <ul> <li>(b) (1,5 puntos) Calcule la complejidad del algoritmo, justificando el resultado: </li> </ul> Mostrar soluci\u00f3n <p>Para la complejidad, observamos que se van recorriendo todos los nodos del \u00e1rbol, excepto cuando se encuentra un valor mayor que <code>x</code>, en cuyo caso se descarta el sub\u00e1rbol derecho.</p> <p>M\u00e1s en detalle, el m\u00e9todo cuenta tiene cuatro casos posibles. Si calculamos el n\u00famero de operaciones que se hacen cada vez que se ejecuta, tenemos</p> <ul> <li> <p>Sumas:</p> <ol> <li> <p><code>nodo == null</code>\\(\\rightarrow T(n) = 0\\)</p> </li> <li> <p><code>nodo.valor == x</code>\\(\\rightarrow T(n) = 1 + T(n/2)\\)</p> </li> <li> <p><code>nodo.valor &lt; x</code>\\(\\rightarrow T(n) = 2 + 2T(n/2)\\)</p> </li> <li> <p><code>nodo.valor &gt; x</code>\\(\\rightarrow T(n) = T(n/2)\\)</p> </li> </ol> </li> <li> <p>Llamadas recursivas:</p> <ol> <li> <p><code>nodo == null</code>\\(\\rightarrow T(n) = 0\\)</p> </li> <li> <p><code>nodo.valor == x</code>\\(\\rightarrow T(n) = 1 + T(n/2)\\)</p> </li> <li> <p><code>nodo.valor &lt; x</code>\\(\\rightarrow T(n) = 1 + 2T(n/2)\\)</p> </li> <li> <p><code>nodo.valor &gt; x</code>\\(\\rightarrow T(n) = T(n/2)\\)</p> </li> </ol> </li> </ul> <p>Suponiendo que el caso 3 es el m\u00e1s frecuente, \\(T(n) \u2248 1 + 2T(n/2)\\) que es lineal, \\(O(n)\\).</p>"},{"location":"exams/2013/extra/#ejercicio-2","title":"Ejercicio 2","text":"<ul> <li>(a) (3 puntos) Escriba un monitor en Java que controle el acceso a un parking de coches. El parking tiene un n\u00famero de plazas N y dispone de dos accesos, Este y Oeste.</li> </ul> <p>Si el parking no est\u00e1 lleno, se admiten entradas por ambos accesos libremente. Si el parking est\u00e1 lleno, los coches deben esperar a que haya plazas disponibles. Cuando queda una plaza libre, el monitor debe alternar los accesos de entrada entre Este y Oeste. Cuando un coche abandona el parking, se considera irrelevante el acceso que usa para salir.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es el siguiente:</p> <pre><code>class Monitor {\n    ...\n    Monitor(int numPlazas) { ... }\n    ...\n    entraCochePorEste(...) { ... }\n    ...\n    entraCochePorOeste(...) { ... }\n    ...\n    saleCoche(...) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n correcta es: <pre><code>public class Monitor {\n\n    private int numPlazas, numCoches;\n    private boolean turnoEste, turnoOeste;\n    private int esperaEnEste, esperaEnOeste;\n\n    public Monitor(int numPlazas) {\n        this.numPlazas = numPlazas;\n        numCoches = 0;\n        turnoEste = turnoOeste = true;\n        esperaEnEste = esperaEnOeste = 0;\n    }\n\n    public synchronized void entraCochePorEste() throws InterruptedException {\n        esperaEnEste++;\n        while ((numCoches &gt;= numPlazas) || (turnoOeste &amp;&amp; (esperaEnOeste &gt; 0))) {\n            wait();\n        }\n        esperaEnEste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = false;\n            turnoOeste = true;\n        }\n    }\n\n    public synchronized void entraCochePorOeste() throws InterruptedException {\n        esperaEnOeste++;\n        while ((numCoches &gt;= numPlazas) || (turnoEste &amp;&amp; (esperaEnEste &gt; 0))) {\n            wait();\n        }\n        esperaEnOeste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = true;\n            turnoOeste = false;\n        }\n    }\n\n    public synchronized void saleCoche() {\n        numCoches--;\n        notifyAll();\n    }\n}\n</code></pre></p>"},{"location":"exams/2013/extra/#ejercicio-3","title":"Ejercicio 3","text":"<ul> <li>(a) (4 puntos) Se desea programar una aplicaci\u00f3n compuesta por tres actividades: <code>MainActivity</code> (actividad inicial), <code>ActivityA</code>, y <code>ActivityB</code>. La tarea de <code>MainActivity</code> consiste en mostrar una lista con dos opciones al usuario: lanzar y terminar.</li> </ul> <p>Si el usuario pulsa lanzar, se lanza la actividad <code>ActivityA</code>, que devuelve como resultado un c\u00f3digo que indica si la actividad ha terminado con \u00e9xito o no (<code>RESULT_OK</code> o <code>RESULT_CANCELED</code>). Si el resultado es <code>RESULT_OK</code>, se lanza la actividad <code>ActivityB</code>, sin esperar a que devuelva ning\u00fan resultado.</p> <p>Mire la soluci\u00f3n que se proporciona a continuaci\u00f3n e indique si es correcta o no. En caso de tener fallos, indique qu\u00e9 fallos hay y c\u00f3mo se corrigen.</p> <pre><code>01 public class MainActivity extends Activity {\n02 \n03     public static final int LANZA_A = 0;\n04     public static final int LANZA_B = 1;\n05\n06     @Override\n07     protected void onCreate(Bundle savedInstanceState) {\n08         super.onCreate(savedInstanceState);\n09         setContentView(R.layout.activity_main);\n10\n11         String[] acciones = {\"lanzar\", \"terminar\"};\n12         setListAdapter(new ArrayAdapter&lt;String&gt;(\n13                 this,\n14                 android.R.layout.simple_list_item_1,\n15                 acciones));\n16     }\n17\n18     private void lanza() {\n19         Intent lanzaA = new Intent(this, ActivityA.class);\n20         if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {\n21             Intent lanzaB = new Intent(this, ActivityB.class);\n22             startActivityForResult(lanzaB, LANZA_B);\n23         }\n24     }\n25\n26     @Override\n27     public void onListItemClick(ListView l, View v, int position, long id) {\n28         super.onListItemClick(l, v, position, id);\n29         switch (position) {\n30             case 0: {\n31                 lanza();\n32                 break;\n33             }\n34             case 1: {\n35                 finish();\n36                 break;\n37             }\n38             default: { }\n39         }\n40     }\n41\n42     public static void main(String[] args) {\n43         onCreate(this);\n44     }\n45 }\n</code></pre> Mostrar soluci\u00f3n <p>La l\u00ednea 01 se reescribe para que quede como sigue: <pre><code>public class MainActivity extends ListActivity {\n</code></pre></p> <p>Despu\u00e9s de la l\u00ednea 19 se a\u00f1ade: <pre><code>startActivityForResult(lanzaA, LANZA_A);\n</code></pre></p> <p>Las l\u00edneas 20 a 23 se borran.</p> <p>Despu\u00e9s de la l\u00ednea 24 se a\u00f1ade: <pre><code>protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == LANZA_A) {\n            if (resultCode == RESULT_OK) {\n                    Intent lanzaB = new Intent(this, ActivityB.class);\n                    startActivity(lanzaB);\n            }\n    }\n}\n</code></pre></p> <p>Las l\u00edneas  y 42 a  44 se borran.</p>"},{"location":"exams/2013/extra/#ejercicio-4","title":"Ejercicio 4","text":"<p>Se desea modificar la aplicaci\u00f3n <code>Teleconote</code> de manera que la pantalla con la lista de notas (controlada por la actividad <code>ListaNotasActivity</code>) se comporte de forma que, al pinchar en una nota, si est\u00e1 cifrada, se descifre sin pedir ninguna contrase\u00f1a. Si la nota no est\u00e1 cifrada, se deja como est\u00e1.</p> <p>Obs\u00e9rvese que no hay que mostrar el contenido de la nota, s\u00f3lo descifrarla en caso necesario desde <code>ListaNotasActivity</code>.</p> <p>Puede suponer que la clase que contiene la tarea as\u00edncrona, que program\u00f3 en <code>DetalleNotaActivity</code>, est\u00e1 refactorizada como una clase de paquete, de la siguiente forma:</p> <pre><code>public class Cifrar extends AsyncTask&lt;?,?,?&gt; {\n    protected void onPreExecute() {...}\n\n    @Override\n    protected ... doInBackground(...) {...}\n\n    protected void onProgressUpdate(...) {...}\n\n    protected void onPostExecute(...) {...}\n}\n</code></pre> <p>La tarea recibe varias cadenas (el t\u00edtulo y contenido de la nota, as\u00ed como su id), comunica el n\u00famero de caracteres cifrados o descifrados, y devuelve el objeto nota con los campos <code>titulo</code> y <code>contenido</code> descifrados.</p> <ul> <li>(a) (3 puntos) Indique qu\u00e9 signatura deber\u00eda tener la clase <code>Cifrar</code>.</li> </ul> Mostrar soluci\u00f3n <p>La signatura correcta de la clase <code>Cifrar</code> es:</p> <pre><code>Cifrar&lt;String, Integer, Nota&gt;\n</code></pre> <ul> <li>(b) (7 puntos) Indique los cambios necesarios para que se ejecute la tarea de descifrado con esta modificaci\u00f3n. Tenga en cuenta que los cambios deben almacenarse en la base de datos, y que debe actualizarse la pantalla de <code>ListaNotasActivity</code>.</li> </ul> <p>NOTA: Lim\u00edtese a hacer los cambios necesarios. No es necesario volver a escribir el c\u00f3digo de <code>Cifrar</code> ni las partes de <code>ListaNotasActivity</code> que no haya que modificar.</p> Mostrar soluci\u00f3n <p>A continuaci\u00f3n se muestran \u00fanicamente los cambios necesarios para ejecutar la tarea de descifrado desde <code>ListaNotasActivity</code>. Los cambios relevantes se destacan conceptualmente.  <pre><code>@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = notasCursor;\n    c.moveToPosition(position);\n    // C\u00f3digo nuevo\n    Nota nota = getNota(c);\n    if ((nota != null) &amp;&amp; (nota.isCifrado())) {\n        new Cifrar().execute(\n            nota.getContenido(),\n            nota.getTitulo(),\n            nota.getCategoria(),\n            id + \"\"\n        );\n    }\n    // Fin del c\u00f3digo nuevo\n    startActivityForResult(intent, MODIFICA_NOTA);\n}\n\n// C\u00f3digo nuevo\nprivate class Cifrar extends AsyncTask&lt;String, Integer, Nota&gt; {\n\n    private final String CLAVE = new String(\"miclave\");\n    private long id = -1;\n\n    // Se puede acceder a la UI\n    @Override\n    protected void onPreExecute() {\n    }\n// Fin del c\u00f3digo nuevo\n\n    // M\u00e9todo de descifrado (no se modifica)\n    private String descifra(String texto, String clave) {\n        // C\u00f3digo existente que almacena el texto\n        // descifrado en un buffer\n        ...\n        publishProgress(i);\n        return buffer.toString();\n    }\n\n// C\u00f3digo nuevo\n    // Ejecuci\u00f3n en segundo plano\n    @Override\n    protected Nota doInBackground(String... params) {\n        Log.i(TAG, \"doInBackground\");\n\n        String titulo = params[0];\n        String contenido = params[1];\n        String categoria = params[2];\n\n        if ((titulo == null) || (contenido == null) || (categoria == null))\n            return null;\n\n        try {\n            id = Long.parseLong(params[3]);\n        } catch (NumberFormatException e) {\n            return null;\n        }\n\n        String tituloDescifrado = descifra(titulo, CLAVE);\n        String contenidoDescifrado = descifra(contenido, CLAVE);\n\n        Nota miNota = new Nota(\n            tituloDescifrado,\n            contenidoDescifrado,\n            categoria,\n            false\n        );\n        return miNota;\n    }\n\n    // Actualizaciones de progreso en la UI\n    @Override\n    protected void onProgressUpdate(Integer... value) {\n        super.onProgressUpdate(value);\n        Log.i(TAG, \"onProgressUpdate\");\n        texto.append(\"\nEjecut\u00e1ndose...\" + value[0]);\n        // Mostrar progreso por pantalla\n    }\n\n    // Al finalizar, se actualiza la BBDD y la lista\n    @Override\n    protected void onPostExecute(Nota miNota) {\n        Log.i(TAG, \"onPostExecute, nota Cifrada\");\n        notaDbAdaptador.actualizaNota(id, miNota);\n        cursorAdapter.notifyDataSetChanged();\n        actualizaLista();\n    }\n// Fin del c\u00f3digo nuevo\n}\n</code></pre></p>"},{"location":"exams/2013/extra01/","title":"Extra01","text":"<p>La siguiente clase implementa un conjunto de enteros ordenados mediante un \u00e1rbol binario. El \u00e1rbol no contiene datos duplicados.</p> <pre><code>public class Arbol {\n    private class Nodo {\n        int valor;\n        Nodo izq, der;\n    }\n\n    private Nodo raiz;\n    private int n; // n\u00famero de datos almacenados en el \u00e1rbol\n    ...\n    public int cuenta(int x) {...} // n\u00famero de valores &lt;= x\n    ...\n}\n</code></pre> <ul> <li>(a) (1,5 puntos) Escriba el m\u00e9todo <code>int cuenta(int x)</code> de forma que devuelva el n\u00famero de valores menores o iguales que <code>x</code> en el \u00e1rbol.</li> </ul> <p>Ejemplo:</p> <p>Si el \u00e1rbol contiene los valores (1,3,4,6,10,14), obtendremos</p> <ul> <li> <p>cuenta(1) = 1</p> </li> <li> <p>cuenta(6) = 4</p> </li> <li> <p>cuenta(9) = 4</p> </li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo, utilizando un m\u00e9todo auxiliar recursivo, es la siguiente:</p> <p><pre><code>public int cuenta(int x) {\n    return cuenta(raiz, x);\n}\n\nprivate int cuenta(Nodo nodo, int x) {\n    if (nodo == null) {\n        return 0;\n    }\n\n    if (nodo.valor == x) { \n        // suma 1 y sigue buscando por la izquierda\n        return 1 + cuenta(nodo.izq, x);\n    } else if (nodo.valor &lt; x) { \n        // suma 1 y sigue buscando por los dos lados\n        return 1 + cuenta(nodo.izq, x) + cuenta(nodo.der, x);\n    } else { \n        // no suma y sigue buscando por la izquierda\n        return cuenta(nodo.izq, x);\n    }\n}\n</code></pre> El algoritmo usa la propiedad del \u00e1rbol binario de b\u00fasqueda de que todos los nodos que est\u00e1n en el sub\u00e1rbol izquierdo de uno dado tienen un valor menor que \u00e9ste. Por tanto, si se encuentra el valor <code>x</code> ya no hay que seguir buscando por su derecha. Si el valor del nodo es menor que <code>x</code>, puede haber nodos menores tanto a la izquierda como a la derecha. Por \u00faltimo, si el valor del nodo es mayor que <code>x</code>, basta con seguir contando por la izquierda, ya que los nodos que haya a la derecha ser\u00e1n tambi\u00e9n mayores que <code>x</code>.</p> <ul> <li>(b) (1,5 puntos) Calcule la complejidad del algoritmo, justificando el resultado: </li> </ul> Mostrar soluci\u00f3n <p>Para la complejidad, observamos que se van recorriendo todos los nodos del \u00e1rbol, excepto cuando se encuentra un valor mayor que <code>x</code>, en cuyo caso se descarta el sub\u00e1rbol derecho.</p> <p>M\u00e1s en detalle, el m\u00e9todo cuenta tiene cuatro casos posibles. Si calculamos el n\u00famero de operaciones que se hacen cada vez que se ejecuta, tenemos</p> <ul> <li> <p>Sumas:</p> <ol> <li> <p><code>nodo == null</code>\\(\\rightarrow T(n) = 0\\)</p> </li> <li> <p><code>nodo.valor == x</code>\\(\\rightarrow T(n) = 1 + T(n/2)\\)</p> </li> <li> <p><code>nodo.valor &lt; x</code>\\(\\rightarrow T(n) = 2 + 2T(n/2)\\)</p> </li> <li> <p><code>nodo.valor &gt; x</code>\\(\\rightarrow T(n) = T(n/2)\\)</p> </li> </ol> </li> <li> <p>Llamadas recursivas:</p> <ol> <li> <p><code>nodo == null</code>\\(\\rightarrow T(n) = 0\\)</p> </li> <li> <p><code>nodo.valor == x</code>\\(\\rightarrow T(n) = 1 + T(n/2)\\)</p> </li> <li> <p><code>nodo.valor &lt; x</code>\\(\\rightarrow T(n) = 1 + 2T(n/2)\\)</p> </li> <li> <p><code>nodo.valor &gt; x</code>\\(\\rightarrow T(n) = T(n/2)\\)</p> </li> </ol> </li> </ul> <p>Suponiendo que el caso 3 es el m\u00e1s frecuente, \\(T(n) \u2248 1 + 2T(n/2)\\) que es lineal, \\(O(n)\\).</p>","tags":["complejidad"]},{"location":"exams/2013/extra02/","title":"Extra02","text":"<ul> <li>(a) (3 puntos) Escriba un monitor en Java que controle el acceso a un parking de coches. El parking tiene un n\u00famero de plazas N y dispone de dos accesos, Este y Oeste.</li> </ul> <p>Si el parking no est\u00e1 lleno, se admiten entradas por ambos accesos libremente. Si el parking est\u00e1 lleno, los coches deben esperar a que haya plazas disponibles. Cuando queda una plaza libre, el monitor debe alternar los accesos de entrada entre Este y Oeste. Cuando un coche abandona el parking, se considera irrelevante el acceso que usa para salir.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es el siguiente:</p> <pre><code>class Monitor {\n    ...\n    Monitor(int numPlazas) { ... }\n    ...\n    entraCochePorEste(...) { ... }\n    ...\n    entraCochePorOeste(...) { ... }\n    ...\n    saleCoche(...) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n correcta es: <pre><code>public class Monitor {\n\n    private int numPlazas, numCoches;\n    private boolean turnoEste, turnoOeste;\n    private int esperaEnEste, esperaEnOeste;\n\n    public Monitor(int numPlazas) {\n        this.numPlazas = numPlazas;\n        numCoches = 0;\n        turnoEste = turnoOeste = true;\n        esperaEnEste = esperaEnOeste = 0;\n    }\n\n    public synchronized void entraCochePorEste() throws InterruptedException {\n        esperaEnEste++;\n        while ((numCoches &gt;= numPlazas) || (turnoOeste &amp;&amp; (esperaEnOeste &gt; 0))) {\n            wait();\n        }\n        esperaEnEste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = false;\n            turnoOeste = true;\n        }\n    }\n\n    public synchronized void entraCochePorOeste() throws InterruptedException {\n        esperaEnOeste++;\n        while ((numCoches &gt;= numPlazas) || (turnoEste &amp;&amp; (esperaEnEste &gt; 0))) {\n            wait();\n        }\n        esperaEnOeste--;\n        numCoches++;\n        if (numCoches == numPlazas) {\n            turnoEste = true;\n            turnoOeste = false;\n        }\n    }\n\n    public synchronized void saleCoche() {\n        numCoches--;\n        notifyAll();\n    }\n}\n</code></pre></p>","tags":["monitores"]},{"location":"exams/2013/extra03/","title":"Extra03","text":"<ul> <li>(a) (4 puntos) Se desea programar una aplicaci\u00f3n compuesta por tres actividades: <code>MainActivity</code> (actividad inicial), <code>ActivityA</code>, y <code>ActivityB</code>. La tarea de <code>MainActivity</code> consiste en mostrar una lista con dos opciones al usuario: lanzar y terminar.</li> </ul> <p>Si el usuario pulsa lanzar, se lanza la actividad <code>ActivityA</code>, que devuelve como resultado un c\u00f3digo que indica si la actividad ha terminado con \u00e9xito o no (<code>RESULT_OK</code> o <code>RESULT_CANCELED</code>). Si el resultado es <code>RESULT_OK</code>, se lanza la actividad <code>ActivityB</code>, sin esperar a que devuelva ning\u00fan resultado.</p> <p>Mire la soluci\u00f3n que se proporciona a continuaci\u00f3n e indique si es correcta o no. En caso de tener fallos, indique qu\u00e9 fallos hay y c\u00f3mo se corrigen.</p> <pre><code>01 public class MainActivity extends Activity {\n02 \n03     public static final int LANZA_A = 0;\n04     public static final int LANZA_B = 1;\n05\n06     @Override\n07     protected void onCreate(Bundle savedInstanceState) {\n08         super.onCreate(savedInstanceState);\n09         setContentView(R.layout.activity_main);\n10\n11         String[] acciones = {\"lanzar\", \"terminar\"};\n12         setListAdapter(new ArrayAdapter&lt;String&gt;(\n13                 this,\n14                 android.R.layout.simple_list_item_1,\n15                 acciones));\n16     }\n17\n18     private void lanza() {\n19         Intent lanzaA = new Intent(this, ActivityA.class);\n20         if (startActivityForResult(lanzaA, LANZA_A) == RESULT_OK) {\n21             Intent lanzaB = new Intent(this, ActivityB.class);\n22             startActivityForResult(lanzaB, LANZA_B);\n23         }\n24     }\n25\n26     @Override\n27     public void onListItemClick(ListView l, View v, int position, long id) {\n28         super.onListItemClick(l, v, position, id);\n29         switch (position) {\n30             case 0: {\n31                 lanza();\n32                 break;\n33             }\n34             case 1: {\n35                 finish();\n36                 break;\n37             }\n38             default: { }\n39         }\n40     }\n41\n42     public static void main(String[] args) {\n43         onCreate(this);\n44     }\n45 }\n</code></pre> Mostrar soluci\u00f3n <p>La l\u00ednea 01 se reescribe para que quede como sigue: <pre><code>public class MainActivity extends ListActivity {\n</code></pre></p> <p>Despu\u00e9s de la l\u00ednea 19 se a\u00f1ade: <pre><code>startActivityForResult(lanzaA, LANZA_A);\n</code></pre></p> <p>Las l\u00edneas 20 a 23 se borran.</p> <p>Despu\u00e9s de la l\u00ednea 24 se a\u00f1ade: <pre><code>protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == LANZA_A) {\n            if (resultCode == RESULT_OK) {\n                    Intent lanzaB = new Intent(this, ActivityB.class);\n                    startActivity(lanzaB);\n            }\n    }\n}\n</code></pre></p> <p>Las l\u00edneas  y 42 a  44 se borran.</p>","tags":["android"]},{"location":"exams/2013/extra04/","title":"Extra04","text":"<p>Se desea modificar la aplicaci\u00f3n <code>Teleconote</code> de manera que la pantalla con la lista de notas (controlada por la actividad <code>ListaNotasActivity</code>) se comporte de forma que, al pinchar en una nota, si est\u00e1 cifrada, se descifre sin pedir ninguna contrase\u00f1a. Si la nota no est\u00e1 cifrada, se deja como est\u00e1.</p> <p>Obs\u00e9rvese que no hay que mostrar el contenido de la nota, s\u00f3lo descifrarla en caso necesario desde <code>ListaNotasActivity</code>.</p> <p>Puede suponer que la clase que contiene la tarea as\u00edncrona, que program\u00f3 en <code>DetalleNotaActivity</code>, est\u00e1 refactorizada como una clase de paquete, de la siguiente forma:</p> <pre><code>public class Cifrar extends AsyncTask&lt;?,?,?&gt; {\n    protected void onPreExecute() {...}\n\n    @Override\n    protected ... doInBackground(...) {...}\n\n    protected void onProgressUpdate(...) {...}\n\n    protected void onPostExecute(...) {...}\n}\n</code></pre> <p>La tarea recibe varias cadenas (el t\u00edtulo y contenido de la nota, as\u00ed como su id), comunica el n\u00famero de caracteres cifrados o descifrados, y devuelve el objeto nota con los campos <code>titulo</code> y <code>contenido</code> descifrados.</p> <ul> <li>(a) (3 puntos) Indique qu\u00e9 signatura deber\u00eda tener la clase <code>Cifrar</code>.</li> </ul> Mostrar soluci\u00f3n <p>La signatura correcta de la clase <code>Cifrar</code> es:</p> <pre><code>Cifrar&lt;String, Integer, Nota&gt;\n</code></pre> <ul> <li>(b) (7 puntos) Indique los cambios necesarios para que se ejecute la tarea de descifrado con esta modificaci\u00f3n. Tenga en cuenta que los cambios deben almacenarse en la base de datos, y que debe actualizarse la pantalla de <code>ListaNotasActivity</code>.</li> </ul> <p>NOTA: Lim\u00edtese a hacer los cambios necesarios. No es necesario volver a escribir el c\u00f3digo de <code>Cifrar</code> ni las partes de <code>ListaNotasActivity</code> que no haya que modificar.</p> Mostrar soluci\u00f3n <p>A continuaci\u00f3n se muestran \u00fanicamente los cambios necesarios para ejecutar la tarea de descifrado desde <code>ListaNotasActivity</code>. Los cambios relevantes se destacan conceptualmente.  <pre><code>@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = notasCursor;\n    c.moveToPosition(position);\n    // C\u00f3digo nuevo\n    Nota nota = getNota(c);\n    if ((nota != null) &amp;&amp; (nota.isCifrado())) {\n        new Cifrar().execute(\n            nota.getContenido(),\n            nota.getTitulo(),\n            nota.getCategoria(),\n            id + \"\"\n        );\n    }\n    // Fin del c\u00f3digo nuevo\n    startActivityForResult(intent, MODIFICA_NOTA);\n}\n\n// C\u00f3digo nuevo\nprivate class Cifrar extends AsyncTask&lt;String, Integer, Nota&gt; {\n\n    private final String CLAVE = new String(\"miclave\");\n    private long id = -1;\n\n    // Se puede acceder a la UI\n    @Override\n    protected void onPreExecute() {\n    }\n// Fin del c\u00f3digo nuevo\n\n    // M\u00e9todo de descifrado (no se modifica)\n    private String descifra(String texto, String clave) {\n        // C\u00f3digo existente que almacena el texto\n        // descifrado en un buffer\n        ...\n        publishProgress(i);\n        return buffer.toString();\n    }\n\n// C\u00f3digo nuevo\n    // Ejecuci\u00f3n en segundo plano\n    @Override\n    protected Nota doInBackground(String... params) {\n        Log.i(TAG, \"doInBackground\");\n\n        String titulo = params[0];\n        String contenido = params[1];\n        String categoria = params[2];\n\n        if ((titulo == null) || (contenido == null) || (categoria == null))\n            return null;\n\n        try {\n            id = Long.parseLong(params[3]);\n        } catch (NumberFormatException e) {\n            return null;\n        }\n\n        String tituloDescifrado = descifra(titulo, CLAVE);\n        String contenidoDescifrado = descifra(contenido, CLAVE);\n\n        Nota miNota = new Nota(\n            tituloDescifrado,\n            contenidoDescifrado,\n            categoria,\n            false\n        );\n        return miNota;\n    }\n\n    // Actualizaciones de progreso en la UI\n    @Override\n    protected void onProgressUpdate(Integer... value) {\n        super.onProgressUpdate(value);\n        Log.i(TAG, \"onProgressUpdate\");\n        texto.append(\"\nEjecut\u00e1ndose...\" + value[0]);\n        // Mostrar progreso por pantalla\n    }\n\n    // Al finalizar, se actualiza la BBDD y la lista\n    @Override\n    protected void onPostExecute(Nota miNota) {\n        Log.i(TAG, \"onPostExecute, nota Cifrada\");\n        notaDbAdaptador.actualizaNota(id, miNota);\n        cursorAdapter.notifyDataSetChanged();\n        actualizaLista();\n    }\n// Fin del c\u00f3digo nuevo\n}\n</code></pre></p>","tags":["android"]},{"location":"exams/2013/p1/","title":"Examen 2013 \u2014 Parcial 1","text":""},{"location":"exams/2013/p1/#problema-1","title":"Problema 1","text":"<p>Tenemos arrays de datos que est\u00e1n ordenados en orden ascendente, pero con los datos desplazados una distancia \\( h \\ge 0 \\). Por ejemplo:</p> h array 0 [1, 3, 5, 7, 11, 13] 1 [13, 1, 3, 5, 7, 11] 2 [11, 13, 1, 3, 5, 7] 3 [7, 11, 13, 1, 3, 5] \u2026 \u2026 <p>Supondremos que todos los datos del array son distintos.</p> <ul> <li>(a) (1,5 puntos) Dados un array y el desplazamiento \\( h \\), desarrolle un algoritmo de complejidad \\(O(1)\\) que devuelva el n\u00famero mayor conociendo el array y el desplazamiento: <pre><code>int getMayor1(int[] array, int h)\n</code></pre> Demuestre que el algoritmo es efectivamente de complejidad \\(O(1)\\).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor1(int[] array, int h) {\n    return array[(array.length - 1 + h) % array.length];\n}\n</code></pre> El algoritmo es de complejidad \\(O(1)\\) porque el n\u00famero de pasos del algoritmo es independiente de \\(n\\).</p> <ul> <li>(b) (1,5 puntos) Desarrolle un algoritmo de complejidad \\(O(n)\\) que devuelva el n\u00famero mayor conociendo el array, pero sin saber el desplazamiento: <pre><code>int getMayor2(int[] array)\n</code></pre> Demuestre que el algoritmo es de complejidad \\(O(n)\\).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor2(int[] array) {\n    int mayor = Integer.MIN_VALUE;\n    for (int num : array) {\n        if (mayor &lt; num)\n            mayor = num;\n    }\n    return mayor;\n}\n</code></pre> El algoritmo es de complejidad \\(O(n)\\) porque es un bucle que se ejecuta \\(n\\) veces.</p> <ul> <li>(c) (2 puntos) Desarrolle un algoritmo de complejidad \\(O(log n)\\) que devuelva el n\u00famero mayor conociendo el array, pero sin conocer el desplazamiento: <pre><code>int getMayor3(int[] array)\n</code></pre></li> </ul> <p>Pista:</p> <p>Hay que usar el algoritmo del apartado (a) probando con diferentes valores de \\(h\\). Para un valor de \\(h\\):     - Sabemos que es el correcto si el n\u00famero siguiente es menor que <code>array[h]</code>.     - Sabemos si hay que aumentar o disminuir \\(h\\) comparando <code>array[h]</code> con <code>array[0]</code>.</p> Mostrar soluci\u00f3n <p>La siguiente soluci\u00f3n utiliza un m\u00e9todo auxiliar, <code>busca</code>:</p> <pre><code>private static int getMayor3(int[] array) {\n    return busca(array, 0, array.length);\n    }\n\n    private static int busca(int[] array, int a, int z) {\n        if (a &gt;= z)\n            return array[a];\n        int h = (a + z) / 2;\n        int num = array[h];\n        int num_1 = array[(h + 1) % array.length];\n        if (num &gt; num_1)\n            return num;\n        if (array[0] &lt; num)\n            return busca(array, h + 1, z);\n        else\n            return busca(array, a, h);\n    }\n</code></pre> <p>El algoritmo es de complejidad \\(O(log n)\\) porque es un esquema de divisi\u00f3n sucesiva. M\u00e1s desarrollado:</p> <ol> <li> <p>Al principio, \\(h\\) puede estar entre \\(O\\) y \\(N-1\\);</p> </li> <li> <p>Tras 1 paso, \\(h\\) puede estar entre \\((O y N/2)\\) o entre \\((N/2 y N)\\); es decir, hemos reducido las opciones a la mitad \\((N/2)\\);</p> </li> <li> <p>Tras \\(k\\) pasos, el rango es \\(N/2^k\\); de forma que el rango se reduce a 1 (\\(h\\) encontrado) cuando \\(1 \\leq N/2^k \\rightarrow k=log_{2} (N) \\subset O(log N)\\).</p> </li> </ol>"},{"location":"exams/2013/p1/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) Sean tres hebras (threads), T1, T2 y T3, que utilizan tres recursos, R1, R2 y R3.</li> </ul> <p>La hebra T1 s\u00f3lo necesita el recurso R1.  </p> <p>La hebra T2 necesita los recursos R2 y R3.  </p> <p>Por \u00faltimo, la hebra T3 requiere los tres recursos, R1, R2 y R3.</p> <p>Escriba un monitor que controle el acceso de las hebras a los recursos. Cada hebra solicita los recursos que necesita invocando un m\u00e9todo del monitor. Cuando una hebra termina de usar los recursos que necesita, lo indica para que otras hebras puedan usarlos. El monitor ha de asegurar que ning\u00fan recurso es utilizado por m\u00e1s de una hebra a la vez.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es:</p> <pre><code>class Monitor {\n    \u2026\n    \u2026 requiereR1 (\u2026) { \u2026 }\n    \u2026 requiereR2_R3 (\u2026) { \u2026 }\n    \u2026 requiereR1_R2_R3 ( \u2026) { \u2026}\n    \u2026 liberaR1(\u2026) { \u2026 }\n    \u2026 liberaR2_R3 (\u2026) { \u2026 }\n    \u2026 liberaR1_R2_R3 ( \u2026) { \u2026}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n ser\u00eda:</p> <pre><code>public class Monitor {\n    private boolean ocupadoR1 = false;\n    private boolean ocupadoR2 = false;\n    private boolean ocupadoR3 = false;\n\n    public synchronized void requiereR1 () \n               throws InterruptedException {\n        while (ocupadoR1) wait();\n        ocupadoR1 = true;\n    }\n\n    public synchronized void requiereR2_R3() \n               throws InterruptedException {\n        while (ocupadoR2 || ocupadoR3) wait();\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void requiereR1_R2_R3 () \n                   throws InterruptedException { \n        while (ocupadoR1 || ocupadoR2 || ocupadoR3) wait();\n        ocupadoR1 = true;\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void liberaR1() {\n        ocupadoR1 = false;\n        notifyAll();\n    }\n\n    public synchronized void libreraR2_R3 () {\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll();\n    }\n\n    public synchronized void liberaR1_R2_R3 () {\n        ocupadoR1 = false;\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll(); \n    }\n}\n</code></pre>"},{"location":"exams/2013/p1_ex01/","title":"P1 ex01","text":"<p>Tenemos arrays de datos que est\u00e1n ordenados en orden ascendente, pero con los datos desplazados una distancia \\( h \\ge 0 \\). Por ejemplo:</p> h array 0 [1, 3, 5, 7, 11, 13] 1 [13, 1, 3, 5, 7, 11] 2 [11, 13, 1, 3, 5, 7] 3 [7, 11, 13, 1, 3, 5] \u2026 \u2026 <p>Supondremos que todos los datos del array son distintos.</p> <ul> <li>(a) (1,5 puntos) Dados un array y el desplazamiento \\( h \\), desarrolle un algoritmo de complejidad \\(O(1)\\) que devuelva el n\u00famero mayor conociendo el array y el desplazamiento: <pre><code>int getMayor1(int[] array, int h)\n</code></pre> Demuestre que el algoritmo es efectivamente de complejidad \\(O(1)\\).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor1(int[] array, int h) {\n    return array[(array.length - 1 + h) % array.length];\n}\n</code></pre> El algoritmo es de complejidad \\(O(1)\\) porque el n\u00famero de pasos del algoritmo es independiente de \\(n\\).</p> <ul> <li>(b) (1,5 puntos) Desarrolle un algoritmo de complejidad \\(O(n)\\) que devuelva el n\u00famero mayor conociendo el array, pero sin saber el desplazamiento: <pre><code>int getMayor2(int[] array)\n</code></pre> Demuestre que el algoritmo es de complejidad \\(O(n)\\).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor2(int[] array) {\n    int mayor = Integer.MIN_VALUE;\n    for (int num : array) {\n        if (mayor &lt; num)\n            mayor = num;\n    }\n    return mayor;\n}\n</code></pre> El algoritmo es de complejidad \\(O(n)\\) porque es un bucle que se ejecuta \\(n\\) veces.</p> <ul> <li>(c) (2 puntos) Desarrolle un algoritmo de complejidad \\(O(log n)\\) que devuelva el n\u00famero mayor conociendo el array, pero sin conocer el desplazamiento: <pre><code>int getMayor3(int[] array)\n</code></pre></li> </ul> <p>Pista:</p> <p>Hay que usar el algoritmo del apartado (a) probando con diferentes valores de \\(h\\). Para un valor de \\(h\\):     - Sabemos que es el correcto si el n\u00famero siguiente es menor que <code>array[h]</code>.     - Sabemos si hay que aumentar o disminuir \\(h\\) comparando <code>array[h]</code> con <code>array[0]</code>.</p> Mostrar soluci\u00f3n <p>La siguiente soluci\u00f3n utiliza un m\u00e9todo auxiliar, <code>busca</code>:</p> <pre><code>private static int getMayor3(int[] array) {\n    return busca(array, 0, array.length);\n    }\n\n    private static int busca(int[] array, int a, int z) {\n        if (a &gt;= z)\n            return array[a];\n        int h = (a + z) / 2;\n        int num = array[h];\n        int num_1 = array[(h + 1) % array.length];\n        if (num &gt; num_1)\n            return num;\n        if (array[0] &lt; num)\n            return busca(array, h + 1, z);\n        else\n            return busca(array, a, h);\n    }\n</code></pre> <p>El algoritmo es de complejidad \\(O(log n)\\) porque es un esquema de divisi\u00f3n sucesiva. M\u00e1s desarrollado:</p> <ol> <li> <p>Al principio, \\(h\\) puede estar entre \\(O\\) y \\(N-1\\);</p> </li> <li> <p>Tras 1 paso, \\(h\\) puede estar entre \\((O y N/2)\\) o entre \\((N/2 y N)\\); es decir, hemos reducido las opciones a la mitad \\((N/2)\\);</p> </li> <li> <p>Tras \\(k\\) pasos, el rango es \\(N/2^k\\); de forma que el rango se reduce a 1 (\\(h\\) encontrado) cuando \\(1 \\leq N/2^k \\rightarrow k=log_{2} (N) \\subset O(log N)\\).</p> </li> </ol>","tags":["complejidad"]},{"location":"exams/2013/p1_ex02/","title":"P1 ex02","text":"<ul> <li>(a) (5 puntos) Sean tres hebras (threads), T1, T2 y T3, que utilizan tres recursos, R1, R2 y R3.</li> </ul> <p>La hebra T1 s\u00f3lo necesita el recurso R1.  </p> <p>La hebra T2 necesita los recursos R2 y R3.  </p> <p>Por \u00faltimo, la hebra T3 requiere los tres recursos, R1, R2 y R3.</p> <p>Escriba un monitor que controle el acceso de las hebras a los recursos. Cada hebra solicita los recursos que necesita invocando un m\u00e9todo del monitor. Cuando una hebra termina de usar los recursos que necesita, lo indica para que otras hebras puedan usarlos. El monitor ha de asegurar que ning\u00fan recurso es utilizado por m\u00e1s de una hebra a la vez.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es:</p> <pre><code>class Monitor {\n    \u2026\n    \u2026 requiereR1 (\u2026) { \u2026 }\n    \u2026 requiereR2_R3 (\u2026) { \u2026 }\n    \u2026 requiereR1_R2_R3 ( \u2026) { \u2026}\n    \u2026 liberaR1(\u2026) { \u2026 }\n    \u2026 liberaR2_R3 (\u2026) { \u2026 }\n    \u2026 liberaR1_R2_R3 ( \u2026) { \u2026}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n ser\u00eda:</p> <pre><code>public class Monitor {\n    private boolean ocupadoR1 = false;\n    private boolean ocupadoR2 = false;\n    private boolean ocupadoR3 = false;\n\n    public synchronized void requiereR1 () \n               throws InterruptedException {\n        while (ocupadoR1) wait();\n        ocupadoR1 = true;\n    }\n\n    public synchronized void requiereR2_R3() \n               throws InterruptedException {\n        while (ocupadoR2 || ocupadoR3) wait();\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void requiereR1_R2_R3 () \n                   throws InterruptedException { \n        while (ocupadoR1 || ocupadoR2 || ocupadoR3) wait();\n        ocupadoR1 = true;\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void liberaR1() {\n        ocupadoR1 = false;\n        notifyAll();\n    }\n\n    public synchronized void libreraR2_R3 () {\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll();\n    }\n\n    public synchronized void liberaR1_R2_R3 () {\n        ocupadoR1 = false;\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll(); \n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2013/p1r/","title":"Examen 2013 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2013/p1r/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o \\(N\u00d7N\\), desarrolle un algoritmo de orden \\(O(N^2)\\) para averiguar si un valor \\(K\\) est\u00e1 presente o no en la matriz. Razone el orden de complejidad del algoritmo desarrollado.</li> </ul> <p>Ejemplo:</p> <p>\\(\\begin{bmatrix}84&amp;32 &amp;-13 &amp;33&amp;13\\\\7&amp;82&amp;93&amp;89&amp;-23\\\\31&amp;-24&amp;-28&amp;57&amp;-93\\\\86&amp;-71&amp;-44&amp;75&amp;-12\\\\-10&amp;-18&amp;53&amp;24&amp;78\\end{bmatrix}\\)</p> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre> Mostrar soluci\u00f3n <p><pre><code>boolean busca1(int[][] matriz, int m) {\n    for (int x = 0; x &lt; matriz.length; x++) {\n        for (int y = 0; y &lt; matriz[x].length; y++) {\n            if (matriz[x][y] == m)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre> En cuanto a la complejidad, es un bucle que hace \\(N\\) vueltas, y en cada una hay otro bucle anidado que hace otras \\(N\\) vueltas. Por tanto, en total es de \\(O(N^2)\\).</p> <p>Dada una matriz de enteros de tama\u00f1o \\(N\u00d7N\\) que est\u00e1 ordenada de forma que:</p> <p>\\(\\forall i, j: matriz[i][j] \\leq matriz[i+1][j] \\wedge matriz[i][j] \\leq matriz[i][j+1]\\)</p> <p>(se cumple que cada elemento es menor o igual que el de abajo y el de la derecha).</p> <p>Se propone el siguiente algoritmo de b\u00fasqueda de un dato <code>m</code>:</p> <pre><code>private static boolean busca2(int[][] matriz, int m) {\n    int xa = 0;\n    int xz = matriz.length;\n    int ya = 0;\n    int yz = matriz[0].length;\n    return busca2(matriz, xa, xz, ya, yz, m);\n}\n\nprivate static boolean busca2(int[][] matriz,\n        int xa, int xz, int ya, int yz, int m) {\n\n    if (xa &gt;= xz || ya &gt;= yz)\n        return false;\n\n    int xm = (xa + xz) / 2;\n    int ym = (ya + yz) / 2;\n    int ref = matriz[xm][ym];\n\n    if (ref == m)\n        return true;\n\n    if (ref &lt; m)\n        return busca2(matriz, xm + 1, xz, ya, yz, m)\n            || busca2(matriz, xa, xz, ym + 1, yz, m);\n    else\n        return busca2(matriz, xa, xm, ya, yz, m)\n            || busca2(matriz, xa, xz, ya, ym, m);\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Se pide calcular la complejidad temporal del algoritmo, razonando el resultado.</li> </ul> <p>Ejemplo:</p> <p>\\(\\begin{bmatrix}-93&amp;-71&amp;-28&amp;-18&amp;7\\\\-44&amp;-24&amp;-13&amp;13&amp;33\\\\-23&amp;-12&amp;24&amp;53&amp;78\\\\-10&amp;31&amp;57&amp;82&amp;86\\\\32&amp;75&amp;84&amp;89&amp;93\\end{bmatrix}\\)</p> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre> Mostrar soluci\u00f3n <p>Un problema de tama\u00f1o \\(X = N^2\\) se parte en 2 subproblemas de tama\u00f1o \\((X/2)\\). Esto hace \\(k\\) veces, siendo \\(X/2^k = 1 \\Rightarrow k = \\log_2(X)\\).</p> <p>En la primera ronda hay 1 comparaci\u00f3n</p> <p>En la segunda ronda 2 comparaciones</p> <p>En la tercera ronda 4 comparaciones</p> <p>\\(\\dots\\)</p> <p>En la \\(k\\)-\u00e9sima ronda, \\(2^k\\) comparaciones</p> <p>El n\u00famero total de comparaciones es la suma \\(1 + 2 + 2^2 + 2^3 + \\dots + 2^k\\)</p> <p>Sustituyendo \\(2 * 2^{\\log_2(X)} = 2X\\)</p> <p>Como \\(X = N^2\\) la soluci\u00f3n al problema cuesta \\(2N^2\\) comparaciones, siendo de la familia \\(O(N^2)\\).</p>"},{"location":"exams/2013/p1r/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) Desarrolle un monitor en Java que gestione el despegue de aviones y avionetas en un aeropuerto como se especifica a continuaci\u00f3n:</li> </ul> <p>Los aviones, al despegar, generan turbulencias, por lo que entre dos despegues consecutivos debe transcurrir un intervalo m\u00ednimo de tiempo:</p> <ul> <li>3 minutos despu\u00e9s del despegue de un avi\u00f3n.</li> <li>2 minutos despu\u00e9s del despegue de una avioneta.</li> </ul> <p>Adem\u00e1s se debe impedir que despeguen consecutivamente dos avionetas si hay aviones esperando. No hay restricciones de este tipo respecto a los aviones (pueden despegar consecutivamente).</p> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorDespegue {\n    ...\n\n    // Lo invoca un avi\u00f3n cuando quiere despegar\n    ... despegarAvion() {...}\n\n    // Lo invoca una avioneta cuando quiere despegar\n    ... despegarAvioneta() {...}\n\n    // Lo invoca el temporizador para indicar que\n    // ha transcurrido el intervalo m\u00ednimo desde\n    // el despegue anterior\n    ... autorizarDespegue() {...}\n    ...\n}\n</code></pre> <p>Para gestionar el intervalo de tiempo entre despegues, se dispone de una clase <code>Temporizador</code>, cuya interfaz se muestra a continuaci\u00f3n. El m\u00e9todo <code>iniciarTemporizador</code> arranca un temporizador que deja pasar un cierto tiempo. Cuando el tiempo expira, se invoca el m\u00e9todo <code>autorizarDespegue</code> del objeto <code>GestorDespegue</code> que se pasa en el constructor. No es necesario desarrollar esta clase.</p> <pre><code>public class Temporizador {\n    public Temporizador(GestorDespegue gestor) { ... }\n    public void iniciarTemporizador(int minutos) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n posible al problema del monitor de gesti\u00f3n de despegues es la siguiente:</p> <pre><code>public class GestorDespegue {\n\n    private boolean pistaOcupada = true;\n    private int nAvionesEsperando = 0;\n\n    private final int tiempoAvion = 3;\n    private final int tiempoAvioneta = 2;\n\n    private boolean anteriorAvioneta = false;\n\n    private Temporizador unTemporizador = new Temporizador(this);\n\n    // Invocado por un avi\u00f3n cuando quiere despegar\n    public synchronized void despegarAvion() throws InterruptedException {\n        nAvionesEsperando++;\n        while (pistaOcupada)\n            wait();\n\n        nAvionesEsperando--;\n        anteriorAvioneta = false;\n\n        unTemporizador.iniciarTemporizador(tiempoAvion);\n        pistaOcupada = true;\n    }\n\n    // Invocado por una avioneta cuando quiere despegar\n    public synchronized void despegarAvioneta() throws InterruptedException {\n        while (pistaOcupada || (nAvionesEsperando &gt; 0 &amp;&amp; anteriorAvioneta))\n            wait();\n\n        anteriorAvioneta = true;\n        unTemporizador.iniciarTemporizador(tiempoAvioneta);\n        pistaOcupada = true;\n    }\n\n    // Invocado por el temporizador cuando finaliza el intervalo m\u00ednimo\n    public synchronized void finTemporizador() throws InterruptedException {\n        pistaOcupada = false;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2013/p1r_ex01/","title":"P1r ex01","text":"<ul> <li>(a) (2,5 puntos) Dada una matriz de enteros de tama\u00f1o \\(N\u00d7N\\), desarrolle un algoritmo de orden \\(O(N^2)\\) para averiguar si un valor \\(K\\) est\u00e1 presente o no en la matriz. Razone el orden de complejidad del algoritmo desarrollado.</li> </ul> <p>Ejemplo:</p> <p>\\(\\begin{bmatrix}84&amp;32 &amp;-13 &amp;33&amp;13\\\\7&amp;82&amp;93&amp;89&amp;-23\\\\31&amp;-24&amp;-28&amp;57&amp;-93\\\\86&amp;-71&amp;-44&amp;75&amp;-12\\\\-10&amp;-18&amp;53&amp;24&amp;78\\end{bmatrix}\\)</p> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre> Mostrar soluci\u00f3n <p><pre><code>boolean busca1(int[][] matriz, int m) {\n    for (int x = 0; x &lt; matriz.length; x++) {\n        for (int y = 0; y &lt; matriz[x].length; y++) {\n            if (matriz[x][y] == m)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre> En cuanto a la complejidad, es un bucle que hace \\(N\\) vueltas, y en cada una hay otro bucle anidado que hace otras \\(N\\) vueltas. Por tanto, en total es de \\(O(N^2)\\).</p> <p>Dada una matriz de enteros de tama\u00f1o \\(N\u00d7N\\) que est\u00e1 ordenada de forma que:</p> <p>\\(\\forall i, j: matriz[i][j] \\leq matriz[i+1][j] \\wedge matriz[i][j] \\leq matriz[i][j+1]\\)</p> <p>(se cumple que cada elemento es menor o igual que el de abajo y el de la derecha).</p> <p>Se propone el siguiente algoritmo de b\u00fasqueda de un dato <code>m</code>:</p> <pre><code>private static boolean busca2(int[][] matriz, int m) {\n    int xa = 0;\n    int xz = matriz.length;\n    int ya = 0;\n    int yz = matriz[0].length;\n    return busca2(matriz, xa, xz, ya, yz, m);\n}\n\nprivate static boolean busca2(int[][] matriz,\n        int xa, int xz, int ya, int yz, int m) {\n\n    if (xa &gt;= xz || ya &gt;= yz)\n        return false;\n\n    int xm = (xa + xz) / 2;\n    int ym = (ya + yz) / 2;\n    int ref = matriz[xm][ym];\n\n    if (ref == m)\n        return true;\n\n    if (ref &lt; m)\n        return busca2(matriz, xm + 1, xz, ya, yz, m)\n            || busca2(matriz, xa, xz, ym + 1, yz, m);\n    else\n        return busca2(matriz, xa, xm, ya, yz, m)\n            || busca2(matriz, xa, xz, ya, ym, m);\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Se pide calcular la complejidad temporal del algoritmo, razonando el resultado.</li> </ul> <p>Ejemplo:</p> <p>\\(\\begin{bmatrix}-93&amp;-71&amp;-28&amp;-18&amp;7\\\\-44&amp;-24&amp;-13&amp;13&amp;33\\\\-23&amp;-12&amp;24&amp;53&amp;78\\\\-10&amp;31&amp;57&amp;82&amp;86\\\\32&amp;75&amp;84&amp;89&amp;93\\end{bmatrix}\\)</p> <pre><code>busca(matriz, 13) -&gt; true;\nbusca(matriz, 50) -&gt; false;\n</code></pre> Mostrar soluci\u00f3n <p>Un problema de tama\u00f1o \\(X = N^2\\) se parte en 2 subproblemas de tama\u00f1o \\((X/2)\\). Esto hace \\(k\\) veces, siendo \\(X/2^k = 1 \\Rightarrow k = \\log_2(X)\\).</p> <p>En la primera ronda hay 1 comparaci\u00f3n</p> <p>En la segunda ronda 2 comparaciones</p> <p>En la tercera ronda 4 comparaciones</p> <p>\\(\\dots\\)</p> <p>En la \\(k\\)-\u00e9sima ronda, \\(2^k\\) comparaciones</p> <p>El n\u00famero total de comparaciones es la suma \\(1 + 2 + 2^2 + 2^3 + \\dots + 2^k\\)</p> <p>Sustituyendo \\(2 * 2^{\\log_2(X)} = 2X\\)</p> <p>Como \\(X = N^2\\) la soluci\u00f3n al problema cuesta \\(2N^2\\) comparaciones, siendo de la familia \\(O(N^2)\\).</p>","tags":["complejidad"]},{"location":"exams/2013/p1r_ex02/","title":"P1r ex02","text":"<ul> <li>(a) (5 puntos) Desarrolle un monitor en Java que gestione el despegue de aviones y avionetas en un aeropuerto como se especifica a continuaci\u00f3n:</li> </ul> <p>Los aviones, al despegar, generan turbulencias, por lo que entre dos despegues consecutivos debe transcurrir un intervalo m\u00ednimo de tiempo:</p> <ul> <li>3 minutos despu\u00e9s del despegue de un avi\u00f3n.</li> <li>2 minutos despu\u00e9s del despegue de una avioneta.</li> </ul> <p>Adem\u00e1s se debe impedir que despeguen consecutivamente dos avionetas si hay aviones esperando. No hay restricciones de este tipo respecto a los aviones (pueden despegar consecutivamente).</p> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorDespegue {\n    ...\n\n    // Lo invoca un avi\u00f3n cuando quiere despegar\n    ... despegarAvion() {...}\n\n    // Lo invoca una avioneta cuando quiere despegar\n    ... despegarAvioneta() {...}\n\n    // Lo invoca el temporizador para indicar que\n    // ha transcurrido el intervalo m\u00ednimo desde\n    // el despegue anterior\n    ... autorizarDespegue() {...}\n    ...\n}\n</code></pre> <p>Para gestionar el intervalo de tiempo entre despegues, se dispone de una clase <code>Temporizador</code>, cuya interfaz se muestra a continuaci\u00f3n. El m\u00e9todo <code>iniciarTemporizador</code> arranca un temporizador que deja pasar un cierto tiempo. Cuando el tiempo expira, se invoca el m\u00e9todo <code>autorizarDespegue</code> del objeto <code>GestorDespegue</code> que se pasa en el constructor. No es necesario desarrollar esta clase.</p> <pre><code>public class Temporizador {\n    public Temporizador(GestorDespegue gestor) { ... }\n    public void iniciarTemporizador(int minutos) { ... }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una soluci\u00f3n posible al problema del monitor de gesti\u00f3n de despegues es la siguiente:</p> <pre><code>public class GestorDespegue {\n\n    private boolean pistaOcupada = true;\n    private int nAvionesEsperando = 0;\n\n    private final int tiempoAvion = 3;\n    private final int tiempoAvioneta = 2;\n\n    private boolean anteriorAvioneta = false;\n\n    private Temporizador unTemporizador = new Temporizador(this);\n\n    // Invocado por un avi\u00f3n cuando quiere despegar\n    public synchronized void despegarAvion() throws InterruptedException {\n        nAvionesEsperando++;\n        while (pistaOcupada)\n            wait();\n\n        nAvionesEsperando--;\n        anteriorAvioneta = false;\n\n        unTemporizador.iniciarTemporizador(tiempoAvion);\n        pistaOcupada = true;\n    }\n\n    // Invocado por una avioneta cuando quiere despegar\n    public synchronized void despegarAvioneta() throws InterruptedException {\n        while (pistaOcupada || (nAvionesEsperando &gt; 0 &amp;&amp; anteriorAvioneta))\n            wait();\n\n        anteriorAvioneta = true;\n        unTemporizador.iniciarTemporizador(tiempoAvioneta);\n        pistaOcupada = true;\n    }\n\n    // Invocado por el temporizador cuando finaliza el intervalo m\u00ednimo\n    public synchronized void finTemporizador() throws InterruptedException {\n        pistaOcupada = false;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2013/p2/","title":"Examen 2013 \u2014 Parcial 2","text":""},{"location":"exams/2013/p2/#problema-1","title":"Problema 1","text":"<p>Se desea desarrollar una aplicaci\u00f3n que facilite la selecci\u00f3n de un vino, ofreci\u00e9ndonos informaci\u00f3n de los vinos m\u00e1s populares. La pantalla inicial muestra una lista de vinos, y est\u00e1 gestionada por una actividad denominada <code>ListaVinosActivity</code>.  Al pinchar en el nombre de un vino se muestra otra pantalla con los detalles correspondientes. Esta pantalla est\u00e1 gestionada por la actividad <code>DetalleVinoActivity</code>.</p> <p></p> <p>Se proporcionan las clases Vino y Bodega tal y como se detallan a continuaci\u00f3n. </p> <pre><code>public class Vino {\n    enum Denominacion { RIOJA, RIBERA, PENEDES; }\n    private String nombre;\n    private Denominacion denominacion;\n    private int foto;\n    private String descripcion;\n    // suponga que tiene m\u00e9todos m\u00e9todos get/put para todos los campos\n    // suponga que tiene un m\u00e9todo toString() que imprime el nombre del vino\n}\n\npublic class Bodega {\n    public Vino getVino(String nombre) {... }\n    public List&lt;Vino&gt; getListaVinos() {...}\n    public static Bodega getBodega(){...}\n}\n\n// ejemplo de uso de las clases anteriores\n\npublic class Ejemplo {\n\n    public static void main(String [] args) {\n        Bodega bodega = Bodega.getBodega(); // creo la bodega\n        List&lt;Vino&gt; vinos = bodega.getListaVinos(); // lista de vinos\n        Vino vino = vinos.get(0); // obtener vino  recorriendo lista\n        // vino dado el nombre del vino\n        Vino valdehermoso = bodega.getVino(\"Valdehermoso\"); \n    }\n}\n</code></pre> <p>Se pide:</p> <ul> <li>(a) (5 puntos) Programe <code>ListaVinosActivity</code>. Suponga que dispone de la plantilla (layout) correspondiente en un fichero lista_vinos.xml, y utilice los nombres que necesite como crea oportuno. Utilice un <code>ArrayAdapter</code> para mostrar los elementos de la lista.</li> </ul> <p>Cuando se pulse en un elemento de la lista (el nombre de un vino), la actividad <code>ListaVinosActivity</code> debe lanzar la actividad <code>DetalleVinoActivity</code> pas\u00e1ndole el nombre del vino en la clave NOMBRE, y sin esperar un resultado de vuelta de dicha actividad.</p> <p>La actividad debe mostrar una traza (Log) de tipo informativo (<code>I</code>)  con el n\u00famero de vinos cargados, y una traza de tipo depuraci\u00f3n (<code>D</code>) con la opci\u00f3n que ha pulsado, como se muestra a continuaci\u00f3n.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public class ListaVinosActivity extends ListActivity {\n   public static final String NOMBRE = \"nombre\";\n   private static final String TAG = ListaVinosActivity.class.getSimpleName();\n   private Bodega bodega;\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.lista_vinos);\n      bodega = Bodega.getBodega();\n      List&lt;Vino&gt; lista = bodega.getListaVinos(); \n      Log.i(TAG, \"Cargando \" + lista.size() + \" vinos\"); \n      setListAdapter(new ArrayAdapter&lt;Vino&gt;(this,\n                       android.R.layout.simple_list_item_1, lista));\n   }\n   @Override\n   protected void onListItemClick(ListView l, View v, int position, long id) { \n      super.onListItemClick(l, v, position, id);\n      Intent intent = new Intent(this, DetalleVinoActivity.class);\n      Vino vino = bodega.getListaVinos().get(position);\n      Log.d(TAG, \"Pulsado en \" + vino);\n      intent.putExtra(NOMBRE, vino.getNombre());\n      startActivity(intent);\n   }\n}\n</code></pre> <ul> <li> <p>(b) (5 puntos) Programe <code>DetalleVinoActivity</code>. Suponga que la plantilla detalle_vino.xml muestra los campos de un  objeto <code>Vino</code> en los siguientes componentes: </p> <ul> <li>Foto en un <code>ImageView</code> (R.id.foto),</li> <li>Nombre, denominaci\u00f3n y descripci\u00f3n en tres <code>EditText</code> (R.id.nombre, R.id.denominacion, R.id.descripcion).</li> </ul> </li> </ul> <p>La actividad recibe en la intenci\u00f3n el nombre del vino en la clave NOMBRE. Debe crear un objeto <code>Bodega</code> y recuperar el objeto <code>Vino</code> correspondiente al nombre recibido. A continuaci\u00f3n, rellene los campos de la pantalla con los valores del vino. Puede suponer que todos los campos de un objeto <code>Vino</code> tienen un valor correcto.</p> Mostrar soluci\u00f3n <pre><code>public class DetalleVinoActivity extends Activity {\n   private EditText nombre;\n   private EditText denominacion;\n   private EditText descripcion;\n   private ImageView foto;\n   private static final String TAG = DetalleVinoActivity.class.getSimpleName();\n\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.detalle_vino);\n      Intent intent = getIntent();\n      String nombreVino = intent.getStringExtra(ListaVinosActivity.NOMBRE);\n      Bodega bodega = Bodega.getBodega();\n      Vino vino = bodega.getVino(nombreVino);\n      nombre = (EditText) findViewById(R.id.nombre); \n      nombre.setText(vino.getNombre());\n      denominacion = (EditText) findViewById(R.id.denominacion);\n      denominacion.setText(vino.getDenominacion().toString());\n      descripcion = (EditText) findViewById(R.id.descripcion);\n      descripcion.setText(vino.getDescripcion());\n      foto = (ImageView) findViewById(R.id.foto); \n      foto.setImageResource(vino.getFoto());\n   }\n}\n</code></pre>"},{"location":"exams/2013/p2_ex01/","title":"P2 ex01","text":"<p>Se desea desarrollar una aplicaci\u00f3n que facilite la selecci\u00f3n de un vino, ofreci\u00e9ndonos informaci\u00f3n de los vinos m\u00e1s populares. La pantalla inicial muestra una lista de vinos, y est\u00e1 gestionada por una actividad denominada <code>ListaVinosActivity</code>.  Al pinchar en el nombre de un vino se muestra otra pantalla con los detalles correspondientes. Esta pantalla est\u00e1 gestionada por la actividad <code>DetalleVinoActivity</code>.</p> <p></p> <p>Se proporcionan las clases Vino y Bodega tal y como se detallan a continuaci\u00f3n. </p> <pre><code>public class Vino {\n    enum Denominacion { RIOJA, RIBERA, PENEDES; }\n    private String nombre;\n    private Denominacion denominacion;\n    private int foto;\n    private String descripcion;\n    // suponga que tiene m\u00e9todos m\u00e9todos get/put para todos los campos\n    // suponga que tiene un m\u00e9todo toString() que imprime el nombre del vino\n}\n\npublic class Bodega {\n    public Vino getVino(String nombre) {... }\n    public List&lt;Vino&gt; getListaVinos() {...}\n    public static Bodega getBodega(){...}\n}\n\n// ejemplo de uso de las clases anteriores\n\npublic class Ejemplo {\n\n    public static void main(String [] args) {\n        Bodega bodega = Bodega.getBodega(); // creo la bodega\n        List&lt;Vino&gt; vinos = bodega.getListaVinos(); // lista de vinos\n        Vino vino = vinos.get(0); // obtener vino  recorriendo lista\n        // vino dado el nombre del vino\n        Vino valdehermoso = bodega.getVino(\"Valdehermoso\"); \n    }\n}\n</code></pre> <p>Se pide:</p> <ul> <li>(a) (5 puntos) Programe <code>ListaVinosActivity</code>. Suponga que dispone de la plantilla (layout) correspondiente en un fichero lista_vinos.xml, y utilice los nombres que necesite como crea oportuno. Utilice un <code>ArrayAdapter</code> para mostrar los elementos de la lista.</li> </ul> <p>Cuando se pulse en un elemento de la lista (el nombre de un vino), la actividad <code>ListaVinosActivity</code> debe lanzar la actividad <code>DetalleVinoActivity</code> pas\u00e1ndole el nombre del vino en la clave NOMBRE, y sin esperar un resultado de vuelta de dicha actividad.</p> <p>La actividad debe mostrar una traza (Log) de tipo informativo (<code>I</code>)  con el n\u00famero de vinos cargados, y una traza de tipo depuraci\u00f3n (<code>D</code>) con la opci\u00f3n que ha pulsado, como se muestra a continuaci\u00f3n.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public class ListaVinosActivity extends ListActivity {\n   public static final String NOMBRE = \"nombre\";\n   private static final String TAG = ListaVinosActivity.class.getSimpleName();\n   private Bodega bodega;\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.lista_vinos);\n      bodega = Bodega.getBodega();\n      List&lt;Vino&gt; lista = bodega.getListaVinos(); \n      Log.i(TAG, \"Cargando \" + lista.size() + \" vinos\"); \n      setListAdapter(new ArrayAdapter&lt;Vino&gt;(this,\n                       android.R.layout.simple_list_item_1, lista));\n   }\n   @Override\n   protected void onListItemClick(ListView l, View v, int position, long id) { \n      super.onListItemClick(l, v, position, id);\n      Intent intent = new Intent(this, DetalleVinoActivity.class);\n      Vino vino = bodega.getListaVinos().get(position);\n      Log.d(TAG, \"Pulsado en \" + vino);\n      intent.putExtra(NOMBRE, vino.getNombre());\n      startActivity(intent);\n   }\n}\n</code></pre> <ul> <li> <p>(b) (5 puntos) Programe <code>DetalleVinoActivity</code>. Suponga que la plantilla detalle_vino.xml muestra los campos de un  objeto <code>Vino</code> en los siguientes componentes: </p> <ul> <li>Foto en un <code>ImageView</code> (R.id.foto),</li> <li>Nombre, denominaci\u00f3n y descripci\u00f3n en tres <code>EditText</code> (R.id.nombre, R.id.denominacion, R.id.descripcion).</li> </ul> </li> </ul> <p>La actividad recibe en la intenci\u00f3n el nombre del vino en la clave NOMBRE. Debe crear un objeto <code>Bodega</code> y recuperar el objeto <code>Vino</code> correspondiente al nombre recibido. A continuaci\u00f3n, rellene los campos de la pantalla con los valores del vino. Puede suponer que todos los campos de un objeto <code>Vino</code> tienen un valor correcto.</p> Mostrar soluci\u00f3n <pre><code>public class DetalleVinoActivity extends Activity {\n   private EditText nombre;\n   private EditText denominacion;\n   private EditText descripcion;\n   private ImageView foto;\n   private static final String TAG = DetalleVinoActivity.class.getSimpleName();\n\n   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.detalle_vino);\n      Intent intent = getIntent();\n      String nombreVino = intent.getStringExtra(ListaVinosActivity.NOMBRE);\n      Bodega bodega = Bodega.getBodega();\n      Vino vino = bodega.getVino(nombreVino);\n      nombre = (EditText) findViewById(R.id.nombre); \n      nombre.setText(vino.getNombre());\n      denominacion = (EditText) findViewById(R.id.denominacion);\n      denominacion.setText(vino.getDenominacion().toString());\n      descripcion = (EditText) findViewById(R.id.descripcion);\n      descripcion.setText(vino.getDescripcion());\n      foto = (ImageView) findViewById(R.id.foto); \n      foto.setImageResource(vino.getFoto());\n   }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2014/extra/","title":"Examen 2014 \u2014 Extraordinario","text":""},{"location":"exams/2014/extra/#problema-1","title":"Problema 1","text":"<p>En una matriz de valores enteros de dos dimensiones, se dice que un elemento es un pico si es mayor o igual que sus cuatro vecinos en vertical y horizontal (o sus tres vecinos, en el caso de que se encuentre en el borde de la matriz, o sus dos vecinos si est\u00e1 en una esquina).</p> <p>Para encontrar un pico en una matriz de \\(N\\) filas por \\(M\\) columnas (se puede demostrar que siempre existe al menos uno) se puede utilizar el siguiente algoritmo:</p> <ol> <li> Si $M$ es igual a 1, encontrar el mayor valor de esa columna, y devolverlo como resultado. </li> <li> En otro caso, encontrar el mayor valor en la columna central de la matriz. </li> <li> Si ese valor es mayor o igual que sus vecinos derecho e izquierdo (si existen), devolverlo como resultado. </li> <li> En otro caso, si ese valor es menor que su vecino izquierdo (si existe), continuar el mismo algoritmo con la mitad izquierda de la matriz. Y si no es as\u00ed, continuar el mismo algoritmo con la mitad derecha de la matriz (quitando la columna central en ambos casos). </li> </ol> <ul> <li>(a) (2,5 puntos) Se pide indicar razonadamente cu\u00e1l es la complejidad del algoritmo descrito, en t\u00e9rminos de \\(N\\) y \\(M\\).</li> </ul> Mostrar soluci\u00f3n <p>La b\u00fasqueda del mayor valor en una columna de \\(N\\) enteros tiene complejidad \\(N\\), ya que todos los valores de la columna han de ser comprobados, y las operaciones a realizar con cada uno de ellos son de complejidad constante. </p> <p>Por otra parte, en el peor caso habr\u00e1 que hacer esa b\u00fasqueda tantas veces como se puedan dividir iterativamente en dos partes iguales las \\(M\\) columnas, para llegar al final a una sola. Es decir, logaritmo en base dos de \\(M\\) veces. Por tanto, la complejidad total del algoritmo es \\(N*log(M)\\).</p>"},{"location":"exams/2014/extra/#problema-2","title":"Problema 2","text":"<p>Un sistema de gesti\u00f3n de un almac\u00e9n de piezas est\u00e1 compuesto por un conjunto de productores y de consumidores, que se modelan mediante hebras. Las hebras productoras a\u00f1aden piezas, mientras que las consumidoras las solicitan y retiran.</p> <ul> <li>(a) (2,5 puntos) Se pide dise\u00f1ar un monitor <code>GestorPiezas</code> que gestione las interacciones de estas hebras, cuya interfaz est\u00e1 formada por los siguientes m\u00e9todos:</li> </ul> <p><code>\u2026 void solicitarPiezas (int cantidadPiezas)</code>: este m\u00e9todo lo invocan las hebras consumidoras cuando quieren solicitar una cantidad de piezas determinada. Si hay piezas suficientes, se le proporcionan inmediatamente (se actualiza el n\u00famero de piezas almacenadas). Si no las hay, se bloquea la hebra hasta que haya suficientes. En este caso, hay que bloquear al resto de hebras consumidoras hasta que se satisfaga la petici\u00f3n pendiente.</p> <p><code>\u2026 void agregarPiezas (int cantidadPiezas)</code>: este m\u00e9todo lo invocan las hebras productoras para a\u00f1adir piezas al almac\u00e9n. La cantidad de piezas que se pueden almacenar es ilimitada.</p> <p>Nota: el n\u00famero de piezas debe ser positivo en todos los casos.</p> Mostrar soluci\u00f3n <pre><code>public class GestorAlmacen {\n    private int cantidadAlmacen = 0;\n    private boolean peticionPendiente = false;\n\n    public synchronized void solicitarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        while (peticionPendiente) wait();\n        peticionPendiente = true;\n        while (cantidadAlmacen &lt; cantidadPiezas) wait();\n        cantidadAlmacen = cantidadAlmacen - cantidadPiezas;\n        peticionPendiente = false;\n        notifyAll();\n    }\n\n    public synchronized void agregarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        cantidadAlmacen = cantidadAlmacen + cantidadPiezas;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2014/extra/#problema-3","title":"Problema 3","text":"<p>Sobre el proyecto del pacman, deseamos mover funcionalidad del men\u00fa a botones:</p> <p></p> <p>Se pide, siendo la respuesta razonada, incluyendo c\u00f3digo java y especificaciones en XML, aunque no sea necesario que la sintaxis de java y xml sea perfectamente correcta:</p> <ul> <li>(a) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para poner botones? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Hay que a\u00f1adir una fila de botones en <code>res/layout/main.xml</code></p> <pre><code>&lt;LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:gravity=\"center\" &gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_reset\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"RESET\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_fantasma\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"fantasma\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_depredador\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"depredador\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Hay que asociar la funcionalidad a cada bot\u00f3n en <code>MainActivity.java</code></p> <pre><code>public void clic(View view) {\n    Escenario escenario = Escenario.getInstance();\n    switch(view.getId()) {\n        case R.id.boton_reset:\n            escenario.restart();\n            return;\n        case R.id.boton_fantasma:\n            escenario.addMovil(this, R.id.fantasma00);\n            return;\n        case R.id.boton_depredador:\n            escenario.addMovil(this, R.id.depredador);\n            return;\n    }\n}\n</code></pre> <p>Si se van a eliminar las entradas del men\u00fa, hay que revisar los <code>R.id</code> que desaparecen, ajustando los identificadores que se usan en cada parte del c\u00f3digo.</p> <p>NOTA: Hay otras formas de hacerlo:</p> <ul> <li> <p>En el layout: identificando cada bot\u00f3n por un <code>onClick()</code> espec\u00edfico.</p> </li> <li> <p>En java, en <code>onCreate()</code>: localizando los botones y asoci\u00e1ndoles la funcionalidad. Por ejemplo:</p> </li> </ul> <pre><code>Button bv = (Button) findViewById(R.id.boton_reset);\nbv.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Escenario escenario = Escenario.getInstance();\n        escenario.restart();\n    }\n});\n</code></pre> <ul> <li>En java, hacemos que la clase <code>MainActivity</code> implemente <code>OnClickListener</code> y escribimos el m\u00e9todo <code>onClick()</code> en la clase principal y la asociamos a cada bot\u00f3n:</li> </ul> <pre><code>public class MainActivity extends \u2026 implements OnClickListener {\n\n    // en onCreate():\n    Button botonReset = (Button)rootView.findViewById(R.id.boton_reset);\n    botonReset.setOnClickListener(this);\n\n    // en la clase MainActivity:\n    public void onClick(View view) {\n        Escenario escenario = Escenario.getInstance();\n        switch (view.getId()) {\n            case R.id.boton_reset:\n                escenario.restart();\n                return;\n            case R.id.boton_fantasma:\n                escenario.addMovil(this, R.id.fantasma00);\n                return;\n            case R.id.boton_depredador:\n                escenario.addMovil(this, R.id.depredador);\n                return;\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para eliminar entradas del men\u00fa? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Hay que eliminar las entradas de <code>res/menu/main.xml</code> que se muestran a continuaci\u00f3n:</p> <p><pre><code>&lt;item\n    android:id=\"@+id/button_reset\"\n    android:icon=\"@drawable/fantasma_rojo\"\n    android:showAsAction=\"ifRoom\"\n    android:title=\"@string/button_reset\"/&gt;\n\n&lt;item\n    android:id=\"@+id/fantasma00\"\n    android:icon=\"@drawable/fantasma_rojo\"\n    android:showAsAction=\"ifRoom\"\n    android:title=\"@string/fantasma00\"/&gt;\n\n&lt;item\n    android:id=\"@+id/depredador\"\n    android:icon=\"@drawable/anibal\"\n    android:showAsAction=\"ifRoom\"\n    android:title=\"@string/depredador\"/&gt;\n</code></pre> </p> <p>Hay que eliminar la funcionalidad de la clase <code>MainActivity</code>:</p> <p>De: <pre><code>01 @Override\n02 public boolean onOptionsItemSelected(MenuItem item) {\n03     Escenario escenario = Escenario.getInstance();\n04     switch (item.getItemId()) {\n05         case R.id.button_reset:\n06             escenario.restart();\n07             return true;\n08     }\n09     if (escenario.addMovil(this, item.getItemId()))\n10         return true;\n11     return super.onOptionsItemSelected(item);\n12 }\n</code></pre> Se eliminan las l\u00edneas 05 a 10.</p> <p>OJO: hemos eliminado la facilidad de a\u00f1adir nuevos fantasmas sin m\u00e1s que a\u00f1adirlos en la especificaci\u00f3n xml del men\u00fa.</p> <ul> <li>(c) (0,5 puntos) \u00bfPodemos mantener ambos? Es decir, la misma funcionalidad accesible por men\u00fa y por bot\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed. Se pueden a\u00f1adir los botones y dejar el c\u00f3digo para el men\u00fa. La misma funci\u00f3n se puede realizar de 2 formas: por bot\u00f3n y por men\u00fa.</p>"},{"location":"exams/2014/extra/#problema-4","title":"Problema 4","text":"<ul> <li>(a) (0,8 puntos) Una aplicaci\u00f3n Android llamada APP est\u00e1 ejecut\u00e1ndose y dispone del foco (interact\u00faa con el usuario). Supongamos que se recibe una llamada telef\u00f3nica, el usuario la atiende y luego cuelga. \u00bfCu\u00e1les son los m\u00e9todos del ciclo de vida de APP llamados?</li> </ul> Mostrar soluci\u00f3n <p>La secuencia m\u00e1s com\u00fan es:</p> <pre><code>onPause()\nonStop()\nonRestart()\nonStart()\nonResume()\n</code></pre> <p>pero tambi\u00e9n puede ocurrir la siguiente secuencia:</p> <pre><code>onPause()\nonStop()\nonDestroy()\nonCreate()\nonStart()\nonResume()\n</code></pre> <p>Tambi\u00e9n podr\u00eda ocurrir que la llamada entrante no llegue a retirar toda la actividad de la pantalla sino que quede en el fondo. En ese caso la secuencia ser\u00eda:</p> <pre><code>onPause()\nonResume()\n</code></pre> <p>Todas las soluciones anteriores se consideran v\u00e1lidas.</p> <ul> <li>(b) (0,7 puntos) Describir brevemente qu\u00e9 es y para qu\u00e9 se usa un <code>SimpleCursorAdapter</code>.</li> </ul> Mostrar soluci\u00f3n <p>Es un mecanismo que sirve para conectar el cursor con el que se accede a las filas que resultan de una consulta en una base datos con una <code>ListView</code> definida en el layout de una actividad. Se usa para mostrar los resultados de una consulta en una pantalla</p> <ul> <li>(c) (1 punto) En la actividad principal de una aplicaci\u00f3n hay un bot\u00f3n que tiene asociado un m\u00e9todo <code>onClick</code> que lanza la ejecuci\u00f3n de una tarea as\u00edncrona para cargar un fichero remoto. Indicar qu\u00e9 m\u00e9todos hay que programar en la clase que implementa la <code>AsyncTask</code>, en qu\u00e9 hebra (thread) se ejecuta cada uno de ellos, y describa sucintamente qu\u00e9 hacen.</li> </ul> Mostrar soluci\u00f3n <p>Suponiendo que la cabecera de la clase es:</p> <pre><code>class MyClass extends AsyncTask&lt;Params, Progress, Result&gt;\n</code></pre> <p>los m\u00e9todos que hay que programar son:</p> <pre><code>void onPreExecute()\n</code></pre> <p>Se ejecuta en la <code>UIThread</code>, cuando se llama a <code>execute()</code>. Sirve para iniciar la tarea antes de empezar a ejecutar <code>doInbackground</code>.</p> <pre><code>Result doInBackground(Params\u2026)\n</code></pre> <p>Se ejecuta en la hebra auxiliar. Es equivalente a <code>run()</code> en las threads normales. <code>Params</code> son los par\u00e1metros que se le pasan al arrancar la tarea.</p> <pre><code>void onProgressUpdate (Progress\u2026)\n</code></pre> <p>Se ejecuta en la <code>UIThread</code> cada vez que se llama a <code>publishProgress(Progress\u2026)</code> desde el cuerpo de <code>doInBackground</code>.</p> <pre><code>void onPostExecute (Result)\n</code></pre> <p>Se ejecuta en la <code>UIThread</code> cuando termina <code>doInBackground</code> (con <code>return Result</code>).</p>"},{"location":"exams/2014/extra01/","title":"Extra01","text":"<p>En una matriz de valores enteros de dos dimensiones, se dice que un elemento es un pico si es mayor o igual que sus cuatro vecinos en vertical y horizontal (o sus tres vecinos, en el caso de que se encuentre en el borde de la matriz, o sus dos vecinos si est\u00e1 en una esquina).</p> <p>Para encontrar un pico en una matriz de \\(N\\) filas por \\(M\\) columnas (se puede demostrar que siempre existe al menos uno) se puede utilizar el siguiente algoritmo:</p> <ol> <li> Si $M$ es igual a 1, encontrar el mayor valor de esa columna, y devolverlo como resultado. </li> <li> En otro caso, encontrar el mayor valor en la columna central de la matriz. </li> <li> Si ese valor es mayor o igual que sus vecinos derecho e izquierdo (si existen), devolverlo como resultado. </li> <li> En otro caso, si ese valor es menor que su vecino izquierdo (si existe), continuar el mismo algoritmo con la mitad izquierda de la matriz. Y si no es as\u00ed, continuar el mismo algoritmo con la mitad derecha de la matriz (quitando la columna central en ambos casos). </li> </ol> <ul> <li>(a) (2,5 puntos) Se pide indicar razonadamente cu\u00e1l es la complejidad del algoritmo descrito, en t\u00e9rminos de \\(N\\) y \\(M\\).</li> </ul> Mostrar soluci\u00f3n <p>La b\u00fasqueda del mayor valor en una columna de \\(N\\) enteros tiene complejidad \\(N\\), ya que todos los valores de la columna han de ser comprobados, y las operaciones a realizar con cada uno de ellos son de complejidad constante. </p> <p>Por otra parte, en el peor caso habr\u00e1 que hacer esa b\u00fasqueda tantas veces como se puedan dividir iterativamente en dos partes iguales las \\(M\\) columnas, para llegar al final a una sola. Es decir, logaritmo en base dos de \\(M\\) veces. Por tanto, la complejidad total del algoritmo es \\(N*log(M)\\).</p>","tags":["complejidad"]},{"location":"exams/2014/extra02/","title":"Extra02","text":"<p>Un sistema de gesti\u00f3n de un almac\u00e9n de piezas est\u00e1 compuesto por un conjunto de productores y de consumidores, que se modelan mediante hebras. Las hebras productoras a\u00f1aden piezas, mientras que las consumidoras las solicitan y retiran.</p> <ul> <li>(a) (2,5 puntos) Se pide dise\u00f1ar un monitor <code>GestorPiezas</code> que gestione las interacciones de estas hebras, cuya interfaz est\u00e1 formada por los siguientes m\u00e9todos:</li> </ul> <p><code>\u2026 void solicitarPiezas (int cantidadPiezas)</code>: este m\u00e9todo lo invocan las hebras consumidoras cuando quieren solicitar una cantidad de piezas determinada. Si hay piezas suficientes, se le proporcionan inmediatamente (se actualiza el n\u00famero de piezas almacenadas). Si no las hay, se bloquea la hebra hasta que haya suficientes. En este caso, hay que bloquear al resto de hebras consumidoras hasta que se satisfaga la petici\u00f3n pendiente.</p> <p><code>\u2026 void agregarPiezas (int cantidadPiezas)</code>: este m\u00e9todo lo invocan las hebras productoras para a\u00f1adir piezas al almac\u00e9n. La cantidad de piezas que se pueden almacenar es ilimitada.</p> <p>Nota: el n\u00famero de piezas debe ser positivo en todos los casos.</p> Mostrar soluci\u00f3n <pre><code>public class GestorAlmacen {\n    private int cantidadAlmacen = 0;\n    private boolean peticionPendiente = false;\n\n    public synchronized void solicitarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        while (peticionPendiente) wait();\n        peticionPendiente = true;\n        while (cantidadAlmacen &lt; cantidadPiezas) wait();\n        cantidadAlmacen = cantidadAlmacen - cantidadPiezas;\n        peticionPendiente = false;\n        notifyAll();\n    }\n\n    public synchronized void agregarPiezas(int cantidadPiezas)\n        throws InterruptedException {\n        cantidadAlmacen = cantidadAlmacen + cantidadPiezas;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2014/extra03/","title":"Extra03","text":"<p>Sobre el proyecto del pacman, deseamos mover funcionalidad del men\u00fa a botones:</p> <p></p> <p>Se pide, siendo la respuesta razonada, incluyendo c\u00f3digo java y especificaciones en XML, aunque no sea necesario que la sintaxis de java y xml sea perfectamente correcta:</p> <ul> <li>(a) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para poner botones? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Hay que a\u00f1adir una fila de botones en <code>res/layout/main.xml</code></p> <pre><code>&lt;LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:gravity=\"center\" &gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_reset\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"RESET\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_fantasma\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"fantasma\" /&gt;\n\n    &lt;Button\n        android:id=\"@+id/boton_depredador\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:onClick=\"clic\"\n        android:text=\"depredador\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Hay que asociar la funcionalidad a cada bot\u00f3n en <code>MainActivity.java</code></p> <pre><code>public void clic(View view) {\n    Escenario escenario = Escenario.getInstance();\n    switch(view.getId()) {\n        case R.id.boton_reset:\n            escenario.restart();\n            return;\n        case R.id.boton_fantasma:\n            escenario.addMovil(this, R.id.fantasma00);\n            return;\n        case R.id.boton_depredador:\n            escenario.addMovil(this, R.id.depredador);\n            return;\n    }\n}\n</code></pre> <p>Si se van a eliminar las entradas del men\u00fa, hay que revisar los <code>R.id</code> que desaparecen, ajustando los identificadores que se usan en cada parte del c\u00f3digo.</p> <p>NOTA: Hay otras formas de hacerlo:</p> <ul> <li> <p>En el layout: identificando cada bot\u00f3n por un <code>onClick()</code> espec\u00edfico.</p> </li> <li> <p>En java, en <code>onCreate()</code>: localizando los botones y asoci\u00e1ndoles la funcionalidad. Por ejemplo:</p> </li> </ul> <pre><code>Button bv = (Button) findViewById(R.id.boton_reset);\nbv.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        Escenario escenario = Escenario.getInstance();\n        escenario.restart();\n    }\n});\n</code></pre> <ul> <li>En java, hacemos que la clase <code>MainActivity</code> implemente <code>OnClickListener</code> y escribimos el m\u00e9todo <code>onClick()</code> en la clase principal y la asociamos a cada bot\u00f3n:</li> </ul> <pre><code>public class MainActivity extends \u2026 implements OnClickListener {\n\n    // en onCreate():\n    Button botonReset = (Button)rootView.findViewById(R.id.boton_reset);\n    botonReset.setOnClickListener(this);\n\n    // en la clase MainActivity:\n    public void onClick(View view) {\n        Escenario escenario = Escenario.getInstance();\n        switch (view.getId()) {\n            case R.id.boton_reset:\n                escenario.restart();\n                return;\n            case R.id.boton_fantasma:\n                escenario.addMovil(this, R.id.fantasma00);\n                return;\n            case R.id.boton_depredador:\n                escenario.addMovil(this, R.id.depredador);\n                return;\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 cambios hay que hacer para eliminar entradas del men\u00fa? Indique ficheros java y ficheros de recursos que hay que modificar y en qu\u00e9 consiste la modificaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Hay que eliminar las entradas de <code>res/menu/main.xml</code> que se muestran a continuaci\u00f3n:</p> <p><pre><code>&lt;item\n    android:id=\"@+id/button_reset\"\n    android:icon=\"@drawable/fantasma_rojo\"\n    android:showAsAction=\"ifRoom\"\n    android:title=\"@string/button_reset\"/&gt;\n\n&lt;item\n    android:id=\"@+id/fantasma00\"\n    android:icon=\"@drawable/fantasma_rojo\"\n    android:showAsAction=\"ifRoom\"\n    android:title=\"@string/fantasma00\"/&gt;\n\n&lt;item\n    android:id=\"@+id/depredador\"\n    android:icon=\"@drawable/anibal\"\n    android:showAsAction=\"ifRoom\"\n    android:title=\"@string/depredador\"/&gt;\n</code></pre> </p> <p>Hay que eliminar la funcionalidad de la clase <code>MainActivity</code>:</p> <p>De: <pre><code>01 @Override\n02 public boolean onOptionsItemSelected(MenuItem item) {\n03     Escenario escenario = Escenario.getInstance();\n04     switch (item.getItemId()) {\n05         case R.id.button_reset:\n06             escenario.restart();\n07             return true;\n08     }\n09     if (escenario.addMovil(this, item.getItemId()))\n10         return true;\n11     return super.onOptionsItemSelected(item);\n12 }\n</code></pre> Se eliminan las l\u00edneas 05 a 10.</p> <p>OJO: hemos eliminado la facilidad de a\u00f1adir nuevos fantasmas sin m\u00e1s que a\u00f1adirlos en la especificaci\u00f3n xml del men\u00fa.</p> <ul> <li>(c) (0,5 puntos) \u00bfPodemos mantener ambos? Es decir, la misma funcionalidad accesible por men\u00fa y por bot\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed. Se pueden a\u00f1adir los botones y dejar el c\u00f3digo para el men\u00fa. La misma funci\u00f3n se puede realizar de 2 formas: por bot\u00f3n y por men\u00fa.</p>","tags":["android"]},{"location":"exams/2014/extra04/","title":"Extra04","text":"<ul> <li>(a) (0,8 puntos) Una aplicaci\u00f3n Android llamada APP est\u00e1 ejecut\u00e1ndose y dispone del foco (interact\u00faa con el usuario). Supongamos que se recibe una llamada telef\u00f3nica, el usuario la atiende y luego cuelga. \u00bfCu\u00e1les son los m\u00e9todos del ciclo de vida de APP llamados?</li> </ul> Mostrar soluci\u00f3n <p>La secuencia m\u00e1s com\u00fan es:</p> <pre><code>onPause()\nonStop()\nonRestart()\nonStart()\nonResume()\n</code></pre> <p>pero tambi\u00e9n puede ocurrir la siguiente secuencia:</p> <pre><code>onPause()\nonStop()\nonDestroy()\nonCreate()\nonStart()\nonResume()\n</code></pre> <p>Tambi\u00e9n podr\u00eda ocurrir que la llamada entrante no llegue a retirar toda la actividad de la pantalla sino que quede en el fondo. En ese caso la secuencia ser\u00eda:</p> <pre><code>onPause()\nonResume()\n</code></pre> <p>Todas las soluciones anteriores se consideran v\u00e1lidas.</p> <ul> <li>(b) (0,7 puntos) Describir brevemente qu\u00e9 es y para qu\u00e9 se usa un <code>SimpleCursorAdapter</code>.</li> </ul> Mostrar soluci\u00f3n <p>Es un mecanismo que sirve para conectar el cursor con el que se accede a las filas que resultan de una consulta en una base datos con una <code>ListView</code> definida en el layout de una actividad. Se usa para mostrar los resultados de una consulta en una pantalla</p> <ul> <li>(c) (1 punto) En la actividad principal de una aplicaci\u00f3n hay un bot\u00f3n que tiene asociado un m\u00e9todo <code>onClick</code> que lanza la ejecuci\u00f3n de una tarea as\u00edncrona para cargar un fichero remoto. Indicar qu\u00e9 m\u00e9todos hay que programar en la clase que implementa la <code>AsyncTask</code>, en qu\u00e9 hebra (thread) se ejecuta cada uno de ellos, y describa sucintamente qu\u00e9 hacen.</li> </ul> Mostrar soluci\u00f3n <p>Suponiendo que la cabecera de la clase es:</p> <pre><code>class MyClass extends AsyncTask&lt;Params, Progress, Result&gt;\n</code></pre> <p>los m\u00e9todos que hay que programar son:</p> <pre><code>void onPreExecute()\n</code></pre> <p>Se ejecuta en la <code>UIThread</code>, cuando se llama a <code>execute()</code>. Sirve para iniciar la tarea antes de empezar a ejecutar <code>doInbackground</code>.</p> <pre><code>Result doInBackground(Params\u2026)\n</code></pre> <p>Se ejecuta en la hebra auxiliar. Es equivalente a <code>run()</code> en las threads normales. <code>Params</code> son los par\u00e1metros que se le pasan al arrancar la tarea.</p> <pre><code>void onProgressUpdate (Progress\u2026)\n</code></pre> <p>Se ejecuta en la <code>UIThread</code> cada vez que se llama a <code>publishProgress(Progress\u2026)</code> desde el cuerpo de <code>doInBackground</code>.</p> <pre><code>void onPostExecute (Result)\n</code></pre> <p>Se ejecuta en la <code>UIThread</code> cuando termina <code>doInBackground</code> (con <code>return Result</code>).</p>","tags":["android"]},{"location":"exams/2014/p1/","title":"Examen 2014 \u2014 Parcial 1","text":""},{"location":"exams/2014/p1/#problema-1","title":"Problema 1","text":"<p>Se necesita comprobar la bondad de los algoritmos de construcci\u00f3n de laberintos que se puedan desarrollar para la pr\u00e1ctica del Pacman. El objetivo es poder construir un laberinto conexo, esto es, un terreno en el que todas las casillas est\u00e9n conectadas, bien directamente o bien a trav\u00e9s de otras que las interconecten. De esta forma, no habr\u00e1 zonas del laberinto aisladas.</p> <p>Para ello, se pide desarrollar una clase auxiliar, llamada <code>Conectividad</code>, que averig\u00fce si un terreno es conexo o no. La especificaci\u00f3n de la clase es la siguiente:</p> <pre><code>package es.upm.dit.adsw.pacman2;\n\npublic class Conectividad {\n    private final Terreno terreno;\n\n    /**\n     * @param terreno\n     */\n    public Conectividad(Terreno terreno) {\n        this.terreno = terreno;\n    }\n\n    /**\n     * Determina si el terreno es conexo\n     * @return true si el terreno es conexo, false en caso contrario\n     */\n    public boolean esConexo() { ... }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Implementaci\u00f3n del m\u00e9todo <code>esConexo()</code>. Este m\u00e9todo ha de comprobar que desde cualquier casilla del terreno se puede alcanzar cualquier otra casilla.</li> </ul> <p>Sugerencia: Se propone el siguiente algoritmo para determinar si un terreno tiene casillas conexas.</p> <ul> <li> <p>Se define un conjunto de casillas visitadas (ya analizadas alguna vez) y una lista de casillas pendientes (a\u00fan no analizadas).</p> </li> <li> <p>Se elige una casilla inicial, por ejemplo (0,0), y se a\u00f1ade a la lista de pendientes.</p> </li> <li> <p>Mientras haya casillas pendientes:</p> <ol> <li>Se saca una casilla de la lista de pendientes;</li> <li>Se a\u00f1ade la casilla al conjunto de visitadas;</li> <li>Para cada direcci\u00f3n:<ul> <li>Si existe una casilla adyacente accesible (no separada por una pared);</li> <li>Y no ha sido visitada, se a\u00f1ade a la lista de pendientes.</li> </ul> </li> </ol> </li> <li> <p>Cuando ya no hay casillas pendientes:</p> <ul> <li>O bien se han visitado todas las casillas;</li> <li>O existen zonas aisladas que no se han podido alcanzar.</li> </ul> </li> <li> <p>Si el tama\u00f1o del conjunto de visitadas coincide con el n\u00famero total de casillas \\((N^2)\\), entonces el terreno es conexo.</p> </li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo <code>esConexo()</code> es la siguiente:</p> <pre><code>public boolean esConexo() {\n    Set&lt;Casilla&gt; visitadas = new HashSet&lt;Casilla&gt;();\n    List&lt;Casilla&gt; pendientes = new ArrayList&lt;Casilla&gt;();\n\n    Casilla origen = terreno.getCasilla(0, 0);\n    pendientes.add(origen);\n\n    while (!pendientes.isEmpty()) {\n        Casilla c = pendientes.remove(0);\n        visitadas.add(c);\n\n        for (Direccion d : Direccion.values()) {\n            if (!c.hayPared(d)) {\n                Casilla v = terreno.getCasilla(c, d);\n                if (v != null &amp;&amp; !visitadas.contains(v)) {\n                    pendientes.add(v);\n                }\n            }\n        }\n    }\n\n    int N = terreno.getN();\n    return visitadas.size() == N * N;\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Complejidad temporal del algoritmo. (0,5 puntos) Determine la complejidad temporal del algoritmo programado en el apartado anterior. (1 punto) Justifique su respuesta. Se considera m\u00e1s importante el razonamiento sobre la complejidad que el c\u00e1lculo correcto.</li> </ul> Mostrar soluci\u00f3n <p>Dado que el algoritmo recorre, en el peor de los casos, todas las casillas del terreno, la complejidad b\u00e1sica ser\u00e1:</p> <p>\\(O(N^2) \\times (\\text{complejidad de las operaciones})\\)</p> <p>Las operaciones b\u00e1sicas (comparaciones, asignaciones, accesos simples) tienen complejidad \\(O(1)\\).</p> <p>El acceso a las estructuras de datos depende de su implementaci\u00f3n. En el caso de<code>HashSet</code> las operaciones de inserci\u00f3n, borrado y b\u00fasqueda tienen complejidad \\(O(1)\\) de forma habitual. En el caso de <code>ArrayList</code>n la operaci\u00f3n <code>remove(0)</code> implica desplazar todos los elementos restantes, por lo que su complejidad es \\(O(N)\\).</p> <p>Por lo tanto, para el primer caso tenemos que el algoritmo es \\(O(N^2)\\) y para el segundo \\(O(N^3)\\).</p>"},{"location":"exams/2014/p1/#problema-2","title":"Problema 2","text":"<p>Sea un cruce de calles por el que circulan coches de oeste a este y de norte a sur. Para regular el tr\u00e1fico hay dos sem\u00e1foros, uno en la entrada oeste y otro en la entrada norte, y dos sensores, que se activan cuando llega un coche a cada una de las entradas. Tambi\u00e9n hay sensores que indican la salida del cruce.</p> <p>Se desea desarrollar un monitor en Java que simule la gesti\u00f3n de los sem\u00e1foros con las siguientes forma:</p> <ul> <li> <p>Los coches se modelan como hebras (threads) que invocan un m\u00e9todo <code>llegaNorte()</code> o <code>llegaOeste()</code> cuando llegan al cruce.</p> </li> <li> <p>Si el sem\u00e1foro correspondiente est\u00e1 en verde, el coche pasa inmediatamente.</p> </li> <li> <p>Si el sem\u00e1foro est\u00e1 en rojo, el coche espera hasta que se ponga en verde.</p> </li> <li> <p>Los coches tardan un cierto tiempo en atravesar el cruce. Al salir invocan el m\u00e9todo <code>sale()</code> del monitor.</p> </li> <li> <p>Una hebra de control llama peri\u00f3dicamente al m\u00e9todo <code>cambiaSem\u00e1foros()</code> para cambiar la configuraci\u00f3n de los sem\u00e1foros.</p> </li> </ul> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorCruce {\n    ...\n\n    // Lo invoca un coche que llega por el norte\n    llegaNorte() { ... }\n\n    // Lo invoca un coche que llega por el oeste\n    llegaOeste() { ... }\n\n    // Lo invoca un coche que sale del cruce\n    sale() { ... }\n\n    // Lo invoca la hebra de control\n    cambiaSem\u00e1foros() { ... }\n...\n}\n</code></pre> <ul> <li>(a) Se pide (5 puntos)  Desarrollar el c\u00f3digo completo del monitor , justificando la respuesta. Se valorar\u00e1 especialmente el razonamiento sobre el dise\u00f1o del monitor.</li> </ul> Mostrar soluci\u00f3n <p>En el sistema existen dos tipos de hebras que representan, respectivamente, el comportamiento de los coches y el control de los sem\u00e1foros. Estas hebras invocan los m\u00e9todos del monitor para actualizar el estado del cruce y sincronizarse.</p> <p>El monitor almacena el estado del cruce mediante atributos privados. En este caso se identifican los siguientes:</p> <ul> <li>Estado de los sem\u00e1foros: puede representarse mediante un valor booleano. Basta con una sola variable, ya que cuando un sem\u00e1foro est\u00e1 en verde, el otro est\u00e1 en rojo.</li> <li>N\u00famero de coches en el cruce: se representa mediante un booleano, ya que solo se permite un coche a la vez.</li> </ul> <p>N\u00f3tese que no es necesario representar el n\u00famero de coches que esperan, ni el tiempo que transcurre entre la entrada y la un salida de un coche. Este \u00faltimo aspecto se debe modelar en la clase que representa elcomportamiento de los coches. Tampoco hay que modelar aqu\u00ed el tiempo que transcurre entre los cambios de los sem\u00e1foros, que corresponde a la hebra de control.</p> <p>En cuanto a la implementaci\u00f3n del gestor, debe realizarse como un monitor, por lo que todos los atributos dedatos deber ser privados, y todos los m\u00e9todos p\u00fablicos (excepto los constructores) deben estar sincronizados.</p> <p>Una posible implementaci\u00f3n es la siguiente:</p> <pre><code>public class GestorCruce {\n\n    // true indica sem\u00e1foro norte en verde (oeste en rojo)\n    private boolean norteVerde = true;\n\n    // Indica si hay un coche pasando por el cruce\n    private boolean cochePasando = false;\n\n    // Invocado por un coche que llega desde el norte\n    public synchronized void entraNorte() throws InterruptedException {\n        while (!norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que llega desde el oeste\n    public synchronized void entraOeste() throws InterruptedException {\n        while (norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que sale del cruce\n    public synchronized void sale() {\n        cochePasando = false;\n        notifyAll();\n    }\n\n    // Invocado por la hebra de control de los sem\u00e1foros\n    public synchronized void cambiaSemaforos() {\n        norteVerde = !norteVerde;\n        notifyAll();\n    }\n}\n</code></pre> <p>Obs\u00e9rvese que si cambian los sem\u00e1foros cuando hay un coche en el cruce, no puede entrar ning\u00fan otro coche en la nueva orientaci\u00f3n hasta que el coche que est\u00e1 en el cruce salga, ya que <code>cochePasando</code> ser\u00e1 <code>true</code>.</p> <p>Los m\u00e9todos <code>entraNorte</code> y <code>entraOeste</code> propagan <code>IntrruptedException</code>. Una alternativa ser\u00eda maneja la interrupci\u00f3n en estos m\u00e9todos con un bloque try-catch.</p>"},{"location":"exams/2014/p1_ex01/","title":"P1 ex01","text":"<p>Se necesita comprobar la bondad de los algoritmos de construcci\u00f3n de laberintos que se puedan desarrollar para la pr\u00e1ctica del Pacman. El objetivo es poder construir un laberinto conexo, esto es, un terreno en el que todas las casillas est\u00e9n conectadas, bien directamente o bien a trav\u00e9s de otras que las interconecten. De esta forma, no habr\u00e1 zonas del laberinto aisladas.</p> <p>Para ello, se pide desarrollar una clase auxiliar, llamada <code>Conectividad</code>, que averig\u00fce si un terreno es conexo o no. La especificaci\u00f3n de la clase es la siguiente:</p> <pre><code>package es.upm.dit.adsw.pacman2;\n\npublic class Conectividad {\n    private final Terreno terreno;\n\n    /**\n     * @param terreno\n     */\n    public Conectividad(Terreno terreno) {\n        this.terreno = terreno;\n    }\n\n    /**\n     * Determina si el terreno es conexo\n     * @return true si el terreno es conexo, false en caso contrario\n     */\n    public boolean esConexo() { ... }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Implementaci\u00f3n del m\u00e9todo <code>esConexo()</code>. Este m\u00e9todo ha de comprobar que desde cualquier casilla del terreno se puede alcanzar cualquier otra casilla.</li> </ul> <p>Sugerencia: Se propone el siguiente algoritmo para determinar si un terreno tiene casillas conexas.</p> <ul> <li> <p>Se define un conjunto de casillas visitadas (ya analizadas alguna vez) y una lista de casillas pendientes (a\u00fan no analizadas).</p> </li> <li> <p>Se elige una casilla inicial, por ejemplo (0,0), y se a\u00f1ade a la lista de pendientes.</p> </li> <li> <p>Mientras haya casillas pendientes:</p> <ol> <li>Se saca una casilla de la lista de pendientes;</li> <li>Se a\u00f1ade la casilla al conjunto de visitadas;</li> <li>Para cada direcci\u00f3n:<ul> <li>Si existe una casilla adyacente accesible (no separada por una pared);</li> <li>Y no ha sido visitada, se a\u00f1ade a la lista de pendientes.</li> </ul> </li> </ol> </li> <li> <p>Cuando ya no hay casillas pendientes:</p> <ul> <li>O bien se han visitado todas las casillas;</li> <li>O existen zonas aisladas que no se han podido alcanzar.</li> </ul> </li> <li> <p>Si el tama\u00f1o del conjunto de visitadas coincide con el n\u00famero total de casillas \\((N^2)\\), entonces el terreno es conexo.</p> </li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo <code>esConexo()</code> es la siguiente:</p> <pre><code>public boolean esConexo() {\n    Set&lt;Casilla&gt; visitadas = new HashSet&lt;Casilla&gt;();\n    List&lt;Casilla&gt; pendientes = new ArrayList&lt;Casilla&gt;();\n\n    Casilla origen = terreno.getCasilla(0, 0);\n    pendientes.add(origen);\n\n    while (!pendientes.isEmpty()) {\n        Casilla c = pendientes.remove(0);\n        visitadas.add(c);\n\n        for (Direccion d : Direccion.values()) {\n            if (!c.hayPared(d)) {\n                Casilla v = terreno.getCasilla(c, d);\n                if (v != null &amp;&amp; !visitadas.contains(v)) {\n                    pendientes.add(v);\n                }\n            }\n        }\n    }\n\n    int N = terreno.getN();\n    return visitadas.size() == N * N;\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Complejidad temporal del algoritmo. (0,5 puntos) Determine la complejidad temporal del algoritmo programado en el apartado anterior. (1 punto) Justifique su respuesta. Se considera m\u00e1s importante el razonamiento sobre la complejidad que el c\u00e1lculo correcto.</li> </ul> Mostrar soluci\u00f3n <p>Dado que el algoritmo recorre, en el peor de los casos, todas las casillas del terreno, la complejidad b\u00e1sica ser\u00e1:</p> <p>\\(O(N^2) \\times (\\text{complejidad de las operaciones})\\)</p> <p>Las operaciones b\u00e1sicas (comparaciones, asignaciones, accesos simples) tienen complejidad \\(O(1)\\).</p> <p>El acceso a las estructuras de datos depende de su implementaci\u00f3n. En el caso de<code>HashSet</code> las operaciones de inserci\u00f3n, borrado y b\u00fasqueda tienen complejidad \\(O(1)\\) de forma habitual. En el caso de <code>ArrayList</code>n la operaci\u00f3n <code>remove(0)</code> implica desplazar todos los elementos restantes, por lo que su complejidad es \\(O(N)\\).</p> <p>Por lo tanto, para el primer caso tenemos que el algoritmo es \\(O(N^2)\\) y para el segundo \\(O(N^3)\\).</p>","tags":["complejidad"]},{"location":"exams/2014/p1_ex02/","title":"P1 ex02","text":"<p>Sea un cruce de calles por el que circulan coches de oeste a este y de norte a sur. Para regular el tr\u00e1fico hay dos sem\u00e1foros, uno en la entrada oeste y otro en la entrada norte, y dos sensores, que se activan cuando llega un coche a cada una de las entradas. Tambi\u00e9n hay sensores que indican la salida del cruce.</p> <p>Se desea desarrollar un monitor en Java que simule la gesti\u00f3n de los sem\u00e1foros con las siguientes forma:</p> <ul> <li> <p>Los coches se modelan como hebras (threads) que invocan un m\u00e9todo <code>llegaNorte()</code> o <code>llegaOeste()</code> cuando llegan al cruce.</p> </li> <li> <p>Si el sem\u00e1foro correspondiente est\u00e1 en verde, el coche pasa inmediatamente.</p> </li> <li> <p>Si el sem\u00e1foro est\u00e1 en rojo, el coche espera hasta que se ponga en verde.</p> </li> <li> <p>Los coches tardan un cierto tiempo en atravesar el cruce. Al salir invocan el m\u00e9todo <code>sale()</code> del monitor.</p> </li> <li> <p>Una hebra de control llama peri\u00f3dicamente al m\u00e9todo <code>cambiaSem\u00e1foros()</code> para cambiar la configuraci\u00f3n de los sem\u00e1foros.</p> </li> </ul> <p>El monitor responde al siguiente esquema:</p> <pre><code>class GestorCruce {\n    ...\n\n    // Lo invoca un coche que llega por el norte\n    llegaNorte() { ... }\n\n    // Lo invoca un coche que llega por el oeste\n    llegaOeste() { ... }\n\n    // Lo invoca un coche que sale del cruce\n    sale() { ... }\n\n    // Lo invoca la hebra de control\n    cambiaSem\u00e1foros() { ... }\n...\n}\n</code></pre> <ul> <li>(a) Se pide (5 puntos)  Desarrollar el c\u00f3digo completo del monitor , justificando la respuesta. Se valorar\u00e1 especialmente el razonamiento sobre el dise\u00f1o del monitor.</li> </ul> Mostrar soluci\u00f3n <p>En el sistema existen dos tipos de hebras que representan, respectivamente, el comportamiento de los coches y el control de los sem\u00e1foros. Estas hebras invocan los m\u00e9todos del monitor para actualizar el estado del cruce y sincronizarse.</p> <p>El monitor almacena el estado del cruce mediante atributos privados. En este caso se identifican los siguientes:</p> <ul> <li>Estado de los sem\u00e1foros: puede representarse mediante un valor booleano. Basta con una sola variable, ya que cuando un sem\u00e1foro est\u00e1 en verde, el otro est\u00e1 en rojo.</li> <li>N\u00famero de coches en el cruce: se representa mediante un booleano, ya que solo se permite un coche a la vez.</li> </ul> <p>N\u00f3tese que no es necesario representar el n\u00famero de coches que esperan, ni el tiempo que transcurre entre la entrada y la un salida de un coche. Este \u00faltimo aspecto se debe modelar en la clase que representa elcomportamiento de los coches. Tampoco hay que modelar aqu\u00ed el tiempo que transcurre entre los cambios de los sem\u00e1foros, que corresponde a la hebra de control.</p> <p>En cuanto a la implementaci\u00f3n del gestor, debe realizarse como un monitor, por lo que todos los atributos dedatos deber ser privados, y todos los m\u00e9todos p\u00fablicos (excepto los constructores) deben estar sincronizados.</p> <p>Una posible implementaci\u00f3n es la siguiente:</p> <pre><code>public class GestorCruce {\n\n    // true indica sem\u00e1foro norte en verde (oeste en rojo)\n    private boolean norteVerde = true;\n\n    // Indica si hay un coche pasando por el cruce\n    private boolean cochePasando = false;\n\n    // Invocado por un coche que llega desde el norte\n    public synchronized void entraNorte() throws InterruptedException {\n        while (!norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que llega desde el oeste\n    public synchronized void entraOeste() throws InterruptedException {\n        while (norteVerde || cochePasando)\n            wait();\n        cochePasando = true;\n    }\n\n    // Invocado por un coche que sale del cruce\n    public synchronized void sale() {\n        cochePasando = false;\n        notifyAll();\n    }\n\n    // Invocado por la hebra de control de los sem\u00e1foros\n    public synchronized void cambiaSemaforos() {\n        norteVerde = !norteVerde;\n        notifyAll();\n    }\n}\n</code></pre> <p>Obs\u00e9rvese que si cambian los sem\u00e1foros cuando hay un coche en el cruce, no puede entrar ning\u00fan otro coche en la nueva orientaci\u00f3n hasta que el coche que est\u00e1 en el cruce salga, ya que <code>cochePasando</code> ser\u00e1 <code>true</code>.</p> <p>Los m\u00e9todos <code>entraNorte</code> y <code>entraOeste</code> propagan <code>IntrruptedException</code>. Una alternativa ser\u00eda maneja la interrupci\u00f3n en estos m\u00e9todos con un bloque try-catch.</p>","tags":["monitores"]},{"location":"exams/2014/p1r/","title":"Examen 2014 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2014/p1r/#problema-1","title":"Problema 1","text":"<p>Se llama mont\u00f3n (heap) a un array de valores enteros en el que, representado como un \u00e1rbol binario, todo nodo es mayor o igual que culaquiera de sus dos hijos (si existen):</p> <p></p> <p>Se ve que para todo nodo representado en la posici\u00f3n <code>i</code> de un array su hijo izquierdo se encuentra en la posici\u00f3n <code>2\u00b7i + 1</code> y su hijo derecho se encuentra en la posici\u00f3n <code>2\u00b7i + 2</code>.</p> <p>As\u00ed pues, para ordenar de mayor a menor un conjunto de valores enteros, basta con colocarlos primero como un mont\u00f3n, y despu\u00e9s ir extrayendo sucesivamente el primer valor del array (la ra\u00edz principal), y a continuaci\u00f3n recuperar el mont\u00f3n de los elementos restantes, hasta que no quede ning\u00fan elemento.</p> <p>Para recuperar el mont\u00f3n de los restantes elementos cuando se extrae el primer elemento de la tabla, basta con colocar en su lugar el \u00faltimo, y a continuaci\u00f3n hacer descender \u00e9ste en el \u00e1rbol iterativamente, si resulta necesario, hasta el nivel donde no sea menor que ninguno de sus dos (posibles) descendientes. Detr\u00e1s se puede ver el c\u00f3digo de esta operaci\u00f3n, aunque no resulta necesario en absoluto consultarlo, si se ha entendido correctamente este p\u00e1rrafo.</p> <ul> <li>(a) (5 puntos) Sabiendo que la operaci\u00f3n de construir un mont\u00f3n a partir de un array de enteros cualquiera tiene una complejidad del orden de \\(n \u2217 log(n)\\), se pide encontrar y justificar la complejidad del algoritmo completo de ordenaci\u00f3n descrito a continuaci\u00f3n:</li> </ul> <pre><code>private static int[] montonOrdenado(int[] monton) {\n    int[] resultado = new int[monton.length];\n\n    for (int j = 0; j &lt; monton.length; j++) {\n        resultado[j] = monton[0];\n\n        int ultimoIndice = monton.length - 1 - j;\n        monton[0] = monton[ultimoIndice];\n        --ultimoIndice;\n\n        int i = 0;\n        while (true) {\n            int indiceHijoIzquierdo = 2 * i + 1;\n            int indiceHijoDerecho = 2 * i + 2;\n\n            // No hay hijos\n            if (indiceHijoIzquierdo &gt; ultimoIndice)\n                break;\n\n            // Solo hay hijo izquierdo\n            if (indiceHijoDerecho &gt; ultimoIndice) {\n                if (monton[i] &lt; monton[indiceHijoIzquierdo])\n                    intercambia(monton, i, indiceHijoIzquierdo);\n                break;\n            }\n\n            // Ambos hijos son menores o iguales\n            if ((monton[i] &gt;= monton[indiceHijoIzquierdo])\n                    &amp;&amp; (monton[i] &gt;= monton[indiceHijoDerecho]))\n                break;\n\n            // Uno de los hijos es mayor\n            if (monton[indiceHijoDerecho] &lt; monton[indiceHijoIzquierdo]) {\n                intercambia(monton, i, indiceHijoIzquierdo);\n                i = indiceHijoIzquierdo;\n            } else {\n                intercambia(monton, i, indiceHijoDerecho);\n                i = indiceHijoDerecho;\n            }\n        }\n    }\n    return resultado;\n}\n\nprivate static void intercambia(int[] array, int i, int j) {\n    int t = array[i];\n    array[i] = array[j];\n    array[j] = t;\n}\n</code></pre> Mostrar soluci\u00f3n <p>En la extracci\u00f3n de los valores en orden (descendente) del array, para cada uno de ellos hay que hacer descender en el \u00e1rbol la nueva raiz, hasta que encuentre un lugar apropiado para que se siga cumpliendo la condici\u00f3n de heap. Y como el \u00e1rbol est\u00e1 siempre equilibrado, este descenso ser\u00e1, como mucho, de longitud \\(log(n)\\).</p> <p>Como, por otra parte, esta operaci\u00f3n ha de realizarse para cada uno de los valores del array, la complejidad de la extracci\u00f3n ordenada de los n valores ser\u00e1 de orden \\(n*log(n)\\). Con lo que se tiene una complejidad para el algoritmo de ordenaci\u00f3n completo (creaci\u00f3n del heap original m\u00e1s extracci\u00f3n ordenada de todos sus valores) de orden \\(n*log(n) + n*log(n)\\). Expresi\u00f3n que, seg\u00fan las reglas de combinaci\u00f3n de \u00f3rdenes de complejidad, equivale simplemente a \\(n*log(n)\\).</p>"},{"location":"exams/2014/p1r/#problema-2","title":"Problema 2","text":"<p>En un museo se exhibe un cortometraje de corta duraci\u00f3n repetidamente, con un breve descanso entre proyecciones. La capacidad de la sala es de 50 personas. En el descanso, se vac\u00eda la sala y pueden entrar los visitantes que lo deseen, sin sobrepasar la capacidad de la sala. Una vez comenzada la proyecci\u00f3n, no se permite el acceso a nuevos visitantes, que quedan esperando al siguiente descanso.</p> <ul> <li>(a) (5 puntos) Escriba una clase Monitor que controle el acceso a la sala. Cada visitante es modelado como una hebra, que invoca el m\u00e9todo <code>accederASala()</code> del Monitor cuando desea ver la proyecci\u00f3n. Adem\u00e1s hay otra hebra, Proyector, que peri\u00f3dicamente invoca el m\u00e9todo <code>comienzaProyecci\u00f3n()</code> y, tras la finalizaci\u00f3n de la proyecci\u00f3n, invoca el m\u00e9todo <code>terminaProyecci\u00f3n()</code>.</li> </ul> <p>El monitor debe permitir acceso a la Sala a las hebras <code>Visitante</code> siempre que:</p> <ul> <li> <p>No se sobrepase la capacidad de la sala;</p> </li> <li> <p>No haya comenzado la proyecci\u00f3n.</p> </li> </ul> <p>Cuando la proyecci\u00f3n termine, se debe permitir que los visitantes que estaban esperando accedan a la sala. Se entiende que TODOS los asistentes a una proyecci\u00f3n salen de la sala al terminar la proyecci\u00f3n.</p> <p>SE PIDE EXCLUSIVAMENTE EL C\u00d3DIGO DEL MONITOR. NO ESCRIBA EL C\u00d3DIGO DE VISITANTE.</p> <p>A continuaci\u00f3n se incluye el c\u00f3digo del Proyector:</p> <pre><code>public class Proyector extends Thread\n{\n    private final Monitor monitor;\n    private final int duracionProyeccion = 15000;\n    private final int duracionDescanso = 5000;\n\n    Proyector (Monitor monitor) {\n        this.monitor = monitor;\n        this.start();\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                sleep(duracionDescanso);\n                monitor.comienzaProyeccion();\n                sleep(duracionProyeccion);\n                monitor.terminaProyeccion();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>private int N= 10;\nprivate int numVisitantes;\nprivate boolean proyectando;\n\nMonitor() {\n    numVisitantes= 0;\n    proyectando= false;\n}\n\npublic synchronized void comienzaProyeccion() {\n    proyectando= true;\n}\n\npublic synchronized void terminaProyeccion() {\n    proyectando= false;\n    numVisitantes= 0;\n    notifyAll();\n}\n\npublic synchronized void accederASala() {\n    while ( proyectando || numVisitantes &gt;= N)\n    {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n        }\n    }\n    numVisitantes++;\n}\n</code></pre>"},{"location":"exams/2014/p1r_ex01/","title":"P1r ex01","text":"<p>Se llama mont\u00f3n (heap) a un array de valores enteros en el que, representado como un \u00e1rbol binario, todo nodo es mayor o igual que culaquiera de sus dos hijos (si existen):</p> <p></p> <p>Se ve que para todo nodo representado en la posici\u00f3n <code>i</code> de un array su hijo izquierdo se encuentra en la posici\u00f3n <code>2\u00b7i + 1</code> y su hijo derecho se encuentra en la posici\u00f3n <code>2\u00b7i + 2</code>.</p> <p>As\u00ed pues, para ordenar de mayor a menor un conjunto de valores enteros, basta con colocarlos primero como un mont\u00f3n, y despu\u00e9s ir extrayendo sucesivamente el primer valor del array (la ra\u00edz principal), y a continuaci\u00f3n recuperar el mont\u00f3n de los elementos restantes, hasta que no quede ning\u00fan elemento.</p> <p>Para recuperar el mont\u00f3n de los restantes elementos cuando se extrae el primer elemento de la tabla, basta con colocar en su lugar el \u00faltimo, y a continuaci\u00f3n hacer descender \u00e9ste en el \u00e1rbol iterativamente, si resulta necesario, hasta el nivel donde no sea menor que ninguno de sus dos (posibles) descendientes. Detr\u00e1s se puede ver el c\u00f3digo de esta operaci\u00f3n, aunque no resulta necesario en absoluto consultarlo, si se ha entendido correctamente este p\u00e1rrafo.</p> <ul> <li>(a) (5 puntos) Sabiendo que la operaci\u00f3n de construir un mont\u00f3n a partir de un array de enteros cualquiera tiene una complejidad del orden de \\(n \u2217 log(n)\\), se pide encontrar y justificar la complejidad del algoritmo completo de ordenaci\u00f3n descrito a continuaci\u00f3n:</li> </ul> <pre><code>private static int[] montonOrdenado(int[] monton) {\n    int[] resultado = new int[monton.length];\n\n    for (int j = 0; j &lt; monton.length; j++) {\n        resultado[j] = monton[0];\n\n        int ultimoIndice = monton.length - 1 - j;\n        monton[0] = monton[ultimoIndice];\n        --ultimoIndice;\n\n        int i = 0;\n        while (true) {\n            int indiceHijoIzquierdo = 2 * i + 1;\n            int indiceHijoDerecho = 2 * i + 2;\n\n            // No hay hijos\n            if (indiceHijoIzquierdo &gt; ultimoIndice)\n                break;\n\n            // Solo hay hijo izquierdo\n            if (indiceHijoDerecho &gt; ultimoIndice) {\n                if (monton[i] &lt; monton[indiceHijoIzquierdo])\n                    intercambia(monton, i, indiceHijoIzquierdo);\n                break;\n            }\n\n            // Ambos hijos son menores o iguales\n            if ((monton[i] &gt;= monton[indiceHijoIzquierdo])\n                    &amp;&amp; (monton[i] &gt;= monton[indiceHijoDerecho]))\n                break;\n\n            // Uno de los hijos es mayor\n            if (monton[indiceHijoDerecho] &lt; monton[indiceHijoIzquierdo]) {\n                intercambia(monton, i, indiceHijoIzquierdo);\n                i = indiceHijoIzquierdo;\n            } else {\n                intercambia(monton, i, indiceHijoDerecho);\n                i = indiceHijoDerecho;\n            }\n        }\n    }\n    return resultado;\n}\n\nprivate static void intercambia(int[] array, int i, int j) {\n    int t = array[i];\n    array[i] = array[j];\n    array[j] = t;\n}\n</code></pre> Mostrar soluci\u00f3n <p>En la extracci\u00f3n de los valores en orden (descendente) del array, para cada uno de ellos hay que hacer descender en el \u00e1rbol la nueva raiz, hasta que encuentre un lugar apropiado para que se siga cumpliendo la condici\u00f3n de heap. Y como el \u00e1rbol est\u00e1 siempre equilibrado, este descenso ser\u00e1, como mucho, de longitud \\(log(n)\\).</p> <p>Como, por otra parte, esta operaci\u00f3n ha de realizarse para cada uno de los valores del array, la complejidad de la extracci\u00f3n ordenada de los n valores ser\u00e1 de orden \\(n*log(n)\\). Con lo que se tiene una complejidad para el algoritmo de ordenaci\u00f3n completo (creaci\u00f3n del heap original m\u00e1s extracci\u00f3n ordenada de todos sus valores) de orden \\(n*log(n) + n*log(n)\\). Expresi\u00f3n que, seg\u00fan las reglas de combinaci\u00f3n de \u00f3rdenes de complejidad, equivale simplemente a \\(n*log(n)\\).</p>","tags":["complejidad"]},{"location":"exams/2014/p1r_ex02/","title":"P1r ex02","text":"<p>En un museo se exhibe un cortometraje de corta duraci\u00f3n repetidamente, con un breve descanso entre proyecciones. La capacidad de la sala es de 50 personas. En el descanso, se vac\u00eda la sala y pueden entrar los visitantes que lo deseen, sin sobrepasar la capacidad de la sala. Una vez comenzada la proyecci\u00f3n, no se permite el acceso a nuevos visitantes, que quedan esperando al siguiente descanso.</p> <ul> <li>(a) (5 puntos) Escriba una clase Monitor que controle el acceso a la sala. Cada visitante es modelado como una hebra, que invoca el m\u00e9todo <code>accederASala()</code> del Monitor cuando desea ver la proyecci\u00f3n. Adem\u00e1s hay otra hebra, Proyector, que peri\u00f3dicamente invoca el m\u00e9todo <code>comienzaProyecci\u00f3n()</code> y, tras la finalizaci\u00f3n de la proyecci\u00f3n, invoca el m\u00e9todo <code>terminaProyecci\u00f3n()</code>.</li> </ul> <p>El monitor debe permitir acceso a la Sala a las hebras <code>Visitante</code> siempre que:</p> <ul> <li> <p>No se sobrepase la capacidad de la sala;</p> </li> <li> <p>No haya comenzado la proyecci\u00f3n.</p> </li> </ul> <p>Cuando la proyecci\u00f3n termine, se debe permitir que los visitantes que estaban esperando accedan a la sala. Se entiende que TODOS los asistentes a una proyecci\u00f3n salen de la sala al terminar la proyecci\u00f3n.</p> <p>SE PIDE EXCLUSIVAMENTE EL C\u00d3DIGO DEL MONITOR. NO ESCRIBA EL C\u00d3DIGO DE VISITANTE.</p> <p>A continuaci\u00f3n se incluye el c\u00f3digo del Proyector:</p> <pre><code>public class Proyector extends Thread\n{\n    private final Monitor monitor;\n    private final int duracionProyeccion = 15000;\n    private final int duracionDescanso = 5000;\n\n    Proyector (Monitor monitor) {\n        this.monitor = monitor;\n        this.start();\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                sleep(duracionDescanso);\n                monitor.comienzaProyeccion();\n                sleep(duracionProyeccion);\n                monitor.terminaProyeccion();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>private int N= 10;\nprivate int numVisitantes;\nprivate boolean proyectando;\n\nMonitor() {\n    numVisitantes= 0;\n    proyectando= false;\n}\n\npublic synchronized void comienzaProyeccion() {\n    proyectando= true;\n}\n\npublic synchronized void terminaProyeccion() {\n    proyectando= false;\n    numVisitantes= 0;\n    notifyAll();\n}\n\npublic synchronized void accederASala() {\n    while ( proyectando || numVisitantes &gt;= N)\n    {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n        }\n    }\n    numVisitantes++;\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2014/p2/","title":"Examen 2014 \u2014 Parcial 2","text":""},{"location":"exams/2014/p2/#problema-1","title":"Problema 1","text":"<p>En la pr\u00e1ctica 2 (Pacman en Android) deseamos a\u00f1adir una nueva funcionalidad: que los jugadores ganen puntos. Consideraremos que cada escenario tiene s\u00f3lo un jugador. El jugador ganar\u00e1 1 punto cada vez que se mueva y avance una casilla.</p> <p>Adem\u00e1s, deseamos que al guardar una partida en la base de datos se almacene la puntuaci\u00f3n, y que se recupere cuando se carga la partida. Al cargar una partida almacenada, se desea que <code>DbLoadActivity</code> muestre una lista de las partidas guardadas, mostrando en cada fila el nombre de la partida y los puntos obtenidos.</p> <ul> <li>(a) (5 puntos) Indique qu\u00e9 clases de la pr\u00e1ctica debe modificar y c\u00f3mo. Incluya exclusivamente las modificaciones realizadas. No hace falta que escriba completas las cabeceras de los m\u00e9todos. En caso de que tenga varias alternativas, justifique y discuta su respuesta. </li> </ul> <p>Nota: En <code>MyDbAdapter</code>, basta con que indique las modificaciones necesarias para crear la tabla e insertar una nueva partida.</p> mostrar soluci\u00f3n <p>Debemos a\u00f1adir un campo puntos. Se puede a\u00f1adir en Escenario o en Jugador.</p> <ul> <li>Jugador</li> </ul> <pre><code>private int puntos;\n...\npublic int getPuntos() { return puntos; }\npublic void setPuntos(int puntos) { this.puntos = puntos; }\npublic void incrementa(int puntos) { this.puntos += puntos; }\n\nprivate Jugador() { ...\n    puntos = 0;\n}\n</code></pre> <ul> <li>Terreno, m\u00e9todo move</li> </ul> <pre><code>public synchronized Casilla move(Movil movil, Direccion direccion) {\n    origen.setMovil(null);\n    destino.setMovil(movil);\n    movil.setCasilla(destino);\n    jugador.incrementa(1);\n    ...\n}\n</code></pre> <ul> <li>Dentro de <code>MyDbAdapter</code>, en <code>DatabaseHelper</code>, debemos cambiar el String para crear la tabla, a\u00f1adiendo una columna:</li> </ul> <pre><code>CREATE TABLE TABLE_FOTOS (id INTEGER PRIMARY KEY AUTOINCREMENT,\nname TEXT, moviles TEXT, casillas TEXT, date TEXT, puntos INT);\n</code></pre> <ul> <li>Tambi\u00e9n dentro de <code>MyDbAdapter</code>, modificamos <code>inserfFoto()</code>:</li> </ul> <pre><code>public static final String COL_PUNTOS = \"puntos\";\n\npublic long insertFoto(String name) {\n    Escenario escenario = Escenario.getInstance();\n    Jugador jugador = escenario.getTerreno().getJugador();\n    ContentValues values = new ContentValues();\n    values.put(COL_NAME, name);\n    values.put(COL_MOVILES, DbUtils.getStringMoviles(terreno));\n    values.put(COL_CASILLAS, DbUtils.getStringCasillas(terreno));\n    values.put(COL_DATE, prepareDate());\n    values.put(COL_PUNTOS, escenario.getPuntos());\n    return db.insert(TABLE_FOTOS, null, values);\n}\n</code></pre> <ul> <li><code>DbLoadActivity</code></li> </ul> <pre><code>public class DbLoadActivity extends ListActivity {\n    private static final String TAG = \u201cDbLoadActivity\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) { ...\n        String[] columns = { MyDbAdapter.COL_NAME, MyDbAdapter.COL_PUNTOS};\n        ...\n    }\n\n    protected void onListItemClick(ListView listView,\n        View view, int position, long id) {\n        ...\n        Jugador jugador = escenario.getTerreno().getJugador();\n        jugador.setPuntos(cursor.getInt(cursor.getColumnIndex(\n            MyDbAdapter.COL_PUNTOS));\n    }\n    ...\n}\n</code></pre>"},{"location":"exams/2014/p2/#problema-2","title":"Problema 2","text":"<p>Conteste a las siguientes preguntas:</p> <ul> <li>(a) (1,5 puntos) En un layout existe un widget de tipo <code>EditText</code> con id telefono. Escribir el c\u00f3digo que extrae lo tecleado por el usuario en el widget y genera una traza con el contenido.</li> </ul> Mostrar soluci\u00f3n <pre><code>EditText telefono = (EditText) findViewById(R.id.telefono);\nString numero = telefono.getText().toString();\nLog.i.(TAG, \u201cTel\u00e9fono: \u201c + numero);\n</code></pre> <ul> <li>(b) (1,5 puntos) Estando en una actividad se desea pasar a otra actividad llamada <code>PantallaActivity</code>. Escribir el c\u00f3digo necesario para lanzar esta actividad pas\u00e1ndole un par\u00e1metro entero llamado n.</li> </ul> Mostrar soluci\u00f3n <pre><code>Intent intent = new Intent(this, PantallaActivity.class);\nintent.putExtra(\"n\", n);\nstartActivity(intent);\n</code></pre> <ul> <li>(c) (2 puntos) Necesitamos enviar un mensaje (<code>String M</code>) a una larga lista de destinatarios cuyas direcciones de email tenemos en una lista de direcciones <code>List&lt;Email&gt;</code>. Tenemos un m\u00e9todo para enviar un correo:</li> </ul> <pre><code>boolean send(Email direccion, String mensaje)\n</code></pre> <p>Como este m\u00e9todo puede ser lento, usaremos una <code>AsyncTask</code> para el env\u00edo a la lista. Suponga que llamamos al m\u00e9todo execute() pas\u00e1ndole como par\u00e1metro la <code>String M</code>. Escriba la cabecera y cuerpo del m\u00e9todo de la <code>AsyncTask</code> que se ejecuta en otra hebra (thread) de forma que ocurra lo siguiente:</p> <ul> <li> <p>Cada vez que termina el env\u00edo de un mensaje, se lanza un <code>Toast</code> en la <code>UI-thread</code> con un mensaje que pone el email y el boolean que ha devuelto el m\u00e9todo <code>send()</code>.</p> </li> <li> <p>El resultado final es el tiempo transcurrido en la hebra as\u00edncrona en milisegundos (un entero largo).</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>class Correo extends AsyncTask&lt;String,String, Long&gt; {\n    List&lt;Email&gt; direcciones ...;\n\n    protected void onPreExecute() {...} // se ejecuta en la UIThread\n\n    // se ejecuta en una nueva hebra, diferente de la UI Thread\n    @Override\n    protected Long doInBackground(final String... params) {\n        Long t0 = System.currentTimeMillis();\n        String mensaje = params[0];\n        for (Email direccion : direcciones) {\n            boolean enviado = send(direccion, mensaje);\n            String resultado = direccion + \": \u201c + enviado;\n            publishProgress(resultado);\n        }\n        Long t1 = System.currentTimeMillis();\n        return t1 - t0;\n    }\n\n    protected void onProgressUpdate(String... message) {...} // en la UIThread\n    protected void onPostExecute(Long result) {...} // en la UIThread\n}\n</code></pre> <p>S\u00f3lo se da el c\u00f3digo del m\u00e9todo <code>doInBackground</code>, dado que los otros m\u00e9todos se ejecutan en la <code>UIThread</code>. En particular, los <code>Toast</code> que se mencionan en el enunciado se lanzan desde los m\u00e9todos <code>onProgressUpdate</code> y <code>onPostExecute</code>, que se ejecutan en la hebra principal (<code>UIThread</code>).</p>"},{"location":"exams/2014/p2_ex01/","title":"P2 ex01","text":"<p>En la pr\u00e1ctica 2 (Pacman en Android) deseamos a\u00f1adir una nueva funcionalidad: que los jugadores ganen puntos. Consideraremos que cada escenario tiene s\u00f3lo un jugador. El jugador ganar\u00e1 1 punto cada vez que se mueva y avance una casilla.</p> <p>Adem\u00e1s, deseamos que al guardar una partida en la base de datos se almacene la puntuaci\u00f3n, y que se recupere cuando se carga la partida. Al cargar una partida almacenada, se desea que <code>DbLoadActivity</code> muestre una lista de las partidas guardadas, mostrando en cada fila el nombre de la partida y los puntos obtenidos.</p> <ul> <li>(a) (5 puntos) Indique qu\u00e9 clases de la pr\u00e1ctica debe modificar y c\u00f3mo. Incluya exclusivamente las modificaciones realizadas. No hace falta que escriba completas las cabeceras de los m\u00e9todos. En caso de que tenga varias alternativas, justifique y discuta su respuesta. </li> </ul> <p>Nota: En <code>MyDbAdapter</code>, basta con que indique las modificaciones necesarias para crear la tabla e insertar una nueva partida.</p> mostrar soluci\u00f3n <p>Debemos a\u00f1adir un campo puntos. Se puede a\u00f1adir en Escenario o en Jugador.</p> <ul> <li>Jugador</li> </ul> <pre><code>private int puntos;\n...\npublic int getPuntos() { return puntos; }\npublic void setPuntos(int puntos) { this.puntos = puntos; }\npublic void incrementa(int puntos) { this.puntos += puntos; }\n\nprivate Jugador() { ...\n    puntos = 0;\n}\n</code></pre> <ul> <li>Terreno, m\u00e9todo move</li> </ul> <pre><code>public synchronized Casilla move(Movil movil, Direccion direccion) {\n    origen.setMovil(null);\n    destino.setMovil(movil);\n    movil.setCasilla(destino);\n    jugador.incrementa(1);\n    ...\n}\n</code></pre> <ul> <li>Dentro de <code>MyDbAdapter</code>, en <code>DatabaseHelper</code>, debemos cambiar el String para crear la tabla, a\u00f1adiendo una columna:</li> </ul> <pre><code>CREATE TABLE TABLE_FOTOS (id INTEGER PRIMARY KEY AUTOINCREMENT,\nname TEXT, moviles TEXT, casillas TEXT, date TEXT, puntos INT);\n</code></pre> <ul> <li>Tambi\u00e9n dentro de <code>MyDbAdapter</code>, modificamos <code>inserfFoto()</code>:</li> </ul> <pre><code>public static final String COL_PUNTOS = \"puntos\";\n\npublic long insertFoto(String name) {\n    Escenario escenario = Escenario.getInstance();\n    Jugador jugador = escenario.getTerreno().getJugador();\n    ContentValues values = new ContentValues();\n    values.put(COL_NAME, name);\n    values.put(COL_MOVILES, DbUtils.getStringMoviles(terreno));\n    values.put(COL_CASILLAS, DbUtils.getStringCasillas(terreno));\n    values.put(COL_DATE, prepareDate());\n    values.put(COL_PUNTOS, escenario.getPuntos());\n    return db.insert(TABLE_FOTOS, null, values);\n}\n</code></pre> <ul> <li><code>DbLoadActivity</code></li> </ul> <pre><code>public class DbLoadActivity extends ListActivity {\n    private static final String TAG = \u201cDbLoadActivity\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) { ...\n        String[] columns = { MyDbAdapter.COL_NAME, MyDbAdapter.COL_PUNTOS};\n        ...\n    }\n\n    protected void onListItemClick(ListView listView,\n        View view, int position, long id) {\n        ...\n        Jugador jugador = escenario.getTerreno().getJugador();\n        jugador.setPuntos(cursor.getInt(cursor.getColumnIndex(\n            MyDbAdapter.COL_PUNTOS));\n    }\n    ...\n}\n</code></pre>","tags":["android"]},{"location":"exams/2014/p2_ex02/","title":"P2 ex02","text":"<p>Conteste a las siguientes preguntas:</p> <ul> <li>(a) (1,5 puntos) En un layout existe un widget de tipo <code>EditText</code> con id telefono. Escribir el c\u00f3digo que extrae lo tecleado por el usuario en el widget y genera una traza con el contenido.</li> </ul> Mostrar soluci\u00f3n <pre><code>EditText telefono = (EditText) findViewById(R.id.telefono);\nString numero = telefono.getText().toString();\nLog.i.(TAG, \u201cTel\u00e9fono: \u201c + numero);\n</code></pre> <ul> <li>(b) (1,5 puntos) Estando en una actividad se desea pasar a otra actividad llamada <code>PantallaActivity</code>. Escribir el c\u00f3digo necesario para lanzar esta actividad pas\u00e1ndole un par\u00e1metro entero llamado n.</li> </ul> Mostrar soluci\u00f3n <pre><code>Intent intent = new Intent(this, PantallaActivity.class);\nintent.putExtra(\"n\", n);\nstartActivity(intent);\n</code></pre> <ul> <li>(c) (2 puntos) Necesitamos enviar un mensaje (<code>String M</code>) a una larga lista de destinatarios cuyas direcciones de email tenemos en una lista de direcciones <code>List&lt;Email&gt;</code>. Tenemos un m\u00e9todo para enviar un correo:</li> </ul> <pre><code>boolean send(Email direccion, String mensaje)\n</code></pre> <p>Como este m\u00e9todo puede ser lento, usaremos una <code>AsyncTask</code> para el env\u00edo a la lista. Suponga que llamamos al m\u00e9todo execute() pas\u00e1ndole como par\u00e1metro la <code>String M</code>. Escriba la cabecera y cuerpo del m\u00e9todo de la <code>AsyncTask</code> que se ejecuta en otra hebra (thread) de forma que ocurra lo siguiente:</p> <ul> <li> <p>Cada vez que termina el env\u00edo de un mensaje, se lanza un <code>Toast</code> en la <code>UI-thread</code> con un mensaje que pone el email y el boolean que ha devuelto el m\u00e9todo <code>send()</code>.</p> </li> <li> <p>El resultado final es el tiempo transcurrido en la hebra as\u00edncrona en milisegundos (un entero largo).</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>class Correo extends AsyncTask&lt;String,String, Long&gt; {\n    List&lt;Email&gt; direcciones ...;\n\n    protected void onPreExecute() {...} // se ejecuta en la UIThread\n\n    // se ejecuta en una nueva hebra, diferente de la UI Thread\n    @Override\n    protected Long doInBackground(final String... params) {\n        Long t0 = System.currentTimeMillis();\n        String mensaje = params[0];\n        for (Email direccion : direcciones) {\n            boolean enviado = send(direccion, mensaje);\n            String resultado = direccion + \": \u201c + enviado;\n            publishProgress(resultado);\n        }\n        Long t1 = System.currentTimeMillis();\n        return t1 - t0;\n    }\n\n    protected void onProgressUpdate(String... message) {...} // en la UIThread\n    protected void onPostExecute(Long result) {...} // en la UIThread\n}\n</code></pre> <p>S\u00f3lo se da el c\u00f3digo del m\u00e9todo <code>doInBackground</code>, dado que los otros m\u00e9todos se ejecutan en la <code>UIThread</code>. En particular, los <code>Toast</code> que se mencionan en el enunciado se lanzan desde los m\u00e9todos <code>onProgressUpdate</code> y <code>onPostExecute</code>, que se ejecutan en la hebra principal (<code>UIThread</code>).</p>","tags":["android"]},{"location":"exams/2015/extra/","title":"Examen 2015 \u2014 Extraordinario","text":""},{"location":"exams/2015/extra/#problema-1","title":"Problema 1","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n es [0, 2, 6, 9, 11, 15] (la soluci\u00f3n no es necesariamente \u00fanica).</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>int[] lis(int[] x) {\n    int n = x.length;\n    int[] p = new int[n];\n    int[] m = new int[n + 1];\n    int le = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        int lo = 1;\n        int hi = le;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi + 1) / 2;\n            if (x[m[mid]] &lt; x[i])\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        int newLe = lo;\n        p[i] = m[newLe - 1];\n        m[newLe] = i;\n        if (newLe &gt; le)\n            le = newLe;\n    }\n\n    int[] s = new int[le];\n    int k = m[le];\n    for (int i = le - 1; i &gt;= 0; i--) {\n        s[i] = x[k];\n        k = p[k];\n    }\n    return s;\n}\n</code></pre></p> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n de tama\u00f1o \\(N\\) de la secuencia de entrada, razonando la soluci\u00f3n. NOTA: A efectos del examen se valorar\u00e1 m\u00e1s el razonamiento que el resultado final.</li> </ul> Mostrar soluci\u00f3n <p>Al principio hay un doble bucle anidado, siendo el bucle externo de complejidad lineal, mientras que el bucle interno es en principio de complejidad logar\u00edtmica, ya que hace b\u00fasqueda dicot\u00f3mica en un intervalo de tama\u00f1o no mayor que \\(n\\).  Visto en m\u00e1s detalle, el bucle interno empieza con un intervalo de una unidad y aumenta su tama\u00f1o como mucho en una unidad m\u00e1s en cada vuelta al bucle externo (algunas vueltas se incrementa en una unidad y algunas vueltas no se incrementa).  As\u00ed pues, su tiempo de ejecuci\u00f3n estar\u00e1 acotado por una constante que multiplica a \\((log 1 + log 2 ... log n)\\), lo cual es igual a \\(log(1*2*...n)\\), es decir, \\(log(n!)\\). Cantidad que puede acotarse tambi\u00e9n por \\(log(n^n)\\), es decir, \\(n*log(n)\\) (aplicando la f\u00f3rmula de Stirling se obtiene un valor mas aproximado, \\((n*log n - n)\\), pero del mismo orden de complejidad). Es decir, el bucle doble tiene complejidad lineal logar\u00edtmica. Y a continuaci\u00f3n del bucle doble anidado hay un bucle simple que es de complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser lineal logar\u00edtmica. En t\u00e9rminos formales: </p> <p>\\(C(for.while) = O(log 1 + log 2 ... log n) = O(log(1*2*...n)) = O(log(n!)) = O(n*log n)\\)</p> <p>\\(C(lis) =\\)</p> <p>\\(= C(for.while) + C(for)\\)</p> <p>\\(= O(n*log n) + O(n)\\)</p> <p>\\(= O(n*log n)\\)</p>"},{"location":"exams/2015/extra/#problema-2","title":"Problema 2","text":"<p>Un sistema est\u00e1 compuesto por un conjunto de hebras que deben acceder a un recurso compartido con exclusi\u00f3n mutua. Estas hebras se dividen en dos grupos: H1 y H2. Las hebras del grupo H2 acceden al recurso con prioridad respecto a las del grupo H1. Es decir, las hebras H1 no pueden acceder al recurso si hay alguna hebra H2 esperando. Adem\u00e1s, las hebras del grupo H1 deben acceder al recurso en el mismo orden en el que lo han solicitado.</p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor <code>GestorRecurso</code> que gestione el acceso al recurso, de acuerdo a las caracter\u00edsticas descritas. El monitor deber\u00e1 tener tres operaciones:<ul> <li><code>\u2026 solicitarRecursoH1()</code>: Este m\u00e9todo lo invocan las hebras del grupo H1 para solicitar acceso al recurso.</li> <li><code>\u2026 solicitarRecursoH2()</code>: Este m\u00e9todo lo invocan las hebras del grupo H2 para solicitar acceso al recurso.</li> <li><code>\u2026 liberarRecurso()</code>: Este m\u00e9todo lo invocan las hebras de los dos grupos para liberar el recurso.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorRecurso {\n    private int turno = 0;\n    private int ultimoSolicitar = 0;\n    private int nH2Esperando = 0;\n    private boolean recursoOcupado = false;\n\n    public synchronized void SolicitarRecursoH1() throws InterruptedException {\n        int miTurno = ultimoSolicitar;\n        ultimoSolicitar++;\n        while (miTurno &gt; turno || nH2Esperando &gt; 0 || recursoOcupado) {\n            wait();\n        }\n        turno++;\n        recursoOcupado = true;\n    }\n\n    public synchronized void SolicitarRecursoH2() throws InterruptedException {\n        nH2Esperando++;\n        while (recursoOcupado) {\n            wait();\n        }\n        recursoOcupado = true;\n        nH2Esperando--;\n    }\n\n    public synchronized void LiberarRecurso() {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2015/extra/#problema-3","title":"Problema 3","text":"<ul> <li> <p>(a) (2 puntos) En el pacman presentado como proyecto 1, queremos modificar el comportamiento del <code>Fantasma00</code> de forma que evite acercarse a los <code>Depredadores</code>. Los <code>Depredadores</code> no saben nada del asco que suscitan. Suponga que nos facilitan un m\u00e9todo en <code>Terreno</code> que nos dice si hay un depredador a menos de 3 casillas de distancia de la que pasamos como argumento: <pre><code>public synchronized boolean hayDepredador(Casilla casilla)\n</code></pre></p> <ul> <li>\u00bfPodemos hacerlo en el m\u00e9todo <code>run()</code> de <code>Fantasma00</code>? Razone si s\u00ed o si no.</li> <li>\u00bfPodemos hacerlo en el m\u00e9todo <code>puedoMoverme()</code> de <code>Fantasma00</code>? Razone si s\u00ed o si no.</li> <li>Si cree que se puede hacer de ambas maneras, indique ventajas e inconvenientes de una y otra opci\u00f3n</li> </ul> </li> </ul> Mostrar soluci\u00f3n <ol> <li>S\u00ed se puede en <code>run()</code>;</li> <li>Se puede optimizar el movimiento huyendo del depredador (moviendo en direcci\u00f3n opuesta);</li> <li>Se ejecuta fuera de la zona cr\u00edtica y el depredador y dem\u00e1s fantasmas se pueden mover mientras estamos eligiendo a d\u00f3nde ir;</li> <li>S\u00ed se puede en <code>puedoMoverme()</code>;</li> <li>S\u00f3lo podemos hacer que el fantasma espere, sin moverse;</li> <li>se ejecuta dentro de la zona cr\u00edtica de forma que el depredador y todos los fantasmas est\u00e1n quietos mientras tomamos la decisi\u00f3n.</li> </ol>"},{"location":"exams/2015/extra/#problema-4","title":"Problema 4","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione los gastos de un usuario. Cada vez que se realiza un gasto, el usuario puede introducir la cantidad gastada (<code>Importe</code>, campo num\u00e9rico real) y en qu\u00e9 se lo ha gastado (<code>Concepto</code>, de tipo texto). Estos registros se guardar\u00e1n en una base de datos sqlite, con una \u00fanica tabla. La aplicaci\u00f3n mostrar\u00e1 los registros existentes mediante una <code>ListActivity</code>. </p> <p>La aplicaci\u00f3n dispone de un men\u00fa con dos opciones, \u201cA\u00f1adir\u201d y \u201cAcerca de\u201d. La especificaci\u00f3n del men\u00fa es la siguiente:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;item\n        android:id=\"@+id/annadir\"\n        android:title=\"A\u00f1adir\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/ayuda\"\n        android:title=\"Acerca de\" /&gt;\n\n&lt;/menu&gt;\n</code></pre> <p>La sentencia SQL para crear la tabla en la base de datos es:</p> <pre><code>CREATE TABLE gastos (_id INTEGER PRIMARY KEY AUTOINCREMENT, Concepto TEXT NOT NULL, Importe REAL NOT NULL)\n</code></pre> <p>La aplicaci\u00f3n dispone de un adaptador de bases de datos, con la siguiente codificaci\u00f3n (parcial):</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba una sentencia SQL que devuelva todos los registros de la base de datos cuyo importe supere el valor de <code>50,00</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>SELECT * FROM gastos WHERE Importe &gt; 50;\n</code></pre> <ul> <li> <p>(b) (1 punto) Sobreescriba el m\u00e9todo adecuado de <code>ListActivity</code> para implementar el siguiente comportamiento:</p> <ul> <li>1) la opci\u00f3n \u201cAcerca de\u201d muestra un <code>Toast</code> con el nombre del autor del c\u00f3digo (usted);</li> <li>2) la opci\u00f3n \u201cA\u00f1adir\u201d se lance otra actividad llamada <code>AnadirGastoActivity</code> que ya est\u00e1 implementada.</li> </ul> <p>Tenga en cuenta que <code>AnadirGastoActivity</code> devolver\u00e1 un <code>Intent</code> con los datos del usuario.</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n\n        case R.id.ayuda:\n            Toast.makeText(\n                    this,\n                    getString(R.string.msg_ayuda),\n                    Toast.LENGTH_SHORT\n            ).show();\n            return true;\n\n        case R.id.annadir: {\n            Intent miIntent = new Intent(\n                    this,\n                    AnadirGastoActivity.class\n            );\n            miIntent.putExtra(REQUEST_CODE, CREA_PRODUCTO);\n            startActivityForResult(miIntent, CREA_PRODUCTO);\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfQu\u00e9 m\u00e9todos relativos al ciclo de vida de las actividades <code>ListActivity</code> y <code>AnadirGastoActivity</code> se ejecutan desde que se selecciona la opci\u00f3n \u201cA\u00f1adir\u201d del men\u00fa hasta que se vuelve a mostrar la lista de gasto? Escriba s\u00f3lo el nombre del m\u00e9todo y la actividad a la que pertenece, y el orden adecuado.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Actividad <code>onPause()</code> <code>ListActivity</code> <code>onCreate()</code> <code>AnadirGastoActivity</code> <code>onStart()</code> <code>AnadirGastoActivity</code> <code>onResume()</code> <code>AnadirGastoActivity</code> <code>onStop()</code> <code>AnadirGastoActivity</code> <code>onPause()</code> <code>AnadirGastoActivity</code> <code>onRestart()</code> <code>ListActivity</code> <code>onStart()</code> <code>ListActivity</code> <code>onResume()</code> <code>ListActivity</code> <code>onStop()</code> <code>AnadirGastoActivity</code> <ul> <li>(d) (1 punto) Escriba un m\u00e9todo de la clase <code>DatabaseHelper</code> que a\u00f1ada un nuevo registro a la base de datos. La informaci\u00f3n del <code>Concepto</code> y del <code>Importe</code> se pasar\u00e1 como par\u00e1metros del m\u00e9todo.</li> </ul> Mostrar soluci\u00f3n <pre><code>public long creaProducto(String gasto, float importe) {\n    ContentValues valoresIniciales = new ContentValues();\n\n    valoresIniciales.put(\"Concepto\", gasto);\n    valoresIniciales.put(\"Importe\", importe);\n\n    return db.insert(DATABASE_TABLE, null, valoresIniciales);\n}\n</code></pre> <ul> <li>(e) (1 punto) Escriba una especificaci\u00f3n de layout adecuada que se pueda utilizar en la actividad <code>AnadirGastoActivity</code>. Adem\u00e1s de los campos de informaci\u00f3n, dispondr\u00e1 de un bot\u00f3n \u201cGuardar\u201d y otro \u201cCancelar\u201d (s\u00f3lo hay que poner los botones). </li> </ul> Mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent \"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content \"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Concepto \" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editConcepto\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"&gt;\n        &lt;/EditText&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cantidad \u201c /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editTextCantidad\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:inputType=\"numberDecimal\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout android:orientation=\"horizontal\"&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonGuardar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Guardar\" /&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonCancelar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cancelar\" /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>"},{"location":"exams/2015/extra/#problema-5","title":"Problema 5","text":"<ul> <li> <p>(a) (2 puntos) El proyecto 2 se basa en una adaptaci\u00f3n del proyecto 1. Seleccione la respuesta o respuestas correctas en la hoja de respuestas. Las respuestas incorrectas restan.</p> <ul> <li> <p>(1) La clase <code>Terreno</code> se adapta al ciclo de vida de Android:</p> <ul> <li>(I) No ser\u00eda imprescindible realizar esta adaptaci\u00f3n; simplemente la aplicaci\u00f3n seguir\u00eda usando recursos cuando no est\u00e1 en primer plano;    </li> <li>(II) Si no hacemos la adaptaci\u00f3n, tendremos interbloqueos;</li> <li>(III) Los m\u00f3viles se congelan en <code>onPause()</code> y se descongelan en <code>onResume()</code>;</li> <li>(IV) Los m\u00f3viles se resucitan en <code>onCreate()</code>.</li> </ul> </li> <li> <p>(2) Las clases que extienden <code>Movil</code> (p.ej. <code>Jugador</code>, <code>Estatua</code>, <code>Depredador</code>, \u2026)</p> <ul> <li>(I) Deben implementar <code>restart()</code> porque es un m\u00e9todo abstracto en <code>Movil</code>;</li> <li>(II) Si adem\u00e1s implementan <code>Runnable</code>, deben crear en <code>restart()</code> una hebra (<code>new Thread()</code>) y llamar a <code>start()</code> en la hebra creada;</li> <li>(III) Si adem\u00e1 s implementan Runnable, deben crear en pause() una hebra (<code>new Thread()</code>) y llamar a <code>pause()</code> en la hebra creada;</li> <li>(IV) Siempre que extienden <code>Movil</code> deben implementar <code>Runnable</code>.</li> </ul> </li> </ul> </li> </ul> Mostrar soluci\u00f3n <ul> <li> <p>En (1) la opci\u00f3n correcta es (III);</p> </li> <li> <p>En (2) las opciones correctas son (III) y (IV).</p> </li> </ul> <ul> <li>(b) (3 puntos) Deseamos simplificar el comportamiento que hemos implementado el proyecto 2 para mover con el dedo el jugador. El nuevo comportamiento consiste en que si pulsamos en la casilla donde est\u00e1 el jugador, lanza un popup. Si pulsamos en una casilla diferente, el jugador se mueve en la direcci\u00f3n en la que est\u00e1 dicha casilla respecto del jugador.</li> </ul> <p>Adem\u00e1s, queremos poner una traza de error si se pulsa fuera del tablero.</p> <p>Suponga que dispone del m\u00e9todo popup para lanzar el popup como en la pr\u00e1ctica, as\u00ed como el resto de m\u00e9todos de las clases.</p> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onTouch(View view, MotionEvent event) {\n    try {\n        Movil jugador = terreno.getJugador();\n        if (jugador == null) {\n            return false;\n        }\n\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            int x1 = (int) (event.getX() / lado1);\n            int y1 = terreno.getN() - 1 - (int) (event.getY() / lado1);\n\n            Casilla casilla = terreno.getCasilla(x1, y1);\n            Casilla casillaJugador = jugador.getCasilla();\n\n            if (casillaJugador.equals(casilla)) {\n                popup(casilla);\n            } else {\n                int dx = (int) (x1 - casillaJugador.getX());\n                int dy = (int) (y1 - casillaJugador.getY());\n                Direccion direccion = null;\n\n                if (dy &gt; 0)\n                    direccion = Direccion.NORTE;\n                else if (dy &lt; 0)\n                    direccion = Direccion.SUR;\n                else if (dx &gt; 0)\n                    direccion = Direccion.ESTE;\n                else if (dx &lt; 0)\n                    direccion = Direccion.OESTE;\n\n                if (direccion != null) {\n                    terreno.move(jugador, direccion);\n                }\n            }\n        }\n    } catch (Exception e) {\n        Log.e(TAG, \"Ha pulsado fuera del tablero\");\n    }\n    return false;\n}\n</code></pre>"},{"location":"exams/2015/extra_ex01/","title":"Extra ex01","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n es [0, 2, 6, 9, 11, 15] (la soluci\u00f3n no es necesariamente \u00fanica).</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>int[] lis(int[] x) {\n    int n = x.length;\n    int[] p = new int[n];\n    int[] m = new int[n + 1];\n    int le = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        int lo = 1;\n        int hi = le;\n        while (lo &lt;= hi) {\n            int mid = (lo + hi + 1) / 2;\n            if (x[m[mid]] &lt; x[i])\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n        int newLe = lo;\n        p[i] = m[newLe - 1];\n        m[newLe] = i;\n        if (newLe &gt; le)\n            le = newLe;\n    }\n\n    int[] s = new int[le];\n    int k = m[le];\n    for (int i = le - 1; i &gt;= 0; i--) {\n        s[i] = x[k];\n        k = p[k];\n    }\n    return s;\n}\n</code></pre></p> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n de tama\u00f1o \\(N\\) de la secuencia de entrada, razonando la soluci\u00f3n. NOTA: A efectos del examen se valorar\u00e1 m\u00e1s el razonamiento que el resultado final.</li> </ul> Mostrar soluci\u00f3n <p>Al principio hay un doble bucle anidado, siendo el bucle externo de complejidad lineal, mientras que el bucle interno es en principio de complejidad logar\u00edtmica, ya que hace b\u00fasqueda dicot\u00f3mica en un intervalo de tama\u00f1o no mayor que \\(n\\).  Visto en m\u00e1s detalle, el bucle interno empieza con un intervalo de una unidad y aumenta su tama\u00f1o como mucho en una unidad m\u00e1s en cada vuelta al bucle externo (algunas vueltas se incrementa en una unidad y algunas vueltas no se incrementa).  As\u00ed pues, su tiempo de ejecuci\u00f3n estar\u00e1 acotado por una constante que multiplica a \\((log 1 + log 2 ... log n)\\), lo cual es igual a \\(log(1*2*...n)\\), es decir, \\(log(n!)\\). Cantidad que puede acotarse tambi\u00e9n por \\(log(n^n)\\), es decir, \\(n*log(n)\\) (aplicando la f\u00f3rmula de Stirling se obtiene un valor mas aproximado, \\((n*log n - n)\\), pero del mismo orden de complejidad). Es decir, el bucle doble tiene complejidad lineal logar\u00edtmica. Y a continuaci\u00f3n del bucle doble anidado hay un bucle simple que es de complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser lineal logar\u00edtmica. En t\u00e9rminos formales: </p> <p>\\(C(for.while) = O(log 1 + log 2 ... log n) = O(log(1*2*...n)) = O(log(n!)) = O(n*log n)\\)</p> <p>\\(C(lis) =\\)</p> <p>\\(= C(for.while) + C(for)\\)</p> <p>\\(= O(n*log n) + O(n)\\)</p> <p>\\(= O(n*log n)\\)</p>","tags":["complejidad"]},{"location":"exams/2015/extra_ex02/","title":"Extra ex02","text":"<p>Un sistema est\u00e1 compuesto por un conjunto de hebras que deben acceder a un recurso compartido con exclusi\u00f3n mutua. Estas hebras se dividen en dos grupos: H1 y H2. Las hebras del grupo H2 acceden al recurso con prioridad respecto a las del grupo H1. Es decir, las hebras H1 no pueden acceder al recurso si hay alguna hebra H2 esperando. Adem\u00e1s, las hebras del grupo H1 deben acceder al recurso en el mismo orden en el que lo han solicitado.</p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor <code>GestorRecurso</code> que gestione el acceso al recurso, de acuerdo a las caracter\u00edsticas descritas. El monitor deber\u00e1 tener tres operaciones:<ul> <li><code>\u2026 solicitarRecursoH1()</code>: Este m\u00e9todo lo invocan las hebras del grupo H1 para solicitar acceso al recurso.</li> <li><code>\u2026 solicitarRecursoH2()</code>: Este m\u00e9todo lo invocan las hebras del grupo H2 para solicitar acceso al recurso.</li> <li><code>\u2026 liberarRecurso()</code>: Este m\u00e9todo lo invocan las hebras de los dos grupos para liberar el recurso.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorRecurso {\n    private int turno = 0;\n    private int ultimoSolicitar = 0;\n    private int nH2Esperando = 0;\n    private boolean recursoOcupado = false;\n\n    public synchronized void SolicitarRecursoH1() throws InterruptedException {\n        int miTurno = ultimoSolicitar;\n        ultimoSolicitar++;\n        while (miTurno &gt; turno || nH2Esperando &gt; 0 || recursoOcupado) {\n            wait();\n        }\n        turno++;\n        recursoOcupado = true;\n    }\n\n    public synchronized void SolicitarRecursoH2() throws InterruptedException {\n        nH2Esperando++;\n        while (recursoOcupado) {\n            wait();\n        }\n        recursoOcupado = true;\n        nH2Esperando--;\n    }\n\n    public synchronized void LiberarRecurso() {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2015/extra_ex03/","title":"Extra ex03","text":"<ul> <li> <p>(a) (2 puntos) En el pacman presentado como proyecto 1, queremos modificar el comportamiento del <code>Fantasma00</code> de forma que evite acercarse a los <code>Depredadores</code>. Los <code>Depredadores</code> no saben nada del asco que suscitan. Suponga que nos facilitan un m\u00e9todo en <code>Terreno</code> que nos dice si hay un depredador a menos de 3 casillas de distancia de la que pasamos como argumento: <pre><code>public synchronized boolean hayDepredador(Casilla casilla)\n</code></pre></p> <ul> <li>\u00bfPodemos hacerlo en el m\u00e9todo <code>run()</code> de <code>Fantasma00</code>? Razone si s\u00ed o si no.</li> <li>\u00bfPodemos hacerlo en el m\u00e9todo <code>puedoMoverme()</code> de <code>Fantasma00</code>? Razone si s\u00ed o si no.</li> <li>Si cree que se puede hacer de ambas maneras, indique ventajas e inconvenientes de una y otra opci\u00f3n</li> </ul> </li> </ul> Mostrar soluci\u00f3n <ol> <li>S\u00ed se puede en <code>run()</code>;</li> <li>Se puede optimizar el movimiento huyendo del depredador (moviendo en direcci\u00f3n opuesta);</li> <li>Se ejecuta fuera de la zona cr\u00edtica y el depredador y dem\u00e1s fantasmas se pueden mover mientras estamos eligiendo a d\u00f3nde ir;</li> <li>S\u00ed se puede en <code>puedoMoverme()</code>;</li> <li>S\u00f3lo podemos hacer que el fantasma espere, sin moverse;</li> <li>se ejecuta dentro de la zona cr\u00edtica de forma que el depredador y todos los fantasmas est\u00e1n quietos mientras tomamos la decisi\u00f3n.</li> </ol>","tags":["monitores"]},{"location":"exams/2015/extra_ex04/","title":"Extra ex04","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione los gastos de un usuario. Cada vez que se realiza un gasto, el usuario puede introducir la cantidad gastada (<code>Importe</code>, campo num\u00e9rico real) y en qu\u00e9 se lo ha gastado (<code>Concepto</code>, de tipo texto). Estos registros se guardar\u00e1n en una base de datos sqlite, con una \u00fanica tabla. La aplicaci\u00f3n mostrar\u00e1 los registros existentes mediante una <code>ListActivity</code>. </p> <p>La aplicaci\u00f3n dispone de un men\u00fa con dos opciones, \u201cA\u00f1adir\u201d y \u201cAcerca de\u201d. La especificaci\u00f3n del men\u00fa es la siguiente:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;item\n        android:id=\"@+id/annadir\"\n        android:title=\"A\u00f1adir\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/ayuda\"\n        android:title=\"Acerca de\" /&gt;\n\n&lt;/menu&gt;\n</code></pre> <p>La sentencia SQL para crear la tabla en la base de datos es:</p> <pre><code>CREATE TABLE gastos (_id INTEGER PRIMARY KEY AUTOINCREMENT, Concepto TEXT NOT NULL, Importe REAL NOT NULL)\n</code></pre> <p>La aplicaci\u00f3n dispone de un adaptador de bases de datos, con la siguiente codificaci\u00f3n (parcial):</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba una sentencia SQL que devuelva todos los registros de la base de datos cuyo importe supere el valor de <code>50,00</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>SELECT * FROM gastos WHERE Importe &gt; 50;\n</code></pre> <ul> <li> <p>(b) (1 punto) Sobreescriba el m\u00e9todo adecuado de <code>ListActivity</code> para implementar el siguiente comportamiento:</p> <ul> <li>1) la opci\u00f3n \u201cAcerca de\u201d muestra un <code>Toast</code> con el nombre del autor del c\u00f3digo (usted);</li> <li>2) la opci\u00f3n \u201cA\u00f1adir\u201d se lance otra actividad llamada <code>AnadirGastoActivity</code> que ya est\u00e1 implementada.</li> </ul> <p>Tenga en cuenta que <code>AnadirGastoActivity</code> devolver\u00e1 un <code>Intent</code> con los datos del usuario.</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n\n        case R.id.ayuda:\n            Toast.makeText(\n                    this,\n                    getString(R.string.msg_ayuda),\n                    Toast.LENGTH_SHORT\n            ).show();\n            return true;\n\n        case R.id.annadir: {\n            Intent miIntent = new Intent(\n                    this,\n                    AnadirGastoActivity.class\n            );\n            miIntent.putExtra(REQUEST_CODE, CREA_PRODUCTO);\n            startActivityForResult(miIntent, CREA_PRODUCTO);\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfQu\u00e9 m\u00e9todos relativos al ciclo de vida de las actividades <code>ListActivity</code> y <code>AnadirGastoActivity</code> se ejecutan desde que se selecciona la opci\u00f3n \u201cA\u00f1adir\u201d del men\u00fa hasta que se vuelve a mostrar la lista de gasto? Escriba s\u00f3lo el nombre del m\u00e9todo y la actividad a la que pertenece, y el orden adecuado.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Actividad <code>onPause()</code> <code>ListActivity</code> <code>onCreate()</code> <code>AnadirGastoActivity</code> <code>onStart()</code> <code>AnadirGastoActivity</code> <code>onResume()</code> <code>AnadirGastoActivity</code> <code>onStop()</code> <code>AnadirGastoActivity</code> <code>onPause()</code> <code>AnadirGastoActivity</code> <code>onRestart()</code> <code>ListActivity</code> <code>onStart()</code> <code>ListActivity</code> <code>onResume()</code> <code>ListActivity</code> <code>onStop()</code> <code>AnadirGastoActivity</code> <ul> <li>(d) (1 punto) Escriba un m\u00e9todo de la clase <code>DatabaseHelper</code> que a\u00f1ada un nuevo registro a la base de datos. La informaci\u00f3n del <code>Concepto</code> y del <code>Importe</code> se pasar\u00e1 como par\u00e1metros del m\u00e9todo.</li> </ul> Mostrar soluci\u00f3n <pre><code>public long creaProducto(String gasto, float importe) {\n    ContentValues valoresIniciales = new ContentValues();\n\n    valoresIniciales.put(\"Concepto\", gasto);\n    valoresIniciales.put(\"Importe\", importe);\n\n    return db.insert(DATABASE_TABLE, null, valoresIniciales);\n}\n</code></pre> <ul> <li>(e) (1 punto) Escriba una especificaci\u00f3n de layout adecuada que se pueda utilizar en la actividad <code>AnadirGastoActivity</code>. Adem\u00e1s de los campos de informaci\u00f3n, dispondr\u00e1 de un bot\u00f3n \u201cGuardar\u201d y otro \u201cCancelar\u201d (s\u00f3lo hay que poner los botones). </li> </ul> Mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent \"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content \"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Concepto \" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editConcepto\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"&gt;\n        &lt;/EditText&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cantidad \u201c /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editTextCantidad\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:inputType=\"numberDecimal\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout android:orientation=\"horizontal\"&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonGuardar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Guardar\" /&gt;\n\n        &lt;Button\n            android:id=\"@+id/buttonCancelar\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Cancelar\" /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>","tags":["android"]},{"location":"exams/2015/extra_ex05/","title":"Extra ex05","text":"<ul> <li> <p>(a) (2 puntos) El proyecto 2 se basa en una adaptaci\u00f3n del proyecto 1. Seleccione la respuesta o respuestas correctas en la hoja de respuestas. Las respuestas incorrectas restan.</p> <ul> <li> <p>(1) La clase <code>Terreno</code> se adapta al ciclo de vida de Android:</p> <ul> <li>(I) No ser\u00eda imprescindible realizar esta adaptaci\u00f3n; simplemente la aplicaci\u00f3n seguir\u00eda usando recursos cuando no est\u00e1 en primer plano;    </li> <li>(II) Si no hacemos la adaptaci\u00f3n, tendremos interbloqueos;</li> <li>(III) Los m\u00f3viles se congelan en <code>onPause()</code> y se descongelan en <code>onResume()</code>;</li> <li>(IV) Los m\u00f3viles se resucitan en <code>onCreate()</code>.</li> </ul> </li> <li> <p>(2) Las clases que extienden <code>Movil</code> (p.ej. <code>Jugador</code>, <code>Estatua</code>, <code>Depredador</code>, \u2026)</p> <ul> <li>(I) Deben implementar <code>restart()</code> porque es un m\u00e9todo abstracto en <code>Movil</code>;</li> <li>(II) Si adem\u00e1s implementan <code>Runnable</code>, deben crear en <code>restart()</code> una hebra (<code>new Thread()</code>) y llamar a <code>start()</code> en la hebra creada;</li> <li>(III) Si adem\u00e1 s implementan Runnable, deben crear en pause() una hebra (<code>new Thread()</code>) y llamar a <code>pause()</code> en la hebra creada;</li> <li>(IV) Siempre que extienden <code>Movil</code> deben implementar <code>Runnable</code>.</li> </ul> </li> </ul> </li> </ul> Mostrar soluci\u00f3n <ul> <li> <p>En (1) la opci\u00f3n correcta es (III);</p> </li> <li> <p>En (2) las opciones correctas son (III) y (IV).</p> </li> </ul> <ul> <li>(b) (3 puntos) Deseamos simplificar el comportamiento que hemos implementado el proyecto 2 para mover con el dedo el jugador. El nuevo comportamiento consiste en que si pulsamos en la casilla donde est\u00e1 el jugador, lanza un popup. Si pulsamos en una casilla diferente, el jugador se mueve en la direcci\u00f3n en la que est\u00e1 dicha casilla respecto del jugador.</li> </ul> <p>Adem\u00e1s, queremos poner una traza de error si se pulsa fuera del tablero.</p> <p>Suponga que dispone del m\u00e9todo popup para lanzar el popup como en la pr\u00e1ctica, as\u00ed como el resto de m\u00e9todos de las clases.</p> Mostrar soluci\u00f3n <pre><code>@Override\npublic boolean onTouch(View view, MotionEvent event) {\n    try {\n        Movil jugador = terreno.getJugador();\n        if (jugador == null) {\n            return false;\n        }\n\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            int x1 = (int) (event.getX() / lado1);\n            int y1 = terreno.getN() - 1 - (int) (event.getY() / lado1);\n\n            Casilla casilla = terreno.getCasilla(x1, y1);\n            Casilla casillaJugador = jugador.getCasilla();\n\n            if (casillaJugador.equals(casilla)) {\n                popup(casilla);\n            } else {\n                int dx = (int) (x1 - casillaJugador.getX());\n                int dy = (int) (y1 - casillaJugador.getY());\n                Direccion direccion = null;\n\n                if (dy &gt; 0)\n                    direccion = Direccion.NORTE;\n                else if (dy &lt; 0)\n                    direccion = Direccion.SUR;\n                else if (dx &gt; 0)\n                    direccion = Direccion.ESTE;\n                else if (dx &lt; 0)\n                    direccion = Direccion.OESTE;\n\n                if (direccion != null) {\n                    terreno.move(jugador, direccion);\n                }\n            }\n        }\n    } catch (Exception e) {\n        Log.e(TAG, \"Ha pulsado fuera del tablero\");\n    }\n    return false;\n}\n</code></pre>","tags":["android"]},{"location":"exams/2015/p1/","title":"Examen 2015 \u2014 Parcial 1","text":""},{"location":"exams/2015/p1/#problema-1","title":"Problema 1","text":"<p>Como medida de similitud (o diferencia) entre dos documentos dados, representados como ficheros de texto, compa\u00f1\u00edas como Google utilizan el concepto de \u201cdistancia\u201d (o su contrario, \u201cproximidad\u201d) entre dos documentos, seg\u00fan el algoritmo que se describe a continuaci\u00f3n. </p> <p>Se descomponen los dos ficheros de texto en palabras y, para cada uno de los dos ficheros, se construye un vector ordenado con tantos componentes como palabras diferentes hay entre los dos ficheros, siendo el valor de cada elemento el n\u00famero de veces que la palabra en cuesti\u00f3n se repite en el fichero de texto dado. En especial, si una determinada palabra existe en un fichero pero no en el otro, el valor correspondiente para el segundo vector,  es cero. Por ejemplo, </p> Palabra d1 d2 \u00e1rbol 5 7 barco 2 0 \u2026 \u2026 \u2026 zapatiesta 0 3 <p>La palabra \u2018\u00e1rbol\u2019 aparece 5 veces en el fichero 1 y 7 veces en el 2. La palabra \u2018barco\u2019 no aparece en el fichero 2. La palabra \u2018zapatiesta\u2019 no aparece en el fichero 1.</p> <p>A continuaci\u00f3n se realiza el producto escalar de los dos vectores que, una vez dividido por el producto del n\u00famero total de palabras que hay en cada uno de los dos textos, nos da como resultado la medida de proximidad entre los dos documentos dados. </p> <ul> <li>(a) (5 puntos) Suponiendo que los dos documentos a comparar tienen una longitud similar, digamos \\(N\\) caracteres, y que la longitud m\u00e1xima de una palabra en espa\u00f1ol es \\(K\\), se pide dar la complejidad del algoritmo descrito en t\u00e9rminos de \\(N\\), a base de justificar la complejidad de cada una de las partes de las que se compone (el algoritmo). </li> </ul> <p>NOTA: Si no puede justificar la complejidad del algoritmo de ordenaci\u00f3n, considere que es \\(O(NlogN)\\).</p> Mostrar soluci\u00f3n <p>La extracci\u00f3n de las palabras se realiza iterando dentro de un simple bucle a lo largo de cada uno de los dos textos, lo cual da una complejidad lineal, es decir, \\(O(N)\\). </p> <p>Cada vez que en el bucle anterior se encuentra una palabra, se consultan y actualizan dos HashMap, cuyas operaciones son en todo caso de orden constante, y se hacen un n\u00famero m\u00e1ximo de ellas finito (y peque\u00f1o) por cada palabra encontrada, por lo que la fase anterior no ve modificada su complejidad de \\(O(N)\\). </p> <p>A continuaci\u00f3n han de construirse los dos vectores ordenados a partir de los valores que est\u00e1n desordenados en los HashMap, lo cual nos dicen que tiene una complejidad de \\(O(N*logN)\\). </p> <p>Por \u00faltimo, el c\u00e1lculo del producto escalar es otro bucle simple, repetido tantas veces como palabras diferentes hay, de una multiplicaci\u00f3n (complejidad constante) m\u00e1s una suma (tambi\u00e9n complejidad constante), lo cual da una complejidad para el producto escalar de \\(O(N)\\). La divisi\u00f3n posterior, siendo una sola y de complejidad constante, no cambia la complejidad de esta fase.  </p> <p>Asi pues, la complejidad total ser\u00e1, sumando las de cada una de sus tres fases, </p> <p>\\(O(N) + O(N*logN) + O(N)\\), lo cual se reduce, simplemente, a \\(O(N*logN)\\).</p>"},{"location":"exams/2015/p1/#problema-2","title":"Problema 2","text":"<p>Se pretende sincronizar la fabricaci\u00f3n en una l\u00ednea de ensamblado de mesas. Hay varios fabricantes de patas, que las depositan en una l\u00ednea con un l\u00edmite de capacidad <code>MAX_NUM_PATAS</code>. Cuando se llena, los fabricantes dejan de producir patas hasta que haya hueco libre. Hay varios fabricantes de tableros, que depositan en otra l\u00ednea de capacidad limitada <code>MAX_NUM_TABLEROS</code>. Por \u00faltimo, hay varios ensambladores de mesas: cada uno coge cuatro patas y un tablero y ensambla una mesa. </p> <p>Se trata de escribir en Java un monitor que sincronice estos tres sistemas, de forma que la producci\u00f3n se detenga cuando se alcanza la capacidad m\u00e1xima de almacenamiento (de patas o tableros independientemente) y sistema de ensamblaje no avance si le faltan piezas para hacer una nueva mesa. </p> <p>NO ESCRIBA NING\u00daN C\u00d3DIGO para los subsistemas de producci\u00f3n y ensamblaje. </p> <p>El sincronizador responde al siguiente esquema: <pre><code>class Sincronizador { \n    ...  \n    ... ponPata() {...}    // lo invoca el productor de patas por cada una \n    ... ponTablero() {...} // lo invoca el productor de tableros \n    ... cogePatasyTablero () {...}   // lo invoca el ensamblador de mesas \n    ... \n} \n</code></pre></p> <ul> <li>(a) (4 puntos) Se pide: Desarrollar el c\u00f3digo completo del monitor sincronizador.</li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.em;\n\npublic class Sincronizador {\n\n   private static final int NUM_MAX_PATAS    = 10;\n   private static final int NUM_MAX_TABLEROS = 4;\n   private int numPatas = 0;\n   private int numTableros = 0;\n\n   public synchronized void ponTablero() throws InterruptedException {\n      while (numTableros &gt;= NUM_MAX_TABLEROS)\n      {\n         wait();\n      }\n\n      numTableros++;\n\n      notifyAll();\n   }\n\n   public synchronized void ponPatas() throws InterruptedException {\n      while (numPatas &gt;= NUM_MAX_PATAS)\n      {\n         wait();\n      }\n\n      numPatas++;\n\n      notifyAll();\n   }\n\n   public synchronized void cogePatasyTablero() throws InterruptedException {\n      while (numTableros &lt; 1 || numPatas &lt; 4)\n      {\n         wait();\n      }\n\n      numTableros--;\n      numPatas -= 4;\n\n      notifyAll();\n   }\n\n}\n</code></pre></p>"},{"location":"exams/2015/p1/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (1 punto) Describa dos casos posibles de error significativamente diferentes para detectar errores de la clase Paredes del alumno en el borde del tablero (concretamente en la casilla <code>(0, 0)</code>) y progr\u00e1melos con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponiendo que partimos de la casilla <code>c = (0,0)</code>, dos ejemplos de casos de error podr\u00edan ser: </p> <p>1) Poner una pared hacia el <code>OESTE</code>. La pared no se a\u00f1ade. </p> <p>2) Obtener la posible pared hacia el <code>SUR</code>. El resultado debe ser <code>null</code>. </p> <p>Y los casos de prueba correspondientes podr\u00edan ser:</p> <pre><code>private Terreno terreno \u2026 \nprivate Paredes paredes \u2026\n\n@Test\npublic void Test001() {\n   Casilla c = terreno.getCasilla(0, 0);\n   int size = paredes.size();\n   paredes.add(c, Direccion.OESTE);\n   assertEquals(paredes.size(), size); // la pared no se ha a\u00f1adido\n}\n\n@Test\npublic void Test002() {\n   Casilla c = terreno.getCasilla(0, 0);\n   assertNull(paredes.get(c, Direccion.SUR));\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba el m\u00e9todo necesario para que un fantasma empiece movi\u00e9ndose hacia el <code>NORTE</code> hasta que choca con una pared; cuando choca intenta moverse al <code>ESTE</code> hasta que choca con una pared; y as\u00ed sucesivamente, rotando 90\u00ba a la derecha cada vez que choca. Si no puede desplazarse a ninguna de las casillas circundantes, deja pasar esta vez y espera al siguiente ciclo.</li> </ul> Mostar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>public class Fantasma01 {\n...\n\npublic void run() {\n    Direccion[] direcciones =\n        {Direccion.NORTE, Direccion.ESTE, Direccion.SUR, Direccion.OESTE};\n    int direccionActual = 0;\n\n    while (vivo) {\n        if (casilla != null) {\n            for (int i = 0; i &lt; 4; i++) {\n                if (!terreno.hayPared(casilla, direcciones[direccionActual])) {\n                    terreno.move(this, direcciones[direccionActual]);\n                    break;\n                }\n                direccionActual = (direccionActual + 1) % 4;\n            }\n            try {\n                Thread.sleep(DELAY);\n            } catch (InterruptedException ignored) {}\n        }\n    }\n}\n}\n</code></pre></p>"},{"location":"exams/2015/p1_ex01/","title":"P1 ex01","text":"<p>Como medida de similitud (o diferencia) entre dos documentos dados, representados como ficheros de texto, compa\u00f1\u00edas como Google utilizan el concepto de \u201cdistancia\u201d (o su contrario, \u201cproximidad\u201d) entre dos documentos, seg\u00fan el algoritmo que se describe a continuaci\u00f3n. </p> <p>Se descomponen los dos ficheros de texto en palabras y, para cada uno de los dos ficheros, se construye un vector ordenado con tantos componentes como palabras diferentes hay entre los dos ficheros, siendo el valor de cada elemento el n\u00famero de veces que la palabra en cuesti\u00f3n se repite en el fichero de texto dado. En especial, si una determinada palabra existe en un fichero pero no en el otro, el valor correspondiente para el segundo vector,  es cero. Por ejemplo, </p> Palabra d1 d2 \u00e1rbol 5 7 barco 2 0 \u2026 \u2026 \u2026 zapatiesta 0 3 <p>La palabra \u2018\u00e1rbol\u2019 aparece 5 veces en el fichero 1 y 7 veces en el 2. La palabra \u2018barco\u2019 no aparece en el fichero 2. La palabra \u2018zapatiesta\u2019 no aparece en el fichero 1.</p> <p>A continuaci\u00f3n se realiza el producto escalar de los dos vectores que, una vez dividido por el producto del n\u00famero total de palabras que hay en cada uno de los dos textos, nos da como resultado la medida de proximidad entre los dos documentos dados. </p> <ul> <li>(a) (5 puntos) Suponiendo que los dos documentos a comparar tienen una longitud similar, digamos \\(N\\) caracteres, y que la longitud m\u00e1xima de una palabra en espa\u00f1ol es \\(K\\), se pide dar la complejidad del algoritmo descrito en t\u00e9rminos de \\(N\\), a base de justificar la complejidad de cada una de las partes de las que se compone (el algoritmo). </li> </ul> <p>NOTA: Si no puede justificar la complejidad del algoritmo de ordenaci\u00f3n, considere que es \\(O(NlogN)\\).</p> Mostrar soluci\u00f3n <p>La extracci\u00f3n de las palabras se realiza iterando dentro de un simple bucle a lo largo de cada uno de los dos textos, lo cual da una complejidad lineal, es decir, \\(O(N)\\). </p> <p>Cada vez que en el bucle anterior se encuentra una palabra, se consultan y actualizan dos HashMap, cuyas operaciones son en todo caso de orden constante, y se hacen un n\u00famero m\u00e1ximo de ellas finito (y peque\u00f1o) por cada palabra encontrada, por lo que la fase anterior no ve modificada su complejidad de \\(O(N)\\). </p> <p>A continuaci\u00f3n han de construirse los dos vectores ordenados a partir de los valores que est\u00e1n desordenados en los HashMap, lo cual nos dicen que tiene una complejidad de \\(O(N*logN)\\). </p> <p>Por \u00faltimo, el c\u00e1lculo del producto escalar es otro bucle simple, repetido tantas veces como palabras diferentes hay, de una multiplicaci\u00f3n (complejidad constante) m\u00e1s una suma (tambi\u00e9n complejidad constante), lo cual da una complejidad para el producto escalar de \\(O(N)\\). La divisi\u00f3n posterior, siendo una sola y de complejidad constante, no cambia la complejidad de esta fase.  </p> <p>Asi pues, la complejidad total ser\u00e1, sumando las de cada una de sus tres fases, </p> <p>\\(O(N) + O(N*logN) + O(N)\\), lo cual se reduce, simplemente, a \\(O(N*logN)\\).</p>","tags":["complejidad"]},{"location":"exams/2015/p1_ex02/","title":"P1 ex02","text":"<p>Se pretende sincronizar la fabricaci\u00f3n en una l\u00ednea de ensamblado de mesas. Hay varios fabricantes de patas, que las depositan en una l\u00ednea con un l\u00edmite de capacidad <code>MAX_NUM_PATAS</code>. Cuando se llena, los fabricantes dejan de producir patas hasta que haya hueco libre. Hay varios fabricantes de tableros, que depositan en otra l\u00ednea de capacidad limitada <code>MAX_NUM_TABLEROS</code>. Por \u00faltimo, hay varios ensambladores de mesas: cada uno coge cuatro patas y un tablero y ensambla una mesa. </p> <p>Se trata de escribir en Java un monitor que sincronice estos tres sistemas, de forma que la producci\u00f3n se detenga cuando se alcanza la capacidad m\u00e1xima de almacenamiento (de patas o tableros independientemente) y sistema de ensamblaje no avance si le faltan piezas para hacer una nueva mesa. </p> <p>NO ESCRIBA NING\u00daN C\u00d3DIGO para los subsistemas de producci\u00f3n y ensamblaje. </p> <p>El sincronizador responde al siguiente esquema: <pre><code>class Sincronizador { \n    ...  \n    ... ponPata() {...}    // lo invoca el productor de patas por cada una \n    ... ponTablero() {...} // lo invoca el productor de tableros \n    ... cogePatasyTablero () {...}   // lo invoca el ensamblador de mesas \n    ... \n} \n</code></pre></p> <ul> <li>(a) (4 puntos) Se pide: Desarrollar el c\u00f3digo completo del monitor sincronizador.</li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.em;\n\npublic class Sincronizador {\n\n   private static final int NUM_MAX_PATAS    = 10;\n   private static final int NUM_MAX_TABLEROS = 4;\n   private int numPatas = 0;\n   private int numTableros = 0;\n\n   public synchronized void ponTablero() throws InterruptedException {\n      while (numTableros &gt;= NUM_MAX_TABLEROS)\n      {\n         wait();\n      }\n\n      numTableros++;\n\n      notifyAll();\n   }\n\n   public synchronized void ponPatas() throws InterruptedException {\n      while (numPatas &gt;= NUM_MAX_PATAS)\n      {\n         wait();\n      }\n\n      numPatas++;\n\n      notifyAll();\n   }\n\n   public synchronized void cogePatasyTablero() throws InterruptedException {\n      while (numTableros &lt; 1 || numPatas &lt; 4)\n      {\n         wait();\n      }\n\n      numTableros--;\n      numPatas -= 4;\n\n      notifyAll();\n   }\n\n}\n</code></pre></p>","tags":["monitores"]},{"location":"exams/2015/p1_ex03/","title":"P1 ex03","text":"<ul> <li>(a) (1 punto) Describa dos casos posibles de error significativamente diferentes para detectar errores de la clase Paredes del alumno en el borde del tablero (concretamente en la casilla <code>(0, 0)</code>) y progr\u00e1melos con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponiendo que partimos de la casilla <code>c = (0,0)</code>, dos ejemplos de casos de error podr\u00edan ser: </p> <p>1) Poner una pared hacia el <code>OESTE</code>. La pared no se a\u00f1ade. </p> <p>2) Obtener la posible pared hacia el <code>SUR</code>. El resultado debe ser <code>null</code>. </p> <p>Y los casos de prueba correspondientes podr\u00edan ser:</p> <pre><code>private Terreno terreno \u2026 \nprivate Paredes paredes \u2026\n\n@Test\npublic void Test001() {\n   Casilla c = terreno.getCasilla(0, 0);\n   int size = paredes.size();\n   paredes.add(c, Direccion.OESTE);\n   assertEquals(paredes.size(), size); // la pared no se ha a\u00f1adido\n}\n\n@Test\npublic void Test002() {\n   Casilla c = terreno.getCasilla(0, 0);\n   assertNull(paredes.get(c, Direccion.SUR));\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba el m\u00e9todo necesario para que un fantasma empiece movi\u00e9ndose hacia el <code>NORTE</code> hasta que choca con una pared; cuando choca intenta moverse al <code>ESTE</code> hasta que choca con una pared; y as\u00ed sucesivamente, rotando 90\u00ba a la derecha cada vez que choca. Si no puede desplazarse a ninguna de las casillas circundantes, deja pasar esta vez y espera al siguiente ciclo.</li> </ul> Mostar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>public class Fantasma01 {\n...\n\npublic void run() {\n    Direccion[] direcciones =\n        {Direccion.NORTE, Direccion.ESTE, Direccion.SUR, Direccion.OESTE};\n    int direccionActual = 0;\n\n    while (vivo) {\n        if (casilla != null) {\n            for (int i = 0; i &lt; 4; i++) {\n                if (!terreno.hayPared(casilla, direcciones[direccionActual])) {\n                    terreno.move(this, direcciones[direccionActual]);\n                    break;\n                }\n                direccionActual = (direccionActual + 1) % 4;\n            }\n            try {\n                Thread.sleep(DELAY);\n            } catch (InterruptedException ignored) {}\n        }\n    }\n}\n}\n</code></pre></p>","tags":["???"]},{"location":"exams/2015/p1r/","title":"Examen 2015 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2015/p1r/#problema-1","title":"Problema 1","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n (puede haber m\u00e1s de una) es:</p> <p>[0, 2, 6, 9, 11, 15]</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre></p> <pre><code>int[] getLIS(int[] x) {\n    int n = x.length;\n    int[] len = new int[n];\n    Arrays.fill(len, 1);\n    int[] pred = new int[n];\n    Arrays.fill(pred, -1);\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 0; j &lt; i; j++) {\n            if (x[j] &lt; x[i] &amp;&amp; len[i] &lt; len[j] + 1) {\n                len[i] = len[j] + 1;\n                pred[i] = j;\n            }\n        }\n    }\n    int bi = 0;\n    for (int i = 1; i &lt; n; i++) {\n        if (len[bi] &lt; len[i])\n            bi = i;\n    }\n    int cnt = len[bi];\n    int[] res = new int[cnt];\n    for (int i = bi; i != -1; i = pred[i])\n        res[--cnt] = x[i];\n    return res;\n}\n</code></pre> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n del tama\u00f1o \\(N\\) de la secuencia de entrada, razonando la soluci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>La iniciaci\u00f3n de los arrays <code>len</code> y <code>pred</code> es de complejidad lineal, pues se visitan todos sus elementos una sola vez, y su longitud es \\(n\\).</p> <p>A continuaci\u00f3n hay un bucle doble anidado, cuyo cuerpo, de complejidad constante, se ejecuta \\(1 + 2 + 3 + ... + n-1\\) veces, es decir, un total de \\(n/2*(n-1)\\) veces. Por lo que su complejidad es cuadr\u00e1tica.</p> <p>Al final hay dos bucles simples con cuerpo de complejidad constante y n\u00famero de vueltas de orden n, que tienen pues complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser cuadr\u00e1tica. En t\u00e9rminos formales:</p> <p>\\(C(for.for) = O(1+2+3+...+(n-1)) = O(n/2 * (n-1)) = O(n^2 / 2) - O(n/2) = O(n^2)\\)</p> <p>\\(C(LIS) = C(arrays.fill) + C(Arrays.fill) + C(for.for) + C(for) + C(for)\\)</p> <p>\\(= O(n) + O(n) + C(for.for) + O(n) + O(n/k)\\)</p> <p>\\(= O(n) + O(n) + O(n^2) + O(n) + O(n)\\)</p> <p>\\(= O(n^2)\\).</p>"},{"location":"exams/2015/p1r/#problema-2","title":"Problema 2","text":"<p>Se tiene un sistema con dos hebras (H1 y H2) que acceden continuamente a un recurso compartido, que se debe usar con exclusi\u00f3n mutua. Para que el sistema funcione correctamente las hebras tienen que acceder seg\u00fan el siguiente patr\u00f3n, que se  debe repetir c\u00edclicamente: H1, H1, H2, H1, H2, como se ve en la figura siguiente:</p> <p></p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor <code>(GestorCiclosAcceso)</code> para sincronizar las hebras seg\u00fan el comportamiento descrito. El monitor debe proporcionar las siguientes operaciones:<ul> <li><code>... void accederH1()</code>: Este m\u00e9todo lo invoca la hebra H1 para solicitar acceso al recurso compartido.</li> <li><code>... void accederH2()</code>: Este m\u00e9todo lo invoca la hebra H2 para solicitar acceso al recurso compartido.</li> <li><code>... void liberar()</code>: Este m\u00e9todo lo invocan las hebras para liberar el recurso compartido.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\npublic class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre> <p>Otra posible implementaci\u00f3n, que utiliza m\u00e1quinas de estados, es la siguiente:</p> <pre><code>public class GestorCiclosAcceso2 {\n    // estado 0 - espera H1\n    // estado 1 - espera H1\n    // estado 2 - espera H2\n    // estado 3 - espera H1\n    // estado 4 - espera H2\n    private int state = 0;\n    private boolean busy = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (busy || !espera(1))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (busy || !espera(2))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        busy = false;\n        notifyAll();\n    }\n\n    private boolean espera(int i) {\n        switch (state) {\n            case 0:\n            case 1:\n            case 3:\n                return i == 1;\n            case 2:\n            case 4:\n                return i == 2;\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"exams/2015/p1r/#problema-3","title":"Problema 3","text":"<p>Dado el siguiente terreno de prueba y la situaci\u00f3n del jugador y el depredador que se muestra:</p> <p></p> <ul> <li>(a) (1 punto) Describa un caso posible de error para detectar errores del m\u00e9todo <code>primerPaso</code> de la clase <code>Depredador</code> del alumno y progr\u00e1melo con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponemos que la variable terreno se refiere al terreno creado con la configuraci\u00f3n de la figura, y que la variable depredador se refiere al depredador situado en el terreno anterior.</p> <p>El primer paso de la ruta m\u00e1s corta desde la casilla donde est\u00e1 el depredador <code>(1,1)</code> y la del jugador <code>(3,2)</code> es la casilla <code>(1,0)</code>. Para comprobar que el funcionamiento del m\u00e9todo <code>primerPaso()</code> es correcto, pues, basta con probar la siguiente aserci\u00f3n</p> <p><code>assertEquals(terreno.getCasilla(1,0)</code>,</p> <p><code>depredador.primerPaso(terreno.getCasilla(1,1),terreno.getCasilla(3,2)))</code></p> <ul> <li>(b) (1 punto) Escriba un caso de prueba para comprobar si el n\u00famero de paredes en el terreno es igual a 10 (los bordes no cuentan), utilizando m\u00e9todos p\u00fablicos de las clases del proyecto.</li> </ul> Mostar soluci\u00f3n <p>Para comprobar el n\u00famero de paredes basta hacer <pre><code>    assertEquals(10, terreno.getparedes().size()\n</code></pre></p>"},{"location":"exams/2015/p1r_ex01/","title":"P1r ex01","text":"<p>Para un programa de an\u00e1lisis del genoma humano, necesitamos encontrar una subsecuencia de elementos en orden creciente. Esto corresponde a un problema de programaci\u00f3n conocido como LIS (Longest Increasing Subsequence) donde, por ejemplo, dada la secuencia:</p> <p>{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}</p> <p>una soluci\u00f3n (puede haber m\u00e1s de una) es:</p> <p>[0, 2, 6, 9, 11, 15]</p> <p>Buscando por Internet encontramos esta soluci\u00f3n que hemos probado y pasa las pruebas: <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre></p> <pre><code>int[] getLIS(int[] x) {\n    int n = x.length;\n    int[] len = new int[n];\n    Arrays.fill(len, 1);\n    int[] pred = new int[n];\n    Arrays.fill(pred, -1);\n    for (int i = 1; i &lt; n; i++) {\n        for (int j = 0; j &lt; i; j++) {\n            if (x[j] &lt; x[i] &amp;&amp; len[i] &lt; len[j] + 1) {\n                len[i] = len[j] + 1;\n                pred[i] = j;\n            }\n        }\n    }\n    int bi = 0;\n    for (int i = 1; i &lt; n; i++) {\n        if (len[bi] &lt; len[i])\n            bi = i;\n    }\n    int cnt = len[bi];\n    int[] res = new int[cnt];\n    for (int i = bi; i != -1; i = pred[i])\n        res[--cnt] = x[i];\n    return res;\n}\n</code></pre> <ul> <li>(a) (4 puntos) Se pide calcular su complejidad en funci\u00f3n del tama\u00f1o \\(N\\) de la secuencia de entrada, razonando la soluci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>La iniciaci\u00f3n de los arrays <code>len</code> y <code>pred</code> es de complejidad lineal, pues se visitan todos sus elementos una sola vez, y su longitud es \\(n\\).</p> <p>A continuaci\u00f3n hay un bucle doble anidado, cuyo cuerpo, de complejidad constante, se ejecuta \\(1 + 2 + 3 + ... + n-1\\) veces, es decir, un total de \\(n/2*(n-1)\\) veces. Por lo que su complejidad es cuadr\u00e1tica.</p> <p>Al final hay dos bucles simples con cuerpo de complejidad constante y n\u00famero de vueltas de orden n, que tienen pues complejidad lineal.</p> <p>Sumando todas las complejidades individuales seg\u00fan su regla (el resultado es el t\u00e9rmino de mayor complejidad), la complejidad del algoritmo descrito resulta ser cuadr\u00e1tica. En t\u00e9rminos formales:</p> <p>\\(C(for.for) = O(1+2+3+...+(n-1)) = O(n/2 * (n-1)) = O(n^2 / 2) - O(n/2) = O(n^2)\\)</p> <p>\\(C(LIS) = C(arrays.fill) + C(Arrays.fill) + C(for.for) + C(for) + C(for)\\)</p> <p>\\(= O(n) + O(n) + C(for.for) + O(n) + O(n/k)\\)</p> <p>\\(= O(n) + O(n) + O(n^2) + O(n) + O(n)\\)</p> <p>\\(= O(n^2)\\).</p>","tags":["complejidad"]},{"location":"exams/2015/p1r_ex02/","title":"P1r ex02","text":"<p>Se tiene un sistema con dos hebras (H1 y H2) que acceden continuamente a un recurso compartido, que se debe usar con exclusi\u00f3n mutua. Para que el sistema funcione correctamente las hebras tienen que acceder seg\u00fan el siguiente patr\u00f3n, que se  debe repetir c\u00edclicamente: H1, H1, H2, H1, H2, como se ve en la figura siguiente:</p> <p></p> <ul> <li>(a) (4 puntos) Se pide desarrollar el monitor <code>(GestorCiclosAcceso)</code> para sincronizar las hebras seg\u00fan el comportamiento descrito. El monitor debe proporcionar las siguientes operaciones:<ul> <li><code>... void accederH1()</code>: Este m\u00e9todo lo invoca la hebra H1 para solicitar acceso al recurso compartido.</li> <li><code>... void accederH2()</code>: Este m\u00e9todo lo invoca la hebra H2 para solicitar acceso al recurso compartido.</li> <li><code>... void liberar()</code>: Este m\u00e9todo lo invocan las hebras para liberar el recurso compartido.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\npublic class GestorCiclosAcceso {\n    private boolean turnoH1 = true;\n    private int nAccesoH1 = 0;\n    private int nAccesoCicloH1 = 3;\n    private boolean recursoOcupado = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (!turnoH1 || recursoOcupado)\n            wait();\n        if (nAccesoH1 == 0)\n            turnoH1 = true;\n        else\n            turnoH1 = false;\n        nAccesoH1++;\n        if (nAccesoH1 == nAccesoCicloH1)\n            nAccesoH1 = 0;\n        recursoOcupado = true;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (turnoH1 || recursoOcupado)\n            wait();\n        turnoH1 = true;\n        recursoOcupado = true;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        recursoOcupado = false;\n        notifyAll();\n    }\n}\n</code></pre> <p>Otra posible implementaci\u00f3n, que utiliza m\u00e1quinas de estados, es la siguiente:</p> <pre><code>public class GestorCiclosAcceso2 {\n    // estado 0 - espera H1\n    // estado 1 - espera H1\n    // estado 2 - espera H2\n    // estado 3 - espera H1\n    // estado 4 - espera H2\n    private int state = 0;\n    private boolean busy = false;\n\n    public synchronized void accederH1()\n            throws InterruptedException {\n        while (busy || !espera(1))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void accederH2()\n            throws InterruptedException {\n        while (busy || !espera(2))\n            wait();\n        busy = true;\n        state = (state + 1) % 5;\n    }\n\n    public synchronized void liberar()\n            throws InterruptedException {\n        busy = false;\n        notifyAll();\n    }\n\n    private boolean espera(int i) {\n        switch (state) {\n            case 0:\n            case 1:\n            case 3:\n                return i == 1;\n            case 2:\n            case 4:\n                return i == 2;\n        }\n        return false;\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2015/p1r_ex03/","title":"P1r ex03","text":"<p>Dado el siguiente terreno de prueba y la situaci\u00f3n del jugador y el depredador que se muestra:</p> <p></p> <ul> <li>(a) (1 punto) Describa un caso posible de error para detectar errores del m\u00e9todo <code>primerPaso</code> de la clase <code>Depredador</code> del alumno y progr\u00e1melo con JUnit.</li> </ul> Mostar soluci\u00f3n <p>Suponemos que la variable terreno se refiere al terreno creado con la configuraci\u00f3n de la figura, y que la variable depredador se refiere al depredador situado en el terreno anterior.</p> <p>El primer paso de la ruta m\u00e1s corta desde la casilla donde est\u00e1 el depredador <code>(1,1)</code> y la del jugador <code>(3,2)</code> es la casilla <code>(1,0)</code>. Para comprobar que el funcionamiento del m\u00e9todo <code>primerPaso()</code> es correcto, pues, basta con probar la siguiente aserci\u00f3n</p> <p><code>assertEquals(terreno.getCasilla(1,0)</code>,</p> <p><code>depredador.primerPaso(terreno.getCasilla(1,1),terreno.getCasilla(3,2)))</code></p> <ul> <li>(b) (1 punto) Escriba un caso de prueba para comprobar si el n\u00famero de paredes en el terreno es igual a 10 (los bordes no cuentan), utilizando m\u00e9todos p\u00fablicos de las clases del proyecto.</li> </ul> Mostar soluci\u00f3n <p>Para comprobar el n\u00famero de paredes basta hacer <pre><code>    assertEquals(10, terreno.getparedes().size()\n</code></pre></p>","tags":["???"]},{"location":"exams/2015/p2/","title":"Examen 2015 \u2014 Parcial 2","text":""},{"location":"exams/2015/p2/#problema-1","title":"Problema 1","text":"<p>Se pretende desarrollar una aplicaci\u00f3n para Android de gesti\u00f3n de una colecci\u00f3n de libros. La informaci\u00f3n de los libros se almacena en una Base de Datos sqlite. Una <code>ListActivity</code> muestra informaci\u00f3n de los libros almacenados.</p> <p>De los libros se almacena la siguiente informaci\u00f3n: Autor, T\u00edtulo, A\u00f1o de publicaci\u00f3n. Los dos primeros campos ser\u00e1n textuales, el \u00faltimo ser\u00e1 un n\u00famero. La Bases de Datos constar\u00e1 de una \u00fanica tabla que contenga esta informaci\u00f3n.</p> <ul> <li>(a) (1 punto) Escriba la sentencia SQL correcta para la creaci\u00f3n de la Base de Datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>CREATE TABLE libros (_id INTEGER PRIMARY KEY AUTOINCREMENT, Autor TEXT NOT NULL, Titulo TEXT NOT NULL, A\u00f1o INTEGER NOT NULL)\n</code></pre> <p>Se decide programar un adaptador para manejar la base de datos. Parte de dicho adaptador es la siguiente:</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n\n    private class MySQLiteHelper extends SQLiteOpenHelper\n    {\n        @Override\n        public void onCreate(SQLiteDatabase db) { \u2026 }\n        \u2026\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un m\u00e9todo de la clase <code>DatabaseHelper</code> que devuelva un Cursor con la informaci\u00f3n de todos los libros. La cabecera del m\u00e9todo ser\u00e1: <code>public Cursor selectAll() { \u2026 }</code>. Si necesita atributos adicionales, decl\u00e1relos correctamente. No duplique las declaraciones de la pregunta anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public Cursor recuperaTodosLosLibros() {\n    return db.query(\"libros\", new String[] {\n        COL_ID, COL_AUTOR, COL_TITULO, COL_ANYO\n    }, null, null, null, null, null);\n}\n</code></pre> <p>Se pretende disponer de una actividad <code>ListaLibrosActivity</code>, que herede de <code>ListActivity</code>, seg\u00fan el siguiente esquema:</p> <pre><code>public class ListaLibrosActivity extends ListActivity {\n    private DatabaseHelper dbHelper;\n    private SimpleCursorAdapter cursorAdapter;\n    \u2026\n}\n</code></pre> <ul> <li>(c) (2 puntos) Se pretende que dicha actividad reaccione de forma que cuando el usuario pulse sobre un registro mostrado en el ListView, se lance otra actividad, llamada <code>EditarLibroActivity</code>, que ya est\u00e1 ya implementada. A la actividad <code>EditarLibroActivity</code> se le ha de pasar toda la informaci\u00f3n del libro seleccionado. Escriba el c\u00f3digo necesario para implementar este comportamiento. </li> </ul> Mostrar soluci\u00f3n <pre><code>public void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = productosCursor;\n    c.moveToPosition(position);\n    Intent intent = new Intent(this, EditarLibroActivity.class);\n    intent.putExtra(ProductoDbAdaptador.COL_ID, id);\n    intent.putExtra(Producto.AUTOR, c.getString(indiceAutor));\n    intent.putExtra(Producto.TITULO, c.getInt(indiceTitulo));\n    intent.putExtra(Producto.ANYO, c.getInt(indiceAnyo));\n    intent.putExtra(REQUEST_CODE, MODIFICA_PRODUCTO);\n    startActivityForResult(intent, MODIFICA_PRODUCTO);\n}\n</code></pre> <ul> <li>(d) (1 punto) Se desea guardar la base de datos de forma autom\u00e1tica, cuando la aplicaci\u00f3n sea interrumpida por otra <code>ACTIVIDAD</code> (por ejemplo, una llamada de tel\u00e9fono o pulsar el bot\u00f3n de aplicaciones). Cuando se vuelva a la aplicaci\u00f3n, se debe cargar la base de datos. \u00bfQu\u00e9 m\u00e9todos han de sobrecargarse relativos al ciclo de vida de la actividad principal? Ponga S\u00d3LO el nombre de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>a) onStart() \u2013 onStop() </p> <p>b) onResume() \u2013 onPause()</p>"},{"location":"exams/2015/p2/#problema-2","title":"Problema 2","text":"<p>En el Juego del Pacman para Android tenemos un tablero de 8x8:</p> <p></p> <ul> <li>(a) (1 punto) Indique las coordinadas <code>(x,y)</code> que debe pasar a <code>juego.pon(terreno.getCasilla(x.y), 0)</code> para poner un Patito (con identificador <code>0</code>) en la casilla con un c\u00edrculo azul (objetivo) situada en el extremo superior derecho.</li> </ul> Mostrar soluci\u00f3n <p><code>X = 7, Y = 7</code></p> <ul> <li>(b) (1 punto) Suponga que tenemos un gestor de eventos t\u00e1ctiles <code>onTouch(View v, MotionEvent event)</code>. Si pulsamos en el objetivo (c\u00edrculo azul situado en el extremo superior derecho), \u00bfqu\u00e9 valores nos dar\u00e1n <code>x</code> e <code>y</code> si se calculan como sigue? </li> </ul> <pre><code>int x = (int) event.getX() / lado1; int y = (int) event.getY() / lado1\n</code></pre> Mostrar soluci\u00f3n <p><code>X = 7, Y = 0</code></p> <p>Deseamos cambiar el comportamiento del gestor de eventos t\u00e1ctiles, de forma que el jugador ya no se mueva con el dedo. Queremos que al poner el dedo en una posici\u00f3n, aparezca un Patito si la casilla est\u00e1 vac\u00eda. El id de Patito registrado en Juego es 0. Adem\u00e1s, queremos que muestre:</p> <ol> <li> Una traza informativa (<code>info</code>) al pulsar en la pantalla. Ej. \u201cPulso en (3, 4)\u201d; </li> <li> Una traza de depuraci\u00f3n (<code>debug</code>) cuando pone el patito. Ej. \u201cPatito puesto en (3, 4)\u201d; </li> <li> Una traza de depuraci\u00f3n si no coincide la posici\u00f3n al poner y quitar el dedo, porque ha realizado alg\u00fan movimiento. Ej. \u201cNo coinciden poner y quitar dedo\u201d; </li> <li> Una traza de advertencia (<code>warn</code>) si ya hay alg\u00fan m\u00f3vil en esa posici\u00f3n. \u201cPatito no puesto ya hay otro m\u00f3vil\u201d. </li> </ol> <ul> <li>(c) (3 puntos) Complete el c\u00f3digo del m\u00e9todo <code>onTouch()</code> que se da en la hoja de respuestas.</li> </ul> Mostrar soluci\u00f3n <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"exams/2015/p2_ex01/","title":"P2 ex01","text":"<p>Se pretende desarrollar una aplicaci\u00f3n para Android de gesti\u00f3n de una colecci\u00f3n de libros. La informaci\u00f3n de los libros se almacena en una Base de Datos sqlite. Una <code>ListActivity</code> muestra informaci\u00f3n de los libros almacenados.</p> <p>De los libros se almacena la siguiente informaci\u00f3n: Autor, T\u00edtulo, A\u00f1o de publicaci\u00f3n. Los dos primeros campos ser\u00e1n textuales, el \u00faltimo ser\u00e1 un n\u00famero. La Bases de Datos constar\u00e1 de una \u00fanica tabla que contenga esta informaci\u00f3n.</p> <ul> <li>(a) (1 punto) Escriba la sentencia SQL correcta para la creaci\u00f3n de la Base de Datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>CREATE TABLE libros (_id INTEGER PRIMARY KEY AUTOINCREMENT, Autor TEXT NOT NULL, Titulo TEXT NOT NULL, A\u00f1o INTEGER NOT NULL)\n</code></pre> <p>Se decide programar un adaptador para manejar la base de datos. Parte de dicho adaptador es la siguiente:</p> <pre><code>public class DatabaseHelper {\n    private SQLiteDatabase database;\n    private MySQLiteHelper dbHelper;\n    private static final int DATABASE_VERSION = 1;\n    private static final String DATABASE_NAME = \"libros.db\";\n    \u2026\n\n    private class MySQLiteHelper extends SQLiteOpenHelper\n    {\n        @Override\n        public void onCreate(SQLiteDatabase db) { \u2026 }\n        \u2026\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un m\u00e9todo de la clase <code>DatabaseHelper</code> que devuelva un Cursor con la informaci\u00f3n de todos los libros. La cabecera del m\u00e9todo ser\u00e1: <code>public Cursor selectAll() { \u2026 }</code>. Si necesita atributos adicionales, decl\u00e1relos correctamente. No duplique las declaraciones de la pregunta anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public Cursor recuperaTodosLosLibros() {\n    return db.query(\"libros\", new String[] {\n        COL_ID, COL_AUTOR, COL_TITULO, COL_ANYO\n    }, null, null, null, null, null);\n}\n</code></pre> <p>Se pretende disponer de una actividad <code>ListaLibrosActivity</code>, que herede de <code>ListActivity</code>, seg\u00fan el siguiente esquema:</p> <pre><code>public class ListaLibrosActivity extends ListActivity {\n    private DatabaseHelper dbHelper;\n    private SimpleCursorAdapter cursorAdapter;\n    \u2026\n}\n</code></pre> <ul> <li>(c) (2 puntos) Se pretende que dicha actividad reaccione de forma que cuando el usuario pulse sobre un registro mostrado en el ListView, se lance otra actividad, llamada <code>EditarLibroActivity</code>, que ya est\u00e1 ya implementada. A la actividad <code>EditarLibroActivity</code> se le ha de pasar toda la informaci\u00f3n del libro seleccionado. Escriba el c\u00f3digo necesario para implementar este comportamiento. </li> </ul> Mostrar soluci\u00f3n <pre><code>public void onListItemClick(ListView l, View v, int position, long id) {\n    super.onListItemClick(l, v, position, id);\n    Cursor c = productosCursor;\n    c.moveToPosition(position);\n    Intent intent = new Intent(this, EditarLibroActivity.class);\n    intent.putExtra(ProductoDbAdaptador.COL_ID, id);\n    intent.putExtra(Producto.AUTOR, c.getString(indiceAutor));\n    intent.putExtra(Producto.TITULO, c.getInt(indiceTitulo));\n    intent.putExtra(Producto.ANYO, c.getInt(indiceAnyo));\n    intent.putExtra(REQUEST_CODE, MODIFICA_PRODUCTO);\n    startActivityForResult(intent, MODIFICA_PRODUCTO);\n}\n</code></pre> <ul> <li>(d) (1 punto) Se desea guardar la base de datos de forma autom\u00e1tica, cuando la aplicaci\u00f3n sea interrumpida por otra <code>ACTIVIDAD</code> (por ejemplo, una llamada de tel\u00e9fono o pulsar el bot\u00f3n de aplicaciones). Cuando se vuelva a la aplicaci\u00f3n, se debe cargar la base de datos. \u00bfQu\u00e9 m\u00e9todos han de sobrecargarse relativos al ciclo de vida de la actividad principal? Ponga S\u00d3LO el nombre de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>a) onStart() \u2013 onStop() </p> <p>b) onResume() \u2013 onPause()</p>","tags":["android"]},{"location":"exams/2015/p2_ex02/","title":"P2 ex02","text":"<p>En el Juego del Pacman para Android tenemos un tablero de 8x8:</p> <p></p> <ul> <li>(a) (1 punto) Indique las coordinadas <code>(x,y)</code> que debe pasar a <code>juego.pon(terreno.getCasilla(x.y), 0)</code> para poner un Patito (con identificador <code>0</code>) en la casilla con un c\u00edrculo azul (objetivo) situada en el extremo superior derecho.</li> </ul> Mostrar soluci\u00f3n <p><code>X = 7, Y = 7</code></p> <ul> <li>(b) (1 punto) Suponga que tenemos un gestor de eventos t\u00e1ctiles <code>onTouch(View v, MotionEvent event)</code>. Si pulsamos en el objetivo (c\u00edrculo azul situado en el extremo superior derecho), \u00bfqu\u00e9 valores nos dar\u00e1n <code>x</code> e <code>y</code> si se calculan como sigue? </li> </ul> <pre><code>int x = (int) event.getX() / lado1; int y = (int) event.getY() / lado1\n</code></pre> Mostrar soluci\u00f3n <p><code>X = 7, Y = 0</code></p> <p>Deseamos cambiar el comportamiento del gestor de eventos t\u00e1ctiles, de forma que el jugador ya no se mueva con el dedo. Queremos que al poner el dedo en una posici\u00f3n, aparezca un Patito si la casilla est\u00e1 vac\u00eda. El id de Patito registrado en Juego es 0. Adem\u00e1s, queremos que muestre:</p> <ol> <li> Una traza informativa (<code>info</code>) al pulsar en la pantalla. Ej. \u201cPulso en (3, 4)\u201d; </li> <li> Una traza de depuraci\u00f3n (<code>debug</code>) cuando pone el patito. Ej. \u201cPatito puesto en (3, 4)\u201d; </li> <li> Una traza de depuraci\u00f3n si no coincide la posici\u00f3n al poner y quitar el dedo, porque ha realizado alg\u00fan movimiento. Ej. \u201cNo coinciden poner y quitar dedo\u201d; </li> <li> Una traza de advertencia (<code>warn</code>) si ya hay alg\u00fan m\u00f3vil en esa posici\u00f3n. \u201cPatito no puesto ya hay otro m\u00f3vil\u201d. </li> </ol> <ul> <li>(c) (3 puntos) Complete el c\u00f3digo del m\u00e9todo <code>onTouch()</code> que se da en la hoja de respuestas.</li> </ul> Mostrar soluci\u00f3n <pre><code>private class MyTouchListener implements OnTouchListener {\n    private float x1;\n    private float y1;\n\n    public boolean onTouch(View view, MotionEvent event) {\n        Movil jugador = terreno.getJugador();\n        Juego juego = Juego.getInstance();\n        if (jugador == null) {\n            return false;\n        }\n        int action = event.getAction();\n        switch (action) {\n            case MotionEvent.ACTION_DOWN: {\n                x1 = (int) (event.getX() / lado1);\n                y1 = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                Log.i(TAG, \u201cPulso en (\u201c + x1 + \u201c \u201c + y1 + \u201c)\u201d);\n                return true;\n            }\n            case MotionEvent.ACTION_UP: {\n                int x = (int) (event.getX() / lado1);\n                int y = terreno.getN() - 1 \u2013 (int) event.getY() / lado1);\n                if ((x != x1) || (y != y1)) {\n                    Log.d(TAG, \u201cNo coinciden poner y quitar dedo\u201d);\n                    break;\n                }\n                if (x &lt; terreno.getN() &amp;&amp; y &lt; terreno.getN()) {\n                    if (terreno.getCasilla(x, y).getMovil() != null) {\n                        Log.w(TAG, \u201cPatito no puesto, ya hay otro m\u00f3vil\u201d);\n                        break;\n                    }\n                    juego.pon(terreno.getCasilla(x, y), 0);\n                    Log.d(TAG, \"Patito puesto en (\" + x + \" \" + y + \")\");\n                }\n                break;\n            }\n            default:\n        }\n        return false;\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2016/extra/","title":"Examen 2016 \u2014 Extraordinario","text":""},{"location":"exams/2016/extra/#problema-1","title":"Problema 1","text":"<p>Queremos programar una clase <code>Conjunto</code> usando internamente una tabla hash con lista de desbordamiento. Se pide programar los siguientes m\u00e9todos:</p> <pre><code>void add(Object x)\n</code></pre> <pre><code>boolean contains(Object x)\n</code></pre> <pre><code>void remove(Object x)\n</code></pre> <p>Razone la complejidad de dichos m\u00e9todos.</p> <p>No se aceptar\u00e1 como soluci\u00f3n recurrir a la clase <code>Map</code> o a la clase <code>Set</code> de la biblioteca de Java.</p> <ul> <li>(a) (2,1 puntos) Escribir el c\u00f3digo de los m\u00e9todos mencionados.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Conjunto {\n    private List&lt;Object&gt;[] tabla;\n\n    public Conjunto(int size) {\n        tabla = new List[size];\n    }\n\n    public void add(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            tabla[h] = new ArrayList&lt;Object&gt;();\n        if (!tabla[h].contains(x))\n            tabla[h].add(x);\n    }\n\n    public void remove(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            return;\n        tabla[h].remove(x);\n    }\n\n    public boolean contains(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            return false;\n        return tabla[h].contains(x);\n    }\n\n    private int hash(Object x) {\n        return Math.abs(x.hashCode() % tabla.length);\n    }\n}\n</code></pre> <ul> <li>(b) (1,4 puntos) Razonar la complejidad de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad de <code>add()</code> es \\(O(1)\\) sobre el supuesto de que la tabla de direccionamiento est\u00e1 dimensionada holgadamente; si no, ser\u00eda la complejidad de la lista de desbordamiento.</p> <p>La complejidad de <code>remove()</code> y <code>contains()</code> es la misma.</p>"},{"location":"exams/2016/extra/#problema-2","title":"Problema 2","text":"<p>Se pide programar un m\u00e9todo que determine si existen dos elementos de un array de enteros que sumen un cierto valor <code>K</code>.</p> <pre><code>boolean check(int[] datos, int k)\n</code></pre> <p>Ejemplos:</p> <pre><code>check([4, 6, 10, 8], 13) \u00e0 FALSE\ncheck([1, 4, 45, 6, 10, -8], 16) \u00e0 TRUE\n</code></pre> <p>Razone la complejidad en tiempo de ejecuci\u00f3n de dicho m\u00e9todo.</p> <p>Sugerencia. Para conseguir un algoritmo \\(O(N)\\) puede meter los datos del array en un conjunto (similar al propuesto en la primera pregunta).</p> <ul> <li>(a) (3,5) Implemente el m\u00e9todo y razone su complejidad. La complejidad del m\u00e9todo ha de ser \\(O(N)\\), en cualquier otro caso, solo se podr\u00e1 optar a la mitad de los puntos.</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n \u00f3ptima, con complejidad \\(O(n)\\) es: <pre><code>static boolean check1(int[] data, int K) {\n    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n    for (int v : data) {\n        if (set.contains(K - v))\n            return true;\n        set.add(v);\n    }\n    return false;\n}\n</code></pre> El orden de complejidad es \\(O(N)\\) porque se trata de un bucle que recorre los elementos del array y, dentro del bucle, las operaciones <code>contains()</code> y <code>add()</code> son \\(O(1)\\).</p> <p>Soluciones alternativas con otros \u00f3rdenes de complejidad son:</p> <ul> <li> <p>\\(O(n log n)\\) <pre><code>static boolean check2(int[] data, int K) {\n    int[] mdata = new int[data.length];\n    System.arraycopy(data, 0, mdata, 0, data.length);\n\n    Arrays.sort(mdata);\n\n    int a = 0;\n    int z = mdata.length - 1;\n\n    while (a &lt; z) {\n        int s = mdata[a] + mdata[z];\n        if (s == K)\n            return true;\n        if (s &lt; K)\n            a++;\n        else\n            z--;\n    }\n    return false;\n}\n</code></pre></p> </li> <li> <p>\\(O(n^2)\\) <pre><code>static boolean check3(int[] data, int K) {\n    for (int i = 0; i &lt; data.length; i++) {\n        for (int j = i + 1; j &lt; data.length; j++) {\n            if (data[i] + data[j] == K)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre></p> </li> </ul>"},{"location":"exams/2016/extra/#problema-3","title":"Problema 3","text":"<p>En un programa de supervisi\u00f3n y control de una central t\u00e9rmica, existen un conjunto de hebras que toman la temperatura del vapor en distintos puntos de la caldera regularmente y la almacenan junto con la hora de la medida, para que posteriormente otro conjunto de hebras pueda leer la \u00faltima temperatura y hora medidas y realizar c\u00e1lculos con ellas. Y se desea que cada una de las hebras del primer conjunto almacene la temperatura y hora medidas con exclusi\u00f3n mutua de todas las dem\u00e1s hebras, pero que cualquier n\u00famero de hebras del segundo tipo pueda estar leyendo esos valores al mismo tiempo.</p> <p>Para solucionar el problema se propone usar un solo objeto, bien de la clase <code>GestorHoraTemperatura</code>, o bien de la clase <code>GestorHoraTemperatura2</code>.</p> <pre><code>public class GestorHoraTemperatura {\n    private HoraTemperatura ht;\n\n    public synchronized void almacenarHoraTemperatura(HoraTemperatura ht) {\n        this.ht = ht;\n    }\n\n    public HoraTemperatura leerHoraTemperatura() {\n        return ht;\n    }\n}\n\npublic class GestorHoraTemperatura2 {\n    private static HoraTemperatura ht;\n\n    public synchronized void almacenarHoraTemperatura(HoraTemperatura ht) {\n        GestorHoraTemperatura2.ht = ht;\n    }\n\n    public synchronized static HoraTemperatura leerHoraTemperatura() {\n        return ht;\n    }\n}\n\npublic class HoraTemperatura {\n    private int hora; // en milisegundos\n    private int temperatura; // en grados cent\u00edgrados\n\n    // Constructor\n    public HoraTemperatura(int h, int t) {\n        hora = h;\n        temperatura = t;\n    }\n\n    // Getters y Setters\n    // \u2026\n}\n</code></pre> <ul> <li>(a) Para cada una de las dos soluciones propuestas, se pide responder si se conseguir\u00e1 o no la sincronizaci\u00f3n deseada (una sola de las hebras del primer grupo, o cualquier n\u00famero de hebras de las del segundo grupo), argumentando las respuestas.</li> </ul> Mostrar soluci\u00f3n <p>Ninguna de las dos soluciones propuestas es correcta. En la primera de ellas, los procesos que escriben la temperatura y la hora (llam\u00e9mosles \"escritores\") lo hacen en exclusi\u00f3n mutua entre ellos, lo cual es correcto, y los procesos que leen los valores (llam\u00e9mosles \"lectores\") pueden estar cualquier n\u00famero de ellos leyendo al mismo tiempo (al no estar el m\u00e9todo de lectura sincronizado). Lo cual tambi\u00e9n coincide con lo que se desea.</p> <p>El problema de esta (pseudo)soluci\u00f3n, sin embargo, es que tambi\u00e9n cualquier n\u00famero de lectores pueden estar leyendo al mismo tiempo que un escritor escribe, lo cual es desde luego un comportamiento incorrecto.</p> <p>En la segunda soluci\u00f3n propuesta, los lectores no pueden leer al mismo tiempo, ya que el m\u00e9todo correspondiente est\u00e1 sincronizado. Lo cual est\u00e1 en contra de lo deseado. Adem\u00e1s, al ser ahora la operaci\u00f3n que hace la lectura un m\u00e9todo de clase (est\u00e1tico), su exclusi\u00f3n mutua estar\u00e1 gobernada por el cerrojo de la clase, que es independiente de los cerrojos de los objetos de la clase, con lo que no ejecutar\u00e1 con exclusi\u00f3n mutua del otro m\u00e9todo, el de escritura. Es decir, que puede haber un lector leyendo al mismo tiempo que un escritor escribiendo, lo cual es desde luego un comportamiento incorrecto. </p>"},{"location":"exams/2016/extra/#problema-4","title":"Problema 4","text":"<p>En un sistema de comunicaciones hay un almac\u00e9n con capacidad para <code>N</code> mensajes, con <code>N</code> comprendido entre <code>MIN = 16</code> y <code>MAX = 1024</code>. Hay un cierto n\u00famero de hebras (emisores) que almacenan mensajes en el almac\u00e9n, y otras (receptores), que extraen mensajes de \u00e9l. No se pueden almacenar mensajes si el almac\u00e9n est\u00e1 lleno, ni se pueden extraer si est\u00e1 vac\u00edo.</p> <p>El almac\u00e9n se crea con capacidad <code>MIN</code>. Una hebra supervisora comprueba peri\u00f3dicamente su ocupaci\u00f3n (n\u00famero de mensajes almacenados), llamando al m\u00e9todo <code>adjust</code> (ver esquema). Si la ocupaci\u00f3n es mayor del 80% de su capacidad, duplica la capacidad del almac\u00e9n, siempre que sea posible sin sobrepasar el valor <code>MAX</code>. Si hab\u00eda emisores esperando por falta de espacio se les debe dar la oportunidad de enviar sus mensajes lo antes posible. Por otra parte, si la ocupaci\u00f3n del almac\u00e9n es menor que el 20% de su capacidad, el supervisor reduce la capacidad a la mitad (pero nunca por debajo de <code>MIN</code>).</p> <ul> <li>(a) (5 puntos) Escriba una clase monitor que cumpla las condiciones anteriores, seg\u00fan el esquema que se da a continuaci\u00f3n.</li> </ul> <pre><code>public class Store {\n\n    private static final int MIN = 5;\n\n    private Message[] buffer;\n    private int capacity;\n    private int count = 0;\n    private int in = 0;\n    private int out = 0;\n\n    // crea un almac\u00e9n de capacidad MIN\n    public Store() {\n        this.capacity = MIN;\n        this.buffer = new Message[capacity];\n    }\n\n    // almacena un mensaje en el almac\u00e9n\n    public synchronized void put(Message m) throws InterruptedException {\n        while (count == capacity) {\n            wait();\n        }\n        buffer[in] = m;\n        in = (in + 1) % capacity;\n        count++;\n        notifyAll();\n    }\n\n    // extrae un mensaje del almac\u00e9n\n    public synchronized Message get() throws InterruptedException {\n        while (count == 0) {\n            wait();\n        }\n        Message m = buffer[out];\n        buffer[out] = null;\n        out = (out + 1) % capacity;\n        count--;\n        notifyAll();\n        return m;\n    }\n\n    // ajusta la capacidad del almac\u00e9n seg\u00fan la especificaci\u00f3n\n    public synchronized void adjust() {\n        int newCapacity = Math.max(MIN, count);\n        if (newCapacity == capacity)\n            return;\n\n        Message[] nuevo = new Message[newCapacity];\n        for (int i = 0; i &lt; count; i++) {\n            nuevo[i] = buffer[(out + i) % capacity];\n        }\n\n        buffer = nuevo;\n        capacity = newCapacity;\n        out = 0;\n        in = count;\n        notifyAll();\n    }\n}\n</code></pre> <p>NOTA: Suponga que est\u00e1 definida la clase <code>Message</code> que se utiliza en este esquema.</p> Mostrar soluci\u00f3n <pre><code>public class Store {\n\n    private static final int MIN = 16;\n    private static final int MAX = 1024;\n\n    private int N;\n    private List&lt;Message&gt; list = new ArrayList&lt;&gt;();\n\n    // crea un almac\u00e9n de capacidad inicial N\n    public Store(int N) {\n        this.N = Math.min(Math.max(N, MIN), MAX);\n    }\n\n    // almacena un mensaje en el almac\u00e9n\n    public synchronized void put(Message m) {\n        while (list.size() &gt;= N) {\n            try {\n                wait();\n            } catch (Exception ignored) {}\n        }\n        list.add(m);\n        notifyAll();\n    }\n\n    // extrae un mensaje del almac\u00e9n\n    public synchronized Message get() {\n        while (list.isEmpty()) {\n            try {\n                wait();\n            } catch (Exception ignored) {}\n        }\n        Message m = list.remove(0);\n        notifyAll();\n        return m;\n    }\n\n    // ajusta la capacidad del almac\u00e9n seg\u00fan la especificaci\u00f3n\n    public synchronized void adjust() {\n        if (list.size() &gt; 0.8 * N) {\n            N = Math.min(2 * N, MAX);\n        }\n        if (list.size() &lt; 0.2 * N) {\n            N = Math.max(N / 2, MIN);\n        }\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2016/extra/#problema-5","title":"Problema 5","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione las notas obtenidas por cada estudiante. En la primera pantalla, se pide el 'login' y 'password' al estudiante, con los cuales se puede acceder a un servidor que contiene las notas. Cuando las notas se han descargado, se presenta una pantalla en la que se muestra un listado con cada asignatura disponible y su calificaci\u00f3n.</p> <ul> <li>(a) (1,25 puntos) Escriba una especificaci\u00f3n de <code>layout</code> adecuada para la actividad principal. Este <code>layout</code> debe permitir introducir una cadena de 'login', una de 'password', y debe disponer de un bot\u00f3n para proceder a la descarga de las notas.</li> </ul> <p>Nota: Si lo desea, para evitar que se vea la 'password' puede usar  <pre><code>android:inputType=\"textPassword\".\n</code></pre></p> mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\"es.upm.dit.adsw.descarganotas.MainActivity\"&gt;\n\n    &lt;LinearLayout\n        android:orientation=\"horizontal\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Login:\" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editLogin\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:orientation=\"horizontal\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Password:\" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editText2\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:inputType=\"textPassword\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;Button\n        android:id=\"@+id/descargar\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Descargar\" /&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre> <p>Se dispone de la siguiente clase auxiliar, denominada <code>BajarNotasAsyncTask</code>, con la siguiente cabecera: <pre><code>private class BajarNotaAsyncTask extends AsyncTask&lt;String, Void, Void&gt; { ... }\n</code></pre></p> <p>(b) (1,25 puntos) Escriba el c\u00f3digo adecuado para que al pulsar el bot\u00f3n de la actividad principal, comience la descarga de las notas. Nota: NO CODIFIQUE la clase <code>BajarNotasAsyncTask</code>.</p> Mostrar soluci\u00f3n <pre><code>Button descargar = (Button) findViewById(R.id.descargar);\ndescargar.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        EditText loginET = (EditText) findViewById(R.id.editLogin);\n        EditText passwordET = (EditText) findViewById(R.id.editPassword);\n\n        String login = loginET.getText().toString();\n        String password = passwordET.getText().toString();\n\n        BajarNotasAsyncTask task = new BajarNotasAsyncTask();\n        task.execute(login, password);\n    }\n});\n</code></pre> <p>Se dispone de las siguientes clases para almacenar las notas de los alumnos (est\u00e1n incompletas): <pre><code>class Nota { // esta clase tiene la nota de una asignatura\n    private String asignatura;\n    private double nota;\n\n    // constructor y getters al uso\n}\n\nclass ListaNotasSingleton {\n    private static final List&lt;Nota&gt; listaNotas = new ArrayList&lt;&gt;();\n\n    private ListaNotasSingleton() {\n        /* nadie lo toca */\n    }\n\n    public static void add(Nota nota) {\n        listaNotas.add(nota);\n    }\n\n    public static List&lt;Nota&gt; getNotas() {\n        return listaNotas;\n    }\n}\n</code></pre></p> <p>La ejecuci\u00f3n de <code>BajarNotasAsyncTask</code> a\u00f1ade en el singleton <code>ListaNotasSingleton</code> las notas obtenidas hasta el momento por el alumno.</p> <ul> <li>(c) (1,25 puntos) Sobreescriba el m\u00e9todo adecuado de la clase <code>BajarNotasAsyncTask</code> de forma que, una vez bajadas las notas, se arranque una actividad denominada <code>NotasListActivity</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\nprotected void onPostExecute(Void v) {\n    super.onPostExecute(v);\n    Intent intent = new Intent(MainActivity.this, NotasListActivity.class);\n    startActivity(intent);\n}\n</code></pre> <p>La actividad <code>NotasListActivity</code> presenta un <code>layout</code> denominado \u201cactivity_notas_list.xml\u201d, en el cual est\u00e1 definido un widget <code>ListView</code> con identificador \u201c@+id/listaNotas\u201d. Adem\u00e1s, se dispone de un <code>layout</code> para cada fila, denominado \u201cnota_item_row.xml\u201d y una clase adaptadora de la lista de notas denominada <code>NotasArrayAdapter</code>.</p> <ul> <li>(d) (1,25 puntos) Programe el m\u00e9todo <code>onCreate</code> de la clase <code>NotasListActivity</code></li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_notas_list);\n\n    ListView listView = (ListView) findViewById(R.id.listaNotas);\n\n    NotasArrayAdapter adapter =\n            new NotasArrayAdapter(\n                    this,\n                    R.layout.nota_item_row,\n                    ListaNotasSingleton.getEntries()\n            );\n\n    listView.setAdapter(adapter);\n    listView.setOnItemClickListener(new OnItemClickListenerListViewItem());\n}\n</code></pre>"},{"location":"exams/2016/extra/#problema-6","title":"Problema 6","text":"<p>Se quiere construir un diccionario donde las claves son <code>Object</code> que no se pueden comparar entre s\u00ed. Los valores tambi\u00e9n son <code>Object</code> de Java. Para ello se ha decidido programar un \u00e1rbol binario de b\u00fasqueda, usando el hash de la clave como criterio para optar por el sub\u00e1rbol izquierdo o el derecho.</p> <p>Se pide programar una clase <code>BST_Object</code> que incorpore el m\u00e9todo <pre><code>void put(Object clave, Object valor)\n</code></pre> que inserta un valor asociado a la clave; si la clave ya exist\u00eda, se reemplaza el antiguo valor por el nuevo </p> <ul> <li>(a) (1 punto) Programe los campos, el constructor y el m\u00e9todo <code>put()</code>. No es necesario que programe m\u00e1s m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class BST_Object {\n\n    private Nodo root = null;\n\n    public void put(Object clave, Object valor) {\n        if (clave == null)\n            throw new IllegalArgumentException(\"put(null, valor)\");\n        root = put(root, clave, valor);\n    }\n\n    private Nodo put(Nodo nodo, Object clave, Object valor) {\n        if (nodo == null)\n            return new Nodo(clave, valor);\n\n        if (clave.equals(nodo.clave))\n            nodo.valor = valor;\n        else if (clave.hashCode() &lt;= nodo.clave.hashCode())\n            nodo.izq = put(nodo.izq, clave, valor);\n        else\n            nodo.der = put(nodo.der, clave, valor);\n\n        return nodo;\n    }\n\n    private class Nodo {\n        Object clave;\n        Object valor;\n        Nodo izq;\n        Nodo der;\n\n        Nodo(Object clave, Object valor) {\n            this.clave = clave;\n            this.valor = valor;\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2016/extra/#problema-7","title":"Problema 7","text":"<p>En una aplicaci\u00f3n Android, se dispone de la clase <code>RssRetrieveTask</code>, que descarga as\u00edncronamente una serie de noticias de una fuente seleccionada, con la siguiente cabecera: <pre><code>private class RssRetrieveTask extends AsyncTask&lt;String, Void, Void&gt; { ... }\n</code></pre> donde el primer par\u00e1metro es una lista de <code>Strings</code>, la primera de las cuales es el URL de la fuente RSS de noticias, y el resto son palabras de filtrado.</p> <p>En el <code>layout</code> de la actividad principal se ha definido un bot\u00f3n con identificador \"@+id/boton_leer\", y se pretende que, al pulsar el bot\u00f3n, se active la tarea as\u00edncrona <code>RssRetrieveTask</code>. </p> <ul> <li>(a) (1 punto) Escriba el c\u00f3digo adecuado que atienda a la pulsaci\u00f3n del bot\u00f3n de forma que se active esta tarea.</li> </ul> Mostrar soluci\u00f3n <p>En el m\u00e9todo <code>onCreate</code> se a\u00f1aden las siguientes l\u00edneas: <pre><code>Button readButton = (Button) findViewById(R.id.read_button);\nreadButton.setOnClickListener(new ReadOnClickListener() {\n    @Override\n    public void onClick(View v) {\n        try {\n            String words = wordsEdit.getText().toString();\n            String[] urls = getResources().getStringArray(R.array.feeds_url);\n            String url = urls[feedSpinner.getSelectedItemPosition()];\n            Log.d(TAG, \"Palabras \" + words);\n            Log.d(TAG, \"URL \" + url);\n            RssRetrieveTask task = new RssRetrieveTask();\n            task.execute(url, words);\n        } catch (Exception e) {\n            Log.e(TAG, \"Error \" + e.toString());\n            Toast.makeText(getBaseContext(), \"Error al recuperar las noticias\",\n                    Toast.LENGTH_LONG).show();\n        }\n    }\n});\n</code></pre></p> <p>Notas: </p> <ul> <li>Se admiten las otras dos formas de asignar un m\u00e9todo al <code>listener</code> de un <code>button</code>;</li> <li>Nota 2: las sentencias <code>Log</code> y <code>Toast</code> son absolutamente opcionales y no influyen en la nota.</li> </ul>"},{"location":"exams/2016/extra_ex01/","title":"Extra ex01","text":"<p>Queremos programar una clase <code>Conjunto</code> usando internamente una tabla hash con lista de desbordamiento. Se pide programar los siguientes m\u00e9todos:</p> <pre><code>void add(Object x)\n</code></pre> <pre><code>boolean contains(Object x)\n</code></pre> <pre><code>void remove(Object x)\n</code></pre> <p>Razone la complejidad de dichos m\u00e9todos.</p> <p>No se aceptar\u00e1 como soluci\u00f3n recurrir a la clase <code>Map</code> o a la clase <code>Set</code> de la biblioteca de Java.</p> <ul> <li>(a) (2,1 puntos) Escribir el c\u00f3digo de los m\u00e9todos mencionados.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Conjunto {\n    private List&lt;Object&gt;[] tabla;\n\n    public Conjunto(int size) {\n        tabla = new List[size];\n    }\n\n    public void add(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            tabla[h] = new ArrayList&lt;Object&gt;();\n        if (!tabla[h].contains(x))\n            tabla[h].add(x);\n    }\n\n    public void remove(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            return;\n        tabla[h].remove(x);\n    }\n\n    public boolean contains(Object x) {\n        int h = hash(x);\n        if (tabla[h] == null)\n            return false;\n        return tabla[h].contains(x);\n    }\n\n    private int hash(Object x) {\n        return Math.abs(x.hashCode() % tabla.length);\n    }\n}\n</code></pre> <ul> <li>(b) (1,4 puntos) Razonar la complejidad de los m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad de <code>add()</code> es \\(O(1)\\) sobre el supuesto de que la tabla de direccionamiento est\u00e1 dimensionada holgadamente; si no, ser\u00eda la complejidad de la lista de desbordamiento.</p> <p>La complejidad de <code>remove()</code> y <code>contains()</code> es la misma.</p>","tags":["complejidad"]},{"location":"exams/2016/extra_ex02/","title":"Extra ex02","text":"<p>Se pide programar un m\u00e9todo que determine si existen dos elementos de un array de enteros que sumen un cierto valor <code>K</code>.</p> <pre><code>boolean check(int[] datos, int k)\n</code></pre> <p>Ejemplos:</p> <pre><code>check([4, 6, 10, 8], 13) \u00e0 FALSE\ncheck([1, 4, 45, 6, 10, -8], 16) \u00e0 TRUE\n</code></pre> <p>Razone la complejidad en tiempo de ejecuci\u00f3n de dicho m\u00e9todo.</p> <p>Sugerencia. Para conseguir un algoritmo \\(O(N)\\) puede meter los datos del array en un conjunto (similar al propuesto en la primera pregunta).</p> <ul> <li>(a) (3,5) Implemente el m\u00e9todo y razone su complejidad. La complejidad del m\u00e9todo ha de ser \\(O(N)\\), en cualquier otro caso, solo se podr\u00e1 optar a la mitad de los puntos.</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n \u00f3ptima, con complejidad \\(O(n)\\) es: <pre><code>static boolean check1(int[] data, int K) {\n    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n    for (int v : data) {\n        if (set.contains(K - v))\n            return true;\n        set.add(v);\n    }\n    return false;\n}\n</code></pre> El orden de complejidad es \\(O(N)\\) porque se trata de un bucle que recorre los elementos del array y, dentro del bucle, las operaciones <code>contains()</code> y <code>add()</code> son \\(O(1)\\).</p> <p>Soluciones alternativas con otros \u00f3rdenes de complejidad son:</p> <ul> <li> <p>\\(O(n log n)\\) <pre><code>static boolean check2(int[] data, int K) {\n    int[] mdata = new int[data.length];\n    System.arraycopy(data, 0, mdata, 0, data.length);\n\n    Arrays.sort(mdata);\n\n    int a = 0;\n    int z = mdata.length - 1;\n\n    while (a &lt; z) {\n        int s = mdata[a] + mdata[z];\n        if (s == K)\n            return true;\n        if (s &lt; K)\n            a++;\n        else\n            z--;\n    }\n    return false;\n}\n</code></pre></p> </li> <li> <p>\\(O(n^2)\\) <pre><code>static boolean check3(int[] data, int K) {\n    for (int i = 0; i &lt; data.length; i++) {\n        for (int j = i + 1; j &lt; data.length; j++) {\n            if (data[i] + data[j] == K)\n                return true;\n        }\n    }\n    return false;\n}\n</code></pre></p> </li> </ul>","tags":["complejidad"]},{"location":"exams/2016/extra_ex03/","title":"Extra ex03","text":"<p>En un programa de supervisi\u00f3n y control de una central t\u00e9rmica, existen un conjunto de hebras que toman la temperatura del vapor en distintos puntos de la caldera regularmente y la almacenan junto con la hora de la medida, para que posteriormente otro conjunto de hebras pueda leer la \u00faltima temperatura y hora medidas y realizar c\u00e1lculos con ellas. Y se desea que cada una de las hebras del primer conjunto almacene la temperatura y hora medidas con exclusi\u00f3n mutua de todas las dem\u00e1s hebras, pero que cualquier n\u00famero de hebras del segundo tipo pueda estar leyendo esos valores al mismo tiempo.</p> <p>Para solucionar el problema se propone usar un solo objeto, bien de la clase <code>GestorHoraTemperatura</code>, o bien de la clase <code>GestorHoraTemperatura2</code>.</p> <pre><code>public class GestorHoraTemperatura {\n    private HoraTemperatura ht;\n\n    public synchronized void almacenarHoraTemperatura(HoraTemperatura ht) {\n        this.ht = ht;\n    }\n\n    public HoraTemperatura leerHoraTemperatura() {\n        return ht;\n    }\n}\n\npublic class GestorHoraTemperatura2 {\n    private static HoraTemperatura ht;\n\n    public synchronized void almacenarHoraTemperatura(HoraTemperatura ht) {\n        GestorHoraTemperatura2.ht = ht;\n    }\n\n    public synchronized static HoraTemperatura leerHoraTemperatura() {\n        return ht;\n    }\n}\n\npublic class HoraTemperatura {\n    private int hora; // en milisegundos\n    private int temperatura; // en grados cent\u00edgrados\n\n    // Constructor\n    public HoraTemperatura(int h, int t) {\n        hora = h;\n        temperatura = t;\n    }\n\n    // Getters y Setters\n    // \u2026\n}\n</code></pre> <ul> <li>(a) Para cada una de las dos soluciones propuestas, se pide responder si se conseguir\u00e1 o no la sincronizaci\u00f3n deseada (una sola de las hebras del primer grupo, o cualquier n\u00famero de hebras de las del segundo grupo), argumentando las respuestas.</li> </ul> Mostrar soluci\u00f3n <p>Ninguna de las dos soluciones propuestas es correcta. En la primera de ellas, los procesos que escriben la temperatura y la hora (llam\u00e9mosles \"escritores\") lo hacen en exclusi\u00f3n mutua entre ellos, lo cual es correcto, y los procesos que leen los valores (llam\u00e9mosles \"lectores\") pueden estar cualquier n\u00famero de ellos leyendo al mismo tiempo (al no estar el m\u00e9todo de lectura sincronizado). Lo cual tambi\u00e9n coincide con lo que se desea.</p> <p>El problema de esta (pseudo)soluci\u00f3n, sin embargo, es que tambi\u00e9n cualquier n\u00famero de lectores pueden estar leyendo al mismo tiempo que un escritor escribe, lo cual es desde luego un comportamiento incorrecto.</p> <p>En la segunda soluci\u00f3n propuesta, los lectores no pueden leer al mismo tiempo, ya que el m\u00e9todo correspondiente est\u00e1 sincronizado. Lo cual est\u00e1 en contra de lo deseado. Adem\u00e1s, al ser ahora la operaci\u00f3n que hace la lectura un m\u00e9todo de clase (est\u00e1tico), su exclusi\u00f3n mutua estar\u00e1 gobernada por el cerrojo de la clase, que es independiente de los cerrojos de los objetos de la clase, con lo que no ejecutar\u00e1 con exclusi\u00f3n mutua del otro m\u00e9todo, el de escritura. Es decir, que puede haber un lector leyendo al mismo tiempo que un escritor escribiendo, lo cual es desde luego un comportamiento incorrecto. </p>","tags":["hebras"]},{"location":"exams/2016/extra_ex04/","title":"Extra ex04","text":"<p>En un sistema de comunicaciones hay un almac\u00e9n con capacidad para <code>N</code> mensajes, con <code>N</code> comprendido entre <code>MIN = 16</code> y <code>MAX = 1024</code>. Hay un cierto n\u00famero de hebras (emisores) que almacenan mensajes en el almac\u00e9n, y otras (receptores), que extraen mensajes de \u00e9l. No se pueden almacenar mensajes si el almac\u00e9n est\u00e1 lleno, ni se pueden extraer si est\u00e1 vac\u00edo.</p> <p>El almac\u00e9n se crea con capacidad <code>MIN</code>. Una hebra supervisora comprueba peri\u00f3dicamente su ocupaci\u00f3n (n\u00famero de mensajes almacenados), llamando al m\u00e9todo <code>adjust</code> (ver esquema). Si la ocupaci\u00f3n es mayor del 80% de su capacidad, duplica la capacidad del almac\u00e9n, siempre que sea posible sin sobrepasar el valor <code>MAX</code>. Si hab\u00eda emisores esperando por falta de espacio se les debe dar la oportunidad de enviar sus mensajes lo antes posible. Por otra parte, si la ocupaci\u00f3n del almac\u00e9n es menor que el 20% de su capacidad, el supervisor reduce la capacidad a la mitad (pero nunca por debajo de <code>MIN</code>).</p> <ul> <li>(a) (5 puntos) Escriba una clase monitor que cumpla las condiciones anteriores, seg\u00fan el esquema que se da a continuaci\u00f3n.</li> </ul> <pre><code>public class Store {\n\n    private static final int MIN = 5;\n\n    private Message[] buffer;\n    private int capacity;\n    private int count = 0;\n    private int in = 0;\n    private int out = 0;\n\n    // crea un almac\u00e9n de capacidad MIN\n    public Store() {\n        this.capacity = MIN;\n        this.buffer = new Message[capacity];\n    }\n\n    // almacena un mensaje en el almac\u00e9n\n    public synchronized void put(Message m) throws InterruptedException {\n        while (count == capacity) {\n            wait();\n        }\n        buffer[in] = m;\n        in = (in + 1) % capacity;\n        count++;\n        notifyAll();\n    }\n\n    // extrae un mensaje del almac\u00e9n\n    public synchronized Message get() throws InterruptedException {\n        while (count == 0) {\n            wait();\n        }\n        Message m = buffer[out];\n        buffer[out] = null;\n        out = (out + 1) % capacity;\n        count--;\n        notifyAll();\n        return m;\n    }\n\n    // ajusta la capacidad del almac\u00e9n seg\u00fan la especificaci\u00f3n\n    public synchronized void adjust() {\n        int newCapacity = Math.max(MIN, count);\n        if (newCapacity == capacity)\n            return;\n\n        Message[] nuevo = new Message[newCapacity];\n        for (int i = 0; i &lt; count; i++) {\n            nuevo[i] = buffer[(out + i) % capacity];\n        }\n\n        buffer = nuevo;\n        capacity = newCapacity;\n        out = 0;\n        in = count;\n        notifyAll();\n    }\n}\n</code></pre> <p>NOTA: Suponga que est\u00e1 definida la clase <code>Message</code> que se utiliza en este esquema.</p> Mostrar soluci\u00f3n <pre><code>public class Store {\n\n    private static final int MIN = 16;\n    private static final int MAX = 1024;\n\n    private int N;\n    private List&lt;Message&gt; list = new ArrayList&lt;&gt;();\n\n    // crea un almac\u00e9n de capacidad inicial N\n    public Store(int N) {\n        this.N = Math.min(Math.max(N, MIN), MAX);\n    }\n\n    // almacena un mensaje en el almac\u00e9n\n    public synchronized void put(Message m) {\n        while (list.size() &gt;= N) {\n            try {\n                wait();\n            } catch (Exception ignored) {}\n        }\n        list.add(m);\n        notifyAll();\n    }\n\n    // extrae un mensaje del almac\u00e9n\n    public synchronized Message get() {\n        while (list.isEmpty()) {\n            try {\n                wait();\n            } catch (Exception ignored) {}\n        }\n        Message m = list.remove(0);\n        notifyAll();\n        return m;\n    }\n\n    // ajusta la capacidad del almac\u00e9n seg\u00fan la especificaci\u00f3n\n    public synchronized void adjust() {\n        if (list.size() &gt; 0.8 * N) {\n            N = Math.min(2 * N, MAX);\n        }\n        if (list.size() &lt; 0.2 * N) {\n            N = Math.max(N / 2, MIN);\n        }\n        notifyAll();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2016/extra_ex05/","title":"Extra ex05","text":"<p>Se pretende realizar una aplicaci\u00f3n Android que gestione las notas obtenidas por cada estudiante. En la primera pantalla, se pide el 'login' y 'password' al estudiante, con los cuales se puede acceder a un servidor que contiene las notas. Cuando las notas se han descargado, se presenta una pantalla en la que se muestra un listado con cada asignatura disponible y su calificaci\u00f3n.</p> <ul> <li>(a) (1,25 puntos) Escriba una especificaci\u00f3n de <code>layout</code> adecuada para la actividad principal. Este <code>layout</code> debe permitir introducir una cadena de 'login', una de 'password', y debe disponer de un bot\u00f3n para proceder a la descarga de las notas.</li> </ul> <p>Nota: Si lo desea, para evitar que se vea la 'password' puede usar  <pre><code>android:inputType=\"textPassword\".\n</code></pre></p> mostrar soluci\u00f3n <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\"es.upm.dit.adsw.descarganotas.MainActivity\"&gt;\n\n    &lt;LinearLayout\n        android:orientation=\"horizontal\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Login:\" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editLogin\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;LinearLayout\n        android:orientation=\"horizontal\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"&gt;\n\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Password:\" /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/editText2\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"wrap_content\"\n            android:layout_weight=\"1\"\n            android:inputType=\"textPassword\" /&gt;\n    &lt;/LinearLayout&gt;\n\n    &lt;Button\n        android:id=\"@+id/descargar\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Descargar\" /&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre> <p>Se dispone de la siguiente clase auxiliar, denominada <code>BajarNotasAsyncTask</code>, con la siguiente cabecera: <pre><code>private class BajarNotaAsyncTask extends AsyncTask&lt;String, Void, Void&gt; { ... }\n</code></pre></p> <p>(b) (1,25 puntos) Escriba el c\u00f3digo adecuado para que al pulsar el bot\u00f3n de la actividad principal, comience la descarga de las notas. Nota: NO CODIFIQUE la clase <code>BajarNotasAsyncTask</code>.</p> Mostrar soluci\u00f3n <pre><code>Button descargar = (Button) findViewById(R.id.descargar);\ndescargar.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        EditText loginET = (EditText) findViewById(R.id.editLogin);\n        EditText passwordET = (EditText) findViewById(R.id.editPassword);\n\n        String login = loginET.getText().toString();\n        String password = passwordET.getText().toString();\n\n        BajarNotasAsyncTask task = new BajarNotasAsyncTask();\n        task.execute(login, password);\n    }\n});\n</code></pre> <p>Se dispone de las siguientes clases para almacenar las notas de los alumnos (est\u00e1n incompletas): <pre><code>class Nota { // esta clase tiene la nota de una asignatura\n    private String asignatura;\n    private double nota;\n\n    // constructor y getters al uso\n}\n\nclass ListaNotasSingleton {\n    private static final List&lt;Nota&gt; listaNotas = new ArrayList&lt;&gt;();\n\n    private ListaNotasSingleton() {\n        /* nadie lo toca */\n    }\n\n    public static void add(Nota nota) {\n        listaNotas.add(nota);\n    }\n\n    public static List&lt;Nota&gt; getNotas() {\n        return listaNotas;\n    }\n}\n</code></pre></p> <p>La ejecuci\u00f3n de <code>BajarNotasAsyncTask</code> a\u00f1ade en el singleton <code>ListaNotasSingleton</code> las notas obtenidas hasta el momento por el alumno.</p> <ul> <li>(c) (1,25 puntos) Sobreescriba el m\u00e9todo adecuado de la clase <code>BajarNotasAsyncTask</code> de forma que, una vez bajadas las notas, se arranque una actividad denominada <code>NotasListActivity</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\nprotected void onPostExecute(Void v) {\n    super.onPostExecute(v);\n    Intent intent = new Intent(MainActivity.this, NotasListActivity.class);\n    startActivity(intent);\n}\n</code></pre> <p>La actividad <code>NotasListActivity</code> presenta un <code>layout</code> denominado \u201cactivity_notas_list.xml\u201d, en el cual est\u00e1 definido un widget <code>ListView</code> con identificador \u201c@+id/listaNotas\u201d. Adem\u00e1s, se dispone de un <code>layout</code> para cada fila, denominado \u201cnota_item_row.xml\u201d y una clase adaptadora de la lista de notas denominada <code>NotasArrayAdapter</code>.</p> <ul> <li>(d) (1,25 puntos) Programe el m\u00e9todo <code>onCreate</code> de la clase <code>NotasListActivity</code></li> </ul> Mostrar soluci\u00f3n <pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_notas_list);\n\n    ListView listView = (ListView) findViewById(R.id.listaNotas);\n\n    NotasArrayAdapter adapter =\n            new NotasArrayAdapter(\n                    this,\n                    R.layout.nota_item_row,\n                    ListaNotasSingleton.getEntries()\n            );\n\n    listView.setAdapter(adapter);\n    listView.setOnItemClickListener(new OnItemClickListenerListViewItem());\n}\n</code></pre>","tags":["android"]},{"location":"exams/2016/extra_ex06/","title":"Extra ex06","text":"<p>Se quiere construir un diccionario donde las claves son <code>Object</code> que no se pueden comparar entre s\u00ed. Los valores tambi\u00e9n son <code>Object</code> de Java. Para ello se ha decidido programar un \u00e1rbol binario de b\u00fasqueda, usando el hash de la clave como criterio para optar por el sub\u00e1rbol izquierdo o el derecho.</p> <p>Se pide programar una clase <code>BST_Object</code> que incorpore el m\u00e9todo <pre><code>void put(Object clave, Object valor)\n</code></pre> que inserta un valor asociado a la clave; si la clave ya exist\u00eda, se reemplaza el antiguo valor por el nuevo </p> <ul> <li>(a) (1 punto) Programe los campos, el constructor y el m\u00e9todo <code>put()</code>. No es necesario que programe m\u00e1s m\u00e9todos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class BST_Object {\n\n    private Nodo root = null;\n\n    public void put(Object clave, Object valor) {\n        if (clave == null)\n            throw new IllegalArgumentException(\"put(null, valor)\");\n        root = put(root, clave, valor);\n    }\n\n    private Nodo put(Nodo nodo, Object clave, Object valor) {\n        if (nodo == null)\n            return new Nodo(clave, valor);\n\n        if (clave.equals(nodo.clave))\n            nodo.valor = valor;\n        else if (clave.hashCode() &lt;= nodo.clave.hashCode())\n            nodo.izq = put(nodo.izq, clave, valor);\n        else\n            nodo.der = put(nodo.der, clave, valor);\n\n        return nodo;\n    }\n\n    private class Nodo {\n        Object clave;\n        Object valor;\n        Nodo izq;\n        Nodo der;\n\n        Nodo(Object clave, Object valor) {\n            this.clave = clave;\n            this.valor = valor;\n        }\n    }\n}\n</code></pre>","tags":["???"]},{"location":"exams/2016/extra_ex07/","title":"Extra ex07","text":"<p>En una aplicaci\u00f3n Android, se dispone de la clase <code>RssRetrieveTask</code>, que descarga as\u00edncronamente una serie de noticias de una fuente seleccionada, con la siguiente cabecera: <pre><code>private class RssRetrieveTask extends AsyncTask&lt;String, Void, Void&gt; { ... }\n</code></pre> donde el primer par\u00e1metro es una lista de <code>Strings</code>, la primera de las cuales es el URL de la fuente RSS de noticias, y el resto son palabras de filtrado.</p> <p>En el <code>layout</code> de la actividad principal se ha definido un bot\u00f3n con identificador \"@+id/boton_leer\", y se pretende que, al pulsar el bot\u00f3n, se active la tarea as\u00edncrona <code>RssRetrieveTask</code>. </p> <ul> <li>(a) (1 punto) Escriba el c\u00f3digo adecuado que atienda a la pulsaci\u00f3n del bot\u00f3n de forma que se active esta tarea.</li> </ul> Mostrar soluci\u00f3n <p>En el m\u00e9todo <code>onCreate</code> se a\u00f1aden las siguientes l\u00edneas: <pre><code>Button readButton = (Button) findViewById(R.id.read_button);\nreadButton.setOnClickListener(new ReadOnClickListener() {\n    @Override\n    public void onClick(View v) {\n        try {\n            String words = wordsEdit.getText().toString();\n            String[] urls = getResources().getStringArray(R.array.feeds_url);\n            String url = urls[feedSpinner.getSelectedItemPosition()];\n            Log.d(TAG, \"Palabras \" + words);\n            Log.d(TAG, \"URL \" + url);\n            RssRetrieveTask task = new RssRetrieveTask();\n            task.execute(url, words);\n        } catch (Exception e) {\n            Log.e(TAG, \"Error \" + e.toString());\n            Toast.makeText(getBaseContext(), \"Error al recuperar las noticias\",\n                    Toast.LENGTH_LONG).show();\n        }\n    }\n});\n</code></pre></p> <p>Notas: </p> <ul> <li>Se admiten las otras dos formas de asignar un m\u00e9todo al <code>listener</code> de un <code>button</code>;</li> <li>Nota 2: las sentencias <code>Log</code> y <code>Toast</code> son absolutamente opcionales y no influyen en la nota.</li> </ul>","tags":["android"]},{"location":"exams/2016/p1/","title":"Examen 2016 \u2014 Parcial 1","text":""},{"location":"exams/2016/p1/#problema-1","title":"Problema 1","text":"<p>Queremos desplegar un conjunto de sensores de contaminaci\u00f3n en Madrid. Cada sensor <code>S</code> est\u00e1 en unas coordenadas <code>(x, y)</code> medidas en metros en una cuadr\u00edcula centrada en la Puerta del Sol, yendo el eje X de oeste a este y el eje Y de sur a norte.</p> <p>Los sensores son fr\u00e1giles y pueden fallar. Pero no queremos quedarnos sin datos, as\u00ed que se les facilita la capacidad de que puedan mandar sus mediciones a otro sensor, que debe estar a una distancia menor que <code>d0</code> metros.</p> <pre><code>public class Sensor {\n    private final String id;\n    private final int x, y;\n\n    public Sensor(String id, int x, int y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distancia(Sensor b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Dada una lista con todos los sensores, escriba un m\u00e9todo que cargue un diccionario donde cada sensor est\u00e1 asociado a una lista con los sensores que est\u00e1n a su alcance (a menos de <code>d0</code> metros). N\u00f3tese que si el sensor <code>A</code> est\u00e1 dentro del alcance de <code>B</code>, tambi\u00e9n est\u00e1 <code>B</code> dentro del alcance de A. Razone la complejidad de este m\u00e9todo: <pre><code>public class Red {\n    private Diccionario diccionario = new \u2026\n\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\u2026}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Soluci\u00f3n usando un diccionario de la biblioteca de Java</p> <pre><code>public class Red {\n    private Map&lt;Sensor, List&lt;Sensor&gt;&gt; diccionario = new HashMap&lt;&gt;();\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        for (int i = 0; i &lt; sensores.size(); i++) {\n            Sensor s1 = sensores.get(i);\n            List&lt;Sensor&gt; lista = new ArrayList&lt;&gt;();\n            for (int j = 0; j &lt; sensores.size(); j++) {\n                if (i == j)\n                    continue;\n                Sensor s2 = sensores.get(j);\n                if (s1.distancia(s2) &lt; d0)\n                    lista.add(s2);\n        }\n        diccionario.put(s1, lista);\n    }\n}\n</code></pre> <p>Para usar un diccionario como el del ejercicio 3, hay que cambiar <code>CV</code> y la implementaci\u00f3n de la misma manera:</p> <pre><code>class CVExamen {\n    final Sensor clave;\n    List&lt;Sensor&gt; valor;\n\n    CVExamen(Sensor clave, List&lt;Sensor&gt; valor) {\n        this.clave = clave;\n        this.valor = valor;\n    }\n}\n\npublic interface Diccionario {\n    void put(Sensor clave, List&lt;Sensor&gt; valor);\n    List&lt;Sensor&gt; get(Sensor clave);\n    List&lt;Sensor&gt; remove(Sensor clave);\n    int size();\n    void clear();\n}\n</code></pre> <p>Complejidad.</p> <p>Siendo \\(N\\) el n\u00famero de sensores, tenemos un bucle exterior que se hace \\(N\\) veces. Cada pasada por el bucle incluye:</p> <ul> <li> <p>bucle interior: \\(N\\) veces, de complejidad \\(O(n)\\).</p> </li> <li> <p><code>diccionario.put()</code>, donde lacomplejidad,  si el n\u00famero de ranuras es sensiblemente superior a \\(N\\) es \\(O(1)\\), si no es \\(O(n)\\).</p> </li> </ul> <p>El total es, por tanto \\(O(n) + \u2026 = O(n)\\)</p> <p>Y la operaci\u00f3n total de carga \\(N \u00d7 O(n) \\rightarrow O(n2)\\)</p> <ul> <li>(b) (3,5 puntos) Escriba un m\u00e9todo para crear un diccionario que, para cada sensor <code>S</code>, contenga el conjunto de sensores a los que mandar\u00e1 regularmente una copia de sus medidas. Sabiendo que los sensores de destino podr\u00edan verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se env\u00edan a los <code>F</code> sensores que a su vez tengan menos sensores a su alcance.</li> </ul> <pre><code>public Diccionario cercanos (int f) {\u2026}\n</code></pre> <p>El algoritmo es como sigue:</p> <ol> <li> <p>Para cada sensor <code>S</code> obtenemos la lista de nodos a distancia alcanzable (pregunta (a));</p> </li> <li> <p>Ordenamos la lista en funci\u00f3n del n\u00famero de sensores al alcance de cada sensor;</p> </li> <li> <p>Nos quedamos con los F primeros sensores en una nueva lista;</p> </li> <li> <p>Asociamos la nueva lista a S en el diccionario de resultado.</p> </li> </ol> <p>NOTAS:</p> <ul> <li>Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java;</li> <li>Como algoritmo de ordenaci\u00f3n, elija uno de los presentados en clase, adaptando el c\u00f3digo al caso;</li> <li>Puede usar m\u00e9todos auxiliares si lo cree oportuno. Privados, por supuesto.</li> </ul> <p>Razone la complejidad de su c\u00f3digo</p> Mostrar soluci\u00f3n <p>Probablemente, el n\u00famero de sensores dentro del alcance sea un n\u00famero peque\u00f1o. En ese caso la ordenaci\u00f3n se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenaci\u00f3n.</p> <p>En la soluci\u00f3n que sigue se recurre al algoritmo de inserci\u00f3n.</p> <p>Usando la biblioteca de Java:</p> <pre><code>public Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n    Map&lt;Sensor, List&lt;Sensor&gt;&gt; resultado = new HashMap&lt;&gt;();\n\n    for (Sensor sensor : diccionario.keySet()) {\n        List&lt;Sensor&gt; list1 = getListaOrdenadaSensores(sensor);\n        List&lt;Sensor&gt; list2 = new ArrayList&lt;&gt;();\n\n        int m = Math.min(f, list1.size());\n        for (int i = 0; i &lt; m; i++)\n            list2.add(list1.get(i));\n\n        resultado.put(sensor, list2);\n    }\n    return resultado;\n}\n\nprivate List&lt;Sensor&gt; getListaOrdenadaSensores(Sensor sensor) {\n    List&lt;Sensor&gt; list0 = diccionario.get(sensor);\n    List&lt;Sensor&gt; list1 = new ArrayList&lt;&gt;(list0);\n    sort(list1);\n    return list1;\n}\n\nprivate void sort(List&lt;Sensor&gt; list) {\n    // inserci\u00f3n\n    for (int i = 1; i &lt; list.size(); i++)\n        inserta(list, i, list.get(i));\n}\n\n// inserta sensor en datos, entre 0 y z-1\nprivate void inserta(List&lt;Sensor&gt; datos, int z, Sensor sensor) {\n    int j = z;\n    while (0 &lt; j &amp;&amp; compareTo(sensor, datos.get(j - 1)) &lt; 0)\n        j--;\n\n    if (j != z) {\n        datos.remove(sensor);\n        datos.add(j, sensor);\n    }\n}\n\nprivate int compareTo(Sensor s1, Sensor s2) {\n    int size1 = diccionario.get(s1).size();\n    int size2 = diccionario.get(s2).size();\n    return size2 - size1;\n}\n</code></pre> <p>Con respecto a la complejidad, hay que revisar \\(N\\) sensores.</p> <p>Para cada sensor hay que localizar su lista de sensores en el diccionario: <code>get()</code>.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a \\(N\\), la complejidad es \\(O(1)\\). De lo contrario, ser\u00e1 \\(O(n)\\).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es \\(O(1)\\).</p> <p>Cada lista, de \\(X\\) elementos, hay que ordenarla. Si usamos un algoritmo de inserci\u00f3n como el de arriba, por t\u00e9rmino medio ser\u00e1 la ordenaci\u00f3n de un array de \\(x\\) elementos: \\(O(x2)\\):</p> <ol> <li> <p>Podemos pensar que \\(X\\) sea constante, independientemente de \\(N\\), en cuyo caso la ordenaci\u00f3n ser\u00e1 de tiempo constante, \\(O(1)\\);</p> </li> <li> <p>Podemos pensar que \\(X\\) sea proporcional a \\(N\\), en cuyo caso la ordenaci\u00f3n ser\u00e1 una proporci\u00f3n de \\(N\\): \\(O(n2)\\).</p> </li> </ol> <p>Nos quedamos con \\(f\\) elementos: \\(O(1)\\).</p> <p>Y hacemos una operaci\u00f3n <code>put()</code> en el diccionario de salida.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a \\(N\\), la complejidad es \\(O(1)\\). De lo contrario, ser\u00e1 \\(O(n)\\).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es \\(O(1)\\).</p> <p>En el caso 1, el total es \\(N \u00d7 (O(1) + O(1) + O(1) + O(1)) \\rightarrow N \u00d7 O(1) \\rightarrow O(n)\\).</p> <p>En el caso 2, el total es \\(N \u00d7 (O(1) + O(n2) + O(1) + O(1)) \\rightarrow N \u00d7 O(n2) \\rightarrow O(n3)\\).</p> <p>Resumiendo, si el n\u00famero de sensores dentro del alcance es independiente de \\(N\\), la complejidad es \\(O(n)\\). Si el n\u00famero de sensores dentro del alcance es proporcional a \\(N\\), la complejidad depende del algoritmo de ordenaci\u00f3n.</p>"},{"location":"exams/2016/p1/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (1 punto) Modifique la clase <code>Sensor</code> para que se pueda integrar en una hebra que comparta informaci\u00f3n con los sensores cercanos cada 30s. Para ello se puede implementar la interfaz <code>Runnable</code>.</li> </ul> <pre><code>public class Sensor implements Runnable {\n    // ...\n    private Red red;\n    private int medida; // valor le\u00eddo por el sensor\n\n    public Sensor(String id, int x, int y, Red red) {\n        this.red = red;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // transmitir la lectura cada 30 segundos\n                red.transmitir(this, medida);\n                Thread.sleep(30000); // 30 s\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Para implementar la interfaz <code>Runnable</code> espreciso redefinir el m\u00e9todo <code>run()</code>: <pre><code>@Override\npublic void run() {\n    while (true) {\n        try {\n            sleep(30000);\n        } catch (InterruptedException ignored) {\n        }\n\n        for (Sensor s : red.cercanos(f).get(this)) {\n            red.enviar(s, medida);\n        }\n    }\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Escriba una l\u00ednea de c\u00f3digo java para arrancar una hebra que ejecute el c\u00f3digo concurrente de Sensor.</li> </ul> Mostrar soluci\u00f3n <p>Para arrancar una hebra que ejecute el m\u00e9todo <code>run()</code> anterior hay que crear la hebra a partir del <code>Runnable</code> y hacer <code>start()</code>: <pre><code>new Thread(new Sensor()).start();\n</code></pre> o alternativamente: <pre><code>Runnable sensor = new Sensor(\u2026);\nThread tread = new Thread(sensor);\nthread.start();\n</code></pre></p> <ul> <li>(c) (1 punto) En el puesto de mando y control, un servidor ejecuta un programa basado en la clase <code>Red</code> de las preguntas anteriores, y recibe peticiones de los operadores locales y de los muchos sensores distribuidos por Madrid. Modifique la clase <code>Red</code> para que pueda atender cargas, recargas y peticiones concurrentes sin problemas de concurrencia.</li> </ul> <p>NOTAS:</p> <ol> <li>Suponga que el valor medido por el sensor (medida) se actualiza autom\u00e1ticamente por alg\u00fan mecanismo que no es relevante para examen.</li> <li>Suponga que la clase <code>Red</code> incluye el m\u00e9todo <pre><code>public void enviar (Sensor destino, int medida) {\u2026}\n</code></pre></li> </ol> Mostrar soluci\u00f3n <p>Para que la clase <code>Red</code> se pueda usar de forma segura desde varias hebras es preciso convertirla en un monitor. Como no tiene atributos p\u00fablicos basta para ello con sincronizar todos sus m\u00e9todos p\u00fablicos: <pre><code>public class Red {\n    private Diccionario diccionario = new DiccionarioImpl();\n\n    public synchronized void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        // ...\n    }\n\n    public synchronized Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n        // ...\n        return null;\n    }\n\n    public synchronized void enviar(Sensor destino, int medida) {\n        // ...\n    }\n}\n</code></pre></p>"},{"location":"exams/2016/p1_ex01/","title":"P1 ex01","text":"<p>Queremos desplegar un conjunto de sensores de contaminaci\u00f3n en Madrid. Cada sensor <code>S</code> est\u00e1 en unas coordenadas <code>(x, y)</code> medidas en metros en una cuadr\u00edcula centrada en la Puerta del Sol, yendo el eje X de oeste a este y el eje Y de sur a norte.</p> <p>Los sensores son fr\u00e1giles y pueden fallar. Pero no queremos quedarnos sin datos, as\u00ed que se les facilita la capacidad de que puedan mandar sus mediciones a otro sensor, que debe estar a una distancia menor que <code>d0</code> metros.</p> <pre><code>public class Sensor {\n    private final String id;\n    private final int x, y;\n\n    public Sensor(String id, int x, int y) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distancia(Sensor b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n</code></pre> <ul> <li>(a) (3,5 puntos) Dada una lista con todos los sensores, escriba un m\u00e9todo que cargue un diccionario donde cada sensor est\u00e1 asociado a una lista con los sensores que est\u00e1n a su alcance (a menos de <code>d0</code> metros). N\u00f3tese que si el sensor <code>A</code> est\u00e1 dentro del alcance de <code>B</code>, tambi\u00e9n est\u00e1 <code>B</code> dentro del alcance de A. Razone la complejidad de este m\u00e9todo: <pre><code>public class Red {\n    private Diccionario diccionario = new \u2026\n\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\u2026}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Soluci\u00f3n usando un diccionario de la biblioteca de Java</p> <pre><code>public class Red {\n    private Map&lt;Sensor, List&lt;Sensor&gt;&gt; diccionario = new HashMap&lt;&gt;();\n    public void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        for (int i = 0; i &lt; sensores.size(); i++) {\n            Sensor s1 = sensores.get(i);\n            List&lt;Sensor&gt; lista = new ArrayList&lt;&gt;();\n            for (int j = 0; j &lt; sensores.size(); j++) {\n                if (i == j)\n                    continue;\n                Sensor s2 = sensores.get(j);\n                if (s1.distancia(s2) &lt; d0)\n                    lista.add(s2);\n        }\n        diccionario.put(s1, lista);\n    }\n}\n</code></pre> <p>Para usar un diccionario como el del ejercicio 3, hay que cambiar <code>CV</code> y la implementaci\u00f3n de la misma manera:</p> <pre><code>class CVExamen {\n    final Sensor clave;\n    List&lt;Sensor&gt; valor;\n\n    CVExamen(Sensor clave, List&lt;Sensor&gt; valor) {\n        this.clave = clave;\n        this.valor = valor;\n    }\n}\n\npublic interface Diccionario {\n    void put(Sensor clave, List&lt;Sensor&gt; valor);\n    List&lt;Sensor&gt; get(Sensor clave);\n    List&lt;Sensor&gt; remove(Sensor clave);\n    int size();\n    void clear();\n}\n</code></pre> <p>Complejidad.</p> <p>Siendo \\(N\\) el n\u00famero de sensores, tenemos un bucle exterior que se hace \\(N\\) veces. Cada pasada por el bucle incluye:</p> <ul> <li> <p>bucle interior: \\(N\\) veces, de complejidad \\(O(n)\\).</p> </li> <li> <p><code>diccionario.put()</code>, donde lacomplejidad,  si el n\u00famero de ranuras es sensiblemente superior a \\(N\\) es \\(O(1)\\), si no es \\(O(n)\\).</p> </li> </ul> <p>El total es, por tanto \\(O(n) + \u2026 = O(n)\\)</p> <p>Y la operaci\u00f3n total de carga \\(N \u00d7 O(n) \\rightarrow O(n2)\\)</p> <ul> <li>(b) (3,5 puntos) Escriba un m\u00e9todo para crear un diccionario que, para cada sensor <code>S</code>, contenga el conjunto de sensores a los que mandar\u00e1 regularmente una copia de sus medidas. Sabiendo que los sensores de destino podr\u00edan verse saturados, decidimos que, de todos los sensores a nuestro alcance, los datos se env\u00edan a los <code>F</code> sensores que a su vez tengan menos sensores a su alcance.</li> </ul> <pre><code>public Diccionario cercanos (int f) {\u2026}\n</code></pre> <p>El algoritmo es como sigue:</p> <ol> <li> <p>Para cada sensor <code>S</code> obtenemos la lista de nodos a distancia alcanzable (pregunta (a));</p> </li> <li> <p>Ordenamos la lista en funci\u00f3n del n\u00famero de sensores al alcance de cada sensor;</p> </li> <li> <p>Nos quedamos con los F primeros sensores en una nueva lista;</p> </li> <li> <p>Asociamos la nueva lista a S en el diccionario de resultado.</p> </li> </ol> <p>NOTAS:</p> <ul> <li>Como Diccionario, puede adaptar su diccionario del ejercicio 3 de clase, o usar la biblioteca de java;</li> <li>Como algoritmo de ordenaci\u00f3n, elija uno de los presentados en clase, adaptando el c\u00f3digo al caso;</li> <li>Puede usar m\u00e9todos auxiliares si lo cree oportuno. Privados, por supuesto.</li> </ul> <p>Razone la complejidad de su c\u00f3digo</p> Mostrar soluci\u00f3n <p>Probablemente, el n\u00famero de sensores dentro del alcance sea un n\u00famero peque\u00f1o. En ese caso la ordenaci\u00f3n se realiza sobre pocos sensores y nos vale cualquier algoritmo de ordenaci\u00f3n.</p> <p>En la soluci\u00f3n que sigue se recurre al algoritmo de inserci\u00f3n.</p> <p>Usando la biblioteca de Java:</p> <pre><code>public Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n    Map&lt;Sensor, List&lt;Sensor&gt;&gt; resultado = new HashMap&lt;&gt;();\n\n    for (Sensor sensor : diccionario.keySet()) {\n        List&lt;Sensor&gt; list1 = getListaOrdenadaSensores(sensor);\n        List&lt;Sensor&gt; list2 = new ArrayList&lt;&gt;();\n\n        int m = Math.min(f, list1.size());\n        for (int i = 0; i &lt; m; i++)\n            list2.add(list1.get(i));\n\n        resultado.put(sensor, list2);\n    }\n    return resultado;\n}\n\nprivate List&lt;Sensor&gt; getListaOrdenadaSensores(Sensor sensor) {\n    List&lt;Sensor&gt; list0 = diccionario.get(sensor);\n    List&lt;Sensor&gt; list1 = new ArrayList&lt;&gt;(list0);\n    sort(list1);\n    return list1;\n}\n\nprivate void sort(List&lt;Sensor&gt; list) {\n    // inserci\u00f3n\n    for (int i = 1; i &lt; list.size(); i++)\n        inserta(list, i, list.get(i));\n}\n\n// inserta sensor en datos, entre 0 y z-1\nprivate void inserta(List&lt;Sensor&gt; datos, int z, Sensor sensor) {\n    int j = z;\n    while (0 &lt; j &amp;&amp; compareTo(sensor, datos.get(j - 1)) &lt; 0)\n        j--;\n\n    if (j != z) {\n        datos.remove(sensor);\n        datos.add(j, sensor);\n    }\n}\n\nprivate int compareTo(Sensor s1, Sensor s2) {\n    int size1 = diccionario.get(s1).size();\n    int size2 = diccionario.get(s2).size();\n    return size2 - size1;\n}\n</code></pre> <p>Con respecto a la complejidad, hay que revisar \\(N\\) sensores.</p> <p>Para cada sensor hay que localizar su lista de sensores en el diccionario: <code>get()</code>.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a \\(N\\), la complejidad es \\(O(1)\\). De lo contrario, ser\u00e1 \\(O(n)\\).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es \\(O(1)\\).</p> <p>Cada lista, de \\(X\\) elementos, hay que ordenarla. Si usamos un algoritmo de inserci\u00f3n como el de arriba, por t\u00e9rmino medio ser\u00e1 la ordenaci\u00f3n de un array de \\(x\\) elementos: \\(O(x2)\\):</p> <ol> <li> <p>Podemos pensar que \\(X\\) sea constante, independientemente de \\(N\\), en cuyo caso la ordenaci\u00f3n ser\u00e1 de tiempo constante, \\(O(1)\\);</p> </li> <li> <p>Podemos pensar que \\(X\\) sea proporcional a \\(N\\), en cuyo caso la ordenaci\u00f3n ser\u00e1 una proporci\u00f3n de \\(N\\): \\(O(n2)\\).</p> </li> </ol> <p>Nos quedamos con \\(f\\) elementos: \\(O(1)\\).</p> <p>Y hacemos una operaci\u00f3n <code>put()</code> en el diccionario de salida.</p> <p>Si el n\u00famero de ranuras es sensiblemente superior a \\(N\\), la complejidad es \\(O(1)\\). De lo contrario, ser\u00e1 \\(O(n)\\).</p> <p>Seguimos en el supuesto de que esta operaci\u00f3n es \\(O(1)\\).</p> <p>En el caso 1, el total es \\(N \u00d7 (O(1) + O(1) + O(1) + O(1)) \\rightarrow N \u00d7 O(1) \\rightarrow O(n)\\).</p> <p>En el caso 2, el total es \\(N \u00d7 (O(1) + O(n2) + O(1) + O(1)) \\rightarrow N \u00d7 O(n2) \\rightarrow O(n3)\\).</p> <p>Resumiendo, si el n\u00famero de sensores dentro del alcance es independiente de \\(N\\), la complejidad es \\(O(n)\\). Si el n\u00famero de sensores dentro del alcance es proporcional a \\(N\\), la complejidad depende del algoritmo de ordenaci\u00f3n.</p>","tags":["complejidad"]},{"location":"exams/2016/p1_ex02/","title":"P1 ex02","text":"<ul> <li>(a) (1 punto) Modifique la clase <code>Sensor</code> para que se pueda integrar en una hebra que comparta informaci\u00f3n con los sensores cercanos cada 30s. Para ello se puede implementar la interfaz <code>Runnable</code>.</li> </ul> <pre><code>public class Sensor implements Runnable {\n    // ...\n    private Red red;\n    private int medida; // valor le\u00eddo por el sensor\n\n    public Sensor(String id, int x, int y, Red red) {\n        this.red = red;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                // transmitir la lectura cada 30 segundos\n                red.transmitir(this, medida);\n                Thread.sleep(30000); // 30 s\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>Para implementar la interfaz <code>Runnable</code> espreciso redefinir el m\u00e9todo <code>run()</code>: <pre><code>@Override\npublic void run() {\n    while (true) {\n        try {\n            sleep(30000);\n        } catch (InterruptedException ignored) {\n        }\n\n        for (Sensor s : red.cercanos(f).get(this)) {\n            red.enviar(s, medida);\n        }\n    }\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Escriba una l\u00ednea de c\u00f3digo java para arrancar una hebra que ejecute el c\u00f3digo concurrente de Sensor.</li> </ul> Mostrar soluci\u00f3n <p>Para arrancar una hebra que ejecute el m\u00e9todo <code>run()</code> anterior hay que crear la hebra a partir del <code>Runnable</code> y hacer <code>start()</code>: <pre><code>new Thread(new Sensor()).start();\n</code></pre> o alternativamente: <pre><code>Runnable sensor = new Sensor(\u2026);\nThread tread = new Thread(sensor);\nthread.start();\n</code></pre></p> <ul> <li>(c) (1 punto) En el puesto de mando y control, un servidor ejecuta un programa basado en la clase <code>Red</code> de las preguntas anteriores, y recibe peticiones de los operadores locales y de los muchos sensores distribuidos por Madrid. Modifique la clase <code>Red</code> para que pueda atender cargas, recargas y peticiones concurrentes sin problemas de concurrencia.</li> </ul> <p>NOTAS:</p> <ol> <li>Suponga que el valor medido por el sensor (medida) se actualiza autom\u00e1ticamente por alg\u00fan mecanismo que no es relevante para examen.</li> <li>Suponga que la clase <code>Red</code> incluye el m\u00e9todo <pre><code>public void enviar (Sensor destino, int medida) {\u2026}\n</code></pre></li> </ol> Mostrar soluci\u00f3n <p>Para que la clase <code>Red</code> se pueda usar de forma segura desde varias hebras es preciso convertirla en un monitor. Como no tiene atributos p\u00fablicos basta para ello con sincronizar todos sus m\u00e9todos p\u00fablicos: <pre><code>public class Red {\n    private Diccionario diccionario = new DiccionarioImpl();\n\n    public synchronized void cargar(List&lt;Sensor&gt; sensores, double d0) {\n        // ...\n    }\n\n    public synchronized Map&lt;Sensor, List&lt;Sensor&gt;&gt; cercanos(int f) {\n        // ...\n        return null;\n    }\n\n    public synchronized void enviar(Sensor destino, int medida) {\n        // ...\n    }\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2016/p1r/","title":"Examen 2016 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2016/p1r/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un algoritmo que, dado un array de enteros, calcule cu\u00e1l es el n\u00famero que se repite m\u00e1s veces. As\u00ed, si el array contiene {2, 4, 3, 4, 2, 6, 1, 4, 4}, el algoritmo devuelve 4. Si hay empate, devuelve el primer valor. Se pide:</p> <ul> <li>(a) (1 punto) Escribir un m\u00e9todo en Java que compute el algoritmo descrito. Si el array est\u00e1 vac\u00edo o es nulo, se lanzar\u00e1 una excepci\u00f3n. La cabecera del m\u00e9todo debe ser:</li> </ul> <pre><code>int mayoria (int []v) throws exception\n</code></pre> Mostrar soluci\u00f3n <p>Hay varias posibles soluciones:</p> <ol> <li>Hacer un histograma, eligiendo el valor mayor seg\u00fan se cuenta;</li> <li>Ordenar el array y contar repeticiones sucesivas.</li> </ol> <p>Se incluye la soluci\u00f3n 1, almacenando el histograma en un <code>Map</code>. Una posible soluci\u00f3n es: <pre><code>public static int mayoria(int[] v) throws Exception {\n    if (v == null || v.length == 0)\n        throw new IllegalArgumentException(\"mayoria: invalid argument\");\n\n    Map&lt;Integer, Integer&gt; histograma = new HashMap&lt;Integer, Integer&gt;();\n    int masRep = v[0];        // candidato inicial\n    int repeticiones = 1;    // aparece una vez\n\n    for (int i = 0; i &lt; v.length; i++) {\n        Integer veces = histograma.get(v[i]);\n        veces = (veces == null) ? 1 : veces + 1;\n        histograma.put(v[i], veces);\n\n        if (veces &gt; repeticiones) {\n            repeticiones = veces;\n            masRep = v[i];\n        }\n    }\n    return masRep;\n}\n</code></pre></p> <p>Se desea calcular la complejidad del m\u00e9todo del apartado anterior. Se pide:</p> <ul> <li>(b) (1 punto) \u00bfCu\u00e1l es la ecuaci\u00f3n de recurrencia?</li> </ul> Mostrar soluci\u00f3n <p>\\(T(n) = T(n-1) + c\\) si \\(n &gt; 1\\)</p> <p>\\(T(0) = d\\)</p> <ul> <li>(c) (1 punto) Determinar su complejidad.</li> </ul> Mostrar soluci\u00f3n <p>Se puede resolver la ecuaci\u00f3n de (b) o razonar de la siguiente forma:</p> <p>Las instrucciones sencillas (<code>if</code>, asignaciones, acceso al array) son constantes \\(O(1)\\).</p> <p>El acceso al <code>Map</code> (<code>get</code> y <code>put</code>) podemos considerarlo tambi\u00e9n constante en condiciones adecuadas de carga.</p> <p>S\u00f3lo el bucle for depende de \\(n\\), procesando cada elemento una \u00fanica vez, ergo es de complejidad \\(O(n)\\).</p> <p>Como \\(O(1) \\subset O(n)\\), el resultado es que el algoritmo es de complejidad \\(O(n)\\).</p> <p>Comentarios adicionales:</p> <ul> <li>No puede existir un algoritmo mejor que \\(O(n)\\) porque al menos hay que ver cada elemento una vez;</li> <li>Se puede tener un algoritmo \\(O(n^2)\\) si con un <code>for</code> vamos viendo cada elemento, y para cada elemento contamos el n\u00famero de repeticiones recorriendo el array (<code>for</code> dentro de <code>for</code>);</li> <li>el \\(O(n log n)\\) se obtiene en varias circunstancias:<ul> <li>suponiendo un algoritmo de ordenaci\u00f3n de esa complejidad.</li> <li>usando un \u00e1rbol binario de b\u00fasqueda para almacenar el histograma.</li> </ul> </li> </ul>"},{"location":"exams/2016/p1r/#problema-2","title":"Problema 2","text":"<p>Una aplicaci\u00f3n m\u00f3vil registra la actividad de un senderista. Cuando empieza una caminata, la aplicaci\u00f3n guarda la fecha (de comienzo del paseo) y una lista de coordenadas en el plano <code>(x, y)</code>, obtenidas cada segundo. Cuando el senderista termina su actividad, la aplicaci\u00f3n manda a un servidor la siguiente informaci\u00f3n: nombre completo del senderista (<code>String</code>), fecha de comienzo de la actividad (<code>Date</code>) y la lista de coordenadas recorridas.</p> <p>El servidor, escrito en Java, guarda para cada senderista, todas las rutas que haya recorrido. Para ello, dispone de un diccionario donde la clave es el nombre del senderista y el valor es una lista de todas las rutas recorridas por dicho senderista.</p> <p>Se dispone de las siguientes declaraciones:</p> <pre><code>public class Coordenada {\n    private double x, y;\n    // constructor, getters y setters al uso\n\n    public double distancia(Coordenada b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n\npublic class Servidor {\n    private Diccionario rutas = new /* implementaci\u00f3n */;\n\n    public void anadir(String senderista, Ruta ruta) {\n        // ...\n    }\n\n    public String campeon() {\n        // ...\n        return null;\n    }\n}\n\npublic class Ruta {\n    private Date fechaComienzo;\n    private List&lt;Coordenada&gt; puntos;\n    // constructor, getters y setters al uso\n\n    public double longitud() {\n        // ...\n        return 0.0;\n    }\n}\n</code></pre> <ul> <li>(a) (1 punto) Codificar el m\u00e9todo a\u00f1adir.</li> </ul> Mostrar soluci\u00f3n <p>Como se usa un diccionario, es necesario que tengamos una lista de senderistas registrados. Por ello queda: <pre><code>// rutas de cada senderista\nprivate Diccionario rutasPorSenderista = new DiccionarioHashMap(1000);\n// tambi\u00e9n vale:\n// private Map&lt;String, List&lt;Ruta&gt;&gt; rutasPorSenderista = new HashMap&lt;&gt;();\n\n// senderistas registrados, puede evitarse a\u00f1adiendo keySet() a Diccionario\nprivate List&lt;String&gt; lsenderistas = new ArrayList&lt;String&gt;();\n\npublic void anadir(String senderista, Ruta ruta) {\n    List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n\n    if (lr == null) { // senderista no registrado\n        lsenderistas.add(senderista);\n        lr = new ArrayList&lt;Ruta&gt;();\n    }\n\n    lr.add(ruta);\n    rutasPorSenderista.put(senderista, lr);\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Codificar un m\u00e9todo de la clase <code>Ruta</code> que calcule la longitud total del recorrido (m\u00e9todo longitud de la clase <code>Ruta</code>).</li> </ul> Mostrar soluci\u00f3n <pre><code>public double longitud() {\n    double total = 0;\n\n    if (puntos == null || puntos.size() &lt; 2) { // \u00bfno hay puntos?\n        return 0;\n    }\n\n    Coordenada ant = puntos.get(0);\n    for (int i = 1; i &lt; puntos.size(); i++) {\n        Coordenada sig = puntos.get(i);\n        total += ant.distancia(sig);\n        ant = sig;\n    }\n\n    return total;\n}\n</code></pre> <ul> <li>(c) (2 puntos) Codificar un m\u00e9todo de la clase <code>Servidor</code> que determine qu\u00e9 senderista ha recorrido m\u00e1s distancia en total, sumando todas sus rutas (m\u00e9todo <code>campeon</code> de la clase <code>Servidor</code>). En caso de empate, puede devolver cualquiera.</li> </ul> Mostrar soluci\u00f3n <p><code>campeon</code> usa un m\u00e9todo auxiliar para averiguar la la suma de longitudes de las rutas de un usuario: <pre><code>public String campeon() {\n    String champ = null;\n    double maxLong = -1;\n\n    // tambi\u00e9n:\n    // for (String senderista : rutasPorSenderista.keySet())\n    for (String senderista : lsenderistas) {\n        List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n        double mayorCamino = sumaTotal(lr);\n\n        if (mayorCamino &gt; maxLong) {\n            maxLong = mayorCamino;\n            champ = senderista;\n        }\n    }\n    return champ;\n}\n\nprivate double sumaTotal(List&lt;Ruta&gt; lr) {\n    double suma = 0;\n    for (Ruta r : lr)\n        suma += r.longitud();\n    return suma;\n}\n</code></pre></p>"},{"location":"exams/2016/p1r/#problema-3","title":"Problema 3","text":"<p>Sea un un sistema de gesti\u00f3n de turnos en un supermercado. Los usuarios, con el tel\u00e9fono inteligente, piden n\u00famero al gestor de turnos, y pueden preguntar en cualquier momento por el turno actual. Los dependientes, con unos botones que hay en los mostradores, hacen avanzar el turno actual.</p> <p>Hay un gestor central que coordina las peticiones y avances para que no haya duplicidades ni se pierda ning\u00fan turno. Su esquema es:</p> <pre><code>class Gestor {\n    // devuelve turnos correlativos 1, 2, 3, ...\n    public int getTurno() { \u2026 }\n\n    // avanza el turno al n\u00famero siguiente\n    public void avanzaTurno() { \u2026 }\n\n    // dice en qu\u00e9 turno estamos\n    public int getActual() { \u2026 }\n}\n</code></pre> <ul> <li>(a) (1,5 puntos) Complete la clase <code>Gestor</code>, teniendo en cuenta que debe poder recibir llamadas concurrentes de clientes y dependientes.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Gestor {\n    private int turno = 0;\n    private int actual = 0;\n\n    // devuelve turnos correlativos 1, 2, 3, ...\n    public synchronized int getTurno() {\n        turno++;\n        return turno;\n    }\n\n    // avanza el turno al n\u00famero siguiente\n    public synchronized void avanzaTurno() {\n        if (actual &lt;= turno)\n            actual++;\n    }\n\n    // dice en qu\u00e9 turno estamos\n    public synchronized int getActual() {\n        return actual;\n    }\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Escriba el c\u00f3digo de una clase <code>Cliente</code> que defina una hebra (<code>thread</code>) que efect\u00fae las siguientes operaciones: </li> </ul> <ol> <li> Pide turno; </li> <li> Cada 10s consulta el turno actual; </li> <li> Si faltan menos de 5 turnos hace `BIP()`; </li> <li> Si le toca el turno hace `BIP(); BIP();`; </li> <li> Si se ha pasado el turno termina la ejecuci\u00f3n de la hebra. </li> </ol> <p>NOTAS:</p> <ul> <li>Suponga que el m\u00e9todo <code>BIP()</code> est\u00e1 disponible directamente en la plataforma de ejecuci\u00f3n</li> <li>El m\u00e9todo <code>avanzaTurno</code> no debe incrementar el n\u00famero de turno m\u00e1s all\u00e1 del \u00faltimo n\u00famero emitido. Por ejemplo, si el \u00faltimo n\u00famero devuelto por <code>getTurno</code> es el <code>41</code>, el m\u00e9todo <code>avanzaTurno</code> puede llegar a <code>42</code>, pero no puede avanzar a <code>43</code>.</li> <li>Los m\u00e9todos de <code>Gestor</code> devuelven el control inmediatamente, sin esperas.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Cliente extends Thread {\n    private Gestor gestor;\n\n    public Cliente(int id, Gestor gestor) {\n        this.gestor = gestor;\n    }\n\n    @Override\n    public void run() {\n        int turno = gestor.getTurno();\n        int actual;\n\n        do {\n            actual = gestor.getActual();\n\n            if (turno - actual &lt; 5)\n                BIP();\n\n            if (actual == turno) {\n                BIP();\n                break;\n            }\n\n            try {\n                sleep(10000);\n            } catch (InterruptedException ignored) {\n            }\n\n        } while (turno &gt; actual);\n    }\n}\n</code></pre>"},{"location":"exams/2016/p1r_ex01/","title":"P1r ex01","text":"<p>Se quiere desarrollar un algoritmo que, dado un array de enteros, calcule cu\u00e1l es el n\u00famero que se repite m\u00e1s veces. As\u00ed, si el array contiene {2, 4, 3, 4, 2, 6, 1, 4, 4}, el algoritmo devuelve 4. Si hay empate, devuelve el primer valor. Se pide:</p> <ul> <li>(a) (1 punto) Escribir un m\u00e9todo en Java que compute el algoritmo descrito. Si el array est\u00e1 vac\u00edo o es nulo, se lanzar\u00e1 una excepci\u00f3n. La cabecera del m\u00e9todo debe ser:</li> </ul> <pre><code>int mayoria (int []v) throws exception\n</code></pre> Mostrar soluci\u00f3n <p>Hay varias posibles soluciones:</p> <ol> <li>Hacer un histograma, eligiendo el valor mayor seg\u00fan se cuenta;</li> <li>Ordenar el array y contar repeticiones sucesivas.</li> </ol> <p>Se incluye la soluci\u00f3n 1, almacenando el histograma en un <code>Map</code>. Una posible soluci\u00f3n es: <pre><code>public static int mayoria(int[] v) throws Exception {\n    if (v == null || v.length == 0)\n        throw new IllegalArgumentException(\"mayoria: invalid argument\");\n\n    Map&lt;Integer, Integer&gt; histograma = new HashMap&lt;Integer, Integer&gt;();\n    int masRep = v[0];        // candidato inicial\n    int repeticiones = 1;    // aparece una vez\n\n    for (int i = 0; i &lt; v.length; i++) {\n        Integer veces = histograma.get(v[i]);\n        veces = (veces == null) ? 1 : veces + 1;\n        histograma.put(v[i], veces);\n\n        if (veces &gt; repeticiones) {\n            repeticiones = veces;\n            masRep = v[i];\n        }\n    }\n    return masRep;\n}\n</code></pre></p> <p>Se desea calcular la complejidad del m\u00e9todo del apartado anterior. Se pide:</p> <ul> <li>(b) (1 punto) \u00bfCu\u00e1l es la ecuaci\u00f3n de recurrencia?</li> </ul> Mostrar soluci\u00f3n <p>\\(T(n) = T(n-1) + c\\) si \\(n &gt; 1\\)</p> <p>\\(T(0) = d\\)</p> <ul> <li>(c) (1 punto) Determinar su complejidad.</li> </ul> Mostrar soluci\u00f3n <p>Se puede resolver la ecuaci\u00f3n de (b) o razonar de la siguiente forma:</p> <p>Las instrucciones sencillas (<code>if</code>, asignaciones, acceso al array) son constantes \\(O(1)\\).</p> <p>El acceso al <code>Map</code> (<code>get</code> y <code>put</code>) podemos considerarlo tambi\u00e9n constante en condiciones adecuadas de carga.</p> <p>S\u00f3lo el bucle for depende de \\(n\\), procesando cada elemento una \u00fanica vez, ergo es de complejidad \\(O(n)\\).</p> <p>Como \\(O(1) \\subset O(n)\\), el resultado es que el algoritmo es de complejidad \\(O(n)\\).</p> <p>Comentarios adicionales:</p> <ul> <li>No puede existir un algoritmo mejor que \\(O(n)\\) porque al menos hay que ver cada elemento una vez;</li> <li>Se puede tener un algoritmo \\(O(n^2)\\) si con un <code>for</code> vamos viendo cada elemento, y para cada elemento contamos el n\u00famero de repeticiones recorriendo el array (<code>for</code> dentro de <code>for</code>);</li> <li>el \\(O(n log n)\\) se obtiene en varias circunstancias:<ul> <li>suponiendo un algoritmo de ordenaci\u00f3n de esa complejidad.</li> <li>usando un \u00e1rbol binario de b\u00fasqueda para almacenar el histograma.</li> </ul> </li> </ul>","tags":["complejidad"]},{"location":"exams/2016/p1r_ex02/","title":"P1r ex02","text":"<p>Una aplicaci\u00f3n m\u00f3vil registra la actividad de un senderista. Cuando empieza una caminata, la aplicaci\u00f3n guarda la fecha (de comienzo del paseo) y una lista de coordenadas en el plano <code>(x, y)</code>, obtenidas cada segundo. Cuando el senderista termina su actividad, la aplicaci\u00f3n manda a un servidor la siguiente informaci\u00f3n: nombre completo del senderista (<code>String</code>), fecha de comienzo de la actividad (<code>Date</code>) y la lista de coordenadas recorridas.</p> <p>El servidor, escrito en Java, guarda para cada senderista, todas las rutas que haya recorrido. Para ello, dispone de un diccionario donde la clave es el nombre del senderista y el valor es una lista de todas las rutas recorridas por dicho senderista.</p> <p>Se dispone de las siguientes declaraciones:</p> <pre><code>public class Coordenada {\n    private double x, y;\n    // constructor, getters y setters al uso\n\n    public double distancia(Coordenada b) {\n        int dx = Math.abs(x - b.x);\n        int dy = Math.abs(y - b.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n\npublic class Servidor {\n    private Diccionario rutas = new /* implementaci\u00f3n */;\n\n    public void anadir(String senderista, Ruta ruta) {\n        // ...\n    }\n\n    public String campeon() {\n        // ...\n        return null;\n    }\n}\n\npublic class Ruta {\n    private Date fechaComienzo;\n    private List&lt;Coordenada&gt; puntos;\n    // constructor, getters y setters al uso\n\n    public double longitud() {\n        // ...\n        return 0.0;\n    }\n}\n</code></pre> <ul> <li>(a) (1 punto) Codificar el m\u00e9todo a\u00f1adir.</li> </ul> Mostrar soluci\u00f3n <p>Como se usa un diccionario, es necesario que tengamos una lista de senderistas registrados. Por ello queda: <pre><code>// rutas de cada senderista\nprivate Diccionario rutasPorSenderista = new DiccionarioHashMap(1000);\n// tambi\u00e9n vale:\n// private Map&lt;String, List&lt;Ruta&gt;&gt; rutasPorSenderista = new HashMap&lt;&gt;();\n\n// senderistas registrados, puede evitarse a\u00f1adiendo keySet() a Diccionario\nprivate List&lt;String&gt; lsenderistas = new ArrayList&lt;String&gt;();\n\npublic void anadir(String senderista, Ruta ruta) {\n    List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n\n    if (lr == null) { // senderista no registrado\n        lsenderistas.add(senderista);\n        lr = new ArrayList&lt;Ruta&gt;();\n    }\n\n    lr.add(ruta);\n    rutasPorSenderista.put(senderista, lr);\n}\n</code></pre></p> <ul> <li>(b) (1 punto) Codificar un m\u00e9todo de la clase <code>Ruta</code> que calcule la longitud total del recorrido (m\u00e9todo longitud de la clase <code>Ruta</code>).</li> </ul> Mostrar soluci\u00f3n <pre><code>public double longitud() {\n    double total = 0;\n\n    if (puntos == null || puntos.size() &lt; 2) { // \u00bfno hay puntos?\n        return 0;\n    }\n\n    Coordenada ant = puntos.get(0);\n    for (int i = 1; i &lt; puntos.size(); i++) {\n        Coordenada sig = puntos.get(i);\n        total += ant.distancia(sig);\n        ant = sig;\n    }\n\n    return total;\n}\n</code></pre> <ul> <li>(c) (2 puntos) Codificar un m\u00e9todo de la clase <code>Servidor</code> que determine qu\u00e9 senderista ha recorrido m\u00e1s distancia en total, sumando todas sus rutas (m\u00e9todo <code>campeon</code> de la clase <code>Servidor</code>). En caso de empate, puede devolver cualquiera.</li> </ul> Mostrar soluci\u00f3n <p><code>campeon</code> usa un m\u00e9todo auxiliar para averiguar la la suma de longitudes de las rutas de un usuario: <pre><code>public String campeon() {\n    String champ = null;\n    double maxLong = -1;\n\n    // tambi\u00e9n:\n    // for (String senderista : rutasPorSenderista.keySet())\n    for (String senderista : lsenderistas) {\n        List&lt;Ruta&gt; lr = (List&lt;Ruta&gt;) rutasPorSenderista.get(senderista);\n        double mayorCamino = sumaTotal(lr);\n\n        if (mayorCamino &gt; maxLong) {\n            maxLong = mayorCamino;\n            champ = senderista;\n        }\n    }\n    return champ;\n}\n\nprivate double sumaTotal(List&lt;Ruta&gt; lr) {\n    double suma = 0;\n    for (Ruta r : lr)\n        suma += r.longitud();\n    return suma;\n}\n</code></pre></p>","tags":["???"]},{"location":"exams/2016/p1r_ex03/","title":"P1r ex03","text":"<p>Sea un un sistema de gesti\u00f3n de turnos en un supermercado. Los usuarios, con el tel\u00e9fono inteligente, piden n\u00famero al gestor de turnos, y pueden preguntar en cualquier momento por el turno actual. Los dependientes, con unos botones que hay en los mostradores, hacen avanzar el turno actual.</p> <p>Hay un gestor central que coordina las peticiones y avances para que no haya duplicidades ni se pierda ning\u00fan turno. Su esquema es:</p> <pre><code>class Gestor {\n    // devuelve turnos correlativos 1, 2, 3, ...\n    public int getTurno() { \u2026 }\n\n    // avanza el turno al n\u00famero siguiente\n    public void avanzaTurno() { \u2026 }\n\n    // dice en qu\u00e9 turno estamos\n    public int getActual() { \u2026 }\n}\n</code></pre> <ul> <li>(a) (1,5 puntos) Complete la clase <code>Gestor</code>, teniendo en cuenta que debe poder recibir llamadas concurrentes de clientes y dependientes.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Gestor {\n    private int turno = 0;\n    private int actual = 0;\n\n    // devuelve turnos correlativos 1, 2, 3, ...\n    public synchronized int getTurno() {\n        turno++;\n        return turno;\n    }\n\n    // avanza el turno al n\u00famero siguiente\n    public synchronized void avanzaTurno() {\n        if (actual &lt;= turno)\n            actual++;\n    }\n\n    // dice en qu\u00e9 turno estamos\n    public synchronized int getActual() {\n        return actual;\n    }\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Escriba el c\u00f3digo de una clase <code>Cliente</code> que defina una hebra (<code>thread</code>) que efect\u00fae las siguientes operaciones: </li> </ul> <ol> <li> Pide turno; </li> <li> Cada 10s consulta el turno actual; </li> <li> Si faltan menos de 5 turnos hace `BIP()`; </li> <li> Si le toca el turno hace `BIP(); BIP();`; </li> <li> Si se ha pasado el turno termina la ejecuci\u00f3n de la hebra. </li> </ol> <p>NOTAS:</p> <ul> <li>Suponga que el m\u00e9todo <code>BIP()</code> est\u00e1 disponible directamente en la plataforma de ejecuci\u00f3n</li> <li>El m\u00e9todo <code>avanzaTurno</code> no debe incrementar el n\u00famero de turno m\u00e1s all\u00e1 del \u00faltimo n\u00famero emitido. Por ejemplo, si el \u00faltimo n\u00famero devuelto por <code>getTurno</code> es el <code>41</code>, el m\u00e9todo <code>avanzaTurno</code> puede llegar a <code>42</code>, pero no puede avanzar a <code>43</code>.</li> <li>Los m\u00e9todos de <code>Gestor</code> devuelven el control inmediatamente, sin esperas.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Cliente extends Thread {\n    private Gestor gestor;\n\n    public Cliente(int id, Gestor gestor) {\n        this.gestor = gestor;\n    }\n\n    @Override\n    public void run() {\n        int turno = gestor.getTurno();\n        int actual;\n\n        do {\n            actual = gestor.getActual();\n\n            if (turno - actual &lt; 5)\n                BIP();\n\n            if (actual == turno) {\n                BIP();\n                break;\n            }\n\n            try {\n                sleep(10000);\n            } catch (InterruptedException ignored) {\n            }\n\n        } while (turno &gt; actual);\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2016/p2/","title":"Examen 2016 \u2014 Parcial 2","text":""},{"location":"exams/2016/p2/#problema-1","title":"Problema 1","text":"<p>En un programa existe una zona cr\u00edtica especial, llam\u00e9mosla \u201csupersticiosa\u201d, en la que puede haber cualquier n\u00famero de hebras, siempre que no sean trece.</p> <ul> <li>(a) (5 puntos) Se pide realizar una clase sincronizada (seg\u00fan el esquema que da a continuaci\u00f3n) que realice tal protocolo de sincronizaci\u00f3n. Para simplificar el c\u00f3digo, no tenga en cuenta la excepci\u00f3n que pueda presentarse en la operaci\u00f3n <code>wait()</code>.</li> </ul> <pre><code>package es.upm.dit.adsw.super;\n\npublic class Supersticiosa {\n    // ...\n\n    // quiero entrar en la zona cr\u00edtica\n    public synchronized void entrar() {\n        // ...\n    }\n\n    // quiero salir de la zona cr\u00edtica\n    public synchronized void salir() {\n        // ...\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>package es.upm.dit.adsw.super;\n\npublic class Supersticioso {\n    // n\u00famero de peticiones de entrada a la R.C.\n    // menos n\u00famero de peticiones de salida de la R.C.\n    private int n = 0;\n\n    // quiero entrar en la zona cr\u00edtica\n    public synchronized void entrar() {\n        n++;\n        while (n == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        notifyAll();\n    }\n\n    // quiero salir de la zona cr\u00edtica\n    public synchronized void salir() {\n        n--;\n        while (n == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        notifyAll();\n    }\n}\n</code></pre> <p>Otra posible soluci\u00f3n para una interpretaci\u00f3n diferente del enunciado es:</p> <pre><code>public class Supersticioso {\n    private int nDentro = 0;\n\n    public synchronized void entrar() {\n        while (nDentro + 1 == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        nDentro++;\n    }\n\n    public synchronized void salir() {\n        nDentro--;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2016/p2/#problema-2","title":"Problema 2","text":"<p>Queremos ampliar la pr\u00e1ctica 7-8 de forma que junto con el detalle de cada noticia, cada usuario pueda valorarla o hacer un comentario. No necesita el c\u00f3digo de la pr\u00e1ctica para realizar este problema.</p> <p>A continuaci\u00f3n se le muestra una secuencia del uso de la nueva pantalla. El usuario parte de <code>DetailActivity</code>, donde ve la noticia (t\u00edtulo y descripci\u00f3n) y aparecen los comentarios y la puntuaci\u00f3n vac\u00edos, junto con dos botones ('Comentar' y 'Puntuar').</p> <p>Si pincha en 'Comentar', va a la segunda pantalla (<code>ComentarActivity</code>), donde rellena el comentario y puede dar a 'Guardar' o 'Cancelar'. En ambos casos volver\u00e1 a <code>DetailActivity</code>. En la imagen se muestra c\u00f3mo ha pulsado 'Guardar' y se muestra el comentario que el usuario ha introducido en <code>DetailActivity</code>.</p> <p></p> <p>A continuaci\u00f3n, suponemos que el usuario da a 'Puntuar', en que introduce una puntaci\u00f3n, y tiene las mismas opciones que en <code>ComentarActivity</code>. Suponemos que ha pulsado 'Guardar' y vuelve a <code>DetailActivity</code>, donde se muestra la puntaci\u00f3n asignada.</p> <p></p> <ul> <li>(a) (5 puntos) Se pide que programe el c\u00f3digo necesario para que <code>DetailActivity</code> tenga el nuevo bot\u00f3n 'Comentar' y realice la funcionalidad descrita cuando se pincha en dicho bot\u00f3n:</li> </ul> <ol> <li> Muestre una pantalla `ComentarActivity`; </li> <li> Si el usuario pulsa 'Guardar' en dicha pantalla, se vuelve a `DetailActivity` y se muestra el comentario escrito en la pantalla, junto con la traza informativa \u201cNuevo comentario\u201d; </li> <li> Si el usuario pulsa 'Cancelar' en dicha pantalla, se vuelve a `DetailActivity` y se muestra un `Toast` y una traza informativa con el contenido \u201cEl usuario no ha hecho comentarios\u201d. </li> </ol> <p>Nota: Suponga que est\u00e1n programados ya todos los <code>layouts</code>, as\u00ed como las clases <code>ComentarActivity</code> y <code>PuntuarActivity</code>. Use las variables que necesite indicando d\u00f3nde estar\u00edan definidas.</p> Mostrar soluci\u00f3n <pre><code>public class DetailActivity extends AppCompatActivity {\n    private static final String TAG = DetailActivity.class.getName();\n    private static final int COMENTAR = 0;\n    private static final int PUNTUAR = 1;\n\n    private TextView comentarioTextView;\n    private RssContent.EntryRss entry;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_detail);\n\n        Bundle extras = getIntent().getExtras();\n        if (extras == null) {\n            Log.e(TAG, \"Fallo - Deber\u00eda recibir la noticia\");\n            finish();\n        }\n\n        entry = (RssContent.EntryRss) extras.getSerializable(\"entry\");\n        if (entry == null) {\n            Log.e(TAG, \"Entry mal recuperado\");\n            finish();\n        }\n\n        comentarioTextView = (TextView) findViewById(R.id.comentario);\n        comentarioTextView.setText(entry.comentario);\n\n        Button botonComentar = (Button) findViewById(R.id.comentar);\n        botonComentar.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Log.d(TAG, \"Comentar\");\n                Intent i = new Intent(DetailActivity.this, ComentarActivity.class);\n                i.putExtra(\"titulo\", entry.title);\n                startActivityForResult(i, COMENTAR);\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int reqCode, int resultCode, Intent data) {\n        switch (reqCode) {\n            case COMENTAR: {\n                if (resultCode == RESULT_OK) {\n                    Log.i(TAG, \"Nuevo comentario\");\n                    Bundle extras = data.getExtras();\n                    String comentario = extras.getString(\"comentario\");\n                    comentarioTextView.setText(comentario);\n                    entry.comentario = comentario;\n                    RssContent.modifyEntryRss(entry); // almaceno cambio\n                } else {\n                    String msg = \"El usuario no ha hecho comentarios\";\n                    Log.i(TAG, msg);\n                    Toast.makeText(getBaseContext(), msg, Toast.LENGTH_SHORT).show();\n                }\n                break;\n            }\n            case PUNTUAR: {\n                break;\n            }\n            default:\n                Log.e(TAG, \"Acci\u00f3n inesperada\");\n                finish();\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2016/p2_ex01/","title":"P2 ex01","text":"<p>En un programa existe una zona cr\u00edtica especial, llam\u00e9mosla \u201csupersticiosa\u201d, en la que puede haber cualquier n\u00famero de hebras, siempre que no sean trece.</p> <ul> <li>(a) (5 puntos) Se pide realizar una clase sincronizada (seg\u00fan el esquema que da a continuaci\u00f3n) que realice tal protocolo de sincronizaci\u00f3n. Para simplificar el c\u00f3digo, no tenga en cuenta la excepci\u00f3n que pueda presentarse en la operaci\u00f3n <code>wait()</code>.</li> </ul> <pre><code>package es.upm.dit.adsw.super;\n\npublic class Supersticiosa {\n    // ...\n\n    // quiero entrar en la zona cr\u00edtica\n    public synchronized void entrar() {\n        // ...\n    }\n\n    // quiero salir de la zona cr\u00edtica\n    public synchronized void salir() {\n        // ...\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>package es.upm.dit.adsw.super;\n\npublic class Supersticioso {\n    // n\u00famero de peticiones de entrada a la R.C.\n    // menos n\u00famero de peticiones de salida de la R.C.\n    private int n = 0;\n\n    // quiero entrar en la zona cr\u00edtica\n    public synchronized void entrar() {\n        n++;\n        while (n == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        notifyAll();\n    }\n\n    // quiero salir de la zona cr\u00edtica\n    public synchronized void salir() {\n        n--;\n        while (n == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        notifyAll();\n    }\n}\n</code></pre> <p>Otra posible soluci\u00f3n para una interpretaci\u00f3n diferente del enunciado es:</p> <pre><code>public class Supersticioso {\n    private int nDentro = 0;\n\n    public synchronized void entrar() {\n        while (nDentro + 1 == 13) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        nDentro++;\n    }\n\n    public synchronized void salir() {\n        nDentro--;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2016/p2_ex02/","title":"P2 ex02","text":"<p>Queremos ampliar la pr\u00e1ctica 7-8 de forma que junto con el detalle de cada noticia, cada usuario pueda valorarla o hacer un comentario. No necesita el c\u00f3digo de la pr\u00e1ctica para realizar este problema.</p> <p>A continuaci\u00f3n se le muestra una secuencia del uso de la nueva pantalla. El usuario parte de <code>DetailActivity</code>, donde ve la noticia (t\u00edtulo y descripci\u00f3n) y aparecen los comentarios y la puntuaci\u00f3n vac\u00edos, junto con dos botones ('Comentar' y 'Puntuar').</p> <p>Si pincha en 'Comentar', va a la segunda pantalla (<code>ComentarActivity</code>), donde rellena el comentario y puede dar a 'Guardar' o 'Cancelar'. En ambos casos volver\u00e1 a <code>DetailActivity</code>. En la imagen se muestra c\u00f3mo ha pulsado 'Guardar' y se muestra el comentario que el usuario ha introducido en <code>DetailActivity</code>.</p> <p></p> <p>A continuaci\u00f3n, suponemos que el usuario da a 'Puntuar', en que introduce una puntaci\u00f3n, y tiene las mismas opciones que en <code>ComentarActivity</code>. Suponemos que ha pulsado 'Guardar' y vuelve a <code>DetailActivity</code>, donde se muestra la puntaci\u00f3n asignada.</p> <p></p> <ul> <li>(a) (5 puntos) Se pide que programe el c\u00f3digo necesario para que <code>DetailActivity</code> tenga el nuevo bot\u00f3n 'Comentar' y realice la funcionalidad descrita cuando se pincha en dicho bot\u00f3n:</li> </ul> <ol> <li> Muestre una pantalla `ComentarActivity`; </li> <li> Si el usuario pulsa 'Guardar' en dicha pantalla, se vuelve a `DetailActivity` y se muestra el comentario escrito en la pantalla, junto con la traza informativa \u201cNuevo comentario\u201d; </li> <li> Si el usuario pulsa 'Cancelar' en dicha pantalla, se vuelve a `DetailActivity` y se muestra un `Toast` y una traza informativa con el contenido \u201cEl usuario no ha hecho comentarios\u201d. </li> </ol> <p>Nota: Suponga que est\u00e1n programados ya todos los <code>layouts</code>, as\u00ed como las clases <code>ComentarActivity</code> y <code>PuntuarActivity</code>. Use las variables que necesite indicando d\u00f3nde estar\u00edan definidas.</p> Mostrar soluci\u00f3n <pre><code>public class DetailActivity extends AppCompatActivity {\n    private static final String TAG = DetailActivity.class.getName();\n    private static final int COMENTAR = 0;\n    private static final int PUNTUAR = 1;\n\n    private TextView comentarioTextView;\n    private RssContent.EntryRss entry;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_detail);\n\n        Bundle extras = getIntent().getExtras();\n        if (extras == null) {\n            Log.e(TAG, \"Fallo - Deber\u00eda recibir la noticia\");\n            finish();\n        }\n\n        entry = (RssContent.EntryRss) extras.getSerializable(\"entry\");\n        if (entry == null) {\n            Log.e(TAG, \"Entry mal recuperado\");\n            finish();\n        }\n\n        comentarioTextView = (TextView) findViewById(R.id.comentario);\n        comentarioTextView.setText(entry.comentario);\n\n        Button botonComentar = (Button) findViewById(R.id.comentar);\n        botonComentar.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Log.d(TAG, \"Comentar\");\n                Intent i = new Intent(DetailActivity.this, ComentarActivity.class);\n                i.putExtra(\"titulo\", entry.title);\n                startActivityForResult(i, COMENTAR);\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int reqCode, int resultCode, Intent data) {\n        switch (reqCode) {\n            case COMENTAR: {\n                if (resultCode == RESULT_OK) {\n                    Log.i(TAG, \"Nuevo comentario\");\n                    Bundle extras = data.getExtras();\n                    String comentario = extras.getString(\"comentario\");\n                    comentarioTextView.setText(comentario);\n                    entry.comentario = comentario;\n                    RssContent.modifyEntryRss(entry); // almaceno cambio\n                } else {\n                    String msg = \"El usuario no ha hecho comentarios\";\n                    Log.i(TAG, msg);\n                    Toast.makeText(getBaseContext(), msg, Toast.LENGTH_SHORT).show();\n                }\n                break;\n            }\n            case PUNTUAR: {\n                break;\n            }\n            default:\n                Log.e(TAG, \"Acci\u00f3n inesperada\");\n                finish();\n        }\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2017/extra/","title":"Examen 2017 - Extraordinario","text":""},{"location":"exams/2017/extra/#problema-1","title":"Problema 1","text":"<p>A pesar de que un genoma tiene m\u00e1s de dos gigas de (solo cuatro tipos distintos de) bases (A, G, C, T), la mayor parte del mismo es \u201cbasura\u201d, pues solo una peque\u00f1a fracci\u00f3n de subsecuencias (contiguas) del mismo codifica la producci\u00f3n de amino\u00e1cidos, es decir, prote\u00ednas. A esas subsecuencias significativas de bases se les conoce con el nombre de genes.</p> <p>Las subsecuencias que constituyen genes son de longitud moderada, entre cien y mil bases, y tienen la caracter\u00edstica de que al menos una de las cuatro bases se presenta en dicha subsecuencia con (mucha) menor frecuencia que las otras tres. Digamos, por ejemplo, 20 por ciento menos. Interpretado este porcentaje sobre el n\u00famero total de bases de la subsecuencia considerada.</p> <ul> <li>(a) (5 puntos) Se pide dise\u00f1ar un algoritmo (no un programa) que, a partir de un genoma especificado como una (muy) larga secuencia de bases, encuentre los genes de longitud 300 bases. Y a continuaci\u00f3n, analizar la complejidad en espacio y en tiempo de dicho algoritmo en t\u00e9rminos del tama\u00f1o del genoma.</li> </ul> Mostrar soluci\u00f3n <p>Se supone declarada una clase, llam\u00e9mosla <code>Contadores</code>, con cuatro atributos enteros de valor inicial cero, que se van a usar para contar del n\u00famero de cada tipo de base que hay, desde el principio del genoma hasta un punto dado. Y se supone tambi\u00e9n que tenemos un array, llam\u00e9mosle <code>ultimas300</code>, que mantiene el valor de los cuatro contadores para cada uno de los \u00faltimos 300 puntos del genoma que hemos visitado, seg\u00fan lo exploramos desde el principio hasta el final de su cadena de bases.</p> <p>El algoritmo es:</p> <ol> <li> <p>Ir leyendo de un fichero el genoma base a base desde el principio hasta su posici\u00f3n 299, actualizando los contadores de <code>ultimas300</code> en las posiciones 0-298.</p> </li> <li> <p>Leer la siguiente base del genoma, incrementar el contador correspondiente a esa base en la \u00faltima posici\u00f3n actualizada del array en una unidad, y guardar los cuatro valores actuales en la siguiente posici\u00f3n de <code>ultimas300</code>, manejando este array de manera circular (la posici\u00f3n siguiente a la 299 es la cero).</p> </li> <li> <p>Restar de los cuatro contadores actuales los contadores que est\u00e1n en el array 299 posiciones antes (de manera circular tambi\u00e9n). Si uno de esos cuatro valores es menor que 60 (=300/4*0.8), hemos encontrado un gen y lo imprimimos.</p> </li> <li> <p>Si a\u00fan quedan bases por leer en el genoma, volvemos al punto (2). En otro caso, hemos acabado el algoritmo.</p> </li> </ol> <p>La complejidad en espacio es constante, pues el tama\u00f1o de <code>ultimas300</code> es fijo, no depende del tama\u00f1o del genoma. En cuanto a la complejidad en tiempo, la parte (1) es tambi\u00e9n constante, ya que tampoco depende del tama\u00f1o del genoma. Mientras que las partes (2), (3) y (4) se ejecutan una vez por cada base del genoma (exceptuando las 299 primeras, valor constante). Y como resulta que esas tres partes tienen una complejidad constante, se tiene:</p> <p>\\(C1 + C2*O(n-299) + C3*O(n-299) + C4*O(n-299)\\)</p> <p>\\(= (C1 - 299*(C2+C3+C4)) + (C2+C3+C4)*O(n)\\)</p> <p>\\(= C5 + C6*O(n)\\) </p> <p>\\(= C6*O(n)\\) </p> <p>\\(= O(n)\\)</p> <p>Es decir, el algoritmo tiene una complejidad lineal en el tiempo.</p>"},{"location":"exams/2017/extra/#problema-2","title":"Problema 2","text":"<p>La clase <code>RegistroDatos</code> permite almacenar los datos producidos por un conjunto de sensores. Los datos producidos por los sensores se env\u00edan como objetos de la clase <code>Dato</code>, cuya estructura se muestra a continuaci\u00f3n:</p> <pre><code>public class Dato implements Comparable&lt;Dato&gt; {\n\n    private String id;   // Identificador \u00fanico del sensor que ha generado el dato\n    private Date d;      // Fecha en la que se ha producido el dato (clase Date de Java)\n    private long v;      // Valor del dato producido\n    ... //Contiene constructor, getters, y setters\n}\n</code></pre> <p>La clase <code>RegistroDatos</code> guarda los datos recibidos en un array <code>(private List&lt;Dato&gt; []datos)</code>. Cada dato se guarda en la posici\u00f3n del array que se obtiene aplicando el m\u00e9todo <code>hashCode</code> de la clase <code>String</code> al identificador \u00fanico del sensor que ha producido el dato y adaptando el resultado al tama\u00f1o del array datos. </p> <p>Adem\u00e1s, se lleva una cuenta del n\u00famero de datos que ha generado cada sensor, mediante el atributo <code>cuentaDatos</code> (<code>private Map &lt;String, Registro&gt; cuentaDatos</code>), usando como clave el identificador \u00fanico del sensor que ha producido el dato y como valor un objeto de la clase <code>Registro</code>, cuya estructura se muestra a continuaci\u00f3n:</p> <pre><code>public class Registro implements Comparable&lt;Registro&gt; {\n\n    private final String clave; // Identificador \u00fanico del sensor\n    private int cnt;            // N\u00famero de datos producidos por ese sensor\n    ... //Contiene constructor, getters, y setters\n}\n</code></pre> <ul> <li>(a) (5 puntos) Se pide completar los m\u00e9todos <code>Constructor</code>, <code>put</code>, <code>getDatos</code>, <code>size</code> y <code>countAbove</code> de la clase <code>RegistroDatos</code>. El esqueleto de la se muestra a continuaci\u00f3n:</li> </ul> <pre><code>public class RegistroDatos {\n    private List&lt;Dato&gt;[] datos;\n    private Map&lt;String, Registro&gt; cuentaDatos;\n\n    /**\n     * Constructor\n     * @param n n\u00famero de posiciones del array datos donde se van a almacenar\n     * los datos producidos por los sensores\n     */\n    public RegistroDatos(int n) {\n        //TODO\n    }\n\n    /**\n     * Devuelve cuantos sensores han producido un n\u00famero de datos por encima\n     * de un determinado umbral c.\n     * @param c umbral de cuenta.\n     * @return n\u00famero de sensores que han generado m\u00e1s de c datos\n     */\n    public int countAbove(int c) {\n        //TODO\n    }\n\n    /**\n     * Devuelve los datos producidos por un determinado sensor\n     * @param sensorId identificador del sensor\n     * @return lista de datos producidos por ese sensor.\n     * Si no hay ning\u00fan sensor con ese sensorId devolver\u00e1 una lista con 0 valores.\n     */\n    public List&lt;Dato&gt; getDatos(String sensorId) {\n        //TODO\n    }\n\n    /**\n     * Almacena un nuevo dato en el Registro de datos, para ello incrementa en uno la\n     * cuenta de datos\n     * proporcionados por el sensor, y almacena el dato en la posici\u00f3n correspondiente de\n     * la tabla Hash\n     * @param dato la nuevo dato a almacenar\n     */\n    private void put(Dato dato) {\n        //TODO\n    }\n\n    /**\n     * Numero de Datos total almacenado.\n     * @return numero de datos.\n     */\n    public int size() {\n        //TODO\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>public class RegistroDatos {\n    private List&lt;Dato&gt;[] datos;\n    private Map&lt;String, Registro&gt; cuentaDatos;\n\n    /**\n     * Constructor\n     * @param n n\u00famero de posiciones del array datos donde se van a almacenar\n     * los datos producidos por los sensores\n     */\n    public RegistroDatos(int n) {\n        this.datos = new List[N];\n        for (int i = 0; i &lt; N; i++) {\n            datos[i] = new ArrayList();\n        }\n        cuentaDatos = new HashMap&lt;String, Registro&gt;();\n    }\n\n    /**\n     * Devuelve cuantos sensores han producido un n\u00famero de datos por encima\n     * de un determinado umbral c.\n     * @param c umbral de cuenta.\n     * @return numero de sensores que han generado m\u00e1s de c datos\n     */\n    public int countAbove(int c) {\n        int cuenta = 0;\n        Set&lt;String&gt; keySet = cuentaDatos.keySet();\n        for (String key : keySet) {\n            if (cuentaDatos.get(key).getCnt() &lt; c)\n                cuenta++;\n        }\n        return cuenta;\n    }\n\n    /*\n     * Devuelve los datos producidos por un determinado sensor\n     * @param sensorId identificador del sensor\n     * @return lista de datos producidos por ese sensor.\n     * Si no hay ning\u00fan sensor con ese sensorId devolver\u00e1 una lista con 0 valores.\n     */\n    public List&lt;Dato&gt; getDatos(String sensorId) {\n        List&lt;Dato&gt; listaDatos = new ArrayList&lt;Dato&gt;();\n        int hc = sensorId.hashCode();\n        hc = hc % datos.length;\n        for (Dato d : datos[hc]) {\n            if (d.getId().equals(sensorId))\n                listaDatos.add(d);\n        }\n        return listaDatos;\n    }\n\n    /**\n     * El m\u00e9todo put (), se encarga de meter un nuevo dato en el Registro de datos,\n     * para ello incrementa en uno la cuenta de datos proporcionados por el sensor,\n     * y almacena el dato en la posici\u00f3n correspondiente de la tabla Hash\n     * @param dato la nuevo dato a almacenar\n     */\n    private void put(Dato dato) {\n        if (cuentaDatos.containsKey(dato.getId())) {\n            cuentaDatos.get(dato.getId()).inc();\n        } else {\n            cuentaDatos.put(dato.getId(), new Registro(dato.getId()));\n        }\n        int hc = dato.getId().hashCode();\n        hc = hc % datos.length;\n        datos[hc].add(dato);\n    }\n\n    /**\n     * Numero de Datos Total Almacenado.\n     * @return numero de datos.\n     */\n    public int size() {\n        int suma = 0;\n        Set&lt;String&gt; keySet = cuentaDatos.keySet();\n        for (String key : keySet) {\n            suma += cuentaDatos.get(key).getCnt();\n        }\n        return suma;\n    }\n}\n</code></pre>"},{"location":"exams/2017/extra/#problema-3","title":"Problema 3","text":"<p>Varios ingenieros utilizan una base de datos para almacenar informes. Para ello disponen de una aplicaci\u00f3n que permite almacenar un informe o recuperar un informe anterior. El acceso a los datos se organiza mediante una clase de Java que responde al esquema siguiente esquema:</p> <pre><code>public class Datos {\n\u2026\n    public \u2026 void guardar (String clave) {\u2026}\n    public \u2026 void consultar (String clave) {\u2026}\n    public \u2026 void terminar (String clave) {\u2026}\n}\n</code></pre> <p>Las aplicaciones se ejecutan concurrentemente, y llaman a <code>guardar</code> o a <code>consultar</code> antes de realizar una secuencia de operaciones de almacenar o recuperar informes, respectivamente. Cuando han terminado de realizar estas operaciones llaman a <code>terminar</code>. Puede haber varias aplicaciones consultando informes a la vez, pero no consultando y guardando, ni varias guardando a la vez.</p> <p>Los objetos de la clase <code>Ingeniero</code> son hebras que ejecutan repetidamente el siguiente c\u00f3digo:</p> <pre><code>datos.guardar(clave);\nfor (int i = 1; i &lt;= ndoc; i++) {\n    // generar informe y almacenarlo en la base de datos\n}\ndatos.terminar(clave);\n</code></pre> <p>o bien</p> <pre><code>datos.consultar(clave);\nfor (int i = 1; i &lt;= ndoc; i++) {\n    // realizar consulta en la base de datos\n}\ndatos.terminar(clave);\n</code></pre> <ul> <li>(a) (4 puntos) Complete el c\u00f3digo de la clase <code>Datos</code> de forma que se cumplan las condiciones del enunciado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Datos {\n    private int consultando = 0;\n    private boolean guardando = false;\n\n    public synchronized void guardar(String clave) {\n        while (guardando || consultando &gt; 0)\n            try {\n                wait();\n            } catch (InterruptedException e) {}\n        guardando = true;\n    }\n\n    public synchronized void consultar(String clave) {\n        while (guardando)\n            try {\n                wait();\n            } catch (InterruptedException e) {}\n        consultando++;\n    }\n\n    public synchronized void terminar(String clave) {\n        if (consultando &gt; 0) {\n            consultando--;\n        } else {\n            guardando = false;\n        }\n        notifyAll();\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Escriba el c\u00f3digo de una posible implementaci\u00f3n de la clase <code>Ingeniero</code> para consultar datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Ingeniero_Consulta extends Thread {\n    Datos datos;\n    int ndoc = 10; // por ejemplo\n\n    public Ingeniero_Consulta(Datos datos) {\n        this.datos = datos;\n    }\n\n    public void run() {\n        datos.consultar(\"clave\"); // por ejemplo\n        for (int i = 1; i &lt;= ndoc; i++) {\n            // realizar la consulta\n        }\n        datos.terminar(\"clave\");\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Analice si puede haber problemas de inanici\u00f3n (starvation) en el acceso a los datos y, si es as\u00ed, ponga alg\u00fan ejemplo (sin resolverlo).</li> </ul> Mostrar soluci\u00f3n <p>Como en el problema original, la soluci\u00f3n dada puede dar lugar a inanici\u00f3n de los ingenieros que guardan informes. Por ejemplo, sin entran varios a consultar y antes de que terminen entran otros nuevos, esta situaci\u00f3n se puede prolongar indefinidamente, no dejando acceder nunca a otros ingenieros que deseen guardar informes. Las soluci\u00f3n es establecer turnos para dar prioridad, alternativamente, a los que guardan (escritores) y a los que consultan (lectores).</p>"},{"location":"exams/2017/extra/#problema-4","title":"Problema 4","text":"<p>Se dispone de una aplicaci\u00f3n Android para la consulta de notas por parte de los alumnos. La aplicaci\u00f3n consta de dos pantallas, denominadas <code>MainActivity</code> y <code>ResultActivity</code>.</p> <p>En la primera pantalla (<code>MainActivity</code>), el usuario introduce su identificaci\u00f3n (nombre y apellidos) y el c\u00f3digo num\u00e9rico de la asignatura a consultar. Dispone de un bot\u00f3n con el texto 'Consultar' que, al pulsarse, pasa a la segunda pantalla <code>ResultActivity</code>, mediante un <code>Intent</code> con la informaci\u00f3n de identificaci\u00f3n del alumno y el c\u00f3digo de la asignatura. La primera pantalla dispone de un <code>layout</code> en el que se dispone de dos <code>EditText</code>, uno para el nombre y otro para el c\u00f3digo, mas el bot\u00f3n para realizar la consulta.</p> <p>En la segunda pantalla (<code>ResultActivity</code>), se consultar\u00e1 la base de datos de notas y se presentar\u00e1 la nota obtenida.</p> <p>Esta pantalla no es de nuestro inter\u00e9s.</p> <ul> <li>(a) (1 punto) Completar el c\u00f3digo del m\u00e9todo <code>onCreat</code>e de la clase <code>MainActivity</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n    private EditText etIdentificacion;\n    private EditText etCodigo;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        etIdentificacion = (EditText) findViewById(R.id.editIdentificador);\n        etCodigo = (EditText) findViewById(R.id.editCodigo);\n\n        Button b = (Button) findViewById(R.id.botonConsultar);\n        b.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // m\u00e9todo a rellenar\n            }\n        });\n    }\n}\n\n// Escriba a continuaci\u00f3n el cuerpo del m\u00e9todo onClick.\npublic void onClick(View v) {\n    String id = etIdentificacion.getText().toString();\n    String codigo = etCodigo.getText().toString();\n    Intent i = new Intent(getApplicationContext(), ResultActivity.class);\n    i.putExtra(\"ID\", id);\n    i.putExtra(\"CODIGO\", codigo);\n    startActivity(i);\n}    \n</code></pre> <ul> <li>(b) (1 punto) Indicar los m\u00e9todos del ciclo de vida que se invocar\u00e1n de la actividad <code>MainActivity</code> y <code>ResultActivity</code> en el orden correcto.</li> </ul> Mostrar soluci\u00f3n <pre><code>MainActivity.onPause()\nResultActivity,onCreate()\nResultActivity.onStart()\nResultActivity.onResume()\nMainActivity.onStop()\n\n// Se puede a\u00f1adir MainActivity.onDestroy()\n</code></pre>"},{"location":"exams/2017/extra/#problema-5","title":"Problema 5","text":"<ul> <li>(a) (?? puntos) \u00bfA qu\u00e9 orden de complejidad se deber\u00eda aproximar la gr\u00e1fica de tiempo de ejecuci\u00f3n para los m\u00e9todos de ordenaci\u00f3n por inserci\u00f3n y mezcla (merge sort)?</li> </ul> Mostrar soluci\u00f3n <p>Inserci\u00f3n: \\(O(n^2)\\); Mezcla: \\(O(n\u00b7log n)\\).</p> <ul> <li>(b) (?? puntos) La clase <code>HashListas</code> implementa tablas hash con listas de desbordamiento. En ella se define el m\u00e9todo <pre><code>private int h(String s){...}\n</code></pre> \u00bfPara qu\u00e9 se usa este m\u00e9todo?</li> </ul> Mostrar soluci\u00f3n <p>Para calcular la posici\u00f3n del array que contiene la lista donde se almacena (o se podr\u00eda almacenar) el elemento de clave <code>s</code>.</p> <ul> <li>(c) (?? puntos) En este ejercicio se usa un diccionario para almacenar palabras de un texto y el n\u00famero de veces que aparecen. Una de las operaciones que se efect\u00faan consiste en imprimir una lista con las n palabras m\u00e1s (o menos) usadas (m\u00e9todo <code>getTop()</code>). En el ejercicio esto se implementa copiando los valores del diccionario a un array, que se ordena seg\u00fan el criterio elegido. Cuando se dice que esto se hace con \u201cevaluaci\u00f3n perezosa\u201d, \u00bfqu\u00e9 significa esta expresi\u00f3n?</li> </ul> Mostrar soluci\u00f3n <p>Que el array no se ordena hasta que es necesario, es decir hasta que se llama a <code>getTop</code> o a <code>countBelow</code>.</p> <ul> <li>(d) (?? puntos) En este ejercicio se usa una cola de paquetes que se puede implementar como un array o una lista. La cola est\u00e1 incluida en una clase, <code>TsRouter</code>, que tiene dos m\u00e9todos p\u00fablicos, <code>send</code> y <code>get</code>, que respectivamente a\u00f1aden y recuperan paquetes de la cola. \u00bfTienen que ser sincronizados estos m\u00e9todos? \u00bfPor qu\u00e9?</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed, porque acceden a la cola, que es un objeto compartido por todas las hebras.</p> <ul> <li>(e) (?? puntos) En este ejercicio se utiliza sincronizaci\u00f3n de lectores y escritores para acceder a una estructura de datos compartida, la lista de manzanas del juego de la serpiente, encapsulada en la clase <code>AppleListMonitor</code>. \u00bfQu\u00e9 cambios habr\u00eda que hacer en esta clase para cambiar la sincronizaci\u00f3n de lectores y escritores por exclusi\u00f3n mutua?</li> </ul> Mostrar soluci\u00f3n <p>Bastar\u00eda con suprimir las referencias a <code>monitor.openReading</code> / <code>monitor.closeReading</code> y a <code>monitor.openWriting</code> / <code>monitor.closeWriting</code> y hacer sincronizados todos los m\u00e9todos de <code>AppleListMonitor</code>.</p> <ul> <li>(f) (?? puntos) En este ejercicio se utiliza un widget de tipo <code>Button</code> para lanzar el c\u00e1lculo del \u00edndice de masa corporal. \u00bfC\u00f3mo se especifica qu\u00e9 m\u00e9todo hay que ejecutar cuando se pulsa el bot\u00f3n?</li> </ul> Mostrar soluci\u00f3n <p>Se puede hacer de dos maneras: poniendo un atributo <pre><code>Android:onClick=\u201dm\u00e9todo\u201d\n</code></pre> en el <code>layout</code> correspondiente, o bien en Java, implementando la interfaz <code>OnClickListener</code>: <pre><code>button.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        muestraMensaje(v);\n    }\n});\n</code></pre></p>"},{"location":"exams/2017/extra_ex01/","title":"Extra ex01","text":"<p>A pesar de que un genoma tiene m\u00e1s de dos gigas de (solo cuatro tipos distintos de) bases (A, G, C, T), la mayor parte del mismo es \u201cbasura\u201d, pues solo una peque\u00f1a fracci\u00f3n de subsecuencias (contiguas) del mismo codifica la producci\u00f3n de amino\u00e1cidos, es decir, prote\u00ednas. A esas subsecuencias significativas de bases se les conoce con el nombre de genes.</p> <p>Las subsecuencias que constituyen genes son de longitud moderada, entre cien y mil bases, y tienen la caracter\u00edstica de que al menos una de las cuatro bases se presenta en dicha subsecuencia con (mucha) menor frecuencia que las otras tres. Digamos, por ejemplo, 20 por ciento menos. Interpretado este porcentaje sobre el n\u00famero total de bases de la subsecuencia considerada.</p> <ul> <li>(a) (5 puntos) Se pide dise\u00f1ar un algoritmo (no un programa) que, a partir de un genoma especificado como una (muy) larga secuencia de bases, encuentre los genes de longitud 300 bases. Y a continuaci\u00f3n, analizar la complejidad en espacio y en tiempo de dicho algoritmo en t\u00e9rminos del tama\u00f1o del genoma.</li> </ul> Mostrar soluci\u00f3n <p>Se supone declarada una clase, llam\u00e9mosla <code>Contadores</code>, con cuatro atributos enteros de valor inicial cero, que se van a usar para contar del n\u00famero de cada tipo de base que hay, desde el principio del genoma hasta un punto dado. Y se supone tambi\u00e9n que tenemos un array, llam\u00e9mosle <code>ultimas300</code>, que mantiene el valor de los cuatro contadores para cada uno de los \u00faltimos 300 puntos del genoma que hemos visitado, seg\u00fan lo exploramos desde el principio hasta el final de su cadena de bases.</p> <p>El algoritmo es:</p> <ol> <li> <p>Ir leyendo de un fichero el genoma base a base desde el principio hasta su posici\u00f3n 299, actualizando los contadores de <code>ultimas300</code> en las posiciones 0-298.</p> </li> <li> <p>Leer la siguiente base del genoma, incrementar el contador correspondiente a esa base en la \u00faltima posici\u00f3n actualizada del array en una unidad, y guardar los cuatro valores actuales en la siguiente posici\u00f3n de <code>ultimas300</code>, manejando este array de manera circular (la posici\u00f3n siguiente a la 299 es la cero).</p> </li> <li> <p>Restar de los cuatro contadores actuales los contadores que est\u00e1n en el array 299 posiciones antes (de manera circular tambi\u00e9n). Si uno de esos cuatro valores es menor que 60 (=300/4*0.8), hemos encontrado un gen y lo imprimimos.</p> </li> <li> <p>Si a\u00fan quedan bases por leer en el genoma, volvemos al punto (2). En otro caso, hemos acabado el algoritmo.</p> </li> </ol> <p>La complejidad en espacio es constante, pues el tama\u00f1o de <code>ultimas300</code> es fijo, no depende del tama\u00f1o del genoma. En cuanto a la complejidad en tiempo, la parte (1) es tambi\u00e9n constante, ya que tampoco depende del tama\u00f1o del genoma. Mientras que las partes (2), (3) y (4) se ejecutan una vez por cada base del genoma (exceptuando las 299 primeras, valor constante). Y como resulta que esas tres partes tienen una complejidad constante, se tiene:</p> <p>\\(C1 + C2*O(n-299) + C3*O(n-299) + C4*O(n-299)\\)</p> <p>\\(= (C1 - 299*(C2+C3+C4)) + (C2+C3+C4)*O(n)\\)</p> <p>\\(= C5 + C6*O(n)\\) </p> <p>\\(= C6*O(n)\\) </p> <p>\\(= O(n)\\)</p> <p>Es decir, el algoritmo tiene una complejidad lineal en el tiempo.</p>","tags":["complejidad"]},{"location":"exams/2017/extra_ex02/","title":"Extra ex02","text":"<p>La clase <code>RegistroDatos</code> permite almacenar los datos producidos por un conjunto de sensores. Los datos producidos por los sensores se env\u00edan como objetos de la clase <code>Dato</code>, cuya estructura se muestra a continuaci\u00f3n:</p> <pre><code>public class Dato implements Comparable&lt;Dato&gt; {\n\n    private String id;   // Identificador \u00fanico del sensor que ha generado el dato\n    private Date d;      // Fecha en la que se ha producido el dato (clase Date de Java)\n    private long v;      // Valor del dato producido\n    ... //Contiene constructor, getters, y setters\n}\n</code></pre> <p>La clase <code>RegistroDatos</code> guarda los datos recibidos en un array <code>(private List&lt;Dato&gt; []datos)</code>. Cada dato se guarda en la posici\u00f3n del array que se obtiene aplicando el m\u00e9todo <code>hashCode</code> de la clase <code>String</code> al identificador \u00fanico del sensor que ha producido el dato y adaptando el resultado al tama\u00f1o del array datos. </p> <p>Adem\u00e1s, se lleva una cuenta del n\u00famero de datos que ha generado cada sensor, mediante el atributo <code>cuentaDatos</code> (<code>private Map &lt;String, Registro&gt; cuentaDatos</code>), usando como clave el identificador \u00fanico del sensor que ha producido el dato y como valor un objeto de la clase <code>Registro</code>, cuya estructura se muestra a continuaci\u00f3n:</p> <pre><code>public class Registro implements Comparable&lt;Registro&gt; {\n\n    private final String clave; // Identificador \u00fanico del sensor\n    private int cnt;            // N\u00famero de datos producidos por ese sensor\n    ... //Contiene constructor, getters, y setters\n}\n</code></pre> <ul> <li>(a) (5 puntos) Se pide completar los m\u00e9todos <code>Constructor</code>, <code>put</code>, <code>getDatos</code>, <code>size</code> y <code>countAbove</code> de la clase <code>RegistroDatos</code>. El esqueleto de la se muestra a continuaci\u00f3n:</li> </ul> <pre><code>public class RegistroDatos {\n    private List&lt;Dato&gt;[] datos;\n    private Map&lt;String, Registro&gt; cuentaDatos;\n\n    /**\n     * Constructor\n     * @param n n\u00famero de posiciones del array datos donde se van a almacenar\n     * los datos producidos por los sensores\n     */\n    public RegistroDatos(int n) {\n        //TODO\n    }\n\n    /**\n     * Devuelve cuantos sensores han producido un n\u00famero de datos por encima\n     * de un determinado umbral c.\n     * @param c umbral de cuenta.\n     * @return n\u00famero de sensores que han generado m\u00e1s de c datos\n     */\n    public int countAbove(int c) {\n        //TODO\n    }\n\n    /**\n     * Devuelve los datos producidos por un determinado sensor\n     * @param sensorId identificador del sensor\n     * @return lista de datos producidos por ese sensor.\n     * Si no hay ning\u00fan sensor con ese sensorId devolver\u00e1 una lista con 0 valores.\n     */\n    public List&lt;Dato&gt; getDatos(String sensorId) {\n        //TODO\n    }\n\n    /**\n     * Almacena un nuevo dato en el Registro de datos, para ello incrementa en uno la\n     * cuenta de datos\n     * proporcionados por el sensor, y almacena el dato en la posici\u00f3n correspondiente de\n     * la tabla Hash\n     * @param dato la nuevo dato a almacenar\n     */\n    private void put(Dato dato) {\n        //TODO\n    }\n\n    /**\n     * Numero de Datos total almacenado.\n     * @return numero de datos.\n     */\n    public int size() {\n        //TODO\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>public class RegistroDatos {\n    private List&lt;Dato&gt;[] datos;\n    private Map&lt;String, Registro&gt; cuentaDatos;\n\n    /**\n     * Constructor\n     * @param n n\u00famero de posiciones del array datos donde se van a almacenar\n     * los datos producidos por los sensores\n     */\n    public RegistroDatos(int n) {\n        this.datos = new List[N];\n        for (int i = 0; i &lt; N; i++) {\n            datos[i] = new ArrayList();\n        }\n        cuentaDatos = new HashMap&lt;String, Registro&gt;();\n    }\n\n    /**\n     * Devuelve cuantos sensores han producido un n\u00famero de datos por encima\n     * de un determinado umbral c.\n     * @param c umbral de cuenta.\n     * @return numero de sensores que han generado m\u00e1s de c datos\n     */\n    public int countAbove(int c) {\n        int cuenta = 0;\n        Set&lt;String&gt; keySet = cuentaDatos.keySet();\n        for (String key : keySet) {\n            if (cuentaDatos.get(key).getCnt() &lt; c)\n                cuenta++;\n        }\n        return cuenta;\n    }\n\n    /*\n     * Devuelve los datos producidos por un determinado sensor\n     * @param sensorId identificador del sensor\n     * @return lista de datos producidos por ese sensor.\n     * Si no hay ning\u00fan sensor con ese sensorId devolver\u00e1 una lista con 0 valores.\n     */\n    public List&lt;Dato&gt; getDatos(String sensorId) {\n        List&lt;Dato&gt; listaDatos = new ArrayList&lt;Dato&gt;();\n        int hc = sensorId.hashCode();\n        hc = hc % datos.length;\n        for (Dato d : datos[hc]) {\n            if (d.getId().equals(sensorId))\n                listaDatos.add(d);\n        }\n        return listaDatos;\n    }\n\n    /**\n     * El m\u00e9todo put (), se encarga de meter un nuevo dato en el Registro de datos,\n     * para ello incrementa en uno la cuenta de datos proporcionados por el sensor,\n     * y almacena el dato en la posici\u00f3n correspondiente de la tabla Hash\n     * @param dato la nuevo dato a almacenar\n     */\n    private void put(Dato dato) {\n        if (cuentaDatos.containsKey(dato.getId())) {\n            cuentaDatos.get(dato.getId()).inc();\n        } else {\n            cuentaDatos.put(dato.getId(), new Registro(dato.getId()));\n        }\n        int hc = dato.getId().hashCode();\n        hc = hc % datos.length;\n        datos[hc].add(dato);\n    }\n\n    /**\n     * Numero de Datos Total Almacenado.\n     * @return numero de datos.\n     */\n    public int size() {\n        int suma = 0;\n        Set&lt;String&gt; keySet = cuentaDatos.keySet();\n        for (String key : keySet) {\n            suma += cuentaDatos.get(key).getCnt();\n        }\n        return suma;\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2017/extra_ex03/","title":"Extra ex03","text":"<p>Varios ingenieros utilizan una base de datos para almacenar informes. Para ello disponen de una aplicaci\u00f3n que permite almacenar un informe o recuperar un informe anterior. El acceso a los datos se organiza mediante una clase de Java que responde al esquema siguiente esquema:</p> <pre><code>public class Datos {\n\u2026\n    public \u2026 void guardar (String clave) {\u2026}\n    public \u2026 void consultar (String clave) {\u2026}\n    public \u2026 void terminar (String clave) {\u2026}\n}\n</code></pre> <p>Las aplicaciones se ejecutan concurrentemente, y llaman a <code>guardar</code> o a <code>consultar</code> antes de realizar una secuencia de operaciones de almacenar o recuperar informes, respectivamente. Cuando han terminado de realizar estas operaciones llaman a <code>terminar</code>. Puede haber varias aplicaciones consultando informes a la vez, pero no consultando y guardando, ni varias guardando a la vez.</p> <p>Los objetos de la clase <code>Ingeniero</code> son hebras que ejecutan repetidamente el siguiente c\u00f3digo:</p> <pre><code>datos.guardar(clave);\nfor (int i = 1; i &lt;= ndoc; i++) {\n    // generar informe y almacenarlo en la base de datos\n}\ndatos.terminar(clave);\n</code></pre> <p>o bien</p> <pre><code>datos.consultar(clave);\nfor (int i = 1; i &lt;= ndoc; i++) {\n    // realizar consulta en la base de datos\n}\ndatos.terminar(clave);\n</code></pre> <ul> <li>(a) (4 puntos) Complete el c\u00f3digo de la clase <code>Datos</code> de forma que se cumplan las condiciones del enunciado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Datos {\n    private int consultando = 0;\n    private boolean guardando = false;\n\n    public synchronized void guardar(String clave) {\n        while (guardando || consultando &gt; 0)\n            try {\n                wait();\n            } catch (InterruptedException e) {}\n        guardando = true;\n    }\n\n    public synchronized void consultar(String clave) {\n        while (guardando)\n            try {\n                wait();\n            } catch (InterruptedException e) {}\n        consultando++;\n    }\n\n    public synchronized void terminar(String clave) {\n        if (consultando &gt; 0) {\n            consultando--;\n        } else {\n            guardando = false;\n        }\n        notifyAll();\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Escriba el c\u00f3digo de una posible implementaci\u00f3n de la clase <code>Ingeniero</code> para consultar datos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Ingeniero_Consulta extends Thread {\n    Datos datos;\n    int ndoc = 10; // por ejemplo\n\n    public Ingeniero_Consulta(Datos datos) {\n        this.datos = datos;\n    }\n\n    public void run() {\n        datos.consultar(\"clave\"); // por ejemplo\n        for (int i = 1; i &lt;= ndoc; i++) {\n            // realizar la consulta\n        }\n        datos.terminar(\"clave\");\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Analice si puede haber problemas de inanici\u00f3n (starvation) en el acceso a los datos y, si es as\u00ed, ponga alg\u00fan ejemplo (sin resolverlo).</li> </ul> Mostrar soluci\u00f3n <p>Como en el problema original, la soluci\u00f3n dada puede dar lugar a inanici\u00f3n de los ingenieros que guardan informes. Por ejemplo, sin entran varios a consultar y antes de que terminen entran otros nuevos, esta situaci\u00f3n se puede prolongar indefinidamente, no dejando acceder nunca a otros ingenieros que deseen guardar informes. Las soluci\u00f3n es establecer turnos para dar prioridad, alternativamente, a los que guardan (escritores) y a los que consultan (lectores).</p>","tags":["hebras"]},{"location":"exams/2017/extra_ex04/","title":"Extra ex04","text":"<p>Se dispone de una aplicaci\u00f3n Android para la consulta de notas por parte de los alumnos. La aplicaci\u00f3n consta de dos pantallas, denominadas <code>MainActivity</code> y <code>ResultActivity</code>.</p> <p>En la primera pantalla (<code>MainActivity</code>), el usuario introduce su identificaci\u00f3n (nombre y apellidos) y el c\u00f3digo num\u00e9rico de la asignatura a consultar. Dispone de un bot\u00f3n con el texto 'Consultar' que, al pulsarse, pasa a la segunda pantalla <code>ResultActivity</code>, mediante un <code>Intent</code> con la informaci\u00f3n de identificaci\u00f3n del alumno y el c\u00f3digo de la asignatura. La primera pantalla dispone de un <code>layout</code> en el que se dispone de dos <code>EditText</code>, uno para el nombre y otro para el c\u00f3digo, mas el bot\u00f3n para realizar la consulta.</p> <p>En la segunda pantalla (<code>ResultActivity</code>), se consultar\u00e1 la base de datos de notas y se presentar\u00e1 la nota obtenida.</p> <p>Esta pantalla no es de nuestro inter\u00e9s.</p> <ul> <li>(a) (1 punto) Completar el c\u00f3digo del m\u00e9todo <code>onCreat</code>e de la clase <code>MainActivity</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n    private EditText etIdentificacion;\n    private EditText etCodigo;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        etIdentificacion = (EditText) findViewById(R.id.editIdentificador);\n        etCodigo = (EditText) findViewById(R.id.editCodigo);\n\n        Button b = (Button) findViewById(R.id.botonConsultar);\n        b.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // m\u00e9todo a rellenar\n            }\n        });\n    }\n}\n\n// Escriba a continuaci\u00f3n el cuerpo del m\u00e9todo onClick.\npublic void onClick(View v) {\n    String id = etIdentificacion.getText().toString();\n    String codigo = etCodigo.getText().toString();\n    Intent i = new Intent(getApplicationContext(), ResultActivity.class);\n    i.putExtra(\"ID\", id);\n    i.putExtra(\"CODIGO\", codigo);\n    startActivity(i);\n}    \n</code></pre> <ul> <li>(b) (1 punto) Indicar los m\u00e9todos del ciclo de vida que se invocar\u00e1n de la actividad <code>MainActivity</code> y <code>ResultActivity</code> en el orden correcto.</li> </ul> Mostrar soluci\u00f3n <pre><code>MainActivity.onPause()\nResultActivity,onCreate()\nResultActivity.onStart()\nResultActivity.onResume()\nMainActivity.onStop()\n\n// Se puede a\u00f1adir MainActivity.onDestroy()\n</code></pre>","tags":["android"]},{"location":"exams/2017/extra_ex05/","title":"Extra ex05","text":"<ul> <li>(a) (?? puntos) \u00bfA qu\u00e9 orden de complejidad se deber\u00eda aproximar la gr\u00e1fica de tiempo de ejecuci\u00f3n para los m\u00e9todos de ordenaci\u00f3n por inserci\u00f3n y mezcla (merge sort)?</li> </ul> Mostrar soluci\u00f3n <p>Inserci\u00f3n: \\(O(n^2)\\); Mezcla: \\(O(n\u00b7log n)\\).</p> <ul> <li>(b) (?? puntos) La clase <code>HashListas</code> implementa tablas hash con listas de desbordamiento. En ella se define el m\u00e9todo <pre><code>private int h(String s){...}\n</code></pre> \u00bfPara qu\u00e9 se usa este m\u00e9todo?</li> </ul> Mostrar soluci\u00f3n <p>Para calcular la posici\u00f3n del array que contiene la lista donde se almacena (o se podr\u00eda almacenar) el elemento de clave <code>s</code>.</p> <ul> <li>(c) (?? puntos) En este ejercicio se usa un diccionario para almacenar palabras de un texto y el n\u00famero de veces que aparecen. Una de las operaciones que se efect\u00faan consiste en imprimir una lista con las n palabras m\u00e1s (o menos) usadas (m\u00e9todo <code>getTop()</code>). En el ejercicio esto se implementa copiando los valores del diccionario a un array, que se ordena seg\u00fan el criterio elegido. Cuando se dice que esto se hace con \u201cevaluaci\u00f3n perezosa\u201d, \u00bfqu\u00e9 significa esta expresi\u00f3n?</li> </ul> Mostrar soluci\u00f3n <p>Que el array no se ordena hasta que es necesario, es decir hasta que se llama a <code>getTop</code> o a <code>countBelow</code>.</p> <ul> <li>(d) (?? puntos) En este ejercicio se usa una cola de paquetes que se puede implementar como un array o una lista. La cola est\u00e1 incluida en una clase, <code>TsRouter</code>, que tiene dos m\u00e9todos p\u00fablicos, <code>send</code> y <code>get</code>, que respectivamente a\u00f1aden y recuperan paquetes de la cola. \u00bfTienen que ser sincronizados estos m\u00e9todos? \u00bfPor qu\u00e9?</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed, porque acceden a la cola, que es un objeto compartido por todas las hebras.</p> <ul> <li>(e) (?? puntos) En este ejercicio se utiliza sincronizaci\u00f3n de lectores y escritores para acceder a una estructura de datos compartida, la lista de manzanas del juego de la serpiente, encapsulada en la clase <code>AppleListMonitor</code>. \u00bfQu\u00e9 cambios habr\u00eda que hacer en esta clase para cambiar la sincronizaci\u00f3n de lectores y escritores por exclusi\u00f3n mutua?</li> </ul> Mostrar soluci\u00f3n <p>Bastar\u00eda con suprimir las referencias a <code>monitor.openReading</code> / <code>monitor.closeReading</code> y a <code>monitor.openWriting</code> / <code>monitor.closeWriting</code> y hacer sincronizados todos los m\u00e9todos de <code>AppleListMonitor</code>.</p> <ul> <li>(f) (?? puntos) En este ejercicio se utiliza un widget de tipo <code>Button</code> para lanzar el c\u00e1lculo del \u00edndice de masa corporal. \u00bfC\u00f3mo se especifica qu\u00e9 m\u00e9todo hay que ejecutar cuando se pulsa el bot\u00f3n?</li> </ul> Mostrar soluci\u00f3n <p>Se puede hacer de dos maneras: poniendo un atributo <pre><code>Android:onClick=\u201dm\u00e9todo\u201d\n</code></pre> en el <code>layout</code> correspondiente, o bien en Java, implementando la interfaz <code>OnClickListener</code>: <pre><code>button.setOnClickListener(new OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        muestraMensaje(v);\n    }\n});\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2017/p1/","title":"Examen 2017 \u2014 Parcial 1","text":""},{"location":"exams/2017/p1/#problema-1","title":"Problema 1","text":"<p>En un proyecto se necesita programar una clase que represente un conjunto de palabras (<code>String</code>), sin que haya duplicados almacenados. Con este fin se realizan dos fases:</p> <ol> <li> <p>fase 1 de carga de todas las palabras, con un m\u00e9todo: <pre><code>public void put (String palabra)\n</code></pre></p> </li> <li> <p>fase 2 de consulta, con un m\u00e9todo: <pre><code>boolean get (String palabra)\n</code></pre> que devuelve <code>TRUE</code> si, y solo si, la palabra dada como par\u00e1metro est\u00e1 en el diccionario.</p> </li> </ol> <p>Se proponen varias opciones:</p> <ol> <li> Las palabras se meten en un array, una tras otra; al acabar la **fase 1**, el array se ordena y se eliminan los duplicados, pasando a la **fase 2** donde se usa el array sin duplicados. </li> <li> Las palabras se meten en un diccionario implementado con una tabla hash, de forma que solo hay que almacenar la clave (es decir la palabra); si la clave est\u00e1 en el diccionario, `get()` devuelve `TRUE`. </li> <li> Se combinan las opciones anteriores: las palabras (1) se meten en un array, (2) se ordena el array, (3) se eliminan duplicados, (4) los datos del array se cargan en un diccionario implementado con una tabla hash y (5) el m\u00e9todo `get()` devuelve `TRUE` si, y solo si, la palabra est\u00e1 en el diccionario. </li> </ol> <ul> <li>(a) (2,5 puntos) Razone la complejidad de los m\u00e9todos <code>put()</code> y <code>get()</code> en cada una de las opciones propuestos.</li> </ul> Mostrar soluci\u00f3n <ol> <li>Fase 1: \\(O(\\)insertar al final del array \\(n\\) veces\\() + O(\\)ordenar\\() + O(\\)borrar duplicados\\() = O(n) + O(nlogn) + O(n)\\)</li> </ol> <p>\\(= O(nlog n)\\)</p> <p>Fase 2: \\(O(\\)b\u00fasqueda array ordenado\\() = O(logn)\\)</p> <ol> <li>Fase 1: \\(O(\\)insertar \\(n\\) veces\\() = O(n)\\)</li> </ol> <p>Fase 2: \\(O(1)\\)</p> <ol> <li>Fase 1 \\(= (1) + O(\\)transferir array \\(\\rightarrow\\) hash\\() = O(nlogn) + O(n) = O(nlogn)\\)</li> </ol> <p>Fase 2 \\(= O(1)\\)</p> <ul> <li>(b) (2,5 puntos) Escriba el m\u00e9todo <code>public void put(String palabra)</code> modificando el m\u00e9todo <code>public void put(String clave, String valor)</code> del ejercicio 2 para que tenga la funcionalidad solicitada, usando internamente una tabla hash. Puede utilizar como base el c\u00f3digo que aparece a continuaci\u00f3n, rellenando los espacios que se indican.</li> </ul> <pre><code>public class HashListas {\n    private List&lt;String&gt;[] slots; // slots de la tabla Hash\n    private int nDatos = 0; // n\u00famero de datos de la tabla\n\n    /**\n     * Constructor\n     * @param nSlots n\u00famero de ranuras\n     */\n    public HashListas(int nSlots) {\n        slots = new List[nSlots];\n        for (int i = 0; i &lt; nSlots; i++) {\n            slots[i] = new ArrayList&lt;String&gt;(0);\n        }\n    }\n\n    /**\n     * Calcula funci\u00f3n hash e \u00edndice en slots\n     * @param clave String\n     * @return \u00edndice en slots\n     */\n    private int getIdx(String clave) {\n        return Math.abs(clave.hashCode()) % slots.length;\n    }\n\n    /**\n     * Mete una nueva palabra en el diccionario\n     * Si ya existe otra palabra, no hace nada\n     * @param clave palabra para almacenar\n     */\n    public void put(String clave) {\n\n    }\n\n    /**\n     * Devuelve el valor asociado a la clave\n     * @param clave palabra que comprobamos\n     * @return true si est\u00e1 en el diccionario;\n     *         false en caso contrario\n     */\n    public boolean get(String clave) {\n\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>public class HashListas {\n    private List&lt;String&gt;[] slots; // slots de la tabla Hash\n    private int nDatos = 0; // n\u00famero de datos de la tabla\n\n    /**\n     * Constructor\n     * @param nSlots n\u00famero de ranuras\n     */\n    public HashListas(int nSlots) {\n        slots = new List[nSlots];\n        for (int i = 0; i &lt; nSlots; i++) {\n            slots[i] = new ArrayList&lt;String&gt;(0);\n        }\n    }\n\n    /**\n     * Calcula funci\u00f3n hash e \u00edndice en slots\n     * @param clave String\n     * @return \u00edndice en slots\n     */\n    private int getIdx(String clave) {\n        return Math.abs(clave.hashCode()) % slots.length;\n    }\n\n    /**\n     * Mete una nueva palabra en el diccionario\n     * Si ya existe otra palabra, no hace nada\n     * @param clave palabra para almacenar\n     */\n    public void put(String clave) {\n        int idx = getIdx(clave);\n        put(slots[idx], clave);\n    }\n\n    private void put(List&lt;String&gt; list, String clave) {\n        for (String palabra : list) {\n            if (palabra.compareTo(clave) == 0) {\n                return;\n            }\n        }\n        list.add(clave);\n        nDatos++;\n    }\n\n    /**\n     * Devuelve el valor asociado a la clave\n     * @param clave palabra que comprobamos\n     * @return true si est\u00e1 en el diccionario;\n     *         false en caso contrario\n     */\n    public boolean get(String clave) {\n        int idx = getIdx(clave);\n        return get(slots[idx], clave);\n    }\n\n    private boolean get(List&lt;String&gt; list, String clave) {\n        for (String palabra : list) {\n            if (palabra.compareTo(clave) == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n</code></pre>"},{"location":"exams/2017/p1/#problema-2","title":"Problema 2","text":"<p>Se implementa un \u00e1rbol binario de b\u00fasqueda (BST) con valores enteros positivos como un array, colocando su ra\u00edz principal en la posici\u00f3n <code>1</code> del array y, para todo nodo del mismo en la posici\u00f3n <code>i</code>, su hijo izquierdo en la posici\u00f3n <code>2*i</code>, y su hijo derecho en la posici\u00f3n <code>2*i+1</code>. La posici\u00f3n <code>0</code> del array mantiene el contador del n\u00famero de nodos en el \u00e1rbol. Un nodo no existe si su posici\u00f3n en el array no existe (se sale del tama\u00f1o del array) o el valor en el array es <code>-1</code>. Por ejemplo:</p> <p></p> \u00cdndice 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Valor 9 8 3 10 1 6 -1 14 -1 -1 4 7 -1 -1 13 -1 <p>Con esta representaci\u00f3n de un \u00e1rbol, se pide:</p> <ul> <li>(a) (2,5 puntos) Programar un recorrido en el \u00e1rbol que imprima ordenados los contenidos de los nodos visitados: <pre><code>public void recorrer (int[] arbol) {...}\n</code></pre> En el ejemplo dado, deber\u00eda imprimir:</li> </ul> <p>1 3 4 6 7 8 10 13 14</p> <p>Nota: suponga que no es necesario comprobar si la representaci\u00f3n del \u00e1rbol proporcionada es correcta.</p> Mostrar soluci\u00f3n <pre><code>public void recorrer(int[] arbol) {\n    recorrer(arbol, 1);\n}\n\nprivate void recorrer(int[] arbol, int i) {\n    if (i &lt; arbol.length &amp;&amp; arbol[i] &gt;= 0) {\n        recorrer(arbol, 2 * i);\n        System.out.println(arbol[i]);\n        recorrer(arbol, 2 * i + 1);\n    }\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Razonar la complejidad de dicho recorrido.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad (en tiempo) del algoritmo es lineal, es decir \\(O(n)\\), siendo \\(n\\) el n\u00famero de nodos, puesto que recorre el \u00e1rbol visitando todos sus nodos, y en cada uno de ellos realiza un trabajo de orden constante, es decir \\(O(1)\\).</p> <p>NOTA:</p> <p>Para la soluci\u00f3n de la ecuaci\u00f3n de recurrencia</p> <p>\\(T(n) = T(n/2) + C + T(n/2) = 2 T(n/2) + C\\)</p> <p>que se resuelve como \\(O(n)\\).</p>"},{"location":"exams/2017/p1_ex01/","title":"P1 ex01","text":"<p>En un proyecto se necesita programar una clase que represente un conjunto de palabras (<code>String</code>), sin que haya duplicados almacenados. Con este fin se realizan dos fases:</p> <ol> <li> <p>fase 1 de carga de todas las palabras, con un m\u00e9todo: <pre><code>public void put (String palabra)\n</code></pre></p> </li> <li> <p>fase 2 de consulta, con un m\u00e9todo: <pre><code>boolean get (String palabra)\n</code></pre> que devuelve <code>TRUE</code> si, y solo si, la palabra dada como par\u00e1metro est\u00e1 en el diccionario.</p> </li> </ol> <p>Se proponen varias opciones:</p> <ol> <li> Las palabras se meten en un array, una tras otra; al acabar la **fase 1**, el array se ordena y se eliminan los duplicados, pasando a la **fase 2** donde se usa el array sin duplicados. </li> <li> Las palabras se meten en un diccionario implementado con una tabla hash, de forma que solo hay que almacenar la clave (es decir la palabra); si la clave est\u00e1 en el diccionario, `get()` devuelve `TRUE`. </li> <li> Se combinan las opciones anteriores: las palabras (1) se meten en un array, (2) se ordena el array, (3) se eliminan duplicados, (4) los datos del array se cargan en un diccionario implementado con una tabla hash y (5) el m\u00e9todo `get()` devuelve `TRUE` si, y solo si, la palabra est\u00e1 en el diccionario. </li> </ol> <ul> <li>(a) (2,5 puntos) Razone la complejidad de los m\u00e9todos <code>put()</code> y <code>get()</code> en cada una de las opciones propuestos.</li> </ul> Mostrar soluci\u00f3n <ol> <li>Fase 1: \\(O(\\)insertar al final del array \\(n\\) veces\\() + O(\\)ordenar\\() + O(\\)borrar duplicados\\() = O(n) + O(nlogn) + O(n)\\)</li> </ol> <p>\\(= O(nlog n)\\)</p> <p>Fase 2: \\(O(\\)b\u00fasqueda array ordenado\\() = O(logn)\\)</p> <ol> <li>Fase 1: \\(O(\\)insertar \\(n\\) veces\\() = O(n)\\)</li> </ol> <p>Fase 2: \\(O(1)\\)</p> <ol> <li>Fase 1 \\(= (1) + O(\\)transferir array \\(\\rightarrow\\) hash\\() = O(nlogn) + O(n) = O(nlogn)\\)</li> </ol> <p>Fase 2 \\(= O(1)\\)</p> <ul> <li>(b) (2,5 puntos) Escriba el m\u00e9todo <code>public void put(String palabra)</code> modificando el m\u00e9todo <code>public void put(String clave, String valor)</code> del ejercicio 2 para que tenga la funcionalidad solicitada, usando internamente una tabla hash. Puede utilizar como base el c\u00f3digo que aparece a continuaci\u00f3n, rellenando los espacios que se indican.</li> </ul> <pre><code>public class HashListas {\n    private List&lt;String&gt;[] slots; // slots de la tabla Hash\n    private int nDatos = 0; // n\u00famero de datos de la tabla\n\n    /**\n     * Constructor\n     * @param nSlots n\u00famero de ranuras\n     */\n    public HashListas(int nSlots) {\n        slots = new List[nSlots];\n        for (int i = 0; i &lt; nSlots; i++) {\n            slots[i] = new ArrayList&lt;String&gt;(0);\n        }\n    }\n\n    /**\n     * Calcula funci\u00f3n hash e \u00edndice en slots\n     * @param clave String\n     * @return \u00edndice en slots\n     */\n    private int getIdx(String clave) {\n        return Math.abs(clave.hashCode()) % slots.length;\n    }\n\n    /**\n     * Mete una nueva palabra en el diccionario\n     * Si ya existe otra palabra, no hace nada\n     * @param clave palabra para almacenar\n     */\n    public void put(String clave) {\n\n    }\n\n    /**\n     * Devuelve el valor asociado a la clave\n     * @param clave palabra que comprobamos\n     * @return true si est\u00e1 en el diccionario;\n     *         false en caso contrario\n     */\n    public boolean get(String clave) {\n\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>public class HashListas {\n    private List&lt;String&gt;[] slots; // slots de la tabla Hash\n    private int nDatos = 0; // n\u00famero de datos de la tabla\n\n    /**\n     * Constructor\n     * @param nSlots n\u00famero de ranuras\n     */\n    public HashListas(int nSlots) {\n        slots = new List[nSlots];\n        for (int i = 0; i &lt; nSlots; i++) {\n            slots[i] = new ArrayList&lt;String&gt;(0);\n        }\n    }\n\n    /**\n     * Calcula funci\u00f3n hash e \u00edndice en slots\n     * @param clave String\n     * @return \u00edndice en slots\n     */\n    private int getIdx(String clave) {\n        return Math.abs(clave.hashCode()) % slots.length;\n    }\n\n    /**\n     * Mete una nueva palabra en el diccionario\n     * Si ya existe otra palabra, no hace nada\n     * @param clave palabra para almacenar\n     */\n    public void put(String clave) {\n        int idx = getIdx(clave);\n        put(slots[idx], clave);\n    }\n\n    private void put(List&lt;String&gt; list, String clave) {\n        for (String palabra : list) {\n            if (palabra.compareTo(clave) == 0) {\n                return;\n            }\n        }\n        list.add(clave);\n        nDatos++;\n    }\n\n    /**\n     * Devuelve el valor asociado a la clave\n     * @param clave palabra que comprobamos\n     * @return true si est\u00e1 en el diccionario;\n     *         false en caso contrario\n     */\n    public boolean get(String clave) {\n        int idx = getIdx(clave);\n        return get(slots[idx], clave);\n    }\n\n    private boolean get(List&lt;String&gt; list, String clave) {\n        for (String palabra : list) {\n            if (palabra.compareTo(clave) == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2017/p1_ex02/","title":"P1 ex02","text":"<p>Se implementa un \u00e1rbol binario de b\u00fasqueda (BST) con valores enteros positivos como un array, colocando su ra\u00edz principal en la posici\u00f3n <code>1</code> del array y, para todo nodo del mismo en la posici\u00f3n <code>i</code>, su hijo izquierdo en la posici\u00f3n <code>2*i</code>, y su hijo derecho en la posici\u00f3n <code>2*i+1</code>. La posici\u00f3n <code>0</code> del array mantiene el contador del n\u00famero de nodos en el \u00e1rbol. Un nodo no existe si su posici\u00f3n en el array no existe (se sale del tama\u00f1o del array) o el valor en el array es <code>-1</code>. Por ejemplo:</p> <p></p> \u00cdndice 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Valor 9 8 3 10 1 6 -1 14 -1 -1 4 7 -1 -1 13 -1 <p>Con esta representaci\u00f3n de un \u00e1rbol, se pide:</p> <ul> <li>(a) (2,5 puntos) Programar un recorrido en el \u00e1rbol que imprima ordenados los contenidos de los nodos visitados: <pre><code>public void recorrer (int[] arbol) {...}\n</code></pre> En el ejemplo dado, deber\u00eda imprimir:</li> </ul> <p>1 3 4 6 7 8 10 13 14</p> <p>Nota: suponga que no es necesario comprobar si la representaci\u00f3n del \u00e1rbol proporcionada es correcta.</p> Mostrar soluci\u00f3n <pre><code>public void recorrer(int[] arbol) {\n    recorrer(arbol, 1);\n}\n\nprivate void recorrer(int[] arbol, int i) {\n    if (i &lt; arbol.length &amp;&amp; arbol[i] &gt;= 0) {\n        recorrer(arbol, 2 * i);\n        System.out.println(arbol[i]);\n        recorrer(arbol, 2 * i + 1);\n    }\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Razonar la complejidad de dicho recorrido.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad (en tiempo) del algoritmo es lineal, es decir \\(O(n)\\), siendo \\(n\\) el n\u00famero de nodos, puesto que recorre el \u00e1rbol visitando todos sus nodos, y en cada uno de ellos realiza un trabajo de orden constante, es decir \\(O(1)\\).</p> <p>NOTA:</p> <p>Para la soluci\u00f3n de la ecuaci\u00f3n de recurrencia</p> <p>\\(T(n) = T(n/2) + C + T(n/2) = 2 T(n/2) + C\\)</p> <p>que se resuelve como \\(O(n)\\).</p>","tags":["grafos"]},{"location":"exams/2017/p1r/","title":"Examen 2017 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2017/p1r/#problema-1","title":"Problema 1","text":"<p>Dado el siguiente \u00e1rbol binario:</p> <p></p> <ul> <li>(a) (1,25 puntos) Escriba el resultado de recorrerlo en preorden.</li> </ul> Mostrar soluci\u00f3n <p>J A M K Z</p> <p>Tenemos un \u00e1rbol binario de b\u00fasqueda (BST) en el que cada nodo almacena un car\u00e1cter. </p> <ul> <li>(b) (1,25 puntos) Dibuje el \u00e1rbol resultante de insertar en la secuencia indicada las letras: Q W E R T Y U I O P.</li> </ul> Mostrar soluci\u00f3n <p></p>"},{"location":"exams/2017/p1r/#problema-2","title":"Problema 2","text":"<p>Un ayuntamiento tiene una base de datos de 20.000 matr\u00edculas. Sobre estos datos el n\u00famero de consultas es abrumadoramente superior al n\u00famero de altas o bajas, por lo que solo nos preocuparemos por las consultas. Tenemos varias opciones para su implementaci\u00f3n:</p> <ol> <li> Un array ordenado, de 20.000 elementos; </li> <li> Una tabla hash de con direccionamiento abierto (resoluci\u00f3n interna de colisiones, sondeo por lista), de  20.000 posiciones; </li> <li> Una tabla hash con listas de desbordamiento y 8.192 (2^13) posiciones; </li> <li> Un \u00e1rbol binario de b\u00fasqueda (BST). </li> </ol> <ul> <li>(a) (2,5 puntos) Para cada opci\u00f3n, indique los pros y los contras y elija razonadamente la estructura de datos que recomienda para el ayuntamiento. Debe argumentar en t\u00e9rminos de espacio ocupado en memoria y del tiempo de b\u00fasqueda.</li> </ul> Mostrar soluci\u00f3n <ol> <li> <p>Pro: Ocupa la memoria imprescindible, sin nada extra; Tiempo \\(O(log n)\\).</p> </li> <li> <p>Pro: Ocupa la memoria imprescindible y un poco m\u00e1s si se guardan los hashes; Contra: El tiempo de acceso se dispara al llegar al 100% de ocupaci\u00f3n y es inviable.</p> </li> <li> <p>Contra: Ocupa memoria para los datos, para la tabla de acceso y para las listas de desbordamiento; Pro: El tiempo de acceso probable es \\(O(1)\\), si los hashes se distribuyen uniformemente y las listas tienen una longitud acotada a unas pocas matr\u00edculas (menos de una docena); Contra: Aunque en el improbable caso peor ser\u00eda \\(O(n)\\).</p> </li> <li> <p>Contra: Ocupa memoria para los datos y para los enlaces entre nodos; Pro: Velocidad de acceso probable \\(O(log n)\\); Contra: Aunque en el improbable caso peor ser\u00eda \\(O(n)\\).</p> </li> </ol> <p>\u00d3ptimo:</p> <ul> <li>por memoria ocupada: (1) Array ordenado;</li> <li>por tiempo (probable) de acceso: (3) Tabla hash.</li> </ul> <p>Si la memoria no es un problema para 20.000 datos, la decisi\u00f3n se tomar\u00eda por tiempo de acceso: tabla hash (3).</p> <p>Si la memoria es la principal limitaci\u00f3n, la mejor opci\u00f3n es el array ordenado (1).</p>"},{"location":"exams/2017/p1r/#problema-3","title":"Problema 3","text":"<p>Sabiendo que el tiempo de ejecuci\u00f3n de la funci\u00f3n <code>f</code> es constante y el de <code>g</code> es lineal con respecto a <code>n</code>.</p> <ul> <li>(a) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    f(i);   \n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>El bucle se ejecuta <code>n</code> veces, y el tiempo de ejecuci\u00f3n de <code>f</code> es constante, por lo que la complejidad es \\(n*O(1) = O(n)\\).</p> <ul> <li>(b) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    g(i);\n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Este bucle se ejecuta <code>n</code> veces, pero ahora el tiempo de ejecuci\u00f3n de <code>g</code> es lineal respecto a <code>n</code>. Por tanto, la complejidad es \\(N*O(N) = O(n2)\\).</p> <ul> <li>(c) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    for (int j = 1; j &lt; i; j*=2) {\n        f(j);\n    };\n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>El bucle exterior se ejecuta <code>n</code> veces, y el bucle interior se ejecuta \\(log\\) \\(i\\) veces. El tiempo de ejecuci\u00f3n de <code>f</code> es constante, como antes. Por tanto la complejidad es \\(O (N log N)\\).</p>"},{"location":"exams/2017/p1r_ex01/","title":"P1r ex01","text":"<p>Dado el siguiente \u00e1rbol binario:</p> <p></p> <ul> <li>(a) (1,25 puntos) Escriba el resultado de recorrerlo en preorden.</li> </ul> Mostrar soluci\u00f3n <p>J A M K Z</p> <p>Tenemos un \u00e1rbol binario de b\u00fasqueda (BST) en el que cada nodo almacena un car\u00e1cter. </p> <ul> <li>(b) (1,25 puntos) Dibuje el \u00e1rbol resultante de insertar en la secuencia indicada las letras: Q W E R T Y U I O P.</li> </ul> Mostrar soluci\u00f3n <p></p>","tags":["grafos"]},{"location":"exams/2017/p1r_ex02/","title":"P1r ex02","text":"<p>Un ayuntamiento tiene una base de datos de 20.000 matr\u00edculas. Sobre estos datos el n\u00famero de consultas es abrumadoramente superior al n\u00famero de altas o bajas, por lo que solo nos preocuparemos por las consultas. Tenemos varias opciones para su implementaci\u00f3n:</p> <ol> <li> Un array ordenado, de 20.000 elementos; </li> <li> Una tabla hash de con direccionamiento abierto (resoluci\u00f3n interna de colisiones, sondeo por lista), de  20.000 posiciones; </li> <li> Una tabla hash con listas de desbordamiento y 8.192 (2^13) posiciones; </li> <li> Un \u00e1rbol binario de b\u00fasqueda (BST). </li> </ol> <ul> <li>(a) (2,5 puntos) Para cada opci\u00f3n, indique los pros y los contras y elija razonadamente la estructura de datos que recomienda para el ayuntamiento. Debe argumentar en t\u00e9rminos de espacio ocupado en memoria y del tiempo de b\u00fasqueda.</li> </ul> Mostrar soluci\u00f3n <ol> <li> <p>Pro: Ocupa la memoria imprescindible, sin nada extra; Tiempo \\(O(log n)\\).</p> </li> <li> <p>Pro: Ocupa la memoria imprescindible y un poco m\u00e1s si se guardan los hashes; Contra: El tiempo de acceso se dispara al llegar al 100% de ocupaci\u00f3n y es inviable.</p> </li> <li> <p>Contra: Ocupa memoria para los datos, para la tabla de acceso y para las listas de desbordamiento; Pro: El tiempo de acceso probable es \\(O(1)\\), si los hashes se distribuyen uniformemente y las listas tienen una longitud acotada a unas pocas matr\u00edculas (menos de una docena); Contra: Aunque en el improbable caso peor ser\u00eda \\(O(n)\\).</p> </li> <li> <p>Contra: Ocupa memoria para los datos y para los enlaces entre nodos; Pro: Velocidad de acceso probable \\(O(log n)\\); Contra: Aunque en el improbable caso peor ser\u00eda \\(O(n)\\).</p> </li> </ol> <p>\u00d3ptimo:</p> <ul> <li>por memoria ocupada: (1) Array ordenado;</li> <li>por tiempo (probable) de acceso: (3) Tabla hash.</li> </ul> <p>Si la memoria no es un problema para 20.000 datos, la decisi\u00f3n se tomar\u00eda por tiempo de acceso: tabla hash (3).</p> <p>Si la memoria es la principal limitaci\u00f3n, la mejor opci\u00f3n es el array ordenado (1).</p>","tags":["complejidad"]},{"location":"exams/2017/p1r_ex03/","title":"P1r ex03","text":"<p>Sabiendo que el tiempo de ejecuci\u00f3n de la funci\u00f3n <code>f</code> es constante y el de <code>g</code> es lineal con respecto a <code>n</code>.</p> <ul> <li>(a) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    f(i);   \n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>El bucle se ejecuta <code>n</code> veces, y el tiempo de ejecuci\u00f3n de <code>f</code> es constante, por lo que la complejidad es \\(n*O(1) = O(n)\\).</p> <ul> <li>(b) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    g(i);\n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Este bucle se ejecuta <code>n</code> veces, pero ahora el tiempo de ejecuci\u00f3n de <code>g</code> es lineal respecto a <code>n</code>. Por tanto, la complejidad es \\(N*O(N) = O(n2)\\).</p> <ul> <li>(c) (1,65 puntos) Razone la complejidad de:  <pre><code>for (int i = 1; i &lt; n; i++) {\n    for (int j = 1; j &lt; i; j*=2) {\n        f(j);\n    };\n};\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>El bucle exterior se ejecuta <code>n</code> veces, y el bucle interior se ejecuta \\(log\\) \\(i\\) veces. El tiempo de ejecuci\u00f3n de <code>f</code> es constante, como antes. Por tanto la complejidad es \\(O (N log N)\\).</p>","tags":["complejidad"]},{"location":"exams/2017/p2/","title":"Examen 2017 \u2014 Parcial 2","text":""},{"location":"exams/2017/p2/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un sistema compuesto de dos conjuntos de hebras. Un conjunto de hebras (editoras) producen contenidos sobre un tema y los env\u00edan a un monitor, <code>Gestor</code>. Otro conjunto de hebras (suscriptoras) reciben los contenidos publicados sobre los temas a los que se suscriben. Las hebras editoras y suscriptoras utilizan los siguientes m\u00e9todos del gestor para sincronizarse:</p> <pre><code>public class Gestor {\n    ...\n    public ... void enviarContenido (Tema unTema, Contenido unContenido) {...}\n    public ... Contenido recibirContenido (Tema unTema) {...}\n}\n</code></pre> <p>Se proporcionan las siguientes clases auxiliares que no hay que implementar:</p> <pre><code>public class Contenido {\n    private String contenido;\n\n    public Contenido(String contenido) {\n        this.contenido = contenido;\n    }\n\n    // ...\n}\n\npublic enum Tema {\n    NACIONAL, INTERNACIONAL, CULTURA, DEPORTE;\n\n    public static Tema random() {\n        // ...\n        return null;\n    }\n}\n\npublic class Nap {\n\n    /**\n     * Duerme un periodo aleatorio entre los limites indicados.\n     *\n     * @param min milisegundos minimos.\n     * @param max milisegundos maximos.\n     */\n    public static void random(int min, int max) {\n        // ...\n    }\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba el c\u00f3digo de una clase que defina hebras suscriptoras. Cada hebra ejecuta un bucle <code>N_VECES</code> (una constante). En cada ciclo genera un tema aleatorio (ver m\u00e1s abajo) e invoca el gestor para recibir mensajes de ese tema. Al recibir un mensaje, invoca un m\u00e9todo privado de la clase, <code>procesarContenido(Contenido c)</code>, que no hay que implementar. Finalmente, se bloquea durante un tiempo aleatorio (puede usar el m\u00e9todo <code>nap.random()</code>).</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Suscriptora extends Thread {\n    private Gestor gestor;\n    private int id;\n    private final int N_VECES = \u2026;\n\n    public Suscriptora(Gestor gestor, int id) {\n        this.gestor = gestor;\n        this.id = id;\n    }\n\n    private void procesarContenido(Contenido unContenido) {\n        // ...\n    }\n\n    @Override\n    public void run() {\n        Tema unTema;\n        Contenido unContenido;\n\n        for (int i = 0; i &lt; N_VECES; i++) {\n            unTema = Tema.random();\n            unContenido = gestor.recibirContenido(unTema);\n            if (unContenido != null)\n                procesarContenido(unContenido);\n\n            Nap.random(100, 500); // por ejemplo\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un esquema del c\u00f3digo de una clase para definir hebras editoras. En este caso, s\u00f3lo hay que implementar el constructor. Su contenido ser\u00eda similar a la anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Editora extends Thread {\n    private Gestor gestor;\n    private int id;\n    private final int N_VECES = 5;\n\n    public Editora(Gestor gestor, int id) {\n        this.gestor = gestor;\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n        // ...\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Escriba el c\u00f3digo de una clase con un programa principal (<code>main</code>) que arranque <code>N_EDITORAS</code> hebras editoras y <code>N_SUSCRIPTORAS</code> hebras suscriptoras, y cree el gestor de contenidos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class PruebaGestor {\n\n    public static void main(String[] args) {\n        final int N_EDITORAS = 10;\n        final int N_SUSCRIPTORAS = 10;\n\n        Gestor gestor = new Gestor();\n\n        for (int i = 0; i &lt; N_EDITORAS; i++) {\n            new Editora(gestor, i).start();\n        }\n\n        for (int i = 0; i &lt; N_SUSCRIPTORAS; i++) {\n            new Suscriptora(gestor, i).start();\n        }\n    }\n}\n</code></pre> <ul> <li>(d) (4 puntos) Completar la clase <code>Gestor</code> de forma que se comporte como un monitor, con lo necesario para sincronizar las hebras de las dos clases citadas. La implementaci\u00f3n de los m\u00e9todos del gestor debe cumplir la siguiente especificaci\u00f3n:</li> </ul> <pre><code>... void enviarContenido(Contenido unContenido, Tema unTema)\n</code></pre> <p>Cuando una hebra editora invoca este m\u00e9todo para publicar un contenido, se debe reanudar la ejecuci\u00f3n de todas las hebras suscriptoras que estuvieran esperando este tema. El contenido debe estar disponible para las suscriptoras hasta que una hebra editora env\u00ede el siguiente contenido.</p> <pre><code>... Contenido recibirContenido (Tema unTema)\n</code></pre> <p>Cuando una hebra suscriptora invoca este m\u00e9todo, recibe el \u00faltimo contenido publicado si su tema coincide con el solicitado. Si el \u00faltimo contenido es de otro tema, la hebra se bloquea hasta que una hebra editora env\u00ede un contenido del tema solicitado.</p> Mostrar soluci\u00f3n <pre><code>public class Gestor {\n\n    private Contenido contenido;\n    private Tema tema;\n\n    public synchronized void enviarContenido(Tema unTema, Contenido unContenido) {\n        if (unContenido == null) return;\n        contenido = unContenido;\n        tema = unTema;\n        notifyAll();\n    }\n\n    public synchronized Contenido recibirContenido(Tema unTema) {\n        if (unTema == null) return null;\n        while (unTema != tema) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                System.out.println(\"Interrupci\u00f3n no esperada\");\n            }\n            return contenido;\n        }\n        return contenido;\n    }\n}\n</code></pre>"},{"location":"exams/2017/p2/#problema-2","title":"Problema 2","text":"<p>Tras numerosos e infructuosos intentos, Espa\u00f1a ha vuelto a ganar el festival de Eurovisi\u00f3n. Como pa\u00eds organizador, debe desarrollar una aplicaci\u00f3n m\u00f3vil para facilitar el televoto. Su misi\u00f3n es completar el c\u00f3digo de la aplicaci\u00f3n que se detalla a continuaci\u00f3n.</p> <p>La aplicaci\u00f3n consta de dos pantallas: <code>MainActivity</code> y <code>VotacionActivity</code>, como se ilustra en la figura.</p> <p>En la primera pantalla, el usuario introduce su pa\u00eds (p.ej. Espa\u00f1a) y puede elegir entre votar o listar canciones (esta \u00faltima utilidad no es misi\u00f3n suya). Una vez escrito el pa\u00eds del usuario, si pincha en el bot\u00f3n 'Votaci\u00f3n', pasa a la segunda pantalla <code>VotacionActivity</code>.</p> <p>En la segunda pantalla, <code>VotacionActivity</code>, el usuario puede realizar dos acciones. La primera es indicar a qu\u00e9 pa\u00eds vota (p.ej. Italia) y cu\u00e1ntos puntos le da (p.ej. 10), y pulsar el bot\u00f3n 'Votar'. La segunda ser\u00eda no realizar la votaci\u00f3n (pulsando el bot\u00f3n 'Cancelar'). Si el usuario pulsa el bot\u00f3n 'Votar', vuelve a la primera pantalla, y se muestra en un mensaje la votaci\u00f3n realizada.</p> <p></p> <ul> <li>(a) (2 puntos) Se pide que complete el c\u00f3digo proporcionado en esta hoja de respuestas. Tenga que cuenta que s\u00f3lo se entregar\u00e1 una hoja.</li> </ul> <p>Tal como se indica en la figura, de la <code>Actividad</code> <code>MainActivity</code> se pasa a <code>VotacionActivity</code> pasando la clave <code>country_voting</code> y el valor <code>String</code> introducido. De la segunda pantalla <code>VotacionActivity</code>, si el usuario pulsa en 'Votaci\u00f3n', pasa a <code>MainActivity</code> pas\u00e1ndole los datos <code>country_voting</code> (valor <code>String</code> inicial recibido), <code>country_voted</code> (<code>String</code> del pa\u00eds votado) y <code>votes</code> (entero de los puntos).</p> <p>Debe completar c\u00f3mo <code>MainActivity</code> pasa a <code>VotacionActivity</code> y c\u00f3mo recibe estos valores. No tenga en cuenta casos an\u00f3malos (un valor no est\u00e1 relleno o no se ha pasado un valor entre actividades)</p> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    private static final String TAG = MainActivity.class.getName();\n    private static final int OBTENER_VOTOS = 0;\n\n    private TextView resultado;\n    private EditText paisVotanteEditText;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Button botonVotar = (Button) findViewById(R.id.botonVotacion);\n        paisVotanteEditText = (EditText) findViewById(R.id.editTextPaisVotante);\n        resultado = (TextView) findViewById(R.id.textViewResultado);\n\n        botonVotar.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                String country = paisVotanteEditText.getText().toString();\n                Intent intent = new Intent(\n                        MainActivity.this,\n                        VotacionActivity.class\n                );\n                intent.putExtra(\"country_voting\", country);\n                startActivityForResult(intent, OBTENER_VOTOS);\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == OBTENER_VOTOS) {\n            if (resultCode == RESULT_OK) {\n                Bundle extras = data.getExtras();\n                String paisVotante = extras.getString(\"country_voting\");\n                String paisVotado = extras.getString(\"country_voted\");\n                int votos = extras.getInt(\"votes\");\n\n                String msg = votos + \" votos recibidos de \"\n                        + paisVotante + \" para \" + paisVotado;\n\n                paisVotanteEditText.setEnabled(false);\n                resultado.setText(msg);\n                resultado.setVisibility(View.VISIBLE);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2017/p2_ex01/","title":"P2 ex01","text":"<p>Se quiere desarrollar un sistema compuesto de dos conjuntos de hebras. Un conjunto de hebras (editoras) producen contenidos sobre un tema y los env\u00edan a un monitor, <code>Gestor</code>. Otro conjunto de hebras (suscriptoras) reciben los contenidos publicados sobre los temas a los que se suscriben. Las hebras editoras y suscriptoras utilizan los siguientes m\u00e9todos del gestor para sincronizarse:</p> <pre><code>public class Gestor {\n    ...\n    public ... void enviarContenido (Tema unTema, Contenido unContenido) {...}\n    public ... Contenido recibirContenido (Tema unTema) {...}\n}\n</code></pre> <p>Se proporcionan las siguientes clases auxiliares que no hay que implementar:</p> <pre><code>public class Contenido {\n    private String contenido;\n\n    public Contenido(String contenido) {\n        this.contenido = contenido;\n    }\n\n    // ...\n}\n\npublic enum Tema {\n    NACIONAL, INTERNACIONAL, CULTURA, DEPORTE;\n\n    public static Tema random() {\n        // ...\n        return null;\n    }\n}\n\npublic class Nap {\n\n    /**\n     * Duerme un periodo aleatorio entre los limites indicados.\n     *\n     * @param min milisegundos minimos.\n     * @param max milisegundos maximos.\n     */\n    public static void random(int min, int max) {\n        // ...\n    }\n}\n</code></pre> <ul> <li>(a) (1 punto) Escriba el c\u00f3digo de una clase que defina hebras suscriptoras. Cada hebra ejecuta un bucle <code>N_VECES</code> (una constante). En cada ciclo genera un tema aleatorio (ver m\u00e1s abajo) e invoca el gestor para recibir mensajes de ese tema. Al recibir un mensaje, invoca un m\u00e9todo privado de la clase, <code>procesarContenido(Contenido c)</code>, que no hay que implementar. Finalmente, se bloquea durante un tiempo aleatorio (puede usar el m\u00e9todo <code>nap.random()</code>).</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Suscriptora extends Thread {\n    private Gestor gestor;\n    private int id;\n    private final int N_VECES = \u2026;\n\n    public Suscriptora(Gestor gestor, int id) {\n        this.gestor = gestor;\n        this.id = id;\n    }\n\n    private void procesarContenido(Contenido unContenido) {\n        // ...\n    }\n\n    @Override\n    public void run() {\n        Tema unTema;\n        Contenido unContenido;\n\n        for (int i = 0; i &lt; N_VECES; i++) {\n            unTema = Tema.random();\n            unContenido = gestor.recibirContenido(unTema);\n            if (unContenido != null)\n                procesarContenido(unContenido);\n\n            Nap.random(100, 500); // por ejemplo\n        }\n    }\n}\n</code></pre> <ul> <li>(b) (1 punto) Escriba un esquema del c\u00f3digo de una clase para definir hebras editoras. En este caso, s\u00f3lo hay que implementar el constructor. Su contenido ser\u00eda similar a la anterior.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Editora extends Thread {\n    private Gestor gestor;\n    private int id;\n    private final int N_VECES = 5;\n\n    public Editora(Gestor gestor, int id) {\n        this.gestor = gestor;\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n        // ...\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Escriba el c\u00f3digo de una clase con un programa principal (<code>main</code>) que arranque <code>N_EDITORAS</code> hebras editoras y <code>N_SUSCRIPTORAS</code> hebras suscriptoras, y cree el gestor de contenidos.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class PruebaGestor {\n\n    public static void main(String[] args) {\n        final int N_EDITORAS = 10;\n        final int N_SUSCRIPTORAS = 10;\n\n        Gestor gestor = new Gestor();\n\n        for (int i = 0; i &lt; N_EDITORAS; i++) {\n            new Editora(gestor, i).start();\n        }\n\n        for (int i = 0; i &lt; N_SUSCRIPTORAS; i++) {\n            new Suscriptora(gestor, i).start();\n        }\n    }\n}\n</code></pre> <ul> <li>(d) (4 puntos) Completar la clase <code>Gestor</code> de forma que se comporte como un monitor, con lo necesario para sincronizar las hebras de las dos clases citadas. La implementaci\u00f3n de los m\u00e9todos del gestor debe cumplir la siguiente especificaci\u00f3n:</li> </ul> <pre><code>... void enviarContenido(Contenido unContenido, Tema unTema)\n</code></pre> <p>Cuando una hebra editora invoca este m\u00e9todo para publicar un contenido, se debe reanudar la ejecuci\u00f3n de todas las hebras suscriptoras que estuvieran esperando este tema. El contenido debe estar disponible para las suscriptoras hasta que una hebra editora env\u00ede el siguiente contenido.</p> <pre><code>... Contenido recibirContenido (Tema unTema)\n</code></pre> <p>Cuando una hebra suscriptora invoca este m\u00e9todo, recibe el \u00faltimo contenido publicado si su tema coincide con el solicitado. Si el \u00faltimo contenido es de otro tema, la hebra se bloquea hasta que una hebra editora env\u00ede un contenido del tema solicitado.</p> Mostrar soluci\u00f3n <pre><code>public class Gestor {\n\n    private Contenido contenido;\n    private Tema tema;\n\n    public synchronized void enviarContenido(Tema unTema, Contenido unContenido) {\n        if (unContenido == null) return;\n        contenido = unContenido;\n        tema = unTema;\n        notifyAll();\n    }\n\n    public synchronized Contenido recibirContenido(Tema unTema) {\n        if (unTema == null) return null;\n        while (unTema != tema) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                System.out.println(\"Interrupci\u00f3n no esperada\");\n            }\n            return contenido;\n        }\n        return contenido;\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2017/p2_ex02/","title":"P2 ex02","text":"<p>Tras numerosos e infructuosos intentos, Espa\u00f1a ha vuelto a ganar el festival de Eurovisi\u00f3n. Como pa\u00eds organizador, debe desarrollar una aplicaci\u00f3n m\u00f3vil para facilitar el televoto. Su misi\u00f3n es completar el c\u00f3digo de la aplicaci\u00f3n que se detalla a continuaci\u00f3n.</p> <p>La aplicaci\u00f3n consta de dos pantallas: <code>MainActivity</code> y <code>VotacionActivity</code>, como se ilustra en la figura.</p> <p>En la primera pantalla, el usuario introduce su pa\u00eds (p.ej. Espa\u00f1a) y puede elegir entre votar o listar canciones (esta \u00faltima utilidad no es misi\u00f3n suya). Una vez escrito el pa\u00eds del usuario, si pincha en el bot\u00f3n 'Votaci\u00f3n', pasa a la segunda pantalla <code>VotacionActivity</code>.</p> <p>En la segunda pantalla, <code>VotacionActivity</code>, el usuario puede realizar dos acciones. La primera es indicar a qu\u00e9 pa\u00eds vota (p.ej. Italia) y cu\u00e1ntos puntos le da (p.ej. 10), y pulsar el bot\u00f3n 'Votar'. La segunda ser\u00eda no realizar la votaci\u00f3n (pulsando el bot\u00f3n 'Cancelar'). Si el usuario pulsa el bot\u00f3n 'Votar', vuelve a la primera pantalla, y se muestra en un mensaje la votaci\u00f3n realizada.</p> <p></p> <ul> <li>(a) (2 puntos) Se pide que complete el c\u00f3digo proporcionado en esta hoja de respuestas. Tenga que cuenta que s\u00f3lo se entregar\u00e1 una hoja.</li> </ul> <p>Tal como se indica en la figura, de la <code>Actividad</code> <code>MainActivity</code> se pasa a <code>VotacionActivity</code> pasando la clave <code>country_voting</code> y el valor <code>String</code> introducido. De la segunda pantalla <code>VotacionActivity</code>, si el usuario pulsa en 'Votaci\u00f3n', pasa a <code>MainActivity</code> pas\u00e1ndole los datos <code>country_voting</code> (valor <code>String</code> inicial recibido), <code>country_voted</code> (<code>String</code> del pa\u00eds votado) y <code>votes</code> (entero de los puntos).</p> <p>Debe completar c\u00f3mo <code>MainActivity</code> pasa a <code>VotacionActivity</code> y c\u00f3mo recibe estos valores. No tenga en cuenta casos an\u00f3malos (un valor no est\u00e1 relleno o no se ha pasado un valor entre actividades)</p> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    private static final String TAG = MainActivity.class.getName();\n    private static final int OBTENER_VOTOS = 0;\n\n    private TextView resultado;\n    private EditText paisVotanteEditText;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Button botonVotar = (Button) findViewById(R.id.botonVotacion);\n        paisVotanteEditText = (EditText) findViewById(R.id.editTextPaisVotante);\n        resultado = (TextView) findViewById(R.id.textViewResultado);\n\n        botonVotar.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                String country = paisVotanteEditText.getText().toString();\n                Intent intent = new Intent(\n                        MainActivity.this,\n                        VotacionActivity.class\n                );\n                intent.putExtra(\"country_voting\", country);\n                startActivityForResult(intent, OBTENER_VOTOS);\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == OBTENER_VOTOS) {\n            if (resultCode == RESULT_OK) {\n                Bundle extras = data.getExtras();\n                String paisVotante = extras.getString(\"country_voting\");\n                String paisVotado = extras.getString(\"country_voted\");\n                int votos = extras.getInt(\"votes\");\n\n                String msg = votos + \" votos recibidos de \"\n                        + paisVotante + \" para \" + paisVotado;\n\n                paisVotanteEditText.setEnabled(false);\n                resultado.setText(msg);\n                resultado.setVisibility(View.VISIBLE);\n            }\n        }\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2018/extra/","title":"Examen 2018 \u2014 Extraordinario","text":""},{"location":"exams/2018/extra/#problema-1","title":"Problema 1","text":"<p>Vamos a trabajar el algoritmo del huevo. Sirve para modelar algoritmos de b\u00fasqueda r\u00e1pida cuando las pruebas son destructivas, reemplazando a la b\u00fasqueda binaria en un array.</p> <p>Tenemos <code>N</code> huevos y un edificio de <code>H</code> pisos. Queremos saber el piso m\u00e1s alto desde el que podemos dejar caer el huevo sin que se rompa. Con las siguientes suposiciones:</p> <ul> <li>Un huevo que sobrevive a una ca\u00edda se puede usar nuevamente;</li> <li>Un huevo roto queda descartado;</li> <li>El efecto de una ca\u00edda es el mismo para todos los huevos;</li> <li>Si un huevo rompe al caer desde un piso, romper\u00e1 si se cae desde un piso superior;</li> <li>Si un huevo no rompe desde un piso, tampoco romper\u00e1 desde un piso superior.</li> </ul> <p>La b\u00fasqueda binaria no sirve. Por ejemplo, si solo tenemos un huevo <code>N=1</code>, el mejor algoritmo es la b\u00fasqueda lineal: ir tirando desde pisos consecutivos hasta que rompa. Si tenemos <code>N=2</code> huevos en un edificio de 100 plantas y probamos en el piso 50 y rompe, solo nos queda un huevo para 49 pruebas adicionales. El \u00f3ptimo para <code>N=2</code> y <code>H=100</code> es empezar desde el piso 14. La b\u00fasqueda binaria vale cuando hay m\u00e1s huevos que pisos.</p> <p>Para averiguar el piso \u00f3ptimo solo necesitamos tener en cuenta cu\u00e1ntos pisos tenemos para probar. Es decir, es lo mismo buscar en los pisos del 1 al 10 que entre el 71 y el 80.</p> <p>Para averiguar el n\u00famero m\u00e1ximo de pruebas con <code>N</code> huevos y <code>H</code> pisos podemos usar un m\u00e9todo recursivo: <pre><code>def drops(n, h):\n    if n == 1:\n        return h\n    if h &lt; 2:\n        return h\n    res = 1000\n    for x in range(1, h + 1):\n        res = min(\n            res,\n            1 + max(drops(n - 1, x - 1), drops(n, h - x))\n        return res;\n</code></pre></p> <p>Simplemente probamos todos los pisos <code>X</code> en el rango de pisos y para cada uno de ellos tenemos 2 opciones:</p> <ul> <li>Que el huevo se rompa y tenemos <code>N-1</code> huevos y <code>X-1</code> pisos;</li> <li>Que el huevo no rompa y tenemos <code>N</code> huevos y <code>H-X</code> pisos.</li> </ul> <p>Probamos este c\u00f3digo y va muy muy lento. Medimos tiempos para <code>N=2</code> y obtenemos esto:</p> <p></p> <ul> <li>(a) (2,5 puntos) Indicar la complejidad del algoritmo recursivo en funci\u00f3n de <code>H</code>. No se pide que la calcule anal\u00edticamente, solo que la marque y la valide a partir de las medidas realizadas.</li> </ul> Mostrar soluci\u00f3n <p>Estudio de opciones en base al coeficiente de correlaci\u00f3n.</p> Complejidad r Evaluaci\u00f3n \\(O(log h)\\) 0.36 NO, \\(r &lt;&lt; 1.0\\) \\(O(h)\\) 0.41 NO, \\(r &lt;&lt; 1.0\\) \\(O(h log h)\\) 0.43 NO, \\(r &lt;&lt; 1.0\\) \\(O(h^18)\\) 0.98 Posible \\(O(1.9^h)\\) 1.00 Posible <p>De las 2 opciones posibles, es absurdo que en un algoritmo recursivo como el presentado aparezca un polinomio de orden 18.</p> <p>S\u00ed es posible una complejidad \\(O(2^h)\\), que es probablemente la soluci\u00f3n.</p> <p>Del an\u00e1lisis de la relaci\u00f3n de recurrencia, para <code>N=2</code>, tenemos un bucle interno sobre <code>x</code> que se ejecuta <code>h</code> veces en forma de serie aritm\u00e9tica:</p> <p>\\(T(n, h-1) + T(n, h-2) + \u2026 + T(n, 1)\\)</p> <p>\\(= h * (T(n, h-1) + T(n, 1)) / 2\\)</p> <p>\\(\u2248 h * T(n, h-1)\\)</p> <p>El algoritmo completo queda definido por la recurrencia:</p> <p>\\(T(h) = h * T(h-1)\\)</p> <p>Intentamos validar la soluci\u00f3n propuesta:</p> <p>\\(T(h) = 2^h\\)</p> <p>Sustituyendo en la recurrencia:</p> <p>\\(2^h = h * 2^{h-1}\\)</p> <p>Esta igualdad se cumple para \\(h &gt;&gt; 1\\) (cuando <code>h</code> tiende a infinito).</p> <p>Para <code>n</code> constante, el algoritmo tiene complejidad \\(O(2^h)\\).</p> <p>Como el algoritmo recursivo no es pr\u00e1ctico, recurrimos a memorizar resultados intermedios, de forma similar a como se hace con las series de Fibonacci. <pre><code>01  int eggDrop(int n, int h) {\n02      int[][] cache = new int[n + 1][h + 1];\n03      for (int i = 1; i &lt;= n; i++) {\n04          cache[i][1] = 1;\n05          cache[i][0] = 0;\n06      }\n07      for (int j = 1; j &lt;= h; j++)\n08          cache[1][j] = j;\n09      for (int i = 2; i &lt;= n; i++) {\n10          for (int j = 2; j &lt;= h; j++) {\n11              int min = Integer.MAX_VALUE;\n12              for (int x = 1; x &lt;= j; x++) {\n13                  int res = 1 + Math.max(cache[i - 1][x - 1],\n14                                          cache[i][j - x]);\n15                  min = Math.min(min, res);\n16              }\n17              cache[i][j] = min;\n18          }\n19      }\n20      return cache[n][h];\n21  }\n</code></pre></p> <ul> <li>(b) (2,5 puntos) Se pide que calcule la complejidad de la implementaci\u00f3n iterativa, en funci\u00f3n de <code>N</code> y <code>H</code>. Se valorar\u00e1 la correcci\u00f3n de los razonamientos usados para determinar la complejidad.</li> </ul> Mostrar soluci\u00f3n L\u00ednea Complejidad 2 \\(O(1)\\) 3\u20136 \\(n \u00b7 O(1) = O(n)\\) 7\u20138 \\(h \u00b7 O(1) = O(h)\\) 9 \\(n \u00b7 ...(bucle\\) <code>for</code>\\()\\) 10 \\(h \u00b7 ...(bucle\\) <code>for</code>\\()\\) 11 \\(O(1)\\) 12 \\(h \u00b7 ...(bucle\\) <code>for</code>\\()\\) 13\u201315 \\(O(1)\\) 12\u201316 \\(h \u00b7 O(1) = O(h)\\) 17 \\(O(1)\\) 10\u201318 \\(h \u00b7 (O(1) + O(h) + O(1)) = O(h^2)\\) 9\u201319 \\(n \u00b7 O(h^2) = O(n\u00b7h^2)\\) 20 \\(O(1)\\) 2\u201321 \\(O(1) + O(n) + O(h) + O(n\u00b7h^2) + O(1) = O(n\u00b7h^2)\\) <p>Hemos convertido un algoritmo recursivo de orden exponencial en un algoritmo iterativo de orden cuadr\u00e1tico.</p>"},{"location":"exams/2018/extra/#problema-2","title":"Problema 2","text":"<p>Disponemos de las clases <code>Datos</code>, <code>DatosOrdenado</code>, y <code>BST</code>, cuyos esquemas se pueden ver debajo. La case <code>Datos</code> almacena valores enteros sin ordenar en un array de tama\u00f1o fijado en el constructor. La clase <code>DatosOrdenado</code> almacena valores enteros ordenados de menor a mayor en un array de tama\u00f1o fijado en el constructor. La clase <code>BST</code> almacena valores enteros en un BST, donde en cada nodo del \u00e1rbol se almacena un n\u00famero entero en el campo valor. <pre><code>public class Datos {\n    private int[] valores;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n\npublic class DatosOrdenado {\n    private int[] valores;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n\npublic class BST {\n    private class Nodo {\n        int valor;\n        Nodo izd;\n        Nodo der;\n    }\n\n    private Nodo raiz;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n</code></pre></p> <p>En una aplicaci\u00f3n concreta que estamos desarrollando, deseamos conocer cu\u00e1ntos valores almacenados son menores que un cierto valor <code>val</code> que se pasa como par\u00e1metro. Este valor que se pasa como par\u00e1metro puede no ser uno de los valores almacenados.</p> <ul> <li>(a) (2,5 puntos) Codificar el m\u00e9todo <code>public int cuentaMenores (int val)</code>, en cada una de las 3 clases: <code>Datos</code>, <code>DatosOrdenado</code> y <code>BST</code>. Nota: Para simplificar suponga que tanto en <code>Datos</code> como en <code>DatosOrdenado</code>, los arrays de enteros est\u00e1n ocupados en su totalidad por valores almacenados. Suponga que no hay datos repetidos y que no hay operaciones de modificaci\u00f3n (inserci\u00f3n o borrado), sino exclusivamente se trata de buscar en una estructura de datos construida.</li> </ul> Mostrar soluci\u00f3n <pre><code>class Datos {\n    public int cuentaMenores(int val) {\n        int cuenta = 0;\n        for (int i = 0; i &lt; nValores; i++) {\n            if (valores[i] &lt; val)\n                cuenta++;\n        }\n        return cuenta;\n    }\n}\n\nclass DatosOrdenado {\n    public int cuentaMenores(int val) {\n        int n = valores.length;\n        int centro, inf = 0, sup = n - 1;\n        while (inf &lt;= sup) {\n            centro = (sup + inf) / 2;\n            if (valores[centro] == val)\n                return centro;\n            else if (val &lt; valores[centro]) {\n                sup = centro - 1;\n            } else {\n                inf = centro + 1;\n            }\n        }\n        return sup + 1;\n    }\n}\n\nclass BST {\n    private int cuentaMenores(Nodo actual, int val) {\n        int cuenta = 0;\n        if (actual == null)\n            return 0;\n        if (actual.valor == val)\n            return cuentaTodos(actual.izd);\n        if (actual.valor &lt; val)\n            cuenta = 1;\n        int nizd = cuentaMenores(actual.izd, val);\n        int nder = cuentaMenores(actual.der, val);\n        return cuenta + nizd + nder;\n    }\n\n    private int cuentaTodos(Nodo actual) {\n        if (actual == null)\n            return 0;\n        return 1 + cuentaTodos(actual.izd) + cuentaTodos(actual.der);\n    }\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Se pide: Considerando s\u00f3lo los m\u00e9todos <code>cuentaMenores</code> que acaba de implementar, cu\u00e1l de las tres clases seleccionar\u00eda para almacenar un conjunto de valores de tama\u00f1o fijo <code>M</code>, donde se vayan a realizar frecuentes llamas al m\u00e9todo <code>cuentaMenores</code>.</li> </ul> Mostrar soluci\u00f3n <p>La clase <code>Datos</code> al tener los valores no ordenados nos obliga a recorrer todo el array, por lo tanto, la complejidad es proporcional al n\u00famero de valores almacenados: \\(O(N)\\).</p> <p>La clase <code>DatosOrdenado</code>, tiene los valores ordenados de menor a mayor. Que los valores est\u00e9n ordenados permite utilizar b\u00fasqueda dicot\u00f3mica para localizar el valor, o en su defecto la posici\u00f3n donde deber\u00eda estar el valor que estamos buscando. Esta operaci\u00f3n tiene una complejidad \\(O(log N)\\). Una vez localizada la posici\u00f3n donde est\u00e1 o deber\u00eda estar el valor, todos los de la izquierda son menores que \u00e9l, por lo tanto, por lo que directamente conocemos el n\u00famero de valores menores que el que nos pasan como par\u00e1metro usando el \u00edndice de la posici\u00f3n del array donde est\u00e1 o deber\u00eda estar el valor pasado como par\u00e1metro. El resultado es un algoritmo de orden \\(O(log N)\\).</p> <p>En el caso de <code>BST</code> la estructura de BST ayuda a encontrar el valor en el \u00e1rbol con una complejidad \\(O(log N)\\),pero como lo que nos piden es el n\u00famero de valores menor que el valor pasado como par\u00e1metro, e incluso puede ocurrir que le propio valor no se encuentre en el \u00e1rbol, debemos recorrer casi todo el \u00e1rbol con una complejidad \\(O(N)\\).</p> <p>Por lo tanto, a la vista de este an\u00e1lisis, para nuestro problema concreto, la clase seleccionada es <code>DatosOrdenado</code>.</p>"},{"location":"exams/2018/extra/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (2 puntos) Explique brevemente cu\u00e1l es la diferencia entre interbloqueo (deadlock) y bloqueo vivo (livelock).</li> </ul> Mostrar soluci\u00f3n <p>En un interbloqueo hay varias hebras suspendidas, esperando conseguir recursos que tienen que liberar otras hebras, de tal manera que en conjunto se forma una cada de espera circular y ninguna hebra puede avanzar.</p> <p>En un bloqueo vivo hay igualmente varias hebras intentando conseguir recursos que tienen otras hebras. La diferencia es que cuando una hebra no puede conseguir todos sus recursos libera los que tiene y lo vuelve a intentar. Como consecuencia, las hebras implicadas est\u00e1n continuamente activas, aunque sin realizar ning\u00fan progreso.</p> <p>Por tanto, la diferencia fundamental es que en un interbloqueo las hebras est\u00e1s suspendidas y nunca se ejecutan, mientras que en un bloqueo vivo las hebras se ejecutan pero no progresan.</p> <p>Sea un sistema con 8 GB de memoria principal. Tenemos procesos concurrentes que solicitan memoria en bloques de 2 GB a medida que la necesitan para su ejecuci\u00f3n. Un proceso que ya tiene <code>N</code> bloques de memoria asignados puede solicitar m\u00e1s memoria, y si ya no hay memoria disponible espera a que la haya antes de continuar. La memoria asignada a un proceso se libera completamente cuando el proceso termina su ejecuci\u00f3n.</p> <ul> <li>(b) (3 puntos) Indique razonadamente si es posible que se d\u00e9 una situaci\u00f3n de interbloqueo (deadlock), en qu\u00e9 circunstancias podr\u00eda ocurrir y, si \u00e9ste es el caso, c\u00f3mo se podr\u00eda evitar.</li> </ul> Mostrar soluci\u00f3n <p>Los procesos acceden a un conjunto de recursos, los bloques de memoria, todos iguales, con una disponibilidad total limitada a 4 bloques en total. Se pueden producir interbloqueos si varios procesos intentan adquirir m\u00e1s memoria cuando ya est\u00e1 toda asignada a otros procesos que tambi\u00e9n necesitan m\u00e1s memoria.</p> <p>Por ejemplo, sup\u00f3ngase que hay dos procesos <code>P</code> y <code>Q</code>, que tiene asignados 2 bloques de memoria cada uno, es decir 4 en total, por lo que no hay bloques libres. Si ambos solicitan un bloque adicional cada uno, al no estar disponible se suspenden esperando que haya memoria libre. Para ello uno de los dos tendr\u00eda que terminar, liberando su memoria, pero al no poder avanzar ninguno de los dos se quedan suspendidos indefinidamente.</p> <p>Podemos comprobar que se cumplen las condiciones necesarias de Coffman:</p> <ol> <li>Exclusi\u00f3n mutua: Un bloque de memoria s\u00f3lo puede estar asignado a un proceso.</li> <li>Tener y esperar: Un proceso puede tener asignada memoria y esperar que conseguir m\u00e1s.</li> <li>Sin expulsi\u00f3n: No se quita memoria a un proceso hasta que termina su ejecuci\u00f3n.</li> <li>Espera circular, como pone de manifiesto el ejemplo anterior.</li> </ol> <p>Para evitar el interbloqueo la soluci\u00f3n m\u00e1s sencilla ser\u00eda obligar a que los procesos soliciten toda la memoria que pueden necesitar al iniciarse, invalidando la condici\u00f3n 2. N\u00f3tese que la soluci\u00f3n frecuentemente recomendada de asignar los recursos siempre en el mismo orden no es aplicable aqu\u00ed porque todos los bloques de memoria son iguales</p>"},{"location":"exams/2018/extra/#problema-4","title":"Problema 4","text":"<p>La panader\u00eda Molinga S.L. quiere modernizar sus instalaciones robotizando su sistema de producci\u00f3n de pan. Para ello han encargado a los alumnos de ADSW que realicen parte del sistema.</p> <p>Se desea realizar dos monitores para gestionar la amasadora y el horno de la panader\u00eda, con acceso exclusivo por parte de varios robots (threads). Existen 3 tipos de robots en la panader\u00eda:</p> <ul> <li>Robots de almac\u00e9n, que meten ingredientes en la amasadora;</li> <li>Robots amasadores, que cuando tienen los ingredientes necesarios amasan y despu\u00e9s meten la masa en el horno;</li> <li>Robots horneadores, que cuando tienen las masas necesarias para llenar un horno, hornean el pan.</li> </ul> <p>La amasadora permitir\u00e1 introducir ingredientes a los robots de almac\u00e9n y amasar a los robots amasadores. Para hacer una masa de pan hacen falta cuatro ingredientes: agua, harina, levadura y sal, en la proporci\u00f3n de <code>4</code>, <code>3</code>, <code>2</code>, y <code>1</code> unidades. No se permitir\u00e1 a los robots de almac\u00e9n introducir m\u00e1s ingredientes si hay suficientes para hacer una masa, y de igual manera no se permitir\u00e1 a los robots amasadores amasar si no hay suficientes ingredientes para hacer una masa.</p> <p>El horno permitir\u00e1 introducir masas a los robots amasadores y hornear a los robots horneadores. Un horno tiene un tama\u00f1o concreto, que recibir\u00e1 como par\u00e1metro en el constructor, indicando el n\u00famero de masas que es capaz de hornear. Por motivos de eficiencia, los robots horneadores solo podr\u00e1n hornear si el horno est\u00e1 completamente lleno, y los robots amasadores solo podr\u00e1n meter masas si hay hueco en el horno.</p> <p>Estructura de clases de la panader\u00eda:</p> <p></p> <p>Ejemplo de programa con varios robots: <pre><code>public enum Ingrediente {\n    Agua, Harina, Levadura, Sal\n}\n\npublic static void main(String[] args) {\n    Amasadora amasadora = new Amasadora();\n    Horno horno = new Horno(5);\n    new RobotAlmacen(\"ED209\",amasadora).start();\n    new RobotAlmacen(\"T-800\",amasadora).start();\n    new RobotAlmacen(\"WALL-E\",amasadora).start();\n    new RobotAlmacen(\"Bumblebee\",amasadora).start();\n    new RobotAmasador(\"R2D2\",amasadora,horno).start();\n    new RobotAmasador(\"C3PO\",amasadora,horno).start();\n    new RobotAmasador(\"BB8\",amasadora,horno).start();\n    new RobotHorneador(\"Chappie\",horno).start();\n    new RobotHorneador(\"RoboCop\",horno).start();\n}\n</code></pre></p> <p>Ejemplo de c\u00f3digo del robor horneador: <pre><code>public class RobotHorneador extends Thread {\n    private Horno horno;\n    private String nombre;\n    private int panes = 0;\n    private Random random = new Random();\n\n    public RobotHorneador(String nombre, Horno horno) {\n        this.horno = horno;\n        this.nombre = nombre;\n        this.panes = 0;\n    }\n\n    public String getNombre() {return this.nombre;}\n\n    public void run() {\n        while (true) {\n            try {\n                int panesNuevos = this.horno.hornear();\n                this.panes = this.panes + panesNuevos;\n                Thread.sleep(random.nextInt(5000));\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre></p> <ul> <li>(a) (2,5 puntos) Desarrollar el monitor <code>Amasadora</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Amasadora {\n    private int cantidadAgua;\n    private int cantidadHarina;\n    private int cantidadLevadura;\n    private int cantidadSal;\n\n    public synchronized void amasar() {\n        try {\n            while (!((this.cantidadAgua &gt;= 4) &amp;&amp; (this.cantidadHarina &gt;= 3) &amp;&amp;\n                   (this.cantidadLevadura &gt;= 2) &amp;&amp; (this.cantidadSal &gt;= 1))) {\n                wait();\n            }\n            this.cantidadAgua = this.cantidadAgua - 4;\n            this.cantidadHarina = this.cantidadHarina - 3;\n            this.cantidadLevadura = this.cantidadLevadura - 2;\n            this.cantidadSal = this.cantidadSal - 1;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n\n    public synchronized void meterIngredientes(Ingrediente ingrediente, int cantidad) {\n        try {\n            while (((this.cantidadAgua &gt;= 4) &amp;&amp; (this.cantidadHarina &gt;= 3) &amp;&amp;\n                   (this.cantidadLevadura &gt;= 2) &amp;&amp; (this.cantidadSal &gt;= 1))) {\n                wait();\n            }\n            switch (ingrediente) {\n                case Agua:\n                    this.cantidadAgua = this.cantidadAgua + cantidad;\n                    break;\n                case Harina:\n                    this.cantidadHarina = this.cantidadHarina + cantidad;\n                    break;\n                case Levadura:\n                    this.cantidadLevadura = this.cantidadLevadura + cantidad;\n                    break;\n                case Sal:\n                    this.cantidadSal = this.cantidadSal + cantidad;\n                    break;\n            }\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Desarrollar el monitor <code>Horno</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Horno {\n    private int masas;\n    private int tama\u00f1o;\n\n    public Horno(int tama\u00f1o) {\n        this.tama\u00f1o = tama\u00f1o;\n    }\n\n    public synchronized int hornear(String nombre) {\n        try {\n            while (!(this.masas &gt;= this.tama\u00f1o)) {\n                wait();\n            }\n            this.masas = this.masas - this.tama\u00f1o;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n        return this.tama\u00f1o;\n    }\n\n    public synchronized void meterMasa(String nombre) {\n        try {\n            while (this.masas &gt;= this.tama\u00f1o) {\n                wait();\n            }\n            this.masas++;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n}\n</code></pre> <ul> <li>(c) (0,5 puntos) Proponer el m\u00e9todo <code>run()</code> del robot amasador.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void run() {\n    while (true) {\n        amasadora.amasar();\n        horno.meterMasa();\n    }\n}\n</code></pre>"},{"location":"exams/2018/extra/#problema-5","title":"Problema 5","text":"<p>Se desea ampliar el juego de la serpiente con un contador de las manzanas que ha comido la serpiente. Naturalmente, cuando la serpiente come una manzana, este contador debe aumentar en una unidad. Para a\u00f1adir dificultad al jugador, tambi\u00e9n puede perder manzanas de este contador por dos motivos:</p> <ul> <li>Si una bola choca con una manzana, el jugador pierde una unidad de su contador de manzanas comidas. El contador no puede nunca tener un valor inferior a cero como resultado de esta p\u00e9rdida, pero la p\u00e9rdida debe ejecutarse tan pronto como sea posible;</li> <li>Si la serpiente es golpeada en la cabeza por una bola, el contador de manzanas se reduce a la mitad, redondeando al entero inmediatamente inferior. Esto es, si el jugador ten\u00eda 7 puntos debe quedarse con 3.</li> </ul> <p>Siendo la clase <code>Manzanas</code>: <pre><code>public class Manzanas\nimplements Screen.Thing {\n\n    /** Constructor. */\n    public Manzanas() {\n        font = new Font(\"SansSerif\", Font.BOLD, 18);\n        Game.getScreen().add(this);\n    }\n\n    /** La serpiente ha comido una manzana. */\n    public void appleEaten() {\n    }\n\n    /** Una bola ha destruido una manzana. */\n    public void appleDestroid() {\n    }\n\n    /** Una bola ha golpeado la cabeza de la serpiente. */\n    public void headShot() {\n    }\n\n    /** Se imprime en pantalla. */\n    @Override\n    public void paint(Graphics2D g) {\n        g.setFont(font);\n        g.setColor(Color.BLACK);\n        g.drawString(\"manzanas: \" + , 10, 30);\n    }\n}\n</code></pre></p> <ul> <li>(a) (5 puntos) Se pide que complete y modifique la clase monitor <code>Manzanas</code> como considere oportuno para obtener la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * Contador de manzanas.\n */\npublic class Manzanas\nimplements Screen.Thing {\n\n    private int manzanas;\n\n    public Manzanas() {\n        font = new Font(\"SansSerif\", Font.BOLD, 18);\n        manzanas = 0;\n        Game.getScreen().add(this);\n    }\n\n    public synchronized void appleEaten() {\n        manzanas++;\n        notifyAll();\n    }\n\n    public synchronized void appleDestroid() {\n        while (manzanas &lt;= 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        manzanas--;\n    }\n\n    public synchronized void headShot() {\n        manzanas = manzanas / 2;\n    }\n\n    @Override\n    public void paint(Graphics2D g) {\n        g.setFont(font);\n        g.setColor(Color.BLACK);\n        g.drawString(\"manzanas: \" + manzanas, 10, 30);\n    }\n}\n</code></pre>"},{"location":"exams/2018/extra/#problema-6","title":"Problema 6","text":"<p>Para la aplicaci\u00f3n Android <code>DaysUntil</code> se desea a\u00f1adir la posibilidad de a\u00f1adir una descripci\u00f3n del evento introducido por el usuario. Esta informaci\u00f3n es opcional para la funcionalidad b\u00e1sica de la aplicaci\u00f3n. Sin embargo, en caso de existir una descripci\u00f3n, esta debe incluirse en la informaci\u00f3n pasada como intenci\u00f3n impl\u00edcita para la creaci\u00f3n de un evento en el calendario del usuario al pulsar un bot\u00f3n.</p> <p>Siendo el esqueleto del c\u00f3digo el siguiente: <pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    /** Devuelve el nombre del evento introducido por el usuario */\n    private String getEvento () { ... }\n\n    /** Devuelve la fecha del evento introducida por el usuario */\n    private Calendar getFecha () { ... }\n\n    /** \n     * A partir de un nombre y una fecha crea una intenci\u00f3n impl\u00edcita para la\n     * inserci\u00f3n de un nuevo evento en un calendario\n     */\n    private Intent eventIntent (String nombre, Calendar fecha) { ... }\n\n    public void crearEvento (View v) {\n        // Completar\n    }\n}\n</code></pre></p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout\n    \u2026 &gt;\n\n    &lt;LinearLayout \u2026 &gt;\n        &lt;EditText\n            android:id=\"@+id/eventName\"\n            \u2026 /&gt;\n        &lt;EditText\n            android:id=\"@+id/eventDate\"\n            \u2026 /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre> <ul> <li>(a) Complete el c\u00f3digo asociado a dicha funcionalidad, tanto en el c\u00f3digo java como en la definici\u00f3n del <code>layout</code> asociado a la actividad en cuesti\u00f3n. Considere implementados los m\u00e9todos <code>getNombre</code> y <code>getFecha</code>. Ha de implementar completamente cualquier otro m\u00e9todo auxiliar que considere necesario. Nota: la clave esperada por la intenci\u00f3n de crear un evento para la descripci\u00f3n del mismo es <code>CalendarContract.Events.DESCRIPTION</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    /** Devuelve el nombre del evento introducido por el usuario */\n    private String getEvento() { ... }\n\n    /** Devuelve la fecha del evento introducida por el usuario */\n    private Calendar getFecha() { ... }\n\n    /**\n     * A partir de un nombre y una fecha crea una intenci\u00f3n impl\u00edcita para la inserci\u00f3n de un\n     * nuevo evento en un calendario\n     */\n    private Intent eventIntent(String nombre, Calendar fecha) { ... }\n\n    public void crearEvento(View v) {\n        EditText eventDescription = eventDescription = (EditText)\n                findViewById(R.id.eventDescription);\n\n        Intent intent = eventIntent(getEvento(), getFecha());\n\n        if (eventDescription.getText().toString().length() &gt; 0) {\n            intent.putExtra(CalendarContract.Events.DESCRIPTION,\n                    eventDescription.getText().toString());\n        }\n\n        startActivity(intent);\n    }\n}\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout\n    \u2026 &gt;\n\n    &lt;LinearLayout \u2026 &gt;\n        &lt;EditText\n            android:id=\"@+id/eventName\"\n            \u2026 /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/eventDate\"\n            \u2026 /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/eventDescription\"\n            android:hint=\"Event description\"\n            \u2026 /&gt;\n\n        &lt;Button\n            android:text=\"Add event to calendar\"\n            android:onClick=\"crearEvento\"/&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>"},{"location":"exams/2018/extra_ex01/","title":"Extra ex01","text":"<p>Vamos a trabajar el algoritmo del huevo. Sirve para modelar algoritmos de b\u00fasqueda r\u00e1pida cuando las pruebas son destructivas, reemplazando a la b\u00fasqueda binaria en un array.</p> <p>Tenemos <code>N</code> huevos y un edificio de <code>H</code> pisos. Queremos saber el piso m\u00e1s alto desde el que podemos dejar caer el huevo sin que se rompa. Con las siguientes suposiciones:</p> <ul> <li>Un huevo que sobrevive a una ca\u00edda se puede usar nuevamente;</li> <li>Un huevo roto queda descartado;</li> <li>El efecto de una ca\u00edda es el mismo para todos los huevos;</li> <li>Si un huevo rompe al caer desde un piso, romper\u00e1 si se cae desde un piso superior;</li> <li>Si un huevo no rompe desde un piso, tampoco romper\u00e1 desde un piso superior.</li> </ul> <p>La b\u00fasqueda binaria no sirve. Por ejemplo, si solo tenemos un huevo <code>N=1</code>, el mejor algoritmo es la b\u00fasqueda lineal: ir tirando desde pisos consecutivos hasta que rompa. Si tenemos <code>N=2</code> huevos en un edificio de 100 plantas y probamos en el piso 50 y rompe, solo nos queda un huevo para 49 pruebas adicionales. El \u00f3ptimo para <code>N=2</code> y <code>H=100</code> es empezar desde el piso 14. La b\u00fasqueda binaria vale cuando hay m\u00e1s huevos que pisos.</p> <p>Para averiguar el piso \u00f3ptimo solo necesitamos tener en cuenta cu\u00e1ntos pisos tenemos para probar. Es decir, es lo mismo buscar en los pisos del 1 al 10 que entre el 71 y el 80.</p> <p>Para averiguar el n\u00famero m\u00e1ximo de pruebas con <code>N</code> huevos y <code>H</code> pisos podemos usar un m\u00e9todo recursivo: <pre><code>def drops(n, h):\n    if n == 1:\n        return h\n    if h &lt; 2:\n        return h\n    res = 1000\n    for x in range(1, h + 1):\n        res = min(\n            res,\n            1 + max(drops(n - 1, x - 1), drops(n, h - x))\n        return res;\n</code></pre></p> <p>Simplemente probamos todos los pisos <code>X</code> en el rango de pisos y para cada uno de ellos tenemos 2 opciones:</p> <ul> <li>Que el huevo se rompa y tenemos <code>N-1</code> huevos y <code>X-1</code> pisos;</li> <li>Que el huevo no rompa y tenemos <code>N</code> huevos y <code>H-X</code> pisos.</li> </ul> <p>Probamos este c\u00f3digo y va muy muy lento. Medimos tiempos para <code>N=2</code> y obtenemos esto:</p> <p></p> <ul> <li>(a) (2,5 puntos) Indicar la complejidad del algoritmo recursivo en funci\u00f3n de <code>H</code>. No se pide que la calcule anal\u00edticamente, solo que la marque y la valide a partir de las medidas realizadas.</li> </ul> Mostrar soluci\u00f3n <p>Estudio de opciones en base al coeficiente de correlaci\u00f3n.</p> Complejidad r Evaluaci\u00f3n \\(O(log h)\\) 0.36 NO, \\(r &lt;&lt; 1.0\\) \\(O(h)\\) 0.41 NO, \\(r &lt;&lt; 1.0\\) \\(O(h log h)\\) 0.43 NO, \\(r &lt;&lt; 1.0\\) \\(O(h^18)\\) 0.98 Posible \\(O(1.9^h)\\) 1.00 Posible <p>De las 2 opciones posibles, es absurdo que en un algoritmo recursivo como el presentado aparezca un polinomio de orden 18.</p> <p>S\u00ed es posible una complejidad \\(O(2^h)\\), que es probablemente la soluci\u00f3n.</p> <p>Del an\u00e1lisis de la relaci\u00f3n de recurrencia, para <code>N=2</code>, tenemos un bucle interno sobre <code>x</code> que se ejecuta <code>h</code> veces en forma de serie aritm\u00e9tica:</p> <p>\\(T(n, h-1) + T(n, h-2) + \u2026 + T(n, 1)\\)</p> <p>\\(= h * (T(n, h-1) + T(n, 1)) / 2\\)</p> <p>\\(\u2248 h * T(n, h-1)\\)</p> <p>El algoritmo completo queda definido por la recurrencia:</p> <p>\\(T(h) = h * T(h-1)\\)</p> <p>Intentamos validar la soluci\u00f3n propuesta:</p> <p>\\(T(h) = 2^h\\)</p> <p>Sustituyendo en la recurrencia:</p> <p>\\(2^h = h * 2^{h-1}\\)</p> <p>Esta igualdad se cumple para \\(h &gt;&gt; 1\\) (cuando <code>h</code> tiende a infinito).</p> <p>Para <code>n</code> constante, el algoritmo tiene complejidad \\(O(2^h)\\).</p> <p>Como el algoritmo recursivo no es pr\u00e1ctico, recurrimos a memorizar resultados intermedios, de forma similar a como se hace con las series de Fibonacci. <pre><code>01  int eggDrop(int n, int h) {\n02      int[][] cache = new int[n + 1][h + 1];\n03      for (int i = 1; i &lt;= n; i++) {\n04          cache[i][1] = 1;\n05          cache[i][0] = 0;\n06      }\n07      for (int j = 1; j &lt;= h; j++)\n08          cache[1][j] = j;\n09      for (int i = 2; i &lt;= n; i++) {\n10          for (int j = 2; j &lt;= h; j++) {\n11              int min = Integer.MAX_VALUE;\n12              for (int x = 1; x &lt;= j; x++) {\n13                  int res = 1 + Math.max(cache[i - 1][x - 1],\n14                                          cache[i][j - x]);\n15                  min = Math.min(min, res);\n16              }\n17              cache[i][j] = min;\n18          }\n19      }\n20      return cache[n][h];\n21  }\n</code></pre></p> <ul> <li>(b) (2,5 puntos) Se pide que calcule la complejidad de la implementaci\u00f3n iterativa, en funci\u00f3n de <code>N</code> y <code>H</code>. Se valorar\u00e1 la correcci\u00f3n de los razonamientos usados para determinar la complejidad.</li> </ul> Mostrar soluci\u00f3n L\u00ednea Complejidad 2 \\(O(1)\\) 3\u20136 \\(n \u00b7 O(1) = O(n)\\) 7\u20138 \\(h \u00b7 O(1) = O(h)\\) 9 \\(n \u00b7 ...(bucle\\) <code>for</code>\\()\\) 10 \\(h \u00b7 ...(bucle\\) <code>for</code>\\()\\) 11 \\(O(1)\\) 12 \\(h \u00b7 ...(bucle\\) <code>for</code>\\()\\) 13\u201315 \\(O(1)\\) 12\u201316 \\(h \u00b7 O(1) = O(h)\\) 17 \\(O(1)\\) 10\u201318 \\(h \u00b7 (O(1) + O(h) + O(1)) = O(h^2)\\) 9\u201319 \\(n \u00b7 O(h^2) = O(n\u00b7h^2)\\) 20 \\(O(1)\\) 2\u201321 \\(O(1) + O(n) + O(h) + O(n\u00b7h^2) + O(1) = O(n\u00b7h^2)\\) <p>Hemos convertido un algoritmo recursivo de orden exponencial en un algoritmo iterativo de orden cuadr\u00e1tico.</p>","tags":["complejidad"]},{"location":"exams/2018/extra_ex02/","title":"Extra ex02","text":"<p>Disponemos de las clases <code>Datos</code>, <code>DatosOrdenado</code>, y <code>BST</code>, cuyos esquemas se pueden ver debajo. La case <code>Datos</code> almacena valores enteros sin ordenar en un array de tama\u00f1o fijado en el constructor. La clase <code>DatosOrdenado</code> almacena valores enteros ordenados de menor a mayor en un array de tama\u00f1o fijado en el constructor. La clase <code>BST</code> almacena valores enteros en un BST, donde en cada nodo del \u00e1rbol se almacena un n\u00famero entero en el campo valor. <pre><code>public class Datos {\n    private int[] valores;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n\npublic class DatosOrdenado {\n    private int[] valores;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n\npublic class BST {\n    private class Nodo {\n        int valor;\n        Nodo izd;\n        Nodo der;\n    }\n\n    private Nodo raiz;\n    // \u2026..\n    public int cuentaMenores(int val) {\n        // \u2026\n    }\n    // \u2026\n}\n</code></pre></p> <p>En una aplicaci\u00f3n concreta que estamos desarrollando, deseamos conocer cu\u00e1ntos valores almacenados son menores que un cierto valor <code>val</code> que se pasa como par\u00e1metro. Este valor que se pasa como par\u00e1metro puede no ser uno de los valores almacenados.</p> <ul> <li>(a) (2,5 puntos) Codificar el m\u00e9todo <code>public int cuentaMenores (int val)</code>, en cada una de las 3 clases: <code>Datos</code>, <code>DatosOrdenado</code> y <code>BST</code>. Nota: Para simplificar suponga que tanto en <code>Datos</code> como en <code>DatosOrdenado</code>, los arrays de enteros est\u00e1n ocupados en su totalidad por valores almacenados. Suponga que no hay datos repetidos y que no hay operaciones de modificaci\u00f3n (inserci\u00f3n o borrado), sino exclusivamente se trata de buscar en una estructura de datos construida.</li> </ul> Mostrar soluci\u00f3n <pre><code>class Datos {\n    public int cuentaMenores(int val) {\n        int cuenta = 0;\n        for (int i = 0; i &lt; nValores; i++) {\n            if (valores[i] &lt; val)\n                cuenta++;\n        }\n        return cuenta;\n    }\n}\n\nclass DatosOrdenado {\n    public int cuentaMenores(int val) {\n        int n = valores.length;\n        int centro, inf = 0, sup = n - 1;\n        while (inf &lt;= sup) {\n            centro = (sup + inf) / 2;\n            if (valores[centro] == val)\n                return centro;\n            else if (val &lt; valores[centro]) {\n                sup = centro - 1;\n            } else {\n                inf = centro + 1;\n            }\n        }\n        return sup + 1;\n    }\n}\n\nclass BST {\n    private int cuentaMenores(Nodo actual, int val) {\n        int cuenta = 0;\n        if (actual == null)\n            return 0;\n        if (actual.valor == val)\n            return cuentaTodos(actual.izd);\n        if (actual.valor &lt; val)\n            cuenta = 1;\n        int nizd = cuentaMenores(actual.izd, val);\n        int nder = cuentaMenores(actual.der, val);\n        return cuenta + nizd + nder;\n    }\n\n    private int cuentaTodos(Nodo actual) {\n        if (actual == null)\n            return 0;\n        return 1 + cuentaTodos(actual.izd) + cuentaTodos(actual.der);\n    }\n}\n</code></pre> <ul> <li>(b) (2,5 puntos) Se pide: Considerando s\u00f3lo los m\u00e9todos <code>cuentaMenores</code> que acaba de implementar, cu\u00e1l de las tres clases seleccionar\u00eda para almacenar un conjunto de valores de tama\u00f1o fijo <code>M</code>, donde se vayan a realizar frecuentes llamas al m\u00e9todo <code>cuentaMenores</code>.</li> </ul> Mostrar soluci\u00f3n <p>La clase <code>Datos</code> al tener los valores no ordenados nos obliga a recorrer todo el array, por lo tanto, la complejidad es proporcional al n\u00famero de valores almacenados: \\(O(N)\\).</p> <p>La clase <code>DatosOrdenado</code>, tiene los valores ordenados de menor a mayor. Que los valores est\u00e9n ordenados permite utilizar b\u00fasqueda dicot\u00f3mica para localizar el valor, o en su defecto la posici\u00f3n donde deber\u00eda estar el valor que estamos buscando. Esta operaci\u00f3n tiene una complejidad \\(O(log N)\\). Una vez localizada la posici\u00f3n donde est\u00e1 o deber\u00eda estar el valor, todos los de la izquierda son menores que \u00e9l, por lo tanto, por lo que directamente conocemos el n\u00famero de valores menores que el que nos pasan como par\u00e1metro usando el \u00edndice de la posici\u00f3n del array donde est\u00e1 o deber\u00eda estar el valor pasado como par\u00e1metro. El resultado es un algoritmo de orden \\(O(log N)\\).</p> <p>En el caso de <code>BST</code> la estructura de BST ayuda a encontrar el valor en el \u00e1rbol con una complejidad \\(O(log N)\\),pero como lo que nos piden es el n\u00famero de valores menor que el valor pasado como par\u00e1metro, e incluso puede ocurrir que le propio valor no se encuentre en el \u00e1rbol, debemos recorrer casi todo el \u00e1rbol con una complejidad \\(O(N)\\).</p> <p>Por lo tanto, a la vista de este an\u00e1lisis, para nuestro problema concreto, la clase seleccionada es <code>DatosOrdenado</code>.</p>","tags":["complejidad"]},{"location":"exams/2018/extra_ex03/","title":"Extra ex03","text":"<ul> <li>(a) (2 puntos) Explique brevemente cu\u00e1l es la diferencia entre interbloqueo (deadlock) y bloqueo vivo (livelock).</li> </ul> Mostrar soluci\u00f3n <p>En un interbloqueo hay varias hebras suspendidas, esperando conseguir recursos que tienen que liberar otras hebras, de tal manera que en conjunto se forma una cada de espera circular y ninguna hebra puede avanzar.</p> <p>En un bloqueo vivo hay igualmente varias hebras intentando conseguir recursos que tienen otras hebras. La diferencia es que cuando una hebra no puede conseguir todos sus recursos libera los que tiene y lo vuelve a intentar. Como consecuencia, las hebras implicadas est\u00e1n continuamente activas, aunque sin realizar ning\u00fan progreso.</p> <p>Por tanto, la diferencia fundamental es que en un interbloqueo las hebras est\u00e1s suspendidas y nunca se ejecutan, mientras que en un bloqueo vivo las hebras se ejecutan pero no progresan.</p> <p>Sea un sistema con 8 GB de memoria principal. Tenemos procesos concurrentes que solicitan memoria en bloques de 2 GB a medida que la necesitan para su ejecuci\u00f3n. Un proceso que ya tiene <code>N</code> bloques de memoria asignados puede solicitar m\u00e1s memoria, y si ya no hay memoria disponible espera a que la haya antes de continuar. La memoria asignada a un proceso se libera completamente cuando el proceso termina su ejecuci\u00f3n.</p> <ul> <li>(b) (3 puntos) Indique razonadamente si es posible que se d\u00e9 una situaci\u00f3n de interbloqueo (deadlock), en qu\u00e9 circunstancias podr\u00eda ocurrir y, si \u00e9ste es el caso, c\u00f3mo se podr\u00eda evitar.</li> </ul> Mostrar soluci\u00f3n <p>Los procesos acceden a un conjunto de recursos, los bloques de memoria, todos iguales, con una disponibilidad total limitada a 4 bloques en total. Se pueden producir interbloqueos si varios procesos intentan adquirir m\u00e1s memoria cuando ya est\u00e1 toda asignada a otros procesos que tambi\u00e9n necesitan m\u00e1s memoria.</p> <p>Por ejemplo, sup\u00f3ngase que hay dos procesos <code>P</code> y <code>Q</code>, que tiene asignados 2 bloques de memoria cada uno, es decir 4 en total, por lo que no hay bloques libres. Si ambos solicitan un bloque adicional cada uno, al no estar disponible se suspenden esperando que haya memoria libre. Para ello uno de los dos tendr\u00eda que terminar, liberando su memoria, pero al no poder avanzar ninguno de los dos se quedan suspendidos indefinidamente.</p> <p>Podemos comprobar que se cumplen las condiciones necesarias de Coffman:</p> <ol> <li>Exclusi\u00f3n mutua: Un bloque de memoria s\u00f3lo puede estar asignado a un proceso.</li> <li>Tener y esperar: Un proceso puede tener asignada memoria y esperar que conseguir m\u00e1s.</li> <li>Sin expulsi\u00f3n: No se quita memoria a un proceso hasta que termina su ejecuci\u00f3n.</li> <li>Espera circular, como pone de manifiesto el ejemplo anterior.</li> </ol> <p>Para evitar el interbloqueo la soluci\u00f3n m\u00e1s sencilla ser\u00eda obligar a que los procesos soliciten toda la memoria que pueden necesitar al iniciarse, invalidando la condici\u00f3n 2. N\u00f3tese que la soluci\u00f3n frecuentemente recomendada de asignar los recursos siempre en el mismo orden no es aplicable aqu\u00ed porque todos los bloques de memoria son iguales</p>","tags":["hebras"]},{"location":"exams/2018/extra_ex04/","title":"Extra ex04","text":"<p>La panader\u00eda Molinga S.L. quiere modernizar sus instalaciones robotizando su sistema de producci\u00f3n de pan. Para ello han encargado a los alumnos de ADSW que realicen parte del sistema.</p> <p>Se desea realizar dos monitores para gestionar la amasadora y el horno de la panader\u00eda, con acceso exclusivo por parte de varios robots (threads). Existen 3 tipos de robots en la panader\u00eda:</p> <ul> <li>Robots de almac\u00e9n, que meten ingredientes en la amasadora;</li> <li>Robots amasadores, que cuando tienen los ingredientes necesarios amasan y despu\u00e9s meten la masa en el horno;</li> <li>Robots horneadores, que cuando tienen las masas necesarias para llenar un horno, hornean el pan.</li> </ul> <p>La amasadora permitir\u00e1 introducir ingredientes a los robots de almac\u00e9n y amasar a los robots amasadores. Para hacer una masa de pan hacen falta cuatro ingredientes: agua, harina, levadura y sal, en la proporci\u00f3n de <code>4</code>, <code>3</code>, <code>2</code>, y <code>1</code> unidades. No se permitir\u00e1 a los robots de almac\u00e9n introducir m\u00e1s ingredientes si hay suficientes para hacer una masa, y de igual manera no se permitir\u00e1 a los robots amasadores amasar si no hay suficientes ingredientes para hacer una masa.</p> <p>El horno permitir\u00e1 introducir masas a los robots amasadores y hornear a los robots horneadores. Un horno tiene un tama\u00f1o concreto, que recibir\u00e1 como par\u00e1metro en el constructor, indicando el n\u00famero de masas que es capaz de hornear. Por motivos de eficiencia, los robots horneadores solo podr\u00e1n hornear si el horno est\u00e1 completamente lleno, y los robots amasadores solo podr\u00e1n meter masas si hay hueco en el horno.</p> <p>Estructura de clases de la panader\u00eda:</p> <p></p> <p>Ejemplo de programa con varios robots: <pre><code>public enum Ingrediente {\n    Agua, Harina, Levadura, Sal\n}\n\npublic static void main(String[] args) {\n    Amasadora amasadora = new Amasadora();\n    Horno horno = new Horno(5);\n    new RobotAlmacen(\"ED209\",amasadora).start();\n    new RobotAlmacen(\"T-800\",amasadora).start();\n    new RobotAlmacen(\"WALL-E\",amasadora).start();\n    new RobotAlmacen(\"Bumblebee\",amasadora).start();\n    new RobotAmasador(\"R2D2\",amasadora,horno).start();\n    new RobotAmasador(\"C3PO\",amasadora,horno).start();\n    new RobotAmasador(\"BB8\",amasadora,horno).start();\n    new RobotHorneador(\"Chappie\",horno).start();\n    new RobotHorneador(\"RoboCop\",horno).start();\n}\n</code></pre></p> <p>Ejemplo de c\u00f3digo del robor horneador: <pre><code>public class RobotHorneador extends Thread {\n    private Horno horno;\n    private String nombre;\n    private int panes = 0;\n    private Random random = new Random();\n\n    public RobotHorneador(String nombre, Horno horno) {\n        this.horno = horno;\n        this.nombre = nombre;\n        this.panes = 0;\n    }\n\n    public String getNombre() {return this.nombre;}\n\n    public void run() {\n        while (true) {\n            try {\n                int panesNuevos = this.horno.hornear();\n                this.panes = this.panes + panesNuevos;\n                Thread.sleep(random.nextInt(5000));\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre></p> <ul> <li>(a) (2,5 puntos) Desarrollar el monitor <code>Amasadora</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Amasadora {\n    private int cantidadAgua;\n    private int cantidadHarina;\n    private int cantidadLevadura;\n    private int cantidadSal;\n\n    public synchronized void amasar() {\n        try {\n            while (!((this.cantidadAgua &gt;= 4) &amp;&amp; (this.cantidadHarina &gt;= 3) &amp;&amp;\n                   (this.cantidadLevadura &gt;= 2) &amp;&amp; (this.cantidadSal &gt;= 1))) {\n                wait();\n            }\n            this.cantidadAgua = this.cantidadAgua - 4;\n            this.cantidadHarina = this.cantidadHarina - 3;\n            this.cantidadLevadura = this.cantidadLevadura - 2;\n            this.cantidadSal = this.cantidadSal - 1;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n\n    public synchronized void meterIngredientes(Ingrediente ingrediente, int cantidad) {\n        try {\n            while (((this.cantidadAgua &gt;= 4) &amp;&amp; (this.cantidadHarina &gt;= 3) &amp;&amp;\n                   (this.cantidadLevadura &gt;= 2) &amp;&amp; (this.cantidadSal &gt;= 1))) {\n                wait();\n            }\n            switch (ingrediente) {\n                case Agua:\n                    this.cantidadAgua = this.cantidadAgua + cantidad;\n                    break;\n                case Harina:\n                    this.cantidadHarina = this.cantidadHarina + cantidad;\n                    break;\n                case Levadura:\n                    this.cantidadLevadura = this.cantidadLevadura + cantidad;\n                    break;\n                case Sal:\n                    this.cantidadSal = this.cantidadSal + cantidad;\n                    break;\n            }\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Desarrollar el monitor <code>Horno</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Horno {\n    private int masas;\n    private int tama\u00f1o;\n\n    public Horno(int tama\u00f1o) {\n        this.tama\u00f1o = tama\u00f1o;\n    }\n\n    public synchronized int hornear(String nombre) {\n        try {\n            while (!(this.masas &gt;= this.tama\u00f1o)) {\n                wait();\n            }\n            this.masas = this.masas - this.tama\u00f1o;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n        return this.tama\u00f1o;\n    }\n\n    public synchronized void meterMasa(String nombre) {\n        try {\n            while (this.masas &gt;= this.tama\u00f1o) {\n                wait();\n            }\n            this.masas++;\n            notifyAll();\n        } catch (InterruptedException ignored) {}\n    }\n}\n</code></pre> <ul> <li>(c) (0,5 puntos) Proponer el m\u00e9todo <code>run()</code> del robot amasador.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void run() {\n    while (true) {\n        amasadora.amasar();\n        horno.meterMasa();\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2018/extra_ex05/","title":"Extra ex05","text":"<p>Se desea ampliar el juego de la serpiente con un contador de las manzanas que ha comido la serpiente. Naturalmente, cuando la serpiente come una manzana, este contador debe aumentar en una unidad. Para a\u00f1adir dificultad al jugador, tambi\u00e9n puede perder manzanas de este contador por dos motivos:</p> <ul> <li>Si una bola choca con una manzana, el jugador pierde una unidad de su contador de manzanas comidas. El contador no puede nunca tener un valor inferior a cero como resultado de esta p\u00e9rdida, pero la p\u00e9rdida debe ejecutarse tan pronto como sea posible;</li> <li>Si la serpiente es golpeada en la cabeza por una bola, el contador de manzanas se reduce a la mitad, redondeando al entero inmediatamente inferior. Esto es, si el jugador ten\u00eda 7 puntos debe quedarse con 3.</li> </ul> <p>Siendo la clase <code>Manzanas</code>: <pre><code>public class Manzanas\nimplements Screen.Thing {\n\n    /** Constructor. */\n    public Manzanas() {\n        font = new Font(\"SansSerif\", Font.BOLD, 18);\n        Game.getScreen().add(this);\n    }\n\n    /** La serpiente ha comido una manzana. */\n    public void appleEaten() {\n    }\n\n    /** Una bola ha destruido una manzana. */\n    public void appleDestroid() {\n    }\n\n    /** Una bola ha golpeado la cabeza de la serpiente. */\n    public void headShot() {\n    }\n\n    /** Se imprime en pantalla. */\n    @Override\n    public void paint(Graphics2D g) {\n        g.setFont(font);\n        g.setColor(Color.BLACK);\n        g.drawString(\"manzanas: \" + , 10, 30);\n    }\n}\n</code></pre></p> <ul> <li>(a) (5 puntos) Se pide que complete y modifique la clase monitor <code>Manzanas</code> como considere oportuno para obtener la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * Contador de manzanas.\n */\npublic class Manzanas\nimplements Screen.Thing {\n\n    private int manzanas;\n\n    public Manzanas() {\n        font = new Font(\"SansSerif\", Font.BOLD, 18);\n        manzanas = 0;\n        Game.getScreen().add(this);\n    }\n\n    public synchronized void appleEaten() {\n        manzanas++;\n        notifyAll();\n    }\n\n    public synchronized void appleDestroid() {\n        while (manzanas &lt;= 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        manzanas--;\n    }\n\n    public synchronized void headShot() {\n        manzanas = manzanas / 2;\n    }\n\n    @Override\n    public void paint(Graphics2D g) {\n        g.setFont(font);\n        g.setColor(Color.BLACK);\n        g.drawString(\"manzanas: \" + manzanas, 10, 30);\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2018/extra_ex06/","title":"Extra ex06","text":"<p>Para la aplicaci\u00f3n Android <code>DaysUntil</code> se desea a\u00f1adir la posibilidad de a\u00f1adir una descripci\u00f3n del evento introducido por el usuario. Esta informaci\u00f3n es opcional para la funcionalidad b\u00e1sica de la aplicaci\u00f3n. Sin embargo, en caso de existir una descripci\u00f3n, esta debe incluirse en la informaci\u00f3n pasada como intenci\u00f3n impl\u00edcita para la creaci\u00f3n de un evento en el calendario del usuario al pulsar un bot\u00f3n.</p> <p>Siendo el esqueleto del c\u00f3digo el siguiente: <pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    /** Devuelve el nombre del evento introducido por el usuario */\n    private String getEvento () { ... }\n\n    /** Devuelve la fecha del evento introducida por el usuario */\n    private Calendar getFecha () { ... }\n\n    /** \n     * A partir de un nombre y una fecha crea una intenci\u00f3n impl\u00edcita para la\n     * inserci\u00f3n de un nuevo evento en un calendario\n     */\n    private Intent eventIntent (String nombre, Calendar fecha) { ... }\n\n    public void crearEvento (View v) {\n        // Completar\n    }\n}\n</code></pre></p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout\n    \u2026 &gt;\n\n    &lt;LinearLayout \u2026 &gt;\n        &lt;EditText\n            android:id=\"@+id/eventName\"\n            \u2026 /&gt;\n        &lt;EditText\n            android:id=\"@+id/eventDate\"\n            \u2026 /&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre> <ul> <li>(a) Complete el c\u00f3digo asociado a dicha funcionalidad, tanto en el c\u00f3digo java como en la definici\u00f3n del <code>layout</code> asociado a la actividad en cuesti\u00f3n. Considere implementados los m\u00e9todos <code>getNombre</code> y <code>getFecha</code>. Ha de implementar completamente cualquier otro m\u00e9todo auxiliar que considere necesario. Nota: la clave esperada por la intenci\u00f3n de crear un evento para la descripci\u00f3n del mismo es <code>CalendarContract.Events.DESCRIPTION</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    /** Devuelve el nombre del evento introducido por el usuario */\n    private String getEvento() { ... }\n\n    /** Devuelve la fecha del evento introducida por el usuario */\n    private Calendar getFecha() { ... }\n\n    /**\n     * A partir de un nombre y una fecha crea una intenci\u00f3n impl\u00edcita para la inserci\u00f3n de un\n     * nuevo evento en un calendario\n     */\n    private Intent eventIntent(String nombre, Calendar fecha) { ... }\n\n    public void crearEvento(View v) {\n        EditText eventDescription = eventDescription = (EditText)\n                findViewById(R.id.eventDescription);\n\n        Intent intent = eventIntent(getEvento(), getFecha());\n\n        if (eventDescription.getText().toString().length() &gt; 0) {\n            intent.putExtra(CalendarContract.Events.DESCRIPTION,\n                    eventDescription.getText().toString());\n        }\n\n        startActivity(intent);\n    }\n}\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;android.support.constraint.ConstraintLayout\n    \u2026 &gt;\n\n    &lt;LinearLayout \u2026 &gt;\n        &lt;EditText\n            android:id=\"@+id/eventName\"\n            \u2026 /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/eventDate\"\n            \u2026 /&gt;\n\n        &lt;EditText\n            android:id=\"@+id/eventDescription\"\n            android:hint=\"Event description\"\n            \u2026 /&gt;\n\n        &lt;Button\n            android:text=\"Add event to calendar\"\n            android:onClick=\"crearEvento\"/&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;\n</code></pre>","tags":["android"]},{"location":"exams/2018/p1/","title":"Examen 2018 \u2014 Parcial 1","text":""},{"location":"exams/2018/p1/#problema-1","title":"Problema 1","text":"<p>En el ejercicio 1 de la asignatura se han recorrido los nodos de un grafo. Utilizando las clases <code>Graph</code>, <code>Node</code> y <code>Link</code> de ese mismo ejercicio, se pide codificar un nuevo m\u00e9todo de <code>Graph</code>: <pre><code>public List&lt;Node&gt; reachableNodes(Node src)\n</code></pre> que devuelve una lista de todos los nodos del grafo, obtenida recorriendo el grafo desde un nodo inicial (<code>src</code>). </p> <p>En el ejercicio 2 se ha propuesto usar la clase <code>Map</code> para reducir el tiempo de ejecuci\u00f3n de algunos m\u00e9todos. </p> <ul> <li>(a) (2 puntos) Use la clase <code>Map</code> en la soluci\u00f3n para mejorar el tiempo de ejecuci\u00f3n del m\u00e9todo <code>reachableNodes()</code>. Justifique la mejora que se consigue con su utilizaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n, basada en el recorrido que usa BFS, se muestra a continuaci\u00f3n. Se mejora la complejidad al usar un <code>HahsSet</code> para comprobar si ya hemos visitado un nodo. Si se usa otro algoritmo para componer la lista de nodos a visitar, se deber\u00eda usar una estrategia similar. <pre><code>List&lt;Node&gt; queue = new ArrayList&lt;Node&gt;();\nList&lt;Node&gt; list = new ArrayList&lt;Node&gt;();\n\nlist.add(src);\nqueue.add(src);\n\nSet&lt;Node&gt; visited = new HashSet&lt;&gt;();\nvisited.add(src);\n\nwhile (queue.size() &gt; 0) {\n    Node node = queue.remove(0);\n    for (Link link : graph.getLinks(node)) {\n        Node next = graph.getNode(link.getDst());\n        if (visited.contains(next))\n            continue;\n        list.add(next);\n        queue.add(next);\n        visited.add(next);\n    }\n}\n\nreturn list;\n</code></pre></p>"},{"location":"exams/2018/p1/#problema-2","title":"Problema 2","text":"<p>Una ordenaci\u00f3n topol\u00f3gica (topological sort) de un grafo dirigido <code>G</code> es una lista con todos los nodos de <code>G</code> tal que no existe ning\u00fan enlace hacia atr\u00e1s. </p> <p></p> <p>Ejemplos:</p> <ul> <li>correcto: <code>[calcetines, camisa, pantal\u00f3n, jersey, cintur\u00f3n, zapatos]</code></li> <li>correcto: <code>[pantal\u00f3n, camisa, jersey, calcetines, zapatos, cintur\u00f3n]</code></li> <li>correcto: <code>[pantal\u00f3n, calcetines, zapatos, camisa, jersey, cintur\u00f3n]</code></li> <li>incorrecto: <code>[pantal\u00f3n, cintur\u00f3n, calcetines, zapatos, CAMISA, jersey]</code></li> </ul> <p>La \u00faltima ordenaci\u00f3n es incorrecta porque camisa deber\u00eda estar antes que cintur\u00f3n.</p> <p>Suponga que tenemos un grafo de <code>N</code> nodos y una media de 5 enlaces por nodo. </p> <ul> <li>(a) (2,5 puntos) Haga suposiciones razonadas sobre la complejidad de las llamadas a los m\u00e9todos de <code>Graph</code>, en funci\u00f3n del tama\u00f1o <code>N</code> del grafo.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Complejidad <code>graph.getNodes()</code> \\(O(1)\\) si se ha implementado con una <code>List</code> que se va cargando cuando se a\u00f1aden nodos al grafo (lo habitual en el ejercicio 1 entregado). \\(O(n)\\) si se calcula al llamar a la funci\u00f3n agregando las tablas de nodos con enlaces (frecuente en el ejercicio 2 entregado). <code>graph.getNode(String)</code> \\(O(n)\\) si hay que recorrer la lista hasta encontrar el nodo (lo habitual en el ejercicio 1 entregado). \\(O(1)\\) si hay un diccionario que asocia el nombre al nodo (lo habitual en el ejercicio 2 entregado). <code>graph.getLinks(Node)</code> \\(O(n)\\) si hay que recorrer la lista hasta encontrar el nodo (lo habitual en el ejercicio 1 entregado). \\(O(1)\\) si hay un diccionario que asocia el nodo a los enlaces (lo habitual en el ejercicio 2 entregado). <ul> <li>(b) (2,5 puntos) Calcule la complejidad del m\u00e9todo <code>sort()</code> en funci\u00f3n de <code>N</code>.</li> </ul> Mostrar soluci\u00f3n <p>Partimos de la implementaci\u00f3n del algoritmo proporcionada con el enunciado. <pre><code>24    public List&lt;Node&gt; sort() {\n25       List&lt;Node&gt; L = new ArrayList&lt;&gt;();\n26       List&lt;Node&gt; S = new ArrayList&lt;&gt;();\n27\n28       List&lt;Node&gt; nodeList = graph.getNodes();\n29        for (Node n : nodeList) {\n30            if (inLinks.get(n).size() == 0)\n31                S.add(n);\n32        }\n33\n34        while (S.size() &gt; 0) {\n35            int i = (int) (Math.random() * S.size());\n36            Node n = S.remove(i);\n37            L.add(n);\n38            List&lt;Link&gt; linkList = graph.getLinks(n);\n39            for (Link link : linkList) {\n40                Node dst = graph.getNode(link.getDst());\n41                List&lt;Link&gt; links = inLinks.get(dst);\n42                links.remove(link);\n43                if (links.size() == 0)\n44                    S.add(dst);\n45            }\n46        }\n47\n48        return L;\n49    }\n</code></pre></p> <p>Si todas las operaciones en <code>Graph</code> se optimizan a \\(O(1)\\), la complejidad del conjunto viene condicionada por el coste de extraer un elemento aleatorio de <code>S</code> (en la l\u00ednea 36).</p> <p>Se podr\u00eda prescindir de la aleatoriedad extrayendo el \u00faltimo elemento de la lista, que es una operaci\u00f3n \\(O(1)\\). <pre><code>Node n = S.remove(S.size()-1)\n</code></pre> Y el algoritmo quedar\u00eda \\(O(n)\\).</p>"},{"location":"exams/2018/p1_ex01/","title":"P1 ex01","text":"<p>En el ejercicio 1 de la asignatura se han recorrido los nodos de un grafo. Utilizando las clases <code>Graph</code>, <code>Node</code> y <code>Link</code> de ese mismo ejercicio, se pide codificar un nuevo m\u00e9todo de <code>Graph</code>: <pre><code>public List&lt;Node&gt; reachableNodes(Node src)\n</code></pre> que devuelve una lista de todos los nodos del grafo, obtenida recorriendo el grafo desde un nodo inicial (<code>src</code>). </p> <p>En el ejercicio 2 se ha propuesto usar la clase <code>Map</code> para reducir el tiempo de ejecuci\u00f3n de algunos m\u00e9todos. </p> <ul> <li>(a) (2 puntos) Use la clase <code>Map</code> en la soluci\u00f3n para mejorar el tiempo de ejecuci\u00f3n del m\u00e9todo <code>reachableNodes()</code>. Justifique la mejora que se consigue con su utilizaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n, basada en el recorrido que usa BFS, se muestra a continuaci\u00f3n. Se mejora la complejidad al usar un <code>HahsSet</code> para comprobar si ya hemos visitado un nodo. Si se usa otro algoritmo para componer la lista de nodos a visitar, se deber\u00eda usar una estrategia similar. <pre><code>List&lt;Node&gt; queue = new ArrayList&lt;Node&gt;();\nList&lt;Node&gt; list = new ArrayList&lt;Node&gt;();\n\nlist.add(src);\nqueue.add(src);\n\nSet&lt;Node&gt; visited = new HashSet&lt;&gt;();\nvisited.add(src);\n\nwhile (queue.size() &gt; 0) {\n    Node node = queue.remove(0);\n    for (Link link : graph.getLinks(node)) {\n        Node next = graph.getNode(link.getDst());\n        if (visited.contains(next))\n            continue;\n        list.add(next);\n        queue.add(next);\n        visited.add(next);\n    }\n}\n\nreturn list;\n</code></pre></p>","tags":["grafos"]},{"location":"exams/2018/p1_ex02/","title":"P1 ex02","text":"<p>Una ordenaci\u00f3n topol\u00f3gica (topological sort) de un grafo dirigido <code>G</code> es una lista con todos los nodos de <code>G</code> tal que no existe ning\u00fan enlace hacia atr\u00e1s. </p> <p></p> <p>Ejemplos:</p> <ul> <li>correcto: <code>[calcetines, camisa, pantal\u00f3n, jersey, cintur\u00f3n, zapatos]</code></li> <li>correcto: <code>[pantal\u00f3n, camisa, jersey, calcetines, zapatos, cintur\u00f3n]</code></li> <li>correcto: <code>[pantal\u00f3n, calcetines, zapatos, camisa, jersey, cintur\u00f3n]</code></li> <li>incorrecto: <code>[pantal\u00f3n, cintur\u00f3n, calcetines, zapatos, CAMISA, jersey]</code></li> </ul> <p>La \u00faltima ordenaci\u00f3n es incorrecta porque camisa deber\u00eda estar antes que cintur\u00f3n.</p> <p>Suponga que tenemos un grafo de <code>N</code> nodos y una media de 5 enlaces por nodo. </p> <ul> <li>(a) (2,5 puntos) Haga suposiciones razonadas sobre la complejidad de las llamadas a los m\u00e9todos de <code>Graph</code>, en funci\u00f3n del tama\u00f1o <code>N</code> del grafo.</li> </ul> Mostrar soluci\u00f3n M\u00e9todo Complejidad <code>graph.getNodes()</code> \\(O(1)\\) si se ha implementado con una <code>List</code> que se va cargando cuando se a\u00f1aden nodos al grafo (lo habitual en el ejercicio 1 entregado). \\(O(n)\\) si se calcula al llamar a la funci\u00f3n agregando las tablas de nodos con enlaces (frecuente en el ejercicio 2 entregado). <code>graph.getNode(String)</code> \\(O(n)\\) si hay que recorrer la lista hasta encontrar el nodo (lo habitual en el ejercicio 1 entregado). \\(O(1)\\) si hay un diccionario que asocia el nombre al nodo (lo habitual en el ejercicio 2 entregado). <code>graph.getLinks(Node)</code> \\(O(n)\\) si hay que recorrer la lista hasta encontrar el nodo (lo habitual en el ejercicio 1 entregado). \\(O(1)\\) si hay un diccionario que asocia el nodo a los enlaces (lo habitual en el ejercicio 2 entregado). <ul> <li>(b) (2,5 puntos) Calcule la complejidad del m\u00e9todo <code>sort()</code> en funci\u00f3n de <code>N</code>.</li> </ul> Mostrar soluci\u00f3n <p>Partimos de la implementaci\u00f3n del algoritmo proporcionada con el enunciado. <pre><code>24    public List&lt;Node&gt; sort() {\n25       List&lt;Node&gt; L = new ArrayList&lt;&gt;();\n26       List&lt;Node&gt; S = new ArrayList&lt;&gt;();\n27\n28       List&lt;Node&gt; nodeList = graph.getNodes();\n29        for (Node n : nodeList) {\n30            if (inLinks.get(n).size() == 0)\n31                S.add(n);\n32        }\n33\n34        while (S.size() &gt; 0) {\n35            int i = (int) (Math.random() * S.size());\n36            Node n = S.remove(i);\n37            L.add(n);\n38            List&lt;Link&gt; linkList = graph.getLinks(n);\n39            for (Link link : linkList) {\n40                Node dst = graph.getNode(link.getDst());\n41                List&lt;Link&gt; links = inLinks.get(dst);\n42                links.remove(link);\n43                if (links.size() == 0)\n44                    S.add(dst);\n45            }\n46        }\n47\n48        return L;\n49    }\n</code></pre></p> <p>Si todas las operaciones en <code>Graph</code> se optimizan a \\(O(1)\\), la complejidad del conjunto viene condicionada por el coste de extraer un elemento aleatorio de <code>S</code> (en la l\u00ednea 36).</p> <p>Se podr\u00eda prescindir de la aleatoriedad extrayendo el \u00faltimo elemento de la lista, que es una operaci\u00f3n \\(O(1)\\). <pre><code>Node n = S.remove(S.size()-1)\n</code></pre> Y el algoritmo quedar\u00eda \\(O(n)\\).</p>","tags":["grafos"]},{"location":"exams/2018/p1r/","title":"Examen 2018 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2018/p1r/#problema-1","title":"Problema 1","text":"<p>Dado un conjunto <code>P</code> de puntos en un plano de 2 dimensiones, necesitamos calcular el subconjunto de <code>P</code> tal que una banda el\u00e1stica alrededor de ellos no deja a ning\u00fan punto fuera.</p> <p>En geometr\u00eda, a este subconjunto se le denomina envolvente convexa (convex hull). Una de sus propiedades es que si enumeramos los puntos seg\u00fan las agujas del reloj (<code>L1, L2, ..., Ln</code>) todos los pares de segmentos consecutivos van girando hacia la derecha. Por ejemplo, <code>L1-L2</code> est\u00e1 girado a la derecha en comparaci\u00f3n con <code>L0-L1</code>.</p> <p>En Internet hemos encontrado este algoritmo (Andrew, 1979) que divide el problema en 2 partes. Calcula la envolvente superior, luego la inferior, y las une.</p> <p>El algoritmo es como sigue para un conjunto de <code>N</code> puntos:</p> <ol> <li>Se ordenan los puntos <code>P</code> en orden creciente de coordenada <code>X</code> y, si tienen el mismo <code>X</code>, en orden creciente de coordenada <code>Y</code>;</li> <li>Se prepara una lista <code>UPPER</code> con los 2 primeros puntos, <code>L0</code> y <code>L1</code>;</li> <li>Para <code>i</code> entre <code>2</code> y <code>N</code>:<ol> <li>Se a\u00f1ade <code>Li</code> a la lista <code>UPPER</code>;</li> <li>Mientras los 3 \u00faltimos puntos en la lista <code>UPPER</code> hagan un giro a la izquierda, se elimina el punto intermedio de esos 3.</li> </ol> </li> <li>Se prepara una lista <code>LOWER</code> con los 2 \u00faltimos puntos <code>L(n-1), L(n-2)</code>;</li> <li>Para <code>i</code> entre <code>N-3</code> y <code>0</code>, descendiendo:<ol> <li>Se a\u00f1ade <code>Li</code> a la lista <code>LOWER</code>;</li> <li>Mientras los 3 \u00faltimos puntos en la lista <code>LOWER</code> hagan un giro a la izquierda, se elimina el punto intermedio de esos 3.</li> </ol> </li> <li>Se concatenan las listas <code>UPPER</code> y <code>LOWER</code> prescindiendo de los puntos finales de cada una.</li> </ol> <p>Suponga que disponemos de un m\u00e9todo auxiliar que, dados 3 puntos, nos dice si los segmentos <code>AB</code> y <code>BC</code> hacen un giro a la izquierda:  <pre><code>boolean giroIzquierda(Punto A, Punto B, Punto C)\n</code></pre></p> <ul> <li>(a) (5 puntos) Calcular la complejidad del algoritmo en funci\u00f3n del tama\u00f1o <code>N</code> del conjunto de puntos <code>P</code>.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo auxiliar, <code>giroIzquierda()</code>, trabaja sobre 3 puntos <code>A</code>, <code>B</code>, y <code>C</code> y es por tanto independiente del tama\u00f1o <code>N</code> del conjunto de puntos. Su complejidad es \\(O(1)\\).</p> <p>El algoritmo principal ordena una lista de <code>N</code> puntos. La comparaci\u00f3n entre 2 puntos <code>A</code> y <code>B</code> es independiente del n\u00famero de puntos, y por tanto es de complejidad \\(O(1)\\). El algoritmo de ordenaci\u00f3n introduce su propia complejidad que se puede estimar en \\(O(n log n)\\) si escogemos un buen algoritmo como puede ser el merge sort.</p> <p>El algoritmo global:</p> Paso Descripci\u00f3n Complejidad 1 Ordenaci\u00f3n \\(O(n log n)\\) 2 <code>new list UPPER</code> \\(O(1)\\) 3 bucle <code>2..N</code> \\(O(n)\\)(*) 4 <code>new list LOWER</code> \\(O(1)\\) 5 bucle <code>2..N</code> \\(O(n)\\)(*) 6 concatena \\(O(n)\\) TOTAL \\(O(n log n)\\) <p>(*) En principio parece un bucle de <code>N</code> veces sobre una lista que va creciendo hasta <code>N</code>; resultando en \\(n^2\\). Pero ocurre que cada pasada por el bucle elimina un elemento de la lista y o la lista es larga y el <code>while</code> termina pronto, o al rev\u00e9s. En resumen, que por una raz\u00f3n u otra no pasamos de \\(O(n)\\). En otras palabras, la combinaci\u00f3n <code>FOR-WHILE</code> recorre exactamente <code>N</code> puntos, bien conservando cada punto o elimin\u00e1ndolo.</p> <p>Por otra parte, la operaci\u00f3n <code>remove(pen\u00faltimo)</code> es independiente del tama\u00f1o de la lista y, por tanto, de \\(O(1)\\).</p> <p>Codificaci\u00f3n en Java: <pre><code>List&lt;Punto&gt; scan(List&lt;Punto&gt; puntos) {\n    if (puntos.size() &lt; 3) return null;\n\n    puntos.sort(new Comparator&lt;Punto&gt;() {\n        @Override\n        public int compare(Punto p1, Punto p2) {\n            if (p1.x == p2.x)\n                return p1.y - p2.y;\n            return p1.x - p2.x;\n        }\n    });\n\n    List&lt;Punto&gt; upper = new ArrayList&lt;&gt;();\n    upper.add(puntos.get(0));\n    upper.add(puntos.get(1));\n\n    for (int i = 2; i &lt; puntos.size(); i++) {\n        upper.add(puntos.get(i));\n        while (true) {\n            int size = upper.size();\n            if (size &lt; 3)\n                break;\n            Punto A = upper.get(size - 3);\n            Punto B = upper.get(size - 2);\n            Punto C = upper.get(size - 1);\n            if (!isGiroIzquierda(A, B, C))\n                break;\n            upper.remove(size - 2);\n        }\n    }\n\n    int n = puntos.size();\n    List&lt;Punto&gt; lower = new ArrayList&lt;&gt;();\n    lower.add(puntos.get(n - 1));\n    lower.add(puntos.get(n - 2));\n\n    for (int i = n - 3; i &gt;= 0; i--) {\n        lower.add(puntos.get(i));\n        while (true) {\n            int size = lower.size();\n            if (size &lt; 3)\n                break;\n            Punto A = lower.get(size - 3);\n            Punto B = lower.get(size - 2);\n            Punto C = lower.get(size - 1);\n            if (!isGiroIzquierda(A, B, C))\n                break;\n            lower.remove(size - 2);\n        }\n    }\n\n    List&lt;Punto&gt; hull = new ArrayList&lt;&gt;();\n    hull.addAll(upper);\n    hull.remove(hull.size() - 1);\n    hull.addAll(lower);\n    hull.remove(hull.size() - 1);\n\n    return hull;\n}\n\nprivate boolean isGiroIzquierda(Punto A, Punto B, Punto C) {\n    int x1 = A.getX();\n    int y1 = A.getY();\n    int x2 = B.getX();\n    int y2 = B.getY();\n    int x3 = C.getX();\n    int y3 = C.getY();\n\n    int val1 = (x2 - x1) * (y3 - y1);\n    int val2 = (y2 - y1) * (x3 - x1);\n\n    return val1 &gt; val2;\n}\n</code></pre></p>"},{"location":"exams/2018/p1r/#problema-2","title":"Problema 2","text":"<p>Se dispone de la clase <code>Graph</code>, con los m\u00e9todos que se indican a continuaci\u00f3n: <pre><code>public void addNode(Node)\npublic vois addLink(Link)\npublic void addLink2D(String, String, int)\npublic List&lt;Node&gt; getNodes()\npublic Node getNode(String)\npublic List&lt;Link&gt; getLinks()\npublic List&lt;Link&gt; getLinks(Node)\npublic Link getLink(Node, Node)\npublic int getWeight(List&lt;Node&gt;)\n</code></pre></p> <p>Un algoritmo alternativo a BFS y Dijkstra para recorrer un grafo es el algoritmo DFS (Depth First Search). El recorrido en profundidad se produce de tal forma que partiendo de un nodo se procesa el primero de los nodos alcanzables desde \u00e9l mediante un <code>Link</code>, despu\u00e9s el segundo y as\u00ed sucesivamente todos los nodos que se pueden alcanzar con un solo <code>Link</code>. Para procesar cada uno de los nodos se utiliza el mismo procedimiento, siempre teniendo en cuenta que, al ser un grafo, no pasemos dos veces por el mismo nodo. En definitiva, se trata del recorrido en pre-orden usado para los \u00e1rboles binarios BST.</p> <p>Se muestra a continuaci\u00f3n un ejemplo del orden de recorrido de DFS sobre un \u00e1rbol para ver si desde el nodo <code>A</code> se puede alcanzar el nodo destino <code>J</code>:</p> <p></p> <p>Una de las formas de implementar DFS en un grafo es mediante un m\u00e9todo recursivo, cuyo seudoc\u00f3digo se proporciona a continuaci\u00f3n:</p> <pre><code>1 m\u00e9todo DFS(origen):\n2   marcamos origen como visitado\n3   para cada v\u00e9rtice v adyacente a origen en el Grafo:\n4     si v no ha sido visitado:\n5       marcamos como visitado v\n6       llamamos recursivamente DFS(v)\n</code></pre> <ul> <li>(a) (5 puntos) Codificar el algoritmo <code>ListaNodos</code> que devuelve todos los nodos alcanzables desde un determinado nodo <code>src</code>. Los nodos alcanzables desde un nodo son todos aquellos a los que se puede llegar desde ese nodo siguiendo una secuencia de enlaces (<code>Link</code>) definidos en el grafo. En el caso del grafo del ejemplo anterior, desde el nodo <code>C</code> ser\u00edan alcanzables: <code>&lt;C,E,I,J,F,K,L&gt;</code> y desde el nodo <code>D</code>: <code>&lt;D,G,H&gt;</code>. Tenga en cuenta que en un caso real pudiera haber bucles al tratarse de un grafo. Se valorar\u00e1 con 2 puntos el uso de la clase <code>Set</code> para aumentar la velocidad del m\u00e9todo <code>ListaNodos</code>, si adem\u00e1s se justifica adecuadamente la mejora producida por su utilizaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <pre><code>private List&lt;Node&gt; getNodesRec (Node src) {\n    // Creamos las variables necesaria\n    Set&lt;Node&gt; visited = new HashSet &lt;Node&gt;();\n\n    // Si el nodo no ha sido visitado, lo marcamos como visitado, lo a\u00f1adimos a la lista\n    List &lt;Node&gt; list = new ArrayList &lt;Node&gt;();\n    visited.add(src);\n    list.add(src);\n\n    // Llamada al m\u00e9todo recursivo\n    List&lt;Node&gt; alcanzables = getNodesRec (src, visited);\n    list.addAll(alcanzables);\n\n    return list;\n}\n\nprivate List&lt;Node&gt; getNodesRec (Node src, Set&lt;Node&gt; visited) {\n    List &lt;Node&gt; list = new ArrayList &lt;Node&gt;();\n\n    // Pasamos a recorrer los nodos desde los que se puede llegar con un Link desde este nodo\n    for (Link link : graph.getLinks(src)) {\n        Node next = graph.getNode(link.getDst());\n\n        // Si el nodo ya ha sido visitado no hacemos nada\n        if (visited.contains(next))\n            continue;\n\n        // Si el nodo no ha sido visitado, lo marcamos como visitado, lo a\u00f1adimos a la lista\n        visited.add(next);\n        list.add(next);\n\n        List &lt;Node&gt; res = getNodesRec(next, visited);\n\n        // A\u00f1adimos a la lista de nodos alcanzables los nodos que devuelve getNodesRec al recorrer el nodo next\n        list.addAll(res);\n    }\n\n    return list;\n}\n</code></pre> <p>El uso de <code>Set</code> para controlar la lista de visitados permite mejorar el algoritmo frente a <code>List</code>, ya que la b\u00fasqueda en listas no est\u00e1 tan optimizada como en <code>Set</code>.</p>"},{"location":"exams/2018/p1r_ex01/","title":"P1r ex01","text":"<p>Dado un conjunto <code>P</code> de puntos en un plano de 2 dimensiones, necesitamos calcular el subconjunto de <code>P</code> tal que una banda el\u00e1stica alrededor de ellos no deja a ning\u00fan punto fuera.</p> <p>En geometr\u00eda, a este subconjunto se le denomina envolvente convexa (convex hull). Una de sus propiedades es que si enumeramos los puntos seg\u00fan las agujas del reloj (<code>L1, L2, ..., Ln</code>) todos los pares de segmentos consecutivos van girando hacia la derecha. Por ejemplo, <code>L1-L2</code> est\u00e1 girado a la derecha en comparaci\u00f3n con <code>L0-L1</code>.</p> <p>En Internet hemos encontrado este algoritmo (Andrew, 1979) que divide el problema en 2 partes. Calcula la envolvente superior, luego la inferior, y las une.</p> <p>El algoritmo es como sigue para un conjunto de <code>N</code> puntos:</p> <ol> <li>Se ordenan los puntos <code>P</code> en orden creciente de coordenada <code>X</code> y, si tienen el mismo <code>X</code>, en orden creciente de coordenada <code>Y</code>;</li> <li>Se prepara una lista <code>UPPER</code> con los 2 primeros puntos, <code>L0</code> y <code>L1</code>;</li> <li>Para <code>i</code> entre <code>2</code> y <code>N</code>:<ol> <li>Se a\u00f1ade <code>Li</code> a la lista <code>UPPER</code>;</li> <li>Mientras los 3 \u00faltimos puntos en la lista <code>UPPER</code> hagan un giro a la izquierda, se elimina el punto intermedio de esos 3.</li> </ol> </li> <li>Se prepara una lista <code>LOWER</code> con los 2 \u00faltimos puntos <code>L(n-1), L(n-2)</code>;</li> <li>Para <code>i</code> entre <code>N-3</code> y <code>0</code>, descendiendo:<ol> <li>Se a\u00f1ade <code>Li</code> a la lista <code>LOWER</code>;</li> <li>Mientras los 3 \u00faltimos puntos en la lista <code>LOWER</code> hagan un giro a la izquierda, se elimina el punto intermedio de esos 3.</li> </ol> </li> <li>Se concatenan las listas <code>UPPER</code> y <code>LOWER</code> prescindiendo de los puntos finales de cada una.</li> </ol> <p>Suponga que disponemos de un m\u00e9todo auxiliar que, dados 3 puntos, nos dice si los segmentos <code>AB</code> y <code>BC</code> hacen un giro a la izquierda:  <pre><code>boolean giroIzquierda(Punto A, Punto B, Punto C)\n</code></pre></p> <ul> <li>(a) (5 puntos) Calcular la complejidad del algoritmo en funci\u00f3n del tama\u00f1o <code>N</code> del conjunto de puntos <code>P</code>.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo auxiliar, <code>giroIzquierda()</code>, trabaja sobre 3 puntos <code>A</code>, <code>B</code>, y <code>C</code> y es por tanto independiente del tama\u00f1o <code>N</code> del conjunto de puntos. Su complejidad es \\(O(1)\\).</p> <p>El algoritmo principal ordena una lista de <code>N</code> puntos. La comparaci\u00f3n entre 2 puntos <code>A</code> y <code>B</code> es independiente del n\u00famero de puntos, y por tanto es de complejidad \\(O(1)\\). El algoritmo de ordenaci\u00f3n introduce su propia complejidad que se puede estimar en \\(O(n log n)\\) si escogemos un buen algoritmo como puede ser el merge sort.</p> <p>El algoritmo global:</p> Paso Descripci\u00f3n Complejidad 1 Ordenaci\u00f3n \\(O(n log n)\\) 2 <code>new list UPPER</code> \\(O(1)\\) 3 bucle <code>2..N</code> \\(O(n)\\)(*) 4 <code>new list LOWER</code> \\(O(1)\\) 5 bucle <code>2..N</code> \\(O(n)\\)(*) 6 concatena \\(O(n)\\) TOTAL \\(O(n log n)\\) <p>(*) En principio parece un bucle de <code>N</code> veces sobre una lista que va creciendo hasta <code>N</code>; resultando en \\(n^2\\). Pero ocurre que cada pasada por el bucle elimina un elemento de la lista y o la lista es larga y el <code>while</code> termina pronto, o al rev\u00e9s. En resumen, que por una raz\u00f3n u otra no pasamos de \\(O(n)\\). En otras palabras, la combinaci\u00f3n <code>FOR-WHILE</code> recorre exactamente <code>N</code> puntos, bien conservando cada punto o elimin\u00e1ndolo.</p> <p>Por otra parte, la operaci\u00f3n <code>remove(pen\u00faltimo)</code> es independiente del tama\u00f1o de la lista y, por tanto, de \\(O(1)\\).</p> <p>Codificaci\u00f3n en Java: <pre><code>List&lt;Punto&gt; scan(List&lt;Punto&gt; puntos) {\n    if (puntos.size() &lt; 3) return null;\n\n    puntos.sort(new Comparator&lt;Punto&gt;() {\n        @Override\n        public int compare(Punto p1, Punto p2) {\n            if (p1.x == p2.x)\n                return p1.y - p2.y;\n            return p1.x - p2.x;\n        }\n    });\n\n    List&lt;Punto&gt; upper = new ArrayList&lt;&gt;();\n    upper.add(puntos.get(0));\n    upper.add(puntos.get(1));\n\n    for (int i = 2; i &lt; puntos.size(); i++) {\n        upper.add(puntos.get(i));\n        while (true) {\n            int size = upper.size();\n            if (size &lt; 3)\n                break;\n            Punto A = upper.get(size - 3);\n            Punto B = upper.get(size - 2);\n            Punto C = upper.get(size - 1);\n            if (!isGiroIzquierda(A, B, C))\n                break;\n            upper.remove(size - 2);\n        }\n    }\n\n    int n = puntos.size();\n    List&lt;Punto&gt; lower = new ArrayList&lt;&gt;();\n    lower.add(puntos.get(n - 1));\n    lower.add(puntos.get(n - 2));\n\n    for (int i = n - 3; i &gt;= 0; i--) {\n        lower.add(puntos.get(i));\n        while (true) {\n            int size = lower.size();\n            if (size &lt; 3)\n                break;\n            Punto A = lower.get(size - 3);\n            Punto B = lower.get(size - 2);\n            Punto C = lower.get(size - 1);\n            if (!isGiroIzquierda(A, B, C))\n                break;\n            lower.remove(size - 2);\n        }\n    }\n\n    List&lt;Punto&gt; hull = new ArrayList&lt;&gt;();\n    hull.addAll(upper);\n    hull.remove(hull.size() - 1);\n    hull.addAll(lower);\n    hull.remove(hull.size() - 1);\n\n    return hull;\n}\n\nprivate boolean isGiroIzquierda(Punto A, Punto B, Punto C) {\n    int x1 = A.getX();\n    int y1 = A.getY();\n    int x2 = B.getX();\n    int y2 = B.getY();\n    int x3 = C.getX();\n    int y3 = C.getY();\n\n    int val1 = (x2 - x1) * (y3 - y1);\n    int val2 = (y2 - y1) * (x3 - x1);\n\n    return val1 &gt; val2;\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2018/p1r_ex02/","title":"P1r ex02","text":"<p>Se dispone de la clase <code>Graph</code>, con los m\u00e9todos que se indican a continuaci\u00f3n: <pre><code>public void addNode(Node)\npublic vois addLink(Link)\npublic void addLink2D(String, String, int)\npublic List&lt;Node&gt; getNodes()\npublic Node getNode(String)\npublic List&lt;Link&gt; getLinks()\npublic List&lt;Link&gt; getLinks(Node)\npublic Link getLink(Node, Node)\npublic int getWeight(List&lt;Node&gt;)\n</code></pre></p> <p>Un algoritmo alternativo a BFS y Dijkstra para recorrer un grafo es el algoritmo DFS (Depth First Search). El recorrido en profundidad se produce de tal forma que partiendo de un nodo se procesa el primero de los nodos alcanzables desde \u00e9l mediante un <code>Link</code>, despu\u00e9s el segundo y as\u00ed sucesivamente todos los nodos que se pueden alcanzar con un solo <code>Link</code>. Para procesar cada uno de los nodos se utiliza el mismo procedimiento, siempre teniendo en cuenta que, al ser un grafo, no pasemos dos veces por el mismo nodo. En definitiva, se trata del recorrido en pre-orden usado para los \u00e1rboles binarios BST.</p> <p>Se muestra a continuaci\u00f3n un ejemplo del orden de recorrido de DFS sobre un \u00e1rbol para ver si desde el nodo <code>A</code> se puede alcanzar el nodo destino <code>J</code>:</p> <p></p> <p>Una de las formas de implementar DFS en un grafo es mediante un m\u00e9todo recursivo, cuyo seudoc\u00f3digo se proporciona a continuaci\u00f3n:</p> <pre><code>1 m\u00e9todo DFS(origen):\n2   marcamos origen como visitado\n3   para cada v\u00e9rtice v adyacente a origen en el Grafo:\n4     si v no ha sido visitado:\n5       marcamos como visitado v\n6       llamamos recursivamente DFS(v)\n</code></pre> <ul> <li>(a) (5 puntos) Codificar el algoritmo <code>ListaNodos</code> que devuelve todos los nodos alcanzables desde un determinado nodo <code>src</code>. Los nodos alcanzables desde un nodo son todos aquellos a los que se puede llegar desde ese nodo siguiendo una secuencia de enlaces (<code>Link</code>) definidos en el grafo. En el caso del grafo del ejemplo anterior, desde el nodo <code>C</code> ser\u00edan alcanzables: <code>&lt;C,E,I,J,F,K,L&gt;</code> y desde el nodo <code>D</code>: <code>&lt;D,G,H&gt;</code>. Tenga en cuenta que en un caso real pudiera haber bucles al tratarse de un grafo. Se valorar\u00e1 con 2 puntos el uso de la clase <code>Set</code> para aumentar la velocidad del m\u00e9todo <code>ListaNodos</code>, si adem\u00e1s se justifica adecuadamente la mejora producida por su utilizaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <pre><code>private List&lt;Node&gt; getNodesRec (Node src) {\n    // Creamos las variables necesaria\n    Set&lt;Node&gt; visited = new HashSet &lt;Node&gt;();\n\n    // Si el nodo no ha sido visitado, lo marcamos como visitado, lo a\u00f1adimos a la lista\n    List &lt;Node&gt; list = new ArrayList &lt;Node&gt;();\n    visited.add(src);\n    list.add(src);\n\n    // Llamada al m\u00e9todo recursivo\n    List&lt;Node&gt; alcanzables = getNodesRec (src, visited);\n    list.addAll(alcanzables);\n\n    return list;\n}\n\nprivate List&lt;Node&gt; getNodesRec (Node src, Set&lt;Node&gt; visited) {\n    List &lt;Node&gt; list = new ArrayList &lt;Node&gt;();\n\n    // Pasamos a recorrer los nodos desde los que se puede llegar con un Link desde este nodo\n    for (Link link : graph.getLinks(src)) {\n        Node next = graph.getNode(link.getDst());\n\n        // Si el nodo ya ha sido visitado no hacemos nada\n        if (visited.contains(next))\n            continue;\n\n        // Si el nodo no ha sido visitado, lo marcamos como visitado, lo a\u00f1adimos a la lista\n        visited.add(next);\n        list.add(next);\n\n        List &lt;Node&gt; res = getNodesRec(next, visited);\n\n        // A\u00f1adimos a la lista de nodos alcanzables los nodos que devuelve getNodesRec al recorrer el nodo next\n        list.addAll(res);\n    }\n\n    return list;\n}\n</code></pre> <p>El uso de <code>Set</code> para controlar la lista de visitados permite mejorar el algoritmo frente a <code>List</code>, ya que la b\u00fasqueda en listas no est\u00e1 tan optimizada como en <code>Set</code>.</p>","tags":["grafos"]},{"location":"exams/2018/p2/","title":"Examen 2018 \u2014 Parcial 2","text":""},{"location":"exams/2018/p2/#problema-1","title":"Problema 1","text":"<p>Se desea realizar un monitor para gestionar un tipo de recursos con acceso exclusivo por parte de varias hebras (threads). Para ello se parte del esquema de la clase <code>Recurso</code>: <pre><code>public class Recurso {\n    private int n = 0;\n    // n\u00famero de usuarios del recurso\n\n    public ... void adquirir() {\n        ...\n        // assert n == 1;\n    }\n\n    public ... void liberar() {\n        ...\n        // assert n == 0\n    }\n}\n</code></pre></p> <ul> <li>(a) (2,5 puntos) Complete el c\u00f3digo de la clase <code>Recurso</code> de forma que se cumplan las aserciones que figuran como comentarios.</li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n de la clase <code>Recurso</code> es: <pre><code>public class Recurso {\n    private int n = 0; // n\u00famero de usuarios del recurso\n\n    public synchronized void adquirir() {\n        while (n &gt; 0)\n            try {\n                wait();\n            } catch (ExceptionIgnored) {}\n        n++;\n        assert n == 1;\n    }\n\n    public class Recurso {\n        private int n = 0;\n        // n\u00famero de usuarios del recurso\n\n        public ... void adquirir() {\n            ...\n            // assert n == 1;\n        }\n\n        public ... void liberar() {\n            ...\n            // assert n == 0\n        }\n    }\n\n    public synchronized void liberar() {\n        n--;\n        notifyAll();\n        assert n == 0;\n    }\n}\n</code></pre></p> <p>Se crean tres hebras, <code>T1</code>, <code>T2</code>, y <code>T3</code>, cuyos m\u00e9todos run incluyen los siguientes accesos a dos objetos, <code>R1</code> y <code>R2</code>, de la clase <code>Recurso</code>: <pre><code>T1: R1.adquirir(); R1.liberar(); ... R2.adquirir(); R2.liberar();\nT2: R2.adquirir(); R1.adquirir(); ... R1.liberar(); R2.liberar();\nT3: R1.adquirir(); R2.adquirir(); ... R2.liberar(); R1.liberar();\n</code></pre></p> <ul> <li>(b) (2,5 puntos) Analice el comportamiento de este programa, indicando si se pueden producir interbloqueos entre todas o algunas de las hebras. Justifique la respuesta mediante las condiciones de interbloqueo explicadas en clase. NOTA : no hace falta implementar las hebras <code>T1</code>, <code>T2</code>, <code>T3</code>, ni los m\u00e9todos <code>run()</code> respectivos.</li> </ul> Mostrar soluci\u00f3n <p>Examinamos las condiciones de Coffman:</p> <ul> <li>Exclusi\u00f3n mutua: Las tres hebras acceden a los recursos de forma mutuamente exclusiva, por medio de los m\u00e9todos <code>adquirir()</code> y <code>liberar()</code>. Por tanto esta condici\u00f3n se cumple para las tres hebras.</li> <li>Tener y esperar: La hebra <code>T1</code> s\u00f3lo adquiere un recurso a la vez. <code>T2</code> accede a <code>R2</code> y luego a <code>R1</code>, y la hebra <code>T3</code> accede a <code>R1</code> y luego <code>R2</code>. Por tanto, la condici\u00f3n se cumple para <code>T2</code> y <code>T3</code>, pero no para <code>T1</code>.</li> <li>Sin expulsi\u00f3n: La implementaci\u00f3n de los m\u00e9todos <code>adquirir()</code> y <code>liberar()</code> no permite expulsar a una hebra de un recurso ya adquirido. Por tanto, esta condici\u00f3n se cumple para todas las hebras.</li> <li>Espera circular: Se puede producir una espera circular entre <code>T2</code> y <code>T3</code>, como se muestra en el siguiente esquema:</li> </ul> <p></p>"},{"location":"exams/2018/p2/#problema-2","title":"Problema 2","text":"<p>Se desea realizar un monitor para gestionar paso de peatones en una carretera con acceso exclusivo por parte de varias hebras (threads). Hay dos tipos de hebras, los coches y los peatones.</p> <p>Los peatones y los coches ir\u00e1n apareciendo aleatoriamente para cruzar el paso de peatones.</p> <p>En el paso de peatones no puede haber a la vez coches y peatones. Los coches esperan a que no haya peatones para pasar. Igualmente, los peatones esperan a que no haya coches. En caso de conflicto se da prioridad a los peatones. <pre><code>public class Coche extends Thread {\n    private int idCoche;\n    private PasoPeatones monitor;\n\n    public Coche(PasoPeatones monitor, int idCoche) {\n        this.idCoche = idCoche;\n        this.monitor = monitor;\n        this.start();\n    }\n\n    public void run() {\n        try {\n            this.monitor.entrarCoche(idCoche);\n            Thread.sleep(\u2026); // tiempo aleatorio para cruzar\n            this.monitor.salirCoche(idCoche);\n        } catch (InterruptedException e) {}\n    }\n}\n\npublic class Peaton extends Thread {\n    private int idPeaton;\n    private PasoPeatones monitor;\n\n    public Peaton(PasoPeatones monitor, int idPeaton) {\n        this.idPeaton = idPeaton;\n        this.monitor = monitor;\n        this.start();\n    }\n\n    public void run() {\n        try {\n            this.monitor.entrarPeaton(idPeaton);\n            Thread.sleep(...); // tiempo aleatorio para cruzar\n            this.monitor.salirPeaton(idPeaton);\n        } catch (InterruptedException e) {}\n    }\n}\n</code></pre></p> <ul> <li>(a) (5 puntos) Crear un monitor <code>PasoPeatones</code> que gestione el acceso al paso de peatones seg\u00fan las condiciones expuestas en el enunciado. <pre><code>public class PasoPeatones {\n...\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * Monitor paso de peatones.\n */\npublic class PasoPeatones {\n\n    private int nPeatonesIn = 0; //N\u00famero de peatones en el paso de peatones\n\n    public class Coche extends Thread {\n        private int idCoche;\n        private PasoPeatones monitor;\n\n        public Coche(PasoPeatones monitor, int idCoche) {\n            this.idCoche = idCoche;\n            this.monitor = monitor;\n            this.start();\n        }\n\n        public void run() {\n            try {\n                this.monitor.entrarCoche(idCoche);\n                Thread.sleep(\u2026); // tiempo aleatorio para cruzar\n                this.monitor.salirCoche(idCoche);\n            } catch (InterruptedException e) {}\n        }\n    }\n\n    public class Peaton extends Thread {\n        private int idPeaton;\n        private PasoPeatones monitor;\n\n        public Peaton(PasoPeatones monitor, int idPeaton) {\n            this.idPeaton = idPeaton;\n            this.monitor = monitor;\n            this.start();\n        }\n\n        public void run() {\n            try {\n                this.monitor.entrarPeaton(idPeaton);\n                Thread.sleep(...); //tiempo aleatorio para cruzar\n                this.monitor.salirPeaton(idPeaton);\n            } catch (InterruptedException e) {}\n        }\n    }\n\n    private int nCochesIn = 0; //N\u00famero de coches en el paso de peatones\n    private int nPeatonesWaiting = 0; //N\u00famero de peatones esperando para entrar en el paso de peatones\n\n    /**\n     * Getter.\n     *\n     * @return n\u00famero de peatones autorizados a pasar por el paso de peatones en este momento.\n     */\n    public synchronized int getNPeatonesIn() {\n        return nPeatonesIn;\n    }\n\n    /**\n     * Getter.\n     *\n     * @return n\u00famero de coches autorizados a pasar por el paso de peatones en este momento.\n     */\n    public synchronized int getNCochesIn() {\n        return nCochesIn;\n    }\n\n    /**\n     * Solicitud de permiso para entrar un peat\u00f3n al paso de peatones.\n     * El thread peaton que llama se queda esperando hasta que pueda entrar.\n     */\n    public synchronized void entraPeaton() {\n        nPeatonesWaiting++;\n        while (nCochesIn &gt; 0)\n            waiting();\n        nPeatonesWaiting--;\n        nPeatonesIn++;\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un peat\u00f3n.\n     *\n     * @throws IllegalMonitorStateException si no hay peat\u00f3n que pueda salir del paso de peatones.\n     */\n    public synchronized void salePeaton()\n            throws IllegalMonitorStateException {\n        try {\n            if (nPeatonesIn &lt;= 0)\n                throw new IllegalMonitorStateException();\n            nPeatonesIn--;\n        } finally {\n            if (nPeatonesIn == 0) notifyAll();\n        }\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un coche.\n     * El thread coche que llama se queda esperando hasta que pueda entrar.\n     */\n    public synchronized void entraCoches() {\n        while (nPeatonesIn &gt; 0 || nPeatonesWaiting &gt; 0)\n            waiting();\n        nCochesIn++;\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un coche.\n     *\n     * @throws IllegalMonitorStateException si no hay coche que pueda salir del paso de peatones.\n     */\n    public synchronized void saleCoche()\n            throws IllegalMonitorStateException {\n        try {\n            if (nCochesIn &lt; 1)\n                throw new IllegalMonitorStateException();\n            nCochesIn--;\n        } finally {\n            if (nCochesIn == 0) notifyAll();\n        }\n    }\n\n    private void waiting() {\n        try {\n            wait();\n        } catch (InterruptedException ignored) {\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2018/p2_ex01/","title":"P2 ex01","text":"<p>Se desea realizar un monitor para gestionar un tipo de recursos con acceso exclusivo por parte de varias hebras (threads). Para ello se parte del esquema de la clase <code>Recurso</code>: <pre><code>public class Recurso {\n    private int n = 0;\n    // n\u00famero de usuarios del recurso\n\n    public ... void adquirir() {\n        ...\n        // assert n == 1;\n    }\n\n    public ... void liberar() {\n        ...\n        // assert n == 0\n    }\n}\n</code></pre></p> <ul> <li>(a) (2,5 puntos) Complete el c\u00f3digo de la clase <code>Recurso</code> de forma que se cumplan las aserciones que figuran como comentarios.</li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n de la clase <code>Recurso</code> es: <pre><code>public class Recurso {\n    private int n = 0; // n\u00famero de usuarios del recurso\n\n    public synchronized void adquirir() {\n        while (n &gt; 0)\n            try {\n                wait();\n            } catch (ExceptionIgnored) {}\n        n++;\n        assert n == 1;\n    }\n\n    public class Recurso {\n        private int n = 0;\n        // n\u00famero de usuarios del recurso\n\n        public ... void adquirir() {\n            ...\n            // assert n == 1;\n        }\n\n        public ... void liberar() {\n            ...\n            // assert n == 0\n        }\n    }\n\n    public synchronized void liberar() {\n        n--;\n        notifyAll();\n        assert n == 0;\n    }\n}\n</code></pre></p> <p>Se crean tres hebras, <code>T1</code>, <code>T2</code>, y <code>T3</code>, cuyos m\u00e9todos run incluyen los siguientes accesos a dos objetos, <code>R1</code> y <code>R2</code>, de la clase <code>Recurso</code>: <pre><code>T1: R1.adquirir(); R1.liberar(); ... R2.adquirir(); R2.liberar();\nT2: R2.adquirir(); R1.adquirir(); ... R1.liberar(); R2.liberar();\nT3: R1.adquirir(); R2.adquirir(); ... R2.liberar(); R1.liberar();\n</code></pre></p> <ul> <li>(b) (2,5 puntos) Analice el comportamiento de este programa, indicando si se pueden producir interbloqueos entre todas o algunas de las hebras. Justifique la respuesta mediante las condiciones de interbloqueo explicadas en clase. NOTA : no hace falta implementar las hebras <code>T1</code>, <code>T2</code>, <code>T3</code>, ni los m\u00e9todos <code>run()</code> respectivos.</li> </ul> Mostrar soluci\u00f3n <p>Examinamos las condiciones de Coffman:</p> <ul> <li>Exclusi\u00f3n mutua: Las tres hebras acceden a los recursos de forma mutuamente exclusiva, por medio de los m\u00e9todos <code>adquirir()</code> y <code>liberar()</code>. Por tanto esta condici\u00f3n se cumple para las tres hebras.</li> <li>Tener y esperar: La hebra <code>T1</code> s\u00f3lo adquiere un recurso a la vez. <code>T2</code> accede a <code>R2</code> y luego a <code>R1</code>, y la hebra <code>T3</code> accede a <code>R1</code> y luego <code>R2</code>. Por tanto, la condici\u00f3n se cumple para <code>T2</code> y <code>T3</code>, pero no para <code>T1</code>.</li> <li>Sin expulsi\u00f3n: La implementaci\u00f3n de los m\u00e9todos <code>adquirir()</code> y <code>liberar()</code> no permite expulsar a una hebra de un recurso ya adquirido. Por tanto, esta condici\u00f3n se cumple para todas las hebras.</li> <li>Espera circular: Se puede producir una espera circular entre <code>T2</code> y <code>T3</code>, como se muestra en el siguiente esquema:</li> </ul> <p></p>","tags":["monitores","hebras"]},{"location":"exams/2018/p2_ex02/","title":"P2 ex02","text":"<p>Se desea realizar un monitor para gestionar paso de peatones en una carretera con acceso exclusivo por parte de varias hebras (threads). Hay dos tipos de hebras, los coches y los peatones.</p> <p>Los peatones y los coches ir\u00e1n apareciendo aleatoriamente para cruzar el paso de peatones.</p> <p>En el paso de peatones no puede haber a la vez coches y peatones. Los coches esperan a que no haya peatones para pasar. Igualmente, los peatones esperan a que no haya coches. En caso de conflicto se da prioridad a los peatones. <pre><code>public class Coche extends Thread {\n    private int idCoche;\n    private PasoPeatones monitor;\n\n    public Coche(PasoPeatones monitor, int idCoche) {\n        this.idCoche = idCoche;\n        this.monitor = monitor;\n        this.start();\n    }\n\n    public void run() {\n        try {\n            this.monitor.entrarCoche(idCoche);\n            Thread.sleep(\u2026); // tiempo aleatorio para cruzar\n            this.monitor.salirCoche(idCoche);\n        } catch (InterruptedException e) {}\n    }\n}\n\npublic class Peaton extends Thread {\n    private int idPeaton;\n    private PasoPeatones monitor;\n\n    public Peaton(PasoPeatones monitor, int idPeaton) {\n        this.idPeaton = idPeaton;\n        this.monitor = monitor;\n        this.start();\n    }\n\n    public void run() {\n        try {\n            this.monitor.entrarPeaton(idPeaton);\n            Thread.sleep(...); // tiempo aleatorio para cruzar\n            this.monitor.salirPeaton(idPeaton);\n        } catch (InterruptedException e) {}\n    }\n}\n</code></pre></p> <ul> <li>(a) (5 puntos) Crear un monitor <code>PasoPeatones</code> que gestione el acceso al paso de peatones seg\u00fan las condiciones expuestas en el enunciado. <pre><code>public class PasoPeatones {\n...\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * Monitor paso de peatones.\n */\npublic class PasoPeatones {\n\n    private int nPeatonesIn = 0; //N\u00famero de peatones en el paso de peatones\n\n    public class Coche extends Thread {\n        private int idCoche;\n        private PasoPeatones monitor;\n\n        public Coche(PasoPeatones monitor, int idCoche) {\n            this.idCoche = idCoche;\n            this.monitor = monitor;\n            this.start();\n        }\n\n        public void run() {\n            try {\n                this.monitor.entrarCoche(idCoche);\n                Thread.sleep(\u2026); // tiempo aleatorio para cruzar\n                this.monitor.salirCoche(idCoche);\n            } catch (InterruptedException e) {}\n        }\n    }\n\n    public class Peaton extends Thread {\n        private int idPeaton;\n        private PasoPeatones monitor;\n\n        public Peaton(PasoPeatones monitor, int idPeaton) {\n            this.idPeaton = idPeaton;\n            this.monitor = monitor;\n            this.start();\n        }\n\n        public void run() {\n            try {\n                this.monitor.entrarPeaton(idPeaton);\n                Thread.sleep(...); //tiempo aleatorio para cruzar\n                this.monitor.salirPeaton(idPeaton);\n            } catch (InterruptedException e) {}\n        }\n    }\n\n    private int nCochesIn = 0; //N\u00famero de coches en el paso de peatones\n    private int nPeatonesWaiting = 0; //N\u00famero de peatones esperando para entrar en el paso de peatones\n\n    /**\n     * Getter.\n     *\n     * @return n\u00famero de peatones autorizados a pasar por el paso de peatones en este momento.\n     */\n    public synchronized int getNPeatonesIn() {\n        return nPeatonesIn;\n    }\n\n    /**\n     * Getter.\n     *\n     * @return n\u00famero de coches autorizados a pasar por el paso de peatones en este momento.\n     */\n    public synchronized int getNCochesIn() {\n        return nCochesIn;\n    }\n\n    /**\n     * Solicitud de permiso para entrar un peat\u00f3n al paso de peatones.\n     * El thread peaton que llama se queda esperando hasta que pueda entrar.\n     */\n    public synchronized void entraPeaton() {\n        nPeatonesWaiting++;\n        while (nCochesIn &gt; 0)\n            waiting();\n        nPeatonesWaiting--;\n        nPeatonesIn++;\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un peat\u00f3n.\n     *\n     * @throws IllegalMonitorStateException si no hay peat\u00f3n que pueda salir del paso de peatones.\n     */\n    public synchronized void salePeaton()\n            throws IllegalMonitorStateException {\n        try {\n            if (nPeatonesIn &lt;= 0)\n                throw new IllegalMonitorStateException();\n            nPeatonesIn--;\n        } finally {\n            if (nPeatonesIn == 0) notifyAll();\n        }\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un coche.\n     * El thread coche que llama se queda esperando hasta que pueda entrar.\n     */\n    public synchronized void entraCoches() {\n        while (nPeatonesIn &gt; 0 || nPeatonesWaiting &gt; 0)\n            waiting();\n        nCochesIn++;\n    }\n\n    /**\n     * Devoluci\u00f3n del permiso de acceso al paso de peatones de un coche.\n     *\n     * @throws IllegalMonitorStateException si no hay coche que pueda salir del paso de peatones.\n     */\n    public synchronized void saleCoche()\n            throws IllegalMonitorStateException {\n        try {\n            if (nCochesIn &lt; 1)\n                throw new IllegalMonitorStateException();\n            nCochesIn--;\n        } finally {\n            if (nCochesIn == 0) notifyAll();\n        }\n    }\n\n    private void waiting() {\n        try {\n            wait();\n        } catch (InterruptedException ignored) {\n        }\n    }\n}\n</code></pre>","tags":["monitores","hebras"]},{"location":"exams/2019/extra/","title":"Examen 2019 \u2014 Extraordinario","text":""},{"location":"exams/2019/extra/#problema-1","title":"Problema 1","text":"<p>Una empresa de telecomunicaciones necesita gestionar una tabla de abonados con sus n\u00fameros de l\u00ednea correspondientes. Para ello utiliza una clase Java denominada <code>TablaAbonados</code> con la interfaz que se especifica a continuaci\u00f3n: <pre><code>public class TablaAbonados {\n    ...\n    /**\n    * Registrar una nueva l\u00ednea\n    * @param numero l\u00ednea\n    * @param abonado apellidos, nombre\n    */\n    public void insertar (String numero, String abonado) {...}\n    /**\n    * Eliminar el registro de una l\u00ednea\n    * @param numero de l\u00ednea\n    */\n    public void eliminar (String numero) {...}\n    /**\n    * Apellidos y nombre del titular de una l\u00ednea\n    * @param numero de l\u00ednea\n    * @return apellidos, nombre\n    */\n    public String abonado (String numero) {...}\n}\n</code></pre></p> <p>Las operaciones insertar y abonado se ejecutan muchas veces al d\u00eda, y la operaci\u00f3n eliminar se ejecuta con menos frecuencia. Para implementar la tabla se utiliza internamente una tabla hash con listas.</p> <p>Nota: no escriba c\u00f3digo, s\u00f3lo indique qu\u00e9 algoritmos habr\u00eda que utilizar</p> <ul> <li>(a) (1 punto) Explique razonadamente qu\u00e9 par\u00e1metros se deben tomar como clave y valor, respectivamente, en la tabla hash.</li> </ul> Mostrar soluci\u00f3n <p>Un n\u00famero de l\u00ednea permite identificarla de forma un\u00edvoca, mientras que los abonados se pueden repetir, por ejemplo, si un abonado tiene varios n\u00fameros. Por tanto, se debe usar el n\u00famero como clave y el abonado como valor en la tabla.</p> <ul> <li>(b) (1 punto) Si el n\u00famero m\u00e1ximo de abonados de empresa se puede estimar en 1.000.000, aproximadamente, indique razonadamente cu\u00e1l ser\u00eda el n\u00famero m\u00ednimo de ranuras (slots) de la tabla hash para obtener un comportamiento eficiente.</li> </ul> Mostrar soluci\u00f3n <p>Para mantener la complejidad \\(O(1)\\) en las operaciones con la tabla hash, el n\u00famero \\(k\\) de ranuras debe ser significativamente superior al n\u00famero de claves, \\(N\\). Por ejemplo, si se quiere mantener la carga de la tabla por debajo del 50% har\u00edan falta 2.000.000 de ranuras</p> <ul> <li>(c) (1,5 puntos) Indique cu\u00e1l ser\u00eda la complejidad que se puede esperar de las operaciones de la tabla para el caso anterior, justificando la respuesta.</li> </ul> Mostrar soluci\u00f3n <p>Para una tabla hash con listas y una carga reducida, el tiempo de acceso para las operaciones de la tabla ser\u00eda \\(t=th+top\u2248constante\\). Por tanto, para \\(N\\) grande se puede suponer \\(t\\in O(1)\\).</p> <ul> <li>(d)  (1,5 puntos) Una vez al trimestre la empresa debe entregar a la administraci\u00f3n, a efectos fiscales, una lista de abonados ordenada alfab\u00e9ticamente. Para ello se a\u00f1ade a la clase anterior un nuevo m\u00e9todo: <pre><code>public List&lt;String&gt; listaAbonados (String) {...}\n</code></pre></li> </ul> <p>que genera la lista a partir del contenido de la tabla hash. Explique, justificando la respuesta, c\u00f3mo se podr\u00eda generar esta y cu\u00e1l ser\u00eda la complejidad de la operaci\u00f3n <code>listaAbonados</code> (1,5 puntos).</p> Mostrar soluci\u00f3n <p>Para obtener la lista ordenada hay que efectuar las siguientes operaciones:</p> <ul> <li>Obtener una lista con todos los elementos de la tabla hash: Para ello hay que recorrer toda la tabla, y por tanto esta operaci\u00f3n tiene complejidad lineal, \\(O(N)\\);</li> <li>Ordenar la lista: Si se usa un algoritmo de ordenaci\u00f3n eficiente, como <code>QuickSort</code> o <code>MergeSort</code>, la complejidad de esta operaci\u00f3n es, en promedio, \\(O(Nlog N)\\).</li> </ul> <p>Por tanto, la complejidad total de la operaci\u00f3n ser\u00e1 \\(O(N)+O(NlogN)\u2248O(NlogN)\\).</p>"},{"location":"exams/2019/extra/#problema-2","title":"Problema 2","text":"<p>Se debe realizar un algoritmo para etiquetar con un n\u00famero todos los nodos de un grafo cumpliendo las siguientes condiciones:</p> <ol> <li>Dos nodos adyacentes no pueden tener el mismo n\u00famero;</li> <li>Sobre el grafo pasado como par\u00e1metro, el algoritmo debe asignar el n\u00famero m\u00ednimo que pueda a todos los nodos, cumpliendo la condici\u00f3n del punto 1, y devolver el n\u00famero m\u00e1ximo utilizado para etiquetar todos los nodos. (Ver ejemplos).</li> <li>Se considera que todos los enlaces son bidireccionales y se han creado con el siguiente m\u00e9todo:     <pre><code>public void addLink2D(String a, String b, int w) {\u2026}\n</code></pre> que a\u00f1ade a un grafo un enlace entre el nodo <code>a</code> y el <code>b</code>, y otro enlace entre <code>b</code> y <code>a</code>. Todos los enlaces tiene peso <code>w = 1</code>.</li> <li>Se usar\u00e1 el modelo de los ejercicios de pr\u00e1cticas 1 y 2, donde tenemos la clase <code>Graph</code> que contiene objetos de la clase <code>Node</code> para definir los v\u00e9rtices (nodos), y objetos de la clase <code>Link</code> para definir los arcos (enlaces.)</li> </ol> <p>Notas: Una posible soluci\u00f3n trivial podr\u00eda ser hacer un <code>for</code> con un \u00edndice y asignar ese \u00edndice a cada nodo. Esta soluci\u00f3n no ser\u00eda v\u00e1lida porque, aunque cumple el punto 2, no cumple el punto 3. Para asignar valores a los nodos se recomienda usar una estructura del estilo <code>Map&lt;Node, Integer&gt;</code>, donde la clave (key) es el <code>Node</code> que queremos etiquetar y el valor (value) es el <code>Integer</code> con el valor etiquetado.</p> <p>Ejemplos:</p> <p></p> <ul> <li>(a) (4 puntos) Dise\u00f1e el algoritmo con la siguiente signatura. Nota: Puede (debe) desarrollar m\u00e9todos auxiliares si lo necesita para facilitar la implementaci\u00f3n del algoritmo. <pre><code>int getMinimunInt(Graph g) {\n    // a rellenar por el alumno\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * M\u00e9todo para conseguir una lista con todos enteros de los nodos vecinos a uno dado.\n * Si el vecino no tiene un entero asignado, no se devuelve nada.\n *\n * @param g Grafo del que se quiere realizar los c\u00e1lculos\n * @param myNode Nodo del cual se quiere obtener todos los vecinos\n * @param ints Mapa con los enteros de todos los nodos\n * @return Lista de los colores de los vecinos\n */\npublic static List&lt;Integer&gt; getNeighborsInts(Graph g, Node myNode, Map&lt;Node, Integer&gt; ints) {\n\n    List&lt;Integer&gt; neighborsInts = new ArrayList&lt;Integer&gt;();\n\n    for (Link link : g.getLinks(myNode)) {\n        Node dst = g.getNode(link.getDst());\n        if (dst != null) {\n            Integer intDst = ints.get(dst);\n            if (intDst != null) {\n                neighborsInts.add(intDst);\n            }\n        }\n    }\n    return neighborsInts;\n}\n\n/**\n * Algoritmo para conseguir el entero m\u00ednimo de una lista de Integers dada.\n *\n * Ejemplos:\n * &lt;1,2,3&gt;  -&gt; devuelve 0\n * &lt;0,1,3&gt;  -&gt; devuelve 2\n * &lt;0,1,2&gt;  -&gt; devuelve 3\n *\n * @param neighborsInts lista con enteros\n * @return entero m\u00ednimo que no est\u00e1 en la lista\n */\npublic static int getMinimunInt(List&lt;Integer&gt; neighborsInts) {\n\n    for (int i = 0; i != Integer.MAX_VALUE; i++) {\n        boolean found = false;\n\n        for (Integer myInteger : neighborsInts) {\n            if (myInteger.intValue() == i) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            return i;\n        }\n    }\n    return Integer.MAX_VALUE;\n}\n\n/**\n * Algoritmo para conseguir el entero mayor (m\u00e1ximo) de un mapa.\n *\n * @param ints mapa con los nodos y el entero asignado\n * @return entero m\u00e1ximo del mapa\n */\npublic static int getMaxIntInGraph(Map&lt;Node, Integer&gt; ints) {\n\n    int maxValue = Integer.MIN_VALUE;\n\n    for (Integer myInteger : ints.values()) {\n        if (myInteger.intValue() &gt; maxValue) {\n            maxValue = myInteger.intValue();\n        }\n    }\n    return maxValue;\n}\n\n/**\n * Algoritmo para conseguir el entero m\u00ednimo para etiquetar un grafo\n * siguiendo las reglas del coloreado de grafos.\n *\n * @param g grafo que describe el problema\n * @return entero m\u00ednimo necesario para etiquetar el grafo\n */\npublic static int getMinimunInt(Graph g) {\n\n    // Estructura para guardar los enteros asignados a cada nodo\n    Map&lt;Node, Integer&gt; ints = new HashMap&lt;Node, Integer&gt;();\n\n    // Recorremos todos los nodos del grafo\n    for (Node myNode : g.getNodes()) {\n\n        // Obtenemos los enteros de los vecinos\n        List&lt;Integer&gt; neighborsInts = getNeighborsInts(g, myNode, ints);\n\n        // Calculamos el entero m\u00ednimo no usado\n        int minimunInt = getMinimunInt(neighborsInts);\n\n        // Asignamos el entero al nodo\n        ints.put(myNode, minimunInt);\n    }\n\n    // Obtenemos el entero m\u00e1ximo usado en el grafo\n    int maxIntInGraph = getMaxIntInGraph(ints);\n\n    return maxIntInGraph;\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfCu\u00e1l es la complejidad de dicho algoritmo? (Razone su respuesta).</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p>"},{"location":"exams/2019/extra/#problema-3","title":"Problema 3","text":"<p>Se quiere desarrollar un sistema de gesti\u00f3n de eventos. Este sistema est\u00e1 compuesto por un conjunto de productores y consumidores. Los productores ponen eventos en el sistema. Los consumidores recogen eventos del sistema para procesarlos.</p> <ul> <li>(a) Desarrolle el monitor <code>EventManager</code> con el siguiente esquema (Nota: el m\u00e9todo <code>getEvents</code> tiene m\u00e1s peso en la calificaci\u00f3n que el resto del c\u00f3digo): <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = ...;\n    ...\n    /**\n    * A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes de procesar\n    * es igual al m\u00e1ximo, la hebra que llama se bloquea hasta que haya hueco\n    */\n    ... void putEvent (Event event) {...}\n    /**\n    * Recuperar eventos para su procesamiento. Este m\u00e9todo admite que se soliciten\n    * uno o dos eventos. El m\u00e9todo deber\u00e1 devolver un array con un n\u00famero de eventos\n    * igual a la solicitud. Las hebras que solicitan dos eventos tienen preferencia.\n    * Si hay hebras bloqueadas y hay eventos suficientes, hay que desbloquear a las que\n    * hayan solicitado dos eventos. Si no hay suficientes eventos pendientes para cada\n    * tipo, se bloquea la hebra que llama hasta que haya suficientes.\n    */\n    ... Event[] getEvents (int nEventos) {...}\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = 10;\n\n    // N\u00famero de hebras que han solicitado dos eventos\n    private int nTwoEvents = 0;\n\n    // Lista de eventos a\u00f1adidos y no recuperados\n    private List&lt;Event&gt; buffer;\n\n    public EventManager () {\n        buffer = new ArrayList&lt;&gt;(MAX_PENDING_EVENTS);\n    }\n\n    /**\n    * A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes\n    * de procesar es igual al m\u00e1ximo, la hebra que\n    * llama se bloquea hasta que haya hueco\n    */\n    public synchronized void putEvent(Event event) {\n        while (buffer.size() == MAX_PENDING_EVENTS) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        buffer.add(event);\n        notifyAll();\n    }\n    /**\n    * Recuperar eventos para su procesamiento. Este m\u00e9todo admite que se soliciten\n    * uno o dos eventos. El m\u00e9todo deber\u00e1 devolver un array con un n\u00famero de eventos\n    * igual a la solicitud. Las hebras que solicitan dos eventos tienen m\u00e1s urgencia.\n    * Si hay hebras bloqueadas y hay eventos suficientes, hay que desbloquear a las que\n    * hayan solicitado dos eventos. Si no hay suficientes eventos pendientes para cada\n    * tipo, se bloquea a la hebra que llama hasta que haya suficientes.\n    */\n    Event[] getEvent(int nEvents) {\n        Event[] events;\n\n        if (nEvents == 2) nTwoEvents++;\n        while ( (nEvents == 2 &amp;&amp; buffer.size() &lt; 2) ||\n                (nEvents == 1 &amp;&amp; nTwoEvents &gt; 0 &amp;&amp; buffer.size() &gt;= 2) ||\n                (buffer.size() == 0)) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n\n        if (nEvents == 2) {\n            nTwoEvents--;\n            events = new Event[2];\n            events[0] = buffer.remove(0);\n            events[1] = buffer.remove(0);\n        } else {\n            events = new Event[1];\n            events[0] = buffer.remove(0);\n        }\n\n        notifyAll(); return events;\n    }\n}\n</code></pre>"},{"location":"exams/2019/extra/#problema-4","title":"Problema 4","text":"<p>A continuaci\u00f3n se muestra el m\u00e9todo <code>getEvent</code> de una versi\u00f3n alternativa de un gestor de eventos con prioridades, al que acceden concurrentemente varias hebras. <pre><code>public class Event {\n    private EventInformation info;\n    private EventPriority priority;\n    // getters &amp; setters\n}\n</code></pre></p> <pre><code>public enum EventPriority {High, Low}\n</code></pre> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n\npublic class PriorityEventManager {\n\n    public final int MAX_PENDING_EVENTS = 10;\n    private List&lt;Event&gt; list;\n\n    public PriorityEventManager() {\n        list = new ArrayList&lt;&gt;(MAX_PENDING_EVENTS);\n    }\n\n    public synchronized void putEvent(Event anEvent) {\n        // implementaci\u00f3n pendiente\n    }\n\n    public synchronized Event getEvent() {\n        List&lt;Event&gt; aux = new ArrayList&lt;Event&gt;();\n        Event event = null;\n\n        // Copiar los elementos de list y guardarlos en aux\n        aux.addAll(list);\n\n        while (aux.size() == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n            }\n        }\n\n        for (Event e : aux) {\n            if (e.getPriority() == EventPriority.High) {\n                event = e;\n                aux.remove(e);\n                break;\n            }\n        }\n\n        if (event == null) {\n            event = aux.remove(0);\n        }\n\n        list = aux;\n        notifyAll();\n        return event;\n    }\n}\n</code></pre> <ul> <li>(a) (2,5 puntos) Razone si esta soluci\u00f3n es correcta y, en caso contrario, describa los errores que contiene.</li> </ul> Mostrar soluci\u00f3n <p>Esta soluci\u00f3n es incorrecta en un programa concurrente. Cuando se ejecuta <code>GetEvent</code> se hace una copia de <code>list</code> a <code>aux</code>. Esta variable es local en cada instancia del m\u00e9todo, por lo que s\u00f3lo se puede cambiar al ejecutar la hebra que ha invocado este m\u00e9todo. Eso quiere decir que si varias hebras han invocado a <code>GetEvent</code>, cada una tiene una variable <code>aux</code> local.</p> <p>Si la lista <code>aux</code> est\u00e1 vac\u00eda, por tanto, su tama\u00f1o es cero. En consecuencia, la hebra se quedar\u00e1 bloqueada en el <code>wait</code> y nunca volver\u00e1 a ejecutarse, por que ninguna otra hebra podr\u00e1 cambiar el valor de la variable <code>aux</code> local.</p> <p>Adem\u00e1s, en el caso de que esta hebra se ejecutara, tambi\u00e9n hay varios errores en el c\u00f3digo. Por ejemplo, cuando actualiza el valor de <code>list</code> machaca su versi\u00f3n actual.</p>"},{"location":"exams/2019/extra/#problema-5","title":"Problema 5","text":"<p>Se desea desarrollar una aplicaci\u00f3n llamada 'Tiempo Perdido', cuya funcionalidad es comparar el tiempo en segundos que la aplicaci\u00f3n ha estado completamente visible con un valor introducido por el usuario. Para ello se ha dise\u00f1ado la siguiente interfaz gr\u00e1fica:</p> <p></p> <p>En ella se han emplazado los siguientes elementos:</p> <ul> <li>Un <code>EditText</code> con <code>id</code>: <code>etNumber</code> e <code>inputType: number</code>. Este \u00faltimo atributo solo permite al usuario introducir n\u00fameros enteros no negativos.</li> <li>Un <code>TextView</code> con <code>id: tvResult</code> donde se muestra el resultado de la comparaci\u00f3n.<ul> <li>Si el valor introducido por el usuario coincide con el tiempo en segundos que la aplicaci\u00f3n ha estado completamente visible indica \u201c\u00a1correcto!\u201d.</li> <li>Si el usuario introduce un valor mayor indica \u201cTe has pasado por X segundos\u201d donde <code>X</code> es la diferencia entre el valor introducido y el correcto.</li> <li>Si el usuario introduce un valor menor indica \u201cTe has quedado corto por X segundos\u201d donde <code>X</code> es la diferencia entre el valor introducido y el correcto.</li> </ul> </li> <li>Un bot\u00f3n con <code>id: bComprobar</code> que lanza la comprobaci\u00f3n. Si al pulsar el bot\u00f3n <code>etNumber</code> no contiene un n\u00famero no negativo se ha de lanzar un mensaje de alerta al usuario.</li> </ul> <p>Para la implementaci\u00f3n nos apoyaremos en la clase <code>Chrono</code> que ofrece los siguientes m\u00e9todos:</p> <pre><code>public class Chrono {\n    int time;\n    public Chrono() {\n        this.time = 0;\n    }\n    // Arranca el cron\u00f3metro\n    public void startChrono (){\u2026}\n    // Para el cron\u00f3metro\n    public void stopChrono (){\u2026}\n    // Reinicia el cron\u00f3metro a 0\n    public void resetChrono (){time = 0;}\n    // Devuelve el valor del cron\u00f3metro en segundos\n    public int currentTime() {return time;}\n}\n</code></pre> <ul> <li>(a) (3 puntos) Complete la clase para implementar la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    Chrono chrono;\n    EditText input;\n    TextView output;\n    Button check;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        chrono = new Chrono();\n        input = findViewById(R.id.etNumber);\n        output = findViewById(R.id.tvResult);\n        check = findViewById(R.id.bComprobar);\n\n        check.setOnClickListener(new View.OnClickListener() {\n            public void onClick(View w) {\n                String st = input.getText().toString();\n\n                if (st == null || st.isEmpty()) {\n                    Toast.makeText(\n                        MainActivity.this,\n                        \"Introduce un n\u00famero entero positivo\",\n                        Toast.LENGTH_SHORT\n                    ).show();\n                    return;\n                }\n\n                Integer in = Integer.parseInt(st);\n                if (in != null &amp;&amp; in &gt;= 0) {\n                    int diff = in.intValue() - chrono.currentTime();\n\n                    if (diff == 0) {\n                        output.setText(\"\u00a1Correcto!\");\n                    } else if (diff &gt; 0) {\n                        output.setText(\"Te has pasado por \" + diff + \" segundos.\");\n                    } else {\n                        output.setText(\"Te has quedado corto por \" + (-diff) + \" segundos.\");\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        chrono.startChrono();\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        chrono.stopChrono();\n    }\n}\n</code></pre>"},{"location":"exams/2019/extra_ex01/","title":"Extra ex01","text":"<p>Una empresa de telecomunicaciones necesita gestionar una tabla de abonados con sus n\u00fameros de l\u00ednea correspondientes. Para ello utiliza una clase Java denominada <code>TablaAbonados</code> con la interfaz que se especifica a continuaci\u00f3n: <pre><code>public class TablaAbonados {\n    ...\n    /**\n    * Registrar una nueva l\u00ednea\n    * @param numero l\u00ednea\n    * @param abonado apellidos, nombre\n    */\n    public void insertar (String numero, String abonado) {...}\n    /**\n    * Eliminar el registro de una l\u00ednea\n    * @param numero de l\u00ednea\n    */\n    public void eliminar (String numero) {...}\n    /**\n    * Apellidos y nombre del titular de una l\u00ednea\n    * @param numero de l\u00ednea\n    * @return apellidos, nombre\n    */\n    public String abonado (String numero) {...}\n}\n</code></pre></p> <p>Las operaciones insertar y abonado se ejecutan muchas veces al d\u00eda, y la operaci\u00f3n eliminar se ejecuta con menos frecuencia. Para implementar la tabla se utiliza internamente una tabla hash con listas.</p> <p>Nota: no escriba c\u00f3digo, s\u00f3lo indique qu\u00e9 algoritmos habr\u00eda que utilizar</p> <ul> <li>(a) (1 punto) Explique razonadamente qu\u00e9 par\u00e1metros se deben tomar como clave y valor, respectivamente, en la tabla hash.</li> </ul> Mostrar soluci\u00f3n <p>Un n\u00famero de l\u00ednea permite identificarla de forma un\u00edvoca, mientras que los abonados se pueden repetir, por ejemplo, si un abonado tiene varios n\u00fameros. Por tanto, se debe usar el n\u00famero como clave y el abonado como valor en la tabla.</p> <ul> <li>(b) (1 punto) Si el n\u00famero m\u00e1ximo de abonados de empresa se puede estimar en 1.000.000, aproximadamente, indique razonadamente cu\u00e1l ser\u00eda el n\u00famero m\u00ednimo de ranuras (slots) de la tabla hash para obtener un comportamiento eficiente.</li> </ul> Mostrar soluci\u00f3n <p>Para mantener la complejidad \\(O(1)\\) en las operaciones con la tabla hash, el n\u00famero \\(k\\) de ranuras debe ser significativamente superior al n\u00famero de claves, \\(N\\). Por ejemplo, si se quiere mantener la carga de la tabla por debajo del 50% har\u00edan falta 2.000.000 de ranuras</p> <ul> <li>(c) (1,5 puntos) Indique cu\u00e1l ser\u00eda la complejidad que se puede esperar de las operaciones de la tabla para el caso anterior, justificando la respuesta.</li> </ul> Mostrar soluci\u00f3n <p>Para una tabla hash con listas y una carga reducida, el tiempo de acceso para las operaciones de la tabla ser\u00eda \\(t=th+top\u2248constante\\). Por tanto, para \\(N\\) grande se puede suponer \\(t\\in O(1)\\).</p> <ul> <li>(d)  (1,5 puntos) Una vez al trimestre la empresa debe entregar a la administraci\u00f3n, a efectos fiscales, una lista de abonados ordenada alfab\u00e9ticamente. Para ello se a\u00f1ade a la clase anterior un nuevo m\u00e9todo: <pre><code>public List&lt;String&gt; listaAbonados (String) {...}\n</code></pre></li> </ul> <p>que genera la lista a partir del contenido de la tabla hash. Explique, justificando la respuesta, c\u00f3mo se podr\u00eda generar esta y cu\u00e1l ser\u00eda la complejidad de la operaci\u00f3n <code>listaAbonados</code> (1,5 puntos).</p> Mostrar soluci\u00f3n <p>Para obtener la lista ordenada hay que efectuar las siguientes operaciones:</p> <ul> <li>Obtener una lista con todos los elementos de la tabla hash: Para ello hay que recorrer toda la tabla, y por tanto esta operaci\u00f3n tiene complejidad lineal, \\(O(N)\\);</li> <li>Ordenar la lista: Si se usa un algoritmo de ordenaci\u00f3n eficiente, como <code>QuickSort</code> o <code>MergeSort</code>, la complejidad de esta operaci\u00f3n es, en promedio, \\(O(Nlog N)\\).</li> </ul> <p>Por tanto, la complejidad total de la operaci\u00f3n ser\u00e1 \\(O(N)+O(NlogN)\u2248O(NlogN)\\).</p>","tags":["???"]},{"location":"exams/2019/extra_ex02/","title":"Extra ex02","text":"<p>Se debe realizar un algoritmo para etiquetar con un n\u00famero todos los nodos de un grafo cumpliendo las siguientes condiciones:</p> <ol> <li>Dos nodos adyacentes no pueden tener el mismo n\u00famero;</li> <li>Sobre el grafo pasado como par\u00e1metro, el algoritmo debe asignar el n\u00famero m\u00ednimo que pueda a todos los nodos, cumpliendo la condici\u00f3n del punto 1, y devolver el n\u00famero m\u00e1ximo utilizado para etiquetar todos los nodos. (Ver ejemplos).</li> <li>Se considera que todos los enlaces son bidireccionales y se han creado con el siguiente m\u00e9todo:     <pre><code>public void addLink2D(String a, String b, int w) {\u2026}\n</code></pre> que a\u00f1ade a un grafo un enlace entre el nodo <code>a</code> y el <code>b</code>, y otro enlace entre <code>b</code> y <code>a</code>. Todos los enlaces tiene peso <code>w = 1</code>.</li> <li>Se usar\u00e1 el modelo de los ejercicios de pr\u00e1cticas 1 y 2, donde tenemos la clase <code>Graph</code> que contiene objetos de la clase <code>Node</code> para definir los v\u00e9rtices (nodos), y objetos de la clase <code>Link</code> para definir los arcos (enlaces.)</li> </ol> <p>Notas: Una posible soluci\u00f3n trivial podr\u00eda ser hacer un <code>for</code> con un \u00edndice y asignar ese \u00edndice a cada nodo. Esta soluci\u00f3n no ser\u00eda v\u00e1lida porque, aunque cumple el punto 2, no cumple el punto 3. Para asignar valores a los nodos se recomienda usar una estructura del estilo <code>Map&lt;Node, Integer&gt;</code>, donde la clave (key) es el <code>Node</code> que queremos etiquetar y el valor (value) es el <code>Integer</code> con el valor etiquetado.</p> <p>Ejemplos:</p> <p></p> <ul> <li>(a) (4 puntos) Dise\u00f1e el algoritmo con la siguiente signatura. Nota: Puede (debe) desarrollar m\u00e9todos auxiliares si lo necesita para facilitar la implementaci\u00f3n del algoritmo. <pre><code>int getMinimunInt(Graph g) {\n    // a rellenar por el alumno\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * M\u00e9todo para conseguir una lista con todos enteros de los nodos vecinos a uno dado.\n * Si el vecino no tiene un entero asignado, no se devuelve nada.\n *\n * @param g Grafo del que se quiere realizar los c\u00e1lculos\n * @param myNode Nodo del cual se quiere obtener todos los vecinos\n * @param ints Mapa con los enteros de todos los nodos\n * @return Lista de los colores de los vecinos\n */\npublic static List&lt;Integer&gt; getNeighborsInts(Graph g, Node myNode, Map&lt;Node, Integer&gt; ints) {\n\n    List&lt;Integer&gt; neighborsInts = new ArrayList&lt;Integer&gt;();\n\n    for (Link link : g.getLinks(myNode)) {\n        Node dst = g.getNode(link.getDst());\n        if (dst != null) {\n            Integer intDst = ints.get(dst);\n            if (intDst != null) {\n                neighborsInts.add(intDst);\n            }\n        }\n    }\n    return neighborsInts;\n}\n\n/**\n * Algoritmo para conseguir el entero m\u00ednimo de una lista de Integers dada.\n *\n * Ejemplos:\n * &lt;1,2,3&gt;  -&gt; devuelve 0\n * &lt;0,1,3&gt;  -&gt; devuelve 2\n * &lt;0,1,2&gt;  -&gt; devuelve 3\n *\n * @param neighborsInts lista con enteros\n * @return entero m\u00ednimo que no est\u00e1 en la lista\n */\npublic static int getMinimunInt(List&lt;Integer&gt; neighborsInts) {\n\n    for (int i = 0; i != Integer.MAX_VALUE; i++) {\n        boolean found = false;\n\n        for (Integer myInteger : neighborsInts) {\n            if (myInteger.intValue() == i) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            return i;\n        }\n    }\n    return Integer.MAX_VALUE;\n}\n\n/**\n * Algoritmo para conseguir el entero mayor (m\u00e1ximo) de un mapa.\n *\n * @param ints mapa con los nodos y el entero asignado\n * @return entero m\u00e1ximo del mapa\n */\npublic static int getMaxIntInGraph(Map&lt;Node, Integer&gt; ints) {\n\n    int maxValue = Integer.MIN_VALUE;\n\n    for (Integer myInteger : ints.values()) {\n        if (myInteger.intValue() &gt; maxValue) {\n            maxValue = myInteger.intValue();\n        }\n    }\n    return maxValue;\n}\n\n/**\n * Algoritmo para conseguir el entero m\u00ednimo para etiquetar un grafo\n * siguiendo las reglas del coloreado de grafos.\n *\n * @param g grafo que describe el problema\n * @return entero m\u00ednimo necesario para etiquetar el grafo\n */\npublic static int getMinimunInt(Graph g) {\n\n    // Estructura para guardar los enteros asignados a cada nodo\n    Map&lt;Node, Integer&gt; ints = new HashMap&lt;Node, Integer&gt;();\n\n    // Recorremos todos los nodos del grafo\n    for (Node myNode : g.getNodes()) {\n\n        // Obtenemos los enteros de los vecinos\n        List&lt;Integer&gt; neighborsInts = getNeighborsInts(g, myNode, ints);\n\n        // Calculamos el entero m\u00ednimo no usado\n        int minimunInt = getMinimunInt(neighborsInts);\n\n        // Asignamos el entero al nodo\n        ints.put(myNode, minimunInt);\n    }\n\n    // Obtenemos el entero m\u00e1ximo usado en el grafo\n    int maxIntInGraph = getMaxIntInGraph(ints);\n\n    return maxIntInGraph;\n}\n</code></pre> <ul> <li>(b) (1 punto) \u00bfCu\u00e1l es la complejidad de dicho algoritmo? (Razone su respuesta).</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p>","tags":["grafos","complejidad"]},{"location":"exams/2019/extra_ex03/","title":"Extra ex03","text":"<p>Se quiere desarrollar un sistema de gesti\u00f3n de eventos. Este sistema est\u00e1 compuesto por un conjunto de productores y consumidores. Los productores ponen eventos en el sistema. Los consumidores recogen eventos del sistema para procesarlos.</p> <ul> <li>(a) Desarrolle el monitor <code>EventManager</code> con el siguiente esquema (Nota: el m\u00e9todo <code>getEvents</code> tiene m\u00e1s peso en la calificaci\u00f3n que el resto del c\u00f3digo): <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = ...;\n    ...\n    /**\n    * A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes de procesar\n    * es igual al m\u00e1ximo, la hebra que llama se bloquea hasta que haya hueco\n    */\n    ... void putEvent (Event event) {...}\n    /**\n    * Recuperar eventos para su procesamiento. Este m\u00e9todo admite que se soliciten\n    * uno o dos eventos. El m\u00e9todo deber\u00e1 devolver un array con un n\u00famero de eventos\n    * igual a la solicitud. Las hebras que solicitan dos eventos tienen preferencia.\n    * Si hay hebras bloqueadas y hay eventos suficientes, hay que desbloquear a las que\n    * hayan solicitado dos eventos. Si no hay suficientes eventos pendientes para cada\n    * tipo, se bloquea la hebra que llama hasta que haya suficientes.\n    */\n    ... Event[] getEvents (int nEventos) {...}\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = 10;\n\n    // N\u00famero de hebras que han solicitado dos eventos\n    private int nTwoEvents = 0;\n\n    // Lista de eventos a\u00f1adidos y no recuperados\n    private List&lt;Event&gt; buffer;\n\n    public EventManager () {\n        buffer = new ArrayList&lt;&gt;(MAX_PENDING_EVENTS);\n    }\n\n    /**\n    * A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes\n    * de procesar es igual al m\u00e1ximo, la hebra que\n    * llama se bloquea hasta que haya hueco\n    */\n    public synchronized void putEvent(Event event) {\n        while (buffer.size() == MAX_PENDING_EVENTS) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n        buffer.add(event);\n        notifyAll();\n    }\n    /**\n    * Recuperar eventos para su procesamiento. Este m\u00e9todo admite que se soliciten\n    * uno o dos eventos. El m\u00e9todo deber\u00e1 devolver un array con un n\u00famero de eventos\n    * igual a la solicitud. Las hebras que solicitan dos eventos tienen m\u00e1s urgencia.\n    * Si hay hebras bloqueadas y hay eventos suficientes, hay que desbloquear a las que\n    * hayan solicitado dos eventos. Si no hay suficientes eventos pendientes para cada\n    * tipo, se bloquea a la hebra que llama hasta que haya suficientes.\n    */\n    Event[] getEvent(int nEvents) {\n        Event[] events;\n\n        if (nEvents == 2) nTwoEvents++;\n        while ( (nEvents == 2 &amp;&amp; buffer.size() &lt; 2) ||\n                (nEvents == 1 &amp;&amp; nTwoEvents &gt; 0 &amp;&amp; buffer.size() &gt;= 2) ||\n                (buffer.size() == 0)) {\n            try {\n                wait();\n            } catch (InterruptedException ignored) {\n            }\n        }\n\n        if (nEvents == 2) {\n            nTwoEvents--;\n            events = new Event[2];\n            events[0] = buffer.remove(0);\n            events[1] = buffer.remove(0);\n        } else {\n            events = new Event[1];\n            events[0] = buffer.remove(0);\n        }\n\n        notifyAll(); return events;\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2019/extra_ex04/","title":"Extra ex04","text":"<p>A continuaci\u00f3n se muestra el m\u00e9todo <code>getEvent</code> de una versi\u00f3n alternativa de un gestor de eventos con prioridades, al que acceden concurrentemente varias hebras. <pre><code>public class Event {\n    private EventInformation info;\n    private EventPriority priority;\n    // getters &amp; setters\n}\n</code></pre></p> <pre><code>public enum EventPriority {High, Low}\n</code></pre> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n\npublic class PriorityEventManager {\n\n    public final int MAX_PENDING_EVENTS = 10;\n    private List&lt;Event&gt; list;\n\n    public PriorityEventManager() {\n        list = new ArrayList&lt;&gt;(MAX_PENDING_EVENTS);\n    }\n\n    public synchronized void putEvent(Event anEvent) {\n        // implementaci\u00f3n pendiente\n    }\n\n    public synchronized Event getEvent() {\n        List&lt;Event&gt; aux = new ArrayList&lt;Event&gt;();\n        Event event = null;\n\n        // Copiar los elementos de list y guardarlos en aux\n        aux.addAll(list);\n\n        while (aux.size() == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n            }\n        }\n\n        for (Event e : aux) {\n            if (e.getPriority() == EventPriority.High) {\n                event = e;\n                aux.remove(e);\n                break;\n            }\n        }\n\n        if (event == null) {\n            event = aux.remove(0);\n        }\n\n        list = aux;\n        notifyAll();\n        return event;\n    }\n}\n</code></pre> <ul> <li>(a) (2,5 puntos) Razone si esta soluci\u00f3n es correcta y, en caso contrario, describa los errores que contiene.</li> </ul> Mostrar soluci\u00f3n <p>Esta soluci\u00f3n es incorrecta en un programa concurrente. Cuando se ejecuta <code>GetEvent</code> se hace una copia de <code>list</code> a <code>aux</code>. Esta variable es local en cada instancia del m\u00e9todo, por lo que s\u00f3lo se puede cambiar al ejecutar la hebra que ha invocado este m\u00e9todo. Eso quiere decir que si varias hebras han invocado a <code>GetEvent</code>, cada una tiene una variable <code>aux</code> local.</p> <p>Si la lista <code>aux</code> est\u00e1 vac\u00eda, por tanto, su tama\u00f1o es cero. En consecuencia, la hebra se quedar\u00e1 bloqueada en el <code>wait</code> y nunca volver\u00e1 a ejecutarse, por que ninguna otra hebra podr\u00e1 cambiar el valor de la variable <code>aux</code> local.</p> <p>Adem\u00e1s, en el caso de que esta hebra se ejecutara, tambi\u00e9n hay varios errores en el c\u00f3digo. Por ejemplo, cuando actualiza el valor de <code>list</code> machaca su versi\u00f3n actual.</p>","tags":["hebras"]},{"location":"exams/2019/extra_ex05/","title":"Extra ex05","text":"<p>Se desea desarrollar una aplicaci\u00f3n llamada 'Tiempo Perdido', cuya funcionalidad es comparar el tiempo en segundos que la aplicaci\u00f3n ha estado completamente visible con un valor introducido por el usuario. Para ello se ha dise\u00f1ado la siguiente interfaz gr\u00e1fica:</p> <p></p> <p>En ella se han emplazado los siguientes elementos:</p> <ul> <li>Un <code>EditText</code> con <code>id</code>: <code>etNumber</code> e <code>inputType: number</code>. Este \u00faltimo atributo solo permite al usuario introducir n\u00fameros enteros no negativos.</li> <li>Un <code>TextView</code> con <code>id: tvResult</code> donde se muestra el resultado de la comparaci\u00f3n.<ul> <li>Si el valor introducido por el usuario coincide con el tiempo en segundos que la aplicaci\u00f3n ha estado completamente visible indica \u201c\u00a1correcto!\u201d.</li> <li>Si el usuario introduce un valor mayor indica \u201cTe has pasado por X segundos\u201d donde <code>X</code> es la diferencia entre el valor introducido y el correcto.</li> <li>Si el usuario introduce un valor menor indica \u201cTe has quedado corto por X segundos\u201d donde <code>X</code> es la diferencia entre el valor introducido y el correcto.</li> </ul> </li> <li>Un bot\u00f3n con <code>id: bComprobar</code> que lanza la comprobaci\u00f3n. Si al pulsar el bot\u00f3n <code>etNumber</code> no contiene un n\u00famero no negativo se ha de lanzar un mensaje de alerta al usuario.</li> </ul> <p>Para la implementaci\u00f3n nos apoyaremos en la clase <code>Chrono</code> que ofrece los siguientes m\u00e9todos:</p> <pre><code>public class Chrono {\n    int time;\n    public Chrono() {\n        this.time = 0;\n    }\n    // Arranca el cron\u00f3metro\n    public void startChrono (){\u2026}\n    // Para el cron\u00f3metro\n    public void stopChrono (){\u2026}\n    // Reinicia el cron\u00f3metro a 0\n    public void resetChrono (){time = 0;}\n    // Devuelve el valor del cron\u00f3metro en segundos\n    public int currentTime() {return time;}\n}\n</code></pre> <ul> <li>(a) (3 puntos) Complete la clase para implementar la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class MainActivity extends AppCompatActivity {\n\n    Chrono chrono;\n    EditText input;\n    TextView output;\n    Button check;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        chrono = new Chrono();\n        input = findViewById(R.id.etNumber);\n        output = findViewById(R.id.tvResult);\n        check = findViewById(R.id.bComprobar);\n\n        check.setOnClickListener(new View.OnClickListener() {\n            public void onClick(View w) {\n                String st = input.getText().toString();\n\n                if (st == null || st.isEmpty()) {\n                    Toast.makeText(\n                        MainActivity.this,\n                        \"Introduce un n\u00famero entero positivo\",\n                        Toast.LENGTH_SHORT\n                    ).show();\n                    return;\n                }\n\n                Integer in = Integer.parseInt(st);\n                if (in != null &amp;&amp; in &gt;= 0) {\n                    int diff = in.intValue() - chrono.currentTime();\n\n                    if (diff == 0) {\n                        output.setText(\"\u00a1Correcto!\");\n                    } else if (diff &gt; 0) {\n                        output.setText(\"Te has pasado por \" + diff + \" segundos.\");\n                    } else {\n                        output.setText(\"Te has quedado corto por \" + (-diff) + \" segundos.\");\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        chrono.startChrono();\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        chrono.stopChrono();\n    }\n}\n</code></pre>","tags":["android"]},{"location":"exams/2019/p1/","title":"Examen 2019 \u2014 Parcial 1","text":""},{"location":"exams/2019/p1/#problema-1","title":"Problema 1","text":"<p>Queremos un algoritmo para calcular el n\u00famero de conjuntos conexos de un grafo no dirigido. Usaremos el modelo de los ejercicios 1 y 2, donde la clase <code>Graph</code> contiene objetos de la clase <code>Node</code> (nodos) y objetos de la clase <code>Link</code> (arcos o enlaces dirigidos ponderados). En lo sucesivo consideraremos que todos los enlaces se han creado con el m\u00e9todo: <pre><code>public void addLink2D (String a, String b, int w) {...}\n</code></pre></p> <p>De esta manera se garantiza que todos los enlaces son bidireccionales.</p> <p>Un conjunto conexo es un conjunto de nodos de un grafo unidos por enlaces directa o indirectamente. Un conjunto de nodos es conexo si existe al menos un camino entre todos los pares de v\u00e9rtices.</p> <p>Ejemplos:</p> <p></p> <ul> <li>(a) (4 puntos) Dise\u00f1e el algoritmo con la siguiente signatura. Nota: Puede desarrollar m\u00e9todos auxiliares si lo necesita. <pre><code>int conjuntosConexos(Graph g) {\n    //TODO a rellenar por el alumno\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Metodos comunes: <pre><code>/**\n * Algoritmo para conseguir todos los nodos vecinos a uno dado.\n *\n * @param g Grafo del que se quiere realizar los c\u00e1lculos\n * @param myNode Nodo del cual se quiere obtener todos los vecinos\n * @return Lista de nodos vecinos a myNode\n */\nList&lt;Node&gt; getNeighbors(Graph g, Node myNode) {\n\n    List&lt;Node&gt; neighbors = new ArrayList&lt;&gt;();\n\n    for (Link link : g.getLinks(myNode)) {\n        Node dst = g.getNode(link.getDst());\n        if (dst != null) {\n            neighbors.add(dst);\n        }\n    }\n    return neighbors;\n}\n</code></pre></p> <p>Soluci\u00f3n Iterativa: <pre><code>int conjuntosConexos(Graph g) {\n    int zones = 0;\n\n    // Se usan dos listas, una para los nodos visitados y otra los que vamos a visitar.\n    List&lt;Node&gt; toVisit = new ArrayList&lt;&gt;();\n    List&lt;Node&gt; visited = new ArrayList&lt;&gt;();\n    Node aNode;\n\n    // Para todos los nodos\n    for (Node myNode : g.getNodes()) {\n        if (!visited.contains(myNode)) {\n\n            // Cada vez que se encuentra un nodo no visitado se a\u00f1ade una zona.\n            zones++;\n\n            // Se a\u00f1ade el nodo en la lista de nodos que hay que visitar\n            toVisit.add(myNode);\n\n            // Mientras queden nodos que visitar\n            while (toVisit.size() &gt; 0) {\n\n                // Se toma el primero\n                aNode = toVisit.get(0);\n\n                // Se a\u00f1ade a los visitados y se quita de los no visitados\n                visited.add(aNode);\n                toVisit.remove(aNode);\n\n                // Se marcan para visitar todos los vecinos que no est\u00e9n visitados\n                for (Node neighbour : getNeighbors(g, aNode)) {\n                    if (!visited.contains(neighbour)) {\n                        toVisit.add(neighbour);\n                    }\n                }\n            }\n        }\n    }\n    return zones;\n}\n</code></pre></p> <p>Soluci\u00f3n Recursiva: <pre><code>/**\n * Algoritmo recursivo que a\u00f1ade todos los nodos del conjunto conexo a la lista\n * visitados\n *\n * @param g Grafo del que se quiere calcular el conjunto conexo\n * @param myNode Nodo donde se empieza a calcular el conjunto conexo\n * @param visited Lista de nodos con los nodos visitados\n */\nvoid visitZone(Graph g, Node myNode, List&lt;Node&gt; visited) {\n\n    // Se a\u00f1ade el nodo al conjunto de visitados\n    visited.add(myNode);\n\n    // Se obtienen los nodos vecinos\n    List&lt;Node&gt; neighbors = getNeighbors(g, myNode);\n\n    // Para todos los vecinos\n    for (Node nodeNeighbour : neighbors) {\n\n        // Si no han sido visitados\n        if (!visited.contains(nodeNeighbour))\n\n            // Se llama recursivamente a este algoritmo para ser visitado\n            visitZone(g, nodeNeighbour, visited);\n    }\n}\n\nint conjuntosConexos(Graph g) {\n\n    // Se inicializan las zonas a 0\n    int zones = 0;\n\n    // Lista de nodos visitados (compartida en las llamadas recursivas)\n    List&lt;Node&gt; visited = new ArrayList&lt;&gt;();\n\n    // Para todos los nodos del grafo\n    for (Node myNode : g.getNodes()) {\n\n        // Si no est\u00e1 visitado\n        if (!visited.contains(myNode)) {\n\n            // Se ha descubierto una zona nueva\n            zones++;\n\n            // Se visita esa zona usando el algoritmo recursivo\n            visitZone(g, myNode, visited);\n        }\n    }\n    return zones;\n}\n</code></pre></p> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 tipo de algoritmo ha dise\u00f1ado? Recursivo/iterativo (Razone su respuesta).</li> </ul> Mostrar soluci\u00f3 <p>La soluci\u00f3n depender\u00e1 del algoritmo desarrollado en la pregunta (a).</p>"},{"location":"exams/2019/p1/#problema-2","title":"Problema 2","text":"<p>Se desea realizar una herramienta de an\u00e1lisis de textos literarios. Una de sus funciones consiste en recorrer el texto extrayendo cada palabra y a\u00f1adi\u00e9ndola a un diccionario. El diccionario tiene como claves las palabras que aparecen en el texto, y como valor el n\u00famero de veces que aparece cada una de ellas, que se actualiza cada vez que se lee una palabra. Al final del proceso se debe ordenar el diccionario, de forma que aparezcan en primer lugar las palabras m\u00e1s utilizadas: <pre><code>while (queda texto sin analizar) {\n    String palabra = siguientePalabra();\n    Diccionario.actualizar(palabra); //a\u00f1adir si no estaba e incrementar no. de apariciones\n}\nDiccionario.ordenar(); // ordenar palabras de mayor a menor n\u00famero de apariciones\n</code></pre></p> <p>Se consideran varias opciones para la implementaci\u00f3n del diccionario:</p> <ol> <li>Un array ordenado de elementos (palabra, n\u00famero).</li> <li>Una tabla hash con direccionamiento abierto.</li> <li>Una tabla hash con listas de desbordamiento.</li> <li>Un \u00e1rbol binario de b\u00fasqueda (BST).</li> </ol> <p>Suponiendo que los textos analizados contienen como m\u00e1ximo 100.000 palabras:</p> <ul> <li>(a) (3 puntos) Indique las ventajas e inconvenientes de cada opci\u00f3n e indique razonadamente cu\u00e1l ser\u00eda preferible para esta aplicaci\u00f3n, argumentando en t\u00e9rminos de tiempo de ejecuci\u00f3n y ocupaci\u00f3n de memoria.</li> </ul> Mostrar soluci\u00f3n <ol> <li>Ventajas: Ocupa la memoria imprescindible; Desventajas: Tiempo de inserci\u00f3n \\(O(n)\\) (hay que insertar la palabra en su sitio).</li> <li>Ventajas: Ocupa la memoria imprescindible; Desventajas: Tiempo de inserci\u00f3n \\(O(1)\\) si la tabla tiene un tama\u00f1o suficiente, pero se dispara si el grado de ocupaci\u00f3n es alto.</li> <li>Ventajas: Tiempo de inserci\u00f3n \\(O(1)\\) si las claves se distribuyen uniformemente; Desventajas: Ocupa memoria adicional para las listas de acceso.</li> <li>Desventajas: Ocupa memoria adicional para los enlaces de los nodos; Tiempo de inserci\u00f3n \\(O(log n)\\).</li> </ol> <p>Bas\u00e1ndonos en estas consideraciones, para la primera fase de la aplicaci\u00f3n, en la que s\u00f3lo se hacen inserciones en la tabla, ser\u00eda preferible la opci\u00f3n (3) desde el punto de vista del tiempo de ejecuci\u00f3n, y la opci\u00f3n (1) desde el punto de vista de la ocupaci\u00f3n de memoria.</p> <ul> <li>(b) (2 puntos) Para la opci\u00f3n recomendada, indique razonadamente cu\u00e1l ser\u00eda la mejor forma de implementar la ordenaci\u00f3n final. (2 puntos)</li> </ul> Mostrar soluci\u00f3n <p>Para un hash con listas habr\u00eda que extraer un array con todos los pares <code>&lt;clave, valor&gt;</code> (complejidad \\(O(n)\\) ) y ordenarlo por valores. Se puede usar <code>MergeSort</code> (complejidad \\(O(n log n)\\) ), con lo que la complejidad total ser\u00eda \\(O(n) + O (n log n) = O (n log n)\\).</p> <p>Si el uso de memoria es importante, <code>MergeSort</code> tiene el inconveniente de necesitar memoria adicional \\(O(n)\\). Este caso ser\u00eda preferible usar <code>QuickSort</code> para ordenar el array.</p>"},{"location":"exams/2019/p1_ex01/","title":"P1 ex01","text":"<p>Queremos un algoritmo para calcular el n\u00famero de conjuntos conexos de un grafo no dirigido. Usaremos el modelo de los ejercicios 1 y 2, donde la clase <code>Graph</code> contiene objetos de la clase <code>Node</code> (nodos) y objetos de la clase <code>Link</code> (arcos o enlaces dirigidos ponderados). En lo sucesivo consideraremos que todos los enlaces se han creado con el m\u00e9todo: <pre><code>public void addLink2D (String a, String b, int w) {...}\n</code></pre></p> <p>De esta manera se garantiza que todos los enlaces son bidireccionales.</p> <p>Un conjunto conexo es un conjunto de nodos de un grafo unidos por enlaces directa o indirectamente. Un conjunto de nodos es conexo si existe al menos un camino entre todos los pares de v\u00e9rtices.</p> <p>Ejemplos:</p> <p></p> <ul> <li>(a) (4 puntos) Dise\u00f1e el algoritmo con la siguiente signatura. Nota: Puede desarrollar m\u00e9todos auxiliares si lo necesita. <pre><code>int conjuntosConexos(Graph g) {\n    //TODO a rellenar por el alumno\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>Metodos comunes: <pre><code>/**\n * Algoritmo para conseguir todos los nodos vecinos a uno dado.\n *\n * @param g Grafo del que se quiere realizar los c\u00e1lculos\n * @param myNode Nodo del cual se quiere obtener todos los vecinos\n * @return Lista de nodos vecinos a myNode\n */\nList&lt;Node&gt; getNeighbors(Graph g, Node myNode) {\n\n    List&lt;Node&gt; neighbors = new ArrayList&lt;&gt;();\n\n    for (Link link : g.getLinks(myNode)) {\n        Node dst = g.getNode(link.getDst());\n        if (dst != null) {\n            neighbors.add(dst);\n        }\n    }\n    return neighbors;\n}\n</code></pre></p> <p>Soluci\u00f3n Iterativa: <pre><code>int conjuntosConexos(Graph g) {\n    int zones = 0;\n\n    // Se usan dos listas, una para los nodos visitados y otra los que vamos a visitar.\n    List&lt;Node&gt; toVisit = new ArrayList&lt;&gt;();\n    List&lt;Node&gt; visited = new ArrayList&lt;&gt;();\n    Node aNode;\n\n    // Para todos los nodos\n    for (Node myNode : g.getNodes()) {\n        if (!visited.contains(myNode)) {\n\n            // Cada vez que se encuentra un nodo no visitado se a\u00f1ade una zona.\n            zones++;\n\n            // Se a\u00f1ade el nodo en la lista de nodos que hay que visitar\n            toVisit.add(myNode);\n\n            // Mientras queden nodos que visitar\n            while (toVisit.size() &gt; 0) {\n\n                // Se toma el primero\n                aNode = toVisit.get(0);\n\n                // Se a\u00f1ade a los visitados y se quita de los no visitados\n                visited.add(aNode);\n                toVisit.remove(aNode);\n\n                // Se marcan para visitar todos los vecinos que no est\u00e9n visitados\n                for (Node neighbour : getNeighbors(g, aNode)) {\n                    if (!visited.contains(neighbour)) {\n                        toVisit.add(neighbour);\n                    }\n                }\n            }\n        }\n    }\n    return zones;\n}\n</code></pre></p> <p>Soluci\u00f3n Recursiva: <pre><code>/**\n * Algoritmo recursivo que a\u00f1ade todos los nodos del conjunto conexo a la lista\n * visitados\n *\n * @param g Grafo del que se quiere calcular el conjunto conexo\n * @param myNode Nodo donde se empieza a calcular el conjunto conexo\n * @param visited Lista de nodos con los nodos visitados\n */\nvoid visitZone(Graph g, Node myNode, List&lt;Node&gt; visited) {\n\n    // Se a\u00f1ade el nodo al conjunto de visitados\n    visited.add(myNode);\n\n    // Se obtienen los nodos vecinos\n    List&lt;Node&gt; neighbors = getNeighbors(g, myNode);\n\n    // Para todos los vecinos\n    for (Node nodeNeighbour : neighbors) {\n\n        // Si no han sido visitados\n        if (!visited.contains(nodeNeighbour))\n\n            // Se llama recursivamente a este algoritmo para ser visitado\n            visitZone(g, nodeNeighbour, visited);\n    }\n}\n\nint conjuntosConexos(Graph g) {\n\n    // Se inicializan las zonas a 0\n    int zones = 0;\n\n    // Lista de nodos visitados (compartida en las llamadas recursivas)\n    List&lt;Node&gt; visited = new ArrayList&lt;&gt;();\n\n    // Para todos los nodos del grafo\n    for (Node myNode : g.getNodes()) {\n\n        // Si no est\u00e1 visitado\n        if (!visited.contains(myNode)) {\n\n            // Se ha descubierto una zona nueva\n            zones++;\n\n            // Se visita esa zona usando el algoritmo recursivo\n            visitZone(g, myNode, visited);\n        }\n    }\n    return zones;\n}\n</code></pre></p> <ul> <li>(b) (1 punto) \u00bfQu\u00e9 tipo de algoritmo ha dise\u00f1ado? Recursivo/iterativo (Razone su respuesta).</li> </ul> Mostrar soluci\u00f3 <p>La soluci\u00f3n depender\u00e1 del algoritmo desarrollado en la pregunta (a).</p>","tags":["grafos"]},{"location":"exams/2019/p1_ex02/","title":"P1 ex02","text":"<p>Se desea realizar una herramienta de an\u00e1lisis de textos literarios. Una de sus funciones consiste en recorrer el texto extrayendo cada palabra y a\u00f1adi\u00e9ndola a un diccionario. El diccionario tiene como claves las palabras que aparecen en el texto, y como valor el n\u00famero de veces que aparece cada una de ellas, que se actualiza cada vez que se lee una palabra. Al final del proceso se debe ordenar el diccionario, de forma que aparezcan en primer lugar las palabras m\u00e1s utilizadas: <pre><code>while (queda texto sin analizar) {\n    String palabra = siguientePalabra();\n    Diccionario.actualizar(palabra); //a\u00f1adir si no estaba e incrementar no. de apariciones\n}\nDiccionario.ordenar(); // ordenar palabras de mayor a menor n\u00famero de apariciones\n</code></pre></p> <p>Se consideran varias opciones para la implementaci\u00f3n del diccionario:</p> <ol> <li>Un array ordenado de elementos (palabra, n\u00famero).</li> <li>Una tabla hash con direccionamiento abierto.</li> <li>Una tabla hash con listas de desbordamiento.</li> <li>Un \u00e1rbol binario de b\u00fasqueda (BST).</li> </ol> <p>Suponiendo que los textos analizados contienen como m\u00e1ximo 100.000 palabras:</p> <ul> <li>(a) (3 puntos) Indique las ventajas e inconvenientes de cada opci\u00f3n e indique razonadamente cu\u00e1l ser\u00eda preferible para esta aplicaci\u00f3n, argumentando en t\u00e9rminos de tiempo de ejecuci\u00f3n y ocupaci\u00f3n de memoria.</li> </ul> Mostrar soluci\u00f3n <ol> <li>Ventajas: Ocupa la memoria imprescindible; Desventajas: Tiempo de inserci\u00f3n \\(O(n)\\) (hay que insertar la palabra en su sitio).</li> <li>Ventajas: Ocupa la memoria imprescindible; Desventajas: Tiempo de inserci\u00f3n \\(O(1)\\) si la tabla tiene un tama\u00f1o suficiente, pero se dispara si el grado de ocupaci\u00f3n es alto.</li> <li>Ventajas: Tiempo de inserci\u00f3n \\(O(1)\\) si las claves se distribuyen uniformemente; Desventajas: Ocupa memoria adicional para las listas de acceso.</li> <li>Desventajas: Ocupa memoria adicional para los enlaces de los nodos; Tiempo de inserci\u00f3n \\(O(log n)\\).</li> </ol> <p>Bas\u00e1ndonos en estas consideraciones, para la primera fase de la aplicaci\u00f3n, en la que s\u00f3lo se hacen inserciones en la tabla, ser\u00eda preferible la opci\u00f3n (3) desde el punto de vista del tiempo de ejecuci\u00f3n, y la opci\u00f3n (1) desde el punto de vista de la ocupaci\u00f3n de memoria.</p> <ul> <li>(b) (2 puntos) Para la opci\u00f3n recomendada, indique razonadamente cu\u00e1l ser\u00eda la mejor forma de implementar la ordenaci\u00f3n final. (2 puntos)</li> </ul> Mostrar soluci\u00f3n <p>Para un hash con listas habr\u00eda que extraer un array con todos los pares <code>&lt;clave, valor&gt;</code> (complejidad \\(O(n)\\) ) y ordenarlo por valores. Se puede usar <code>MergeSort</code> (complejidad \\(O(n log n)\\) ), con lo que la complejidad total ser\u00eda \\(O(n) + O (n log n) = O (n log n)\\).</p> <p>Si el uso de memoria es importante, <code>MergeSort</code> tiene el inconveniente de necesitar memoria adicional \\(O(n)\\). Este caso ser\u00eda preferible usar <code>QuickSort</code> para ordenar el array.</p>","tags":["complejidad"]},{"location":"exams/2019/p1r/","title":"Examen 2019 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2019/p1r/#problema-1","title":"Problema 1","text":"<p>Se construye un \u00e1rbol binario de b\u00fasqueda (BST) cuyos nodos contienen valores enteros.</p> <ul> <li>(a) (1,5 puntos) Dibuje la estructura del \u00e1rbol resultante de insertar los valores 17, 11, 4, 21, 15, 18, en este orden.</li> </ul> Mostrar soluci\u00f3n <p></p> <ul> <li>(b) (1,5 puntos) Escriba el resultado que se obtiene al recorrer el \u00e1rbol anterior en postorden.</li> </ul> Mostrar soluci\u00f3n <p>4 15 11 18 21 17</p> <ul> <li>(c) (2 puntos) Se a\u00f1ade al \u00e1rbol un n\u00famero <code>N</code> de valores enteros, generados de forma aleatoria. Para <code>N</code> suficientemente grande, el tiempo necesario para ello depende de la complejidad de la operaci\u00f3n de insertar valores en el \u00e1rbol. Indique razonadamente cu\u00e1l es esta complejidad, justificando el resultado.</li> </ul> Mostrar soluci\u00f3n <p>Para insertar un valor hay que recorrer el \u00e1rbol desde la ra\u00edz hasta encontrar el lugar apropiado donde meterlo. Si los valores se generan aleatoriamente podemos suponer que para \\(N\\) grande el \u00e1rbol est\u00e1 equilibrado, y por tanto, el n\u00famero de niveles que hay que recorrer es \\(k\\), con \\(N=2k\\) y \\(k=log2 N\\). Por tanto, la complejidad del algoritmo es \\(O(log N)\\).</p>"},{"location":"exams/2019/p1r/#problema-2","title":"Problema 2","text":"<p>Se debe implementar los tres m\u00e9todos principales de una clase llamada <code>ListaEnlazadaOrdenada</code>: <code>a\u00f1adirValor</code>, <code>eliminarValor</code>, y <code>buscarElementoAnterior</code>.</p> <p>El objetivo de dicha clase consiste en mantener un conjunto de objetos de la clase <code>Elemento</code> ordenados de menor a mayor. La clase <code>ListaEnlazadaOrdenada</code> solo tendr\u00e1 un variable de clase que ser\u00e1 el primer objeto <code>Elemento</code>.</p> <p>La lista debe mantenerse ordenada en todo momento.</p> <p>La clase <code>Elemento</code> est\u00e1 implementada y podemos utilizarla seg\u00fan la descripci\u00f3n de m\u00e9todos que se muestran a continuaci\u00f3n: <pre><code>Elemento (int valor)\nElemento getSiguiente()\nvoid setSiguiente (Elemento siguiente)\nint getValor()\n</code></pre></p> <p>La clase <code>Elemento</code> almacena un entero que pasamos en el m\u00e9todo constructor. Adem\u00e1s, guarda un enlace al siguiente objeto de la clase <code>Elemento</code> que le sucede. El constructor inicializa el enlace al siguiente objeto <code>Elemento</code> a <code>null</code>.</p> <p>La clase <code>ListaEnlazadaOrdenada</code> deber\u00e1 usar los m\u00e9todos <code>setSiguiente</code> y <code>getSiguiente</code> para mantener el orden entre los objetos de la clase <code>Elemento</code>. Si no hubiera siguiente elemento entonces el valor para el siguiente ser\u00e1 <code>null</code>.</p> <p>Descripci\u00f3n de los m\u00e9todos que deber\u00e1 implementar de la clase <code>ListaEnlazadaOrdenada</code>:</p> <pre><code>private Elemento buscarElementoAnterior (int valor) {...}\n</code></pre> <p>Se recomienda empezar por este m\u00e9todo ya que va a resultar muy \u00fatil para la realizaci\u00f3n de los m\u00e9todos <code>a\u00f1adirValor</code> y <code>eliminarValor</code>.</p> <p>Este m\u00e9todo busca y devuelve un objeto Elemento en la <code>ListaEnlazadaOrdenada</code>. La lista est\u00e1 ordenada de menor a mayor, por lo tanto, el Elemento que devuelve debe ser el que tenga el valor m\u00e1s peque\u00f1o al que se pasa por par\u00e1metro en el par\u00e1metro valor.</p> <pre><code>public boolean a\u00f1adirValor (int valor) {...}\n</code></pre> <p>Este m\u00e9todo debe a\u00f1adir un objeto <code>Elemento</code> nuevo que contenga el entero valor que se pasa por par\u00e1metro. Se debe mantener el orden. Se pueden a\u00f1adir varios elementos con el mismo valor.</p> <p>Devuelve <code>true</code> cuando se ha podido a\u00f1adir el objeto <code>Elemento</code> con el valor que se pasa por par\u00e1metro.</p> <p>Devuelve <code>false</code> cuando NO se ha podido a\u00f1adir el objeto <code>Elemento</code> con el valor que se pasa por par\u00e1metro.</p> <pre><code>public boolean eliminarValor (int valor) {...}\n</code></pre> <p>Este m\u00e9todo debe eliminar un objeto <code>Elemento</code> que contenga el entero valor que se pasa por par\u00e1metro al m\u00e9todo. Despu\u00e9s de eliminar el <code>Elemento</code> debe garantizar que se mantenga el orden de la lista.</p> <p>Devuelve <code>true</code> cuando se ha podido eliminar el objeto <code>Elemento</code> con el valor que se pasa por par\u00e1metro.</p> <p>Devuelve <code>false</code> cuando NO se ha podido eliminar el objeto <code>Elemento</code> con el valor que se pasa por par\u00e1metro.</p> <p>Notas: La soluci\u00f3n debe presentarse en Java y comentando lo que hace el c\u00f3digo. Alternativamente se puede presentar la soluci\u00f3n en pseudoc\u00f3digo. No se pueden utilizar estructuras de datos adicionales como <code>List</code>, <code>ArrayList</code>, <code>HashSet</code>, <code>Map</code>, <code>Diccionario</code>, etc. Solo las clases <code>Elemento</code> y <code>ListaEnlazadaOrdenada</code>. No se trata de un array, por lo tanto, no se pueden hacer accesos del tipo <code>miLista[posicion]</code> o <code>miLista[14]</code>.</p> <p>Ejemplos:</p> <p></p> <p></p> <ul> <li>(a) (1,5 puntos) Implementar el m\u00e9todo <code>public boolean a\u00f1adirValor (int valor)</code> de la clase <code>ListaEnlazadaOrdenada</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public boolean addValor(int valor) {\n\n    // Creamos el elemento que queremos insertar\n    Elemento elementoNuevo = new Elemento(valor);\n\n    // Si la lista est\u00e1 vac\u00eda\n    if (this.primerElemento == null) {\n        this.primerElemento = elementoNuevo;\n        return true;\n    }\n\n    // Buscamos el elemento anterior al punto de inserci\u00f3n\n    Elemento anterior = searchAnterior(valor);\n\n    // Si no hay anterior, se inserta en la cabeza de la lista\n    if (anterior == null) {\n        elementoNuevo.setSiguiente(this.primerElemento);\n        this.primerElemento = elementoNuevo;\n        return true;\n    }\n\n    // Si la inserci\u00f3n se hace en medio de la lista\n    else if (anterior.getSiguiente() != null) {\n        Elemento elementoCentral = anterior.getSiguiente();\n        elementoNuevo.setSiguiente(elementoCentral);\n        anterior.setSiguiente(elementoNuevo);\n        return true;\n    }\n\n    // Si la inserci\u00f3n se hace al final de la lista\n    else {\n        anterior.setSiguiente(elementoNuevo);\n        return true;\n    }\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Implementar el m\u00e9todo <code>public boolean eliminarValor (int valor)</code> de la clase <code>ListaEnlazadaOrdenada</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para eliminar el valor que nos mandan como par\u00e1metro\n// Devuelve true si lo ha eliminado\n// Devuelve false si no lo ha eliminado\npublic boolean removeValor(int valor) {\n\n    // Si el primer elemento es null, no podemos eliminar nada\n    if (this.primerElemento == null)\n        return false;\n\n    // Buscamos el elemento anterior al que queremos eliminar\n    Elemento anterior = searchAnterior(valor);\n\n    // Si no hay anterior, el elemento a eliminar podr\u00eda ser el primero\n    if (anterior == null) {\n\n        // Se trata del primer elemento\n        if (this.primerElemento.getValor() == valor) {\n            this.primerElemento = this.primerElemento.getSiguiente();\n            return true;\n        }\n        // No es el primer elemento\n        else {\n            return false;\n        }\n    }\n\n    // Si la eliminaci\u00f3n se hace en medio de la lista\n    else if (anterior.getSiguiente() != null) {\n\n        // Si el siguiente es el que queremos eliminar\n        if (anterior.getSiguiente().getValor() == valor) {\n            Elemento elementoCentralAEliminar = anterior.getSiguiente();\n            Elemento elementoSiguiente =\n                    elementoCentralAEliminar.getSiguiente();\n            anterior.setSiguiente(elementoSiguiente);\n            return true;\n        }\n        // El siguiente no es el que queremos eliminar\n        else {\n            return false;\n        }\n    }\n\n    // Si se intenta eliminar al final sin coincidencia\n    else {\n        return false;\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Implementar el m\u00e9todo <code>private Elemento buscarElementoAnterior (int valor)</code> de la clase <code>ListaEnlazadaOrdenada</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para buscar el elemento anterior. Nos va a servir para poder\n// implementar el resto de m\u00e9todos\n// Devuelve null si no hay primerElemento, o si donde hay que insertar es al inicio.\nprivate Elemento searchAnterior(int valor) {\n\n    // Si la lista est\u00e1 vac\u00eda no hay anterior, se devuelve null\n    if (this.primerElemento == null)\n        return null;\n\n    // Inicializamos dos variables para la b\u00fasqueda de la posici\u00f3n:\n    // - elementoIterador: recorre la lista\n    // - anterior: ser\u00e1 el elemento que devolveremos\n    Elemento elementoIterador = primerElemento;\n    Elemento anterior = null;\n\n    // Usamos un bucle while(true) porque siempre habr\u00e1 al menos una iteraci\u00f3n\n    while (true) {\n\n        // Si el valor a insertar es mayor que el valor del iterador\n        if (valor &gt; elementoIterador.getValor()) {\n\n            // Si no es el \u00faltimo elemento, avanzamos\n            if (elementoIterador.getSiguiente() != null) {\n                anterior = elementoIterador;\n                elementoIterador = elementoIterador.getSiguiente();\n\n            // Si el siguiente es null, se inserta al final\n            } else {\n                return elementoIterador;\n            }\n\n        // Si el valor a insertar es menor o igual, devolvemos el anterior\n        } else {\n            return anterior;\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2019/p1r_ex01/","title":"P1r ex01","text":"<p>Se construye un \u00e1rbol binario de b\u00fasqueda (BST) cuyos nodos contienen valores enteros.</p> <ul> <li>(a) (1,5 puntos) Dibuje la estructura del \u00e1rbol resultante de insertar los valores 17, 11, 4, 21, 15, 18, en este orden.</li> </ul> Mostrar soluci\u00f3n <p></p> <ul> <li>(b) (1,5 puntos) Escriba el resultado que se obtiene al recorrer el \u00e1rbol anterior en postorden.</li> </ul> Mostrar soluci\u00f3n <p>4 15 11 18 21 17</p> <ul> <li>(c) (2 puntos) Se a\u00f1ade al \u00e1rbol un n\u00famero <code>N</code> de valores enteros, generados de forma aleatoria. Para <code>N</code> suficientemente grande, el tiempo necesario para ello depende de la complejidad de la operaci\u00f3n de insertar valores en el \u00e1rbol. Indique razonadamente cu\u00e1l es esta complejidad, justificando el resultado.</li> </ul> Mostrar soluci\u00f3n <p>Para insertar un valor hay que recorrer el \u00e1rbol desde la ra\u00edz hasta encontrar el lugar apropiado donde meterlo. Si los valores se generan aleatoriamente podemos suponer que para \\(N\\) grande el \u00e1rbol est\u00e1 equilibrado, y por tanto, el n\u00famero de niveles que hay que recorrer es \\(k\\), con \\(N=2k\\) y \\(k=log2 N\\). Por tanto, la complejidad del algoritmo es \\(O(log N)\\).</p>","tags":["complejidad"]},{"location":"exams/2019/p1r_ex02/","title":"P1r ex02","text":"<p>Se debe implementar los tres m\u00e9todos principales de una clase llamada <code>ListaEnlazadaOrdenada</code>: <code>a\u00f1adirValor</code>, <code>eliminarValor</code>, y <code>buscarElementoAnterior</code>.</p> <p>El objetivo de dicha clase consiste en mantener un conjunto de objetos de la clase <code>Elemento</code> ordenados de menor a mayor. La clase <code>ListaEnlazadaOrdenada</code> solo tendr\u00e1 un variable de clase que ser\u00e1 el primer objeto <code>Elemento</code>.</p> <p>La lista debe mantenerse ordenada en todo momento.</p> <p>La clase <code>Elemento</code> est\u00e1 implementada y podemos utilizarla seg\u00fan la descripci\u00f3n de m\u00e9todos que se muestran a continuaci\u00f3n: <pre><code>Elemento (int valor)\nElemento getSiguiente()\nvoid setSiguiente (Elemento siguiente)\nint getValor()\n</code></pre></p> <p>La clase <code>Elemento</code> almacena un entero que pasamos en el m\u00e9todo constructor. Adem\u00e1s, guarda un enlace al siguiente objeto de la clase <code>Elemento</code> que le sucede. El constructor inicializa el enlace al siguiente objeto <code>Elemento</code> a <code>null</code>.</p> <p>La clase <code>ListaEnlazadaOrdenada</code> deber\u00e1 usar los m\u00e9todos <code>setSiguiente</code> y <code>getSiguiente</code> para mantener el orden entre los objetos de la clase <code>Elemento</code>. Si no hubiera siguiente elemento entonces el valor para el siguiente ser\u00e1 <code>null</code>.</p> <p>Descripci\u00f3n de los m\u00e9todos que deber\u00e1 implementar de la clase <code>ListaEnlazadaOrdenada</code>:</p> <pre><code>private Elemento buscarElementoAnterior (int valor) {...}\n</code></pre> <p>Se recomienda empezar por este m\u00e9todo ya que va a resultar muy \u00fatil para la realizaci\u00f3n de los m\u00e9todos <code>a\u00f1adirValor</code> y <code>eliminarValor</code>.</p> <p>Este m\u00e9todo busca y devuelve un objeto Elemento en la <code>ListaEnlazadaOrdenada</code>. La lista est\u00e1 ordenada de menor a mayor, por lo tanto, el Elemento que devuelve debe ser el que tenga el valor m\u00e1s peque\u00f1o al que se pasa por par\u00e1metro en el par\u00e1metro valor.</p> <pre><code>public boolean a\u00f1adirValor (int valor) {...}\n</code></pre> <p>Este m\u00e9todo debe a\u00f1adir un objeto <code>Elemento</code> nuevo que contenga el entero valor que se pasa por par\u00e1metro. Se debe mantener el orden. Se pueden a\u00f1adir varios elementos con el mismo valor.</p> <p>Devuelve <code>true</code> cuando se ha podido a\u00f1adir el objeto <code>Elemento</code> con el valor que se pasa por par\u00e1metro.</p> <p>Devuelve <code>false</code> cuando NO se ha podido a\u00f1adir el objeto <code>Elemento</code> con el valor que se pasa por par\u00e1metro.</p> <pre><code>public boolean eliminarValor (int valor) {...}\n</code></pre> <p>Este m\u00e9todo debe eliminar un objeto <code>Elemento</code> que contenga el entero valor que se pasa por par\u00e1metro al m\u00e9todo. Despu\u00e9s de eliminar el <code>Elemento</code> debe garantizar que se mantenga el orden de la lista.</p> <p>Devuelve <code>true</code> cuando se ha podido eliminar el objeto <code>Elemento</code> con el valor que se pasa por par\u00e1metro.</p> <p>Devuelve <code>false</code> cuando NO se ha podido eliminar el objeto <code>Elemento</code> con el valor que se pasa por par\u00e1metro.</p> <p>Notas: La soluci\u00f3n debe presentarse en Java y comentando lo que hace el c\u00f3digo. Alternativamente se puede presentar la soluci\u00f3n en pseudoc\u00f3digo. No se pueden utilizar estructuras de datos adicionales como <code>List</code>, <code>ArrayList</code>, <code>HashSet</code>, <code>Map</code>, <code>Diccionario</code>, etc. Solo las clases <code>Elemento</code> y <code>ListaEnlazadaOrdenada</code>. No se trata de un array, por lo tanto, no se pueden hacer accesos del tipo <code>miLista[posicion]</code> o <code>miLista[14]</code>.</p> <p>Ejemplos:</p> <p></p> <p></p> <ul> <li>(a) (1,5 puntos) Implementar el m\u00e9todo <code>public boolean a\u00f1adirValor (int valor)</code> de la clase <code>ListaEnlazadaOrdenada</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public boolean addValor(int valor) {\n\n    // Creamos el elemento que queremos insertar\n    Elemento elementoNuevo = new Elemento(valor);\n\n    // Si la lista est\u00e1 vac\u00eda\n    if (this.primerElemento == null) {\n        this.primerElemento = elementoNuevo;\n        return true;\n    }\n\n    // Buscamos el elemento anterior al punto de inserci\u00f3n\n    Elemento anterior = searchAnterior(valor);\n\n    // Si no hay anterior, se inserta en la cabeza de la lista\n    if (anterior == null) {\n        elementoNuevo.setSiguiente(this.primerElemento);\n        this.primerElemento = elementoNuevo;\n        return true;\n    }\n\n    // Si la inserci\u00f3n se hace en medio de la lista\n    else if (anterior.getSiguiente() != null) {\n        Elemento elementoCentral = anterior.getSiguiente();\n        elementoNuevo.setSiguiente(elementoCentral);\n        anterior.setSiguiente(elementoNuevo);\n        return true;\n    }\n\n    // Si la inserci\u00f3n se hace al final de la lista\n    else {\n        anterior.setSiguiente(elementoNuevo);\n        return true;\n    }\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Implementar el m\u00e9todo <code>public boolean eliminarValor (int valor)</code> de la clase <code>ListaEnlazadaOrdenada</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para eliminar el valor que nos mandan como par\u00e1metro\n// Devuelve true si lo ha eliminado\n// Devuelve false si no lo ha eliminado\npublic boolean removeValor(int valor) {\n\n    // Si el primer elemento es null, no podemos eliminar nada\n    if (this.primerElemento == null)\n        return false;\n\n    // Buscamos el elemento anterior al que queremos eliminar\n    Elemento anterior = searchAnterior(valor);\n\n    // Si no hay anterior, el elemento a eliminar podr\u00eda ser el primero\n    if (anterior == null) {\n\n        // Se trata del primer elemento\n        if (this.primerElemento.getValor() == valor) {\n            this.primerElemento = this.primerElemento.getSiguiente();\n            return true;\n        }\n        // No es el primer elemento\n        else {\n            return false;\n        }\n    }\n\n    // Si la eliminaci\u00f3n se hace en medio de la lista\n    else if (anterior.getSiguiente() != null) {\n\n        // Si el siguiente es el que queremos eliminar\n        if (anterior.getSiguiente().getValor() == valor) {\n            Elemento elementoCentralAEliminar = anterior.getSiguiente();\n            Elemento elementoSiguiente =\n                    elementoCentralAEliminar.getSiguiente();\n            anterior.setSiguiente(elementoSiguiente);\n            return true;\n        }\n        // El siguiente no es el que queremos eliminar\n        else {\n            return false;\n        }\n    }\n\n    // Si se intenta eliminar al final sin coincidencia\n    else {\n        return false;\n    }\n}\n</code></pre> <ul> <li>(c) (2 puntos) Implementar el m\u00e9todo <code>private Elemento buscarElementoAnterior (int valor)</code> de la clase <code>ListaEnlazadaOrdenada</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para buscar el elemento anterior. Nos va a servir para poder\n// implementar el resto de m\u00e9todos\n// Devuelve null si no hay primerElemento, o si donde hay que insertar es al inicio.\nprivate Elemento searchAnterior(int valor) {\n\n    // Si la lista est\u00e1 vac\u00eda no hay anterior, se devuelve null\n    if (this.primerElemento == null)\n        return null;\n\n    // Inicializamos dos variables para la b\u00fasqueda de la posici\u00f3n:\n    // - elementoIterador: recorre la lista\n    // - anterior: ser\u00e1 el elemento que devolveremos\n    Elemento elementoIterador = primerElemento;\n    Elemento anterior = null;\n\n    // Usamos un bucle while(true) porque siempre habr\u00e1 al menos una iteraci\u00f3n\n    while (true) {\n\n        // Si el valor a insertar es mayor que el valor del iterador\n        if (valor &gt; elementoIterador.getValor()) {\n\n            // Si no es el \u00faltimo elemento, avanzamos\n            if (elementoIterador.getSiguiente() != null) {\n                anterior = elementoIterador;\n                elementoIterador = elementoIterador.getSiguiente();\n\n            // Si el siguiente es null, se inserta al final\n            } else {\n                return elementoIterador;\n            }\n\n        // Si el valor a insertar es menor o igual, devolvemos el anterior\n        } else {\n            return anterior;\n        }\n    }\n}\n</code></pre>","tags":["???"]},{"location":"exams/2019/p2/","title":"Examen 2019 \u2014 Parcial 2","text":""},{"location":"exams/2019/p2/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un sistema de gesti\u00f3n de eventos. Este sistema est\u00e1 compuesto por un conjunto de productores y consumidores. Los productores ponen eventos con una prioridad asociada en el sistema. Los consumidores recogen eventos del sistema para procesarlos.</p> <p>Los eventos se representan con la clase <code>Event</code> definida como sigue (no hay que desarrollarla): <pre><code>public class Event {\n    private EventInformation info;\n    private EventPriority priority;\n    // getters &amp; setters\n}\n</code></pre></p> <p><code>EventInformation</code> indica la informaci\u00f3n asociada al evento. No es necesario conocer los detalles de esta clase, ni desarrollarla. </p> <p><code>EventPriority</code> indica la prioridad del evento, definida como sigue: <pre><code>public enum EventPriority {High, Low}\n</code></pre></p> <p>Dado el siguiente esquema: <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos de cada nivel de prioridad que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = ...;\n    ...\n    /** A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes\n    * con la prioridad correspondiente es igual al m\u00e1ximo, la hebra que\n    * llama se bloquea hasta que haya hueco\n    */\n    ... void putEvent (Event anEvent) {...}\n    /** Recuperar un evento para su procesamiento. Devuelve un evento de prioridad High\n    * si lo hay, si no un evento de prioridad Low, y si tampoco hay ninguno se bloquea\n    * la hebra que llama hasta que haya alguno.\n    */\n    ... Event getEvent() {...}\n    /** N\u00famero total de eventos pendientes de procesamiento. */\n    ... int getPendingEvents() {...}\n}\n</code></pre></p> <ul> <li>(a) (4,5 puntos) Desarrolle el monitor <code>EventManager</code>. Se puede utilizar el siguiente esquema: <pre><code>public class Buffer {\n\n    private Event[] b;\n    private int in, out, count;\n\n    public Buffer (int size) {\n        b = new Event[size]; I\n        in = 0; out = 0; count = 0;\n    }\n\n    public void put (Event e) {\n        b[in] = e;\n        in = (in + 1) % b.length; ++count;\n    }\n\n    public Event get() {\n        Event e = boOut];\n        out = (out + 1) % b.length; --count;\n        return e;\n    }\n\n    public int getCount() { return count;}\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorEventos {\n\n    private int MaxPendingEvents;\n    private Buffer highPriority;\n    private Buffer lowPriority;\n\n    public GestorEventos(int MaxPendingEvents) {\n        this.MaxPendingEvents = MaxPendingEvents;\n        highPriority = new Buffer(MaxPendingEvents);\n        lowPriority = new Buffer(MaxPendingEvents);\n    }\n\n    public synchronized void PutEvent(Event anEvent) \n            throws InterruptedException {\n\n        if (anEvent.getPriority() == EventPriority.High) {\n\n            while (highPriority.GetCount() == MaxPendingEvents) {\n                wait();\n            }\n            highPriority.Put(anEvent);\n\n        } else {\n\n            while (lowPriority.GetCount() == MaxPendingEvents) {\n                wait();\n            }\n            lowPriority.Put(anEvent);\n        }\n\n        notifyAll();\n    }\n\n    public synchronized Event GetEvent() \n            throws InterruptedException {\n\n        while (highPriority.GetCount() == 0 &amp;&amp;\n               lowPriority.GetCount() == 0) {\n            wait();\n        }\n\n        if (highPriority.GetCount() &gt; 0) {\n            notifyAll();\n            return highPriority.Get();\n        }\n\n        notifyAll();\n        return lowPriority.Get();\n    }\n\n    public synchronized int GetPendingEvents() {\n        return lowPriority.GetCount() + highPriority.GetCount();\n    }\n}\n</code></pre> <p>Suponiendo que el tiempo de proceso de los consumidores es mayor que el de los productores, puede ocurrir que las colas de eventos pendientes se mantengan llenas durante un tiempo prolongado y, por tanto, se bloqueen los productores.</p> <ul> <li>(b) (2,5 puntos) Para corregir este problema, se pide desarrollar una clase <code>ThreadManager</code> que cree hebras consumidoras cuando el n\u00famero de eventos pendientes sea mayor al 90% del n\u00famero m\u00e1ximo de eventos. Esta clase responde al siguiente esquema: <pre><code>public class ThreadManager {\n    private final int DELAY = ...; //intervalo de comprobaci\u00f3n (ms)\n    ...\n    public void main(...) {\n        while(true) {\n            Thread.sleep(DELAY);\n            // comprobar si el n\u00famero de eventos pendientes es mayor que el 90% del m\u00e1ximo\n            // en ese caso, crear una nueva hebra de clase Consumer\n        }\n    }\n}\n</code></pre></li> </ul> <p>La clase <code>Consumer</code> responde al esquema siguiente y no es necesario desarrollarla: <pre><code>public class Consumer\n    extends Thread {\n        public Consumer(...) {...}\n        public void run() {...}\n}\n</code></pre></p> Mostrar soluci\u00f3n <pre><code>public class ThreadManager {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        int DELAY = 10000; // intervalo de comprobaci\u00f3n (ms)\n        Consumer c;\n\n        // Obtener un gestor. No se hab\u00eda que hacer\n        GestorEventos gestor = ...;\n\n        while (true) {\n\n            Thread.sleep(DELAY);\n\n            if (gestor.GetPendingEvents() &gt; gestor.MAX_PENDING_EVENTS * 0.9) {\n                Consumer consumer = new Consumer(gestor);\n                consumer.start();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2019/p2/#problema-2","title":"Problema 2","text":"<p>Se desea programar una aplicaci\u00f3n llamada <code>ParApp</code>, que recibiendo una entrada de texto del usuario indique si su tama\u00f1o es par o impar. Para ello, recibimos una interfaz gr\u00e1fica ya dise\u00f1ada que incluye:</p> <ul> <li>Un <code>EditText</code> con <code>id</code> \u201cetEntrada';</li> <li>Un <code>TextView</code> con <code>id</code> \u201ctvResultado';</li> <li>Un bot\u00f3n con <code>id</code> 'bComprobar'.</li> </ul> <p>Cuando el usuario pulsa el bot\u00f3n se ha de comprobar el tama\u00f1o de la cadena de texto introducida en el campo de entrada de texto. Pueden darse 3 situaciones:</p> <ul> <li>Si el tama\u00f1o de texto es <code>0</code>, se ha de lanzar un aviso al usuario para que introduzca una cadena de texto;</li> <li>Si el tama\u00f1o es par, el campo de texto de salida se actualiza con el siguiente mensaje: \u201cEl texto introducido tiene un tama\u00f1o par\u201d seguido del tama\u00f1o de la cadena entre par\u00e9ntesis. Ej: <code>(6)</code>;</li> <li> <p>Si el tama\u00f1o es impar, el campo de texto de salida se actualiza con el siguiente mensaje: \u201cEl texto introducido tiene un tama\u00f1o impar\u201d seguido del tama\u00f1o de la cadena entre par\u00e9ntesis. Ej: <code>(5)</code>.</p> </li> <li> <p>(a) (0,5 puntos) \u00bfMediante qu\u00e9 atributo asociar\u00eda la ejecuci\u00f3n de un m\u00e9todo Java cuando el bot\u00f3n es pulsado por el usuario?</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>onClick\n</code></pre> <ul> <li>(b) (2,5 puntos) Programe un m\u00e9todo <code>calculoParidad</code> que implemente la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void CompruebaParidad(View V) {\n\n    EditText et = findViewById(R.id.etEntrada);\n    TextView tv = findViewById(R.id.tvResultado);\n\n    int len = et.getText().toString().length();\n\n    if (len == 0) {\n        Toast.makeText(this, \"Introduzca texto\", Toast.LENGTH_SHORT).show();\n        tv.setText(\"\");\n    } \n    else if (len % 2 == 0) {\n        tv.setText(\"Es par (\" + len + \")\");\n    } \n    else {\n        tv.setText(\"Es impar (\" + len + \")\");\n    }\n}\n</code></pre>"},{"location":"exams/2019/p2_ex01/","title":"P2 ex01","text":"<p>Se quiere desarrollar un sistema de gesti\u00f3n de eventos. Este sistema est\u00e1 compuesto por un conjunto de productores y consumidores. Los productores ponen eventos con una prioridad asociada en el sistema. Los consumidores recogen eventos del sistema para procesarlos.</p> <p>Los eventos se representan con la clase <code>Event</code> definida como sigue (no hay que desarrollarla): <pre><code>public class Event {\n    private EventInformation info;\n    private EventPriority priority;\n    // getters &amp; setters\n}\n</code></pre></p> <p><code>EventInformation</code> indica la informaci\u00f3n asociada al evento. No es necesario conocer los detalles de esta clase, ni desarrollarla. </p> <p><code>EventPriority</code> indica la prioridad del evento, definida como sigue: <pre><code>public enum EventPriority {High, Low}\n</code></pre></p> <p>Dado el siguiente esquema: <pre><code>public class EventManager {\n    // N\u00famero m\u00e1ximo de eventos de cada nivel de prioridad que se pueden almacenar\n    public final int MAX_PENDING_EVENTS = ...;\n    ...\n    /** A\u00f1adir un evento para procesar. Si el n\u00famero de eventos pendientes\n    * con la prioridad correspondiente es igual al m\u00e1ximo, la hebra que\n    * llama se bloquea hasta que haya hueco\n    */\n    ... void putEvent (Event anEvent) {...}\n    /** Recuperar un evento para su procesamiento. Devuelve un evento de prioridad High\n    * si lo hay, si no un evento de prioridad Low, y si tampoco hay ninguno se bloquea\n    * la hebra que llama hasta que haya alguno.\n    */\n    ... Event getEvent() {...}\n    /** N\u00famero total de eventos pendientes de procesamiento. */\n    ... int getPendingEvents() {...}\n}\n</code></pre></p> <ul> <li>(a) (4,5 puntos) Desarrolle el monitor <code>EventManager</code>. Se puede utilizar el siguiente esquema: <pre><code>public class Buffer {\n\n    private Event[] b;\n    private int in, out, count;\n\n    public Buffer (int size) {\n        b = new Event[size]; I\n        in = 0; out = 0; count = 0;\n    }\n\n    public void put (Event e) {\n        b[in] = e;\n        in = (in + 1) % b.length; ++count;\n    }\n\n    public Event get() {\n        Event e = boOut];\n        out = (out + 1) % b.length; --count;\n        return e;\n    }\n\n    public int getCount() { return count;}\n}\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorEventos {\n\n    private int MaxPendingEvents;\n    private Buffer highPriority;\n    private Buffer lowPriority;\n\n    public GestorEventos(int MaxPendingEvents) {\n        this.MaxPendingEvents = MaxPendingEvents;\n        highPriority = new Buffer(MaxPendingEvents);\n        lowPriority = new Buffer(MaxPendingEvents);\n    }\n\n    public synchronized void PutEvent(Event anEvent) \n            throws InterruptedException {\n\n        if (anEvent.getPriority() == EventPriority.High) {\n\n            while (highPriority.GetCount() == MaxPendingEvents) {\n                wait();\n            }\n            highPriority.Put(anEvent);\n\n        } else {\n\n            while (lowPriority.GetCount() == MaxPendingEvents) {\n                wait();\n            }\n            lowPriority.Put(anEvent);\n        }\n\n        notifyAll();\n    }\n\n    public synchronized Event GetEvent() \n            throws InterruptedException {\n\n        while (highPriority.GetCount() == 0 &amp;&amp;\n               lowPriority.GetCount() == 0) {\n            wait();\n        }\n\n        if (highPriority.GetCount() &gt; 0) {\n            notifyAll();\n            return highPriority.Get();\n        }\n\n        notifyAll();\n        return lowPriority.Get();\n    }\n\n    public synchronized int GetPendingEvents() {\n        return lowPriority.GetCount() + highPriority.GetCount();\n    }\n}\n</code></pre> <p>Suponiendo que el tiempo de proceso de los consumidores es mayor que el de los productores, puede ocurrir que las colas de eventos pendientes se mantengan llenas durante un tiempo prolongado y, por tanto, se bloqueen los productores.</p> <ul> <li>(b) (2,5 puntos) Para corregir este problema, se pide desarrollar una clase <code>ThreadManager</code> que cree hebras consumidoras cuando el n\u00famero de eventos pendientes sea mayor al 90% del n\u00famero m\u00e1ximo de eventos. Esta clase responde al siguiente esquema: <pre><code>public class ThreadManager {\n    private final int DELAY = ...; //intervalo de comprobaci\u00f3n (ms)\n    ...\n    public void main(...) {\n        while(true) {\n            Thread.sleep(DELAY);\n            // comprobar si el n\u00famero de eventos pendientes es mayor que el 90% del m\u00e1ximo\n            // en ese caso, crear una nueva hebra de clase Consumer\n        }\n    }\n}\n</code></pre></li> </ul> <p>La clase <code>Consumer</code> responde al esquema siguiente y no es necesario desarrollarla: <pre><code>public class Consumer\n    extends Thread {\n        public Consumer(...) {...}\n        public void run() {...}\n}\n</code></pre></p> Mostrar soluci\u00f3n <pre><code>public class ThreadManager {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        int DELAY = 10000; // intervalo de comprobaci\u00f3n (ms)\n        Consumer c;\n\n        // Obtener un gestor. No se hab\u00eda que hacer\n        GestorEventos gestor = ...;\n\n        while (true) {\n\n            Thread.sleep(DELAY);\n\n            if (gestor.GetPendingEvents() &gt; gestor.MAX_PENDING_EVENTS * 0.9) {\n                Consumer consumer = new Consumer(gestor);\n                consumer.start();\n            }\n        }\n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2019/p2_ex02/","title":"P2 ex02","text":"<p>Se desea programar una aplicaci\u00f3n llamada <code>ParApp</code>, que recibiendo una entrada de texto del usuario indique si su tama\u00f1o es par o impar. Para ello, recibimos una interfaz gr\u00e1fica ya dise\u00f1ada que incluye:</p> <ul> <li>Un <code>EditText</code> con <code>id</code> \u201cetEntrada';</li> <li>Un <code>TextView</code> con <code>id</code> \u201ctvResultado';</li> <li>Un bot\u00f3n con <code>id</code> 'bComprobar'.</li> </ul> <p>Cuando el usuario pulsa el bot\u00f3n se ha de comprobar el tama\u00f1o de la cadena de texto introducida en el campo de entrada de texto. Pueden darse 3 situaciones:</p> <ul> <li>Si el tama\u00f1o de texto es <code>0</code>, se ha de lanzar un aviso al usuario para que introduzca una cadena de texto;</li> <li>Si el tama\u00f1o es par, el campo de texto de salida se actualiza con el siguiente mensaje: \u201cEl texto introducido tiene un tama\u00f1o par\u201d seguido del tama\u00f1o de la cadena entre par\u00e9ntesis. Ej: <code>(6)</code>;</li> <li> <p>Si el tama\u00f1o es impar, el campo de texto de salida se actualiza con el siguiente mensaje: \u201cEl texto introducido tiene un tama\u00f1o impar\u201d seguido del tama\u00f1o de la cadena entre par\u00e9ntesis. Ej: <code>(5)</code>.</p> </li> <li> <p>(a) (0,5 puntos) \u00bfMediante qu\u00e9 atributo asociar\u00eda la ejecuci\u00f3n de un m\u00e9todo Java cuando el bot\u00f3n es pulsado por el usuario?</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>onClick\n</code></pre> <ul> <li>(b) (2,5 puntos) Programe un m\u00e9todo <code>calculoParidad</code> que implemente la funcionalidad descrita.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void CompruebaParidad(View V) {\n\n    EditText et = findViewById(R.id.etEntrada);\n    TextView tv = findViewById(R.id.tvResultado);\n\n    int len = et.getText().toString().length();\n\n    if (len == 0) {\n        Toast.makeText(this, \"Introduzca texto\", Toast.LENGTH_SHORT).show();\n        tv.setText(\"\");\n    } \n    else if (len % 2 == 0) {\n        tv.setText(\"Es par (\" + len + \")\");\n    } \n    else {\n        tv.setText(\"Es impar (\" + len + \")\");\n    }\n}\n</code></pre>","tags":["Android"]},{"location":"exams/2019/pract/","title":"Examen 2019 \u2014 Pr\u00e1cticas","text":""},{"location":"exams/2019/pract/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (5 puntos) Se requiere una clase de pruebas JUnit para comprobar la correcta implementaci\u00f3n del monitor de lectura-escritura <code>RW_Monitor</code> del ejercicio 3. Complete la siguiente clase con, al menos, 5 pruebas distintas que prueben diferentes posibles situaciones. En particular debe incluir, al menos una prueba que verifique un n\u00famero correcto de lectores dentro del monitor despu\u00e9s de una secuencia correcta de peticiones de acceso y otra prueba que fuerce el lanzamiento de una excepci\u00f3n dentro del monitor.</li> </ul> <p>Considere importadas todas las funcionalidades del paquete <code>org.junit</code> y valore la necesidad de ejecutar alg\u00fan m\u00e9todo antes y/o despu\u00e9s de cada test. <pre><code>public class MonitorTest {\n</code></pre></p>"},{"location":"exams/2019/pract_ex01/","title":"Pract ex01","text":"<ul> <li>(a) (5 puntos) Se requiere una clase de pruebas JUnit para comprobar la correcta implementaci\u00f3n del monitor de lectura-escritura <code>RW_Monitor</code> del ejercicio 3. Complete la siguiente clase con, al menos, 5 pruebas distintas que prueben diferentes posibles situaciones. En particular debe incluir, al menos una prueba que verifique un n\u00famero correcto de lectores dentro del monitor despu\u00e9s de una secuencia correcta de peticiones de acceso y otra prueba que fuerce el lanzamiento de una excepci\u00f3n dentro del monitor.</li> </ul> <p>Considere importadas todas las funcionalidades del paquete <code>org.junit</code> y valore la necesidad de ejecutar alg\u00fan m\u00e9todo antes y/o despu\u00e9s de cada test. <pre><code>public class MonitorTest {\n</code></pre></p>","tags":["???"]},{"location":"exams/2021/extra/","title":"Examen 2021 \u2014 Extraordinario","text":""},{"location":"exams/2021/extra/#problema-1","title":"Problema 1","text":"<p>Un sistema real se describe como un grafo no dirigido. Los arcos o aristas (edge) tienen un coste o peso mayor que cero. Un camino es una secuencia de arcos que conectan dos nodos o v\u00e9rtices. Un camino se representa mediante una lista (List). En este sistema, interesa agrupar a todos los posibles caminos entre dos nodos concretos, que se representa mediante una lista de caminos (<code>List&lt;List&lt;Edge&gt;&gt;</code>). <p>Se pide desarrollar dos m\u00e9todos, descritos en el cuadro adjunto:</p> <ul> <li> <p>(a) (2 puntos) <code>menorCamino</code> selecciona el camino m\u00ednimo (el de menor coste total) de una lista de caminos. Se aconseja (no obligatorio) desarrollar un m\u00e9todo que reciba como entrada un camino y retorne el peso total del camino.</p> </li> <li> <p>(b) (3 puntos) <code>numeroVecesUsadoArco</code>: genera un diccionario (<code>Map&lt;Edge, Integer&gt;</code>) con el n\u00famero de veces que aparece cada arco en la lista de caminos del par\u00e1metro de entrada.</p> </li> </ul> menorCamino <code>public java.util.List&lt;Edge&gt; menorCamino (java.util.List&lt;java.util.List&lt;Edge&gt;&gt; listaCaminos)</code> Seleccionar el camino con el menor coste total. Parameters <code>listaCaminos</code> - una lista de caminos del grafo del sistema entre dos v\u00e9rtices. Returns La respuesta es un camino que sea el m\u00ednimo de la lista recibida. Si hubieran varios caminos m\u00ednimos con el mismo coste, se puede retornar cualquiera de ellos. numeroVecesUsadoArco <code>public java.util.Map&lt;Edge,java.lang.Integer&gt; numeroVecesUsadoArco (java.util.List&lt;java.util.List&lt;Edge&gt;&gt; listaCaminos)</code> Determinta cu\u00e1ntas veces aparece cada arco en una lista de caminos Parameters <code>listaCaminos</code> - una lista de caminos del grafo del sistema entre dos v\u00e9rtices. Returns Devuelve un diccionario, en el que la clave es un arco y el valor un entero que representa el n\u00famero de veces que el arco aparece en el par\u00e1metro de entrada. Edge <code>int compareTo(Edge that)</code> Compares two edges by weight. <code>int either()</code> Returns either endpoint of this edge. <code>int other(int vertex)</code> Returns the endpoint of this edge that is different from the given vertex. <code>Double weight()</code> Returns the weight of this edge. List <code>boolean add(E e)</code> Appends the specified element to the end of this list (optional operation). <code>boolean contains(Object o)</code> Returns true if this list contains the specified element. <code>E get(int index)</code> Returns the element at the specified position in this list. <code>boolean isEmpty()</code> Returns true if this list contains no elements. <code>E remove(int index)</code> Removes the element at the specified position in this list (optional operation). <code>int size()</code> Returns the number of elements in this list. Map <code>boolean containsKey(Object key)</code> Returns true if this map contains a mapping for the specified key. <code>V get(Object key)</code> Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. <code>boolean isEmpty()</code> Returns true if this map contains no key-value mappings. <code>V put(K key, V value)</code> Associates the specified value with the specified key in this map. <code>V remove(Object key)</code> Removes the mapping for the specified key from this map if present. <code>int size()</code> Returns the number of key-value mappings in this map. <p>Nota: En la implementaci\u00f3n de estos m\u00e9todos, se gestionan listas de arcos. No es necesario conocer, ni gestionar los v\u00e9rtices conectados en los caminos incluidos en la lista de entrada.</p> Mostrar soluci\u00f3n <pre><code>private double pesoCamino(List&lt;Edge&gt; camino) {\n    double distancia = 0;\n    for (Edge arco : camino) {\n        distancia = distancia + arco.weight();\n    }\n    return distancia;\n}\n\n/**\n * Seleccionar el camino con el menor coste total.\n * @param listaCaminos una lista de caminos del grafo del sistema entre dos v\u00e9rtices.\n * @return La respuesta es un camino que sea el m\u00ednimo de la lista recibida.\n * Si hubieran varios caminos m\u00ednimos con el mismo coste, se puede retornar\n * cualquiera de ellos.\n */\npublic List&lt;Edge&gt; menorCamino(List&lt;List&lt;Edge&gt;&gt; listaCaminos) {\n    List&lt;Edge&gt; menorCamino = null;\n    double menorPeso = Double.MAX_VALUE;\n\n    for (List&lt;Edge&gt; camino : listaCaminos) {\n        double aux = pesoCamino(camino);\n        if (menorCamino == null || aux &lt; menorPeso) {\n            menorPeso = aux;\n            menorCamino = camino;\n        }\n    }\n    return menorCamino;\n}\n\n/**\n * Determinar cu\u00e1ntas veces aparece cada arco en una lista de caminos\n * @param listaCaminos una lista de caminos del grafo del sistema entre dos v\u00e9rtices.\n * @return devuelve un diccionario, en el que la clave es un arco y el valor un\n * entero que representa el n\u00famero de veces que el arco aparece en el par\u00e1metro de entrada.\n */\npublic Map&lt;Edge, Integer&gt; numeroVecesUsadoArco(List&lt;List&lt;Edge&gt;&gt; listaCaminos) {\n    // Diccionario\n    Map&lt;Edge, Integer&gt; diccionario = new HashMap&lt;Edge, Integer&gt;();\n\n    for (List&lt;Edge&gt; camino : listaCaminos) {\n        for (Edge arco : camino) {\n            if (diccionario.containsKey(arco)) {\n                int aux = diccionario.get(arco) + 1;\n                diccionario.put(arco, aux);\n            } else {\n                diccionario.put(arco, 1);\n            }\n        }\n    }\n    return diccionario;\n}\n</code></pre>"},{"location":"exams/2021/extra/#problema-2","title":"Problema 2","text":"<p>Se quiere evaluar tres algoritmos que calculan cu\u00e1ntas veces aparecen los n\u00fameros en un rango de valores enteros en otra secuencia de enteros representada en un array desordenado y sin valores repetidos. Los tres algoritmos retornan los mismos valores y son correctos. La signatura de los tres algoritmos es: <code>buscar(int[] buscados, int inicio, int fin)</code>, donde: <code>buscados</code> es el array de enteros e <code>inicio</code> y <code>fin</code> (<code>inicio &lt;= fin</code>) determinan el rango de enteros a buscar.</p> <p>Por ejemplo: <code>buscados = [1, 9, 4, 5, -3, 8, 7]</code>; <code>inicio = 5, fin = 7</code>. Entonces, habr\u00eda que contar el n\u00famero de veces que aparecen los enteros de la secuencia: 5, 6, 7. El resultado ser\u00e1: 2, ya que el 5 aparece una vez, el 6 no aparece y el 7 aparece una vez. </p> <pre><code>public static int buscar1(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n    ordenaOptimo(buscados);\n\n    for (int unNumero = inicio; unNumero &lt;= fin; unNumero++) {\n        if (busquedaBinaria(buscados, unNumero) != -1) {\n            encontrados++;\n        }\n    }\n    return encontrados;\n}\n\npublic static int buscar2(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n\n    for (int unNumero = inicio; unNumero &lt;= fin; unNumero++) {\n        for (int i = 0; i &lt; buscados.length; i++) {\n            if (buscados[i] == unNumero) {\n                encontrados++;\n                break;\n            }\n        }\n    }\n    return encontrados;\n}\n\npublic static int buscar3(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n    ordenaOptimo(buscados);\n\n    int principio = buscaMasCercano(buscados, inicio, true);\n    int final_ = buscaMasCercano(buscados, fin, false);\n    int dif = final_ - principio;\n\n    if ((principio &lt; 0 &amp;&amp; fin != buscados[final_]) ||\n        (principio == buscados.length - 1 &amp;&amp; inicio != buscados[principio])) {\n        dif--;\n    } else {\n        if (principio &gt;= 0 &amp;&amp; final_ &lt; buscados.length &amp;&amp;\n            inicio != buscados[principio] &amp;&amp; fin != buscados[final_]) {\n            dif--;\n        }\n        if (principio &gt;= 0 &amp;&amp; final_ &lt; buscados.length &amp;&amp;\n            inicio == buscados[principio] &amp;&amp; fin == buscados[final_]) {\n            dif++;\n        }\n    }\n    return dif;\n}\n</code></pre> <p>Se describen algunos aspectos sobre los m\u00e9todos auxiliares del c\u00f3digo:</p> <ul> <li><code>ordenaOptimo</code>: implementa un algoritmo de ordenaci\u00f3n del array en orden ascendente, y tiene una complejidad \\(n log n\\) (donde \\(n\\) es el tama\u00f1o del array que recibe como par\u00e1metro). Al completar este m\u00e9todo, el array de entrada estar\u00e1 ordenado.</li> <li><code>busquedaBinaria</code>: implementa un algoritmo de b\u00fasqueda binaria, de un entero, en un array ordenado; devuelve la posici\u00f3n del n\u00famero en el array, o -1 si no se encuentra en el array.</li> <li><code>buscaMasCercano</code>: en un array ordenado, busca la posici\u00f3n cuyo valor es el m\u00e1s pr\u00f3ximo al segundo par\u00e1metro. La implementaci\u00f3n de este m\u00e9todo emplea un algoritmo de b\u00fasqueda binaria de complejidad $log n.</li> <li>En el m\u00e9todo <code>buscar2</code>, se supone que el n\u00famero de veces que se ejecuta el segundo bucle es \\(N/2\\).</li> </ul> <p>\u00bfCu\u00e1l de los tres algoritmos se deber\u00eda utilizar en los siguientes casos? Justifique cada caso, para cada algoritmo, indicando la complejidad del algoritmo. \\(N\\) es el n\u00famero de elementos en el array y \\(M\\) es el n\u00famero de elementos en la secuencia de b\u00fasqueda <code>(fin \u2013 inicio + 1)</code>.</p> <ul> <li>(a) (1,5 puntos) \\(M=2\\) y \\(N\\) es n\u00famero muy grande.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad del m\u00e9todo <code>buscar1</code> es:</p> <p>\\(N log N\\), esto es <code>ordenarOptimo</code>;</p> <p>\\(M log N\\), esto es el bucle <code>for</code>;</p> <p>La complejidad depende de los valores \\(N\\) y \\(M\\).</p> <p>La complejidad del m\u00e9todo <code>buscar2</code> es: \\(M*N/2\\)</p> <p>La complejidad del m\u00e9todo <code>buscar3</code> es:</p> <p>\\(N log N\\), esto es <code>ordenarOptimo</code>;</p> <p>\\(2 log N\\), esto la complejidad de ejecuci\u00f3n 2 veces de <code>buscaMasCercano</code>.</p> <p>La complejidad es \\(N log N\\).</p> <ul> <li>(b) (1,5 puntos) \\(M = N\\), ambos n\u00fameros grandes. </li> </ul> Mostrar soluci\u00f3n <p>Caso 1, \\(M = 2\\):</p> <p>La complejidad de <code>buscar1</code> es \\(N log N\\);</p> <p>La complejidad de <code>buscar2</code> es \\(N\\);</p> <p>La complejidad de <code>buscar3</code> es \\(N log N\\);</p> <p>Es mejor algoritmo <code>buscar2</code>.</p> <p>Caso 2, \\(M = N\\):</p> <p>La complejidad de <code>buscar1</code> es \\(N log N\\);</p> <p>La complejidad de <code>buscar2</code> es \\(N2/2\\);</p> <p>La complejidad de <code>buscar3</code> es \\(N log N\\);</p> <p>Es mejor algoritmo <code>buscar1</code> o <code>buscar3</code>.</p> <p>Caso 3, \\(M &gt;&gt; N\\):</p> <p>La complejidad de <code>buscar1</code> es \\(M log N\\);</p> <p>La complejidad de <code>buscar2</code> es \\(M*N/2\\);</p> <p>La complejidad de <code>buscar3</code> es \\(N log N\\);</p> <p>Es mejor el algoritmo <code>buscar3</code>.</p> <ul> <li>(c) (2 puntos) \\(M\\) es bastante m\u00e1s grande que \\(N\\), y ambos son grandes.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p>"},{"location":"exams/2021/extra_ex01/","title":"Extra ex01","text":"<p>Un sistema real se describe como un grafo no dirigido. Los arcos o aristas (edge) tienen un coste o peso mayor que cero. Un camino es una secuencia de arcos que conectan dos nodos o v\u00e9rtices. Un camino se representa mediante una lista (List). En este sistema, interesa agrupar a todos los posibles caminos entre dos nodos concretos, que se representa mediante una lista de caminos (<code>List&lt;List&lt;Edge&gt;&gt;</code>). <p>Se pide desarrollar dos m\u00e9todos, descritos en el cuadro adjunto:</p> <ul> <li> <p>(a) (2 puntos) <code>menorCamino</code> selecciona el camino m\u00ednimo (el de menor coste total) de una lista de caminos. Se aconseja (no obligatorio) desarrollar un m\u00e9todo que reciba como entrada un camino y retorne el peso total del camino.</p> </li> <li> <p>(b) (3 puntos) <code>numeroVecesUsadoArco</code>: genera un diccionario (<code>Map&lt;Edge, Integer&gt;</code>) con el n\u00famero de veces que aparece cada arco en la lista de caminos del par\u00e1metro de entrada.</p> </li> </ul> menorCamino <code>public java.util.List&lt;Edge&gt; menorCamino (java.util.List&lt;java.util.List&lt;Edge&gt;&gt; listaCaminos)</code> Seleccionar el camino con el menor coste total. Parameters <code>listaCaminos</code> - una lista de caminos del grafo del sistema entre dos v\u00e9rtices. Returns La respuesta es un camino que sea el m\u00ednimo de la lista recibida. Si hubieran varios caminos m\u00ednimos con el mismo coste, se puede retornar cualquiera de ellos. numeroVecesUsadoArco <code>public java.util.Map&lt;Edge,java.lang.Integer&gt; numeroVecesUsadoArco (java.util.List&lt;java.util.List&lt;Edge&gt;&gt; listaCaminos)</code> Determinta cu\u00e1ntas veces aparece cada arco en una lista de caminos Parameters <code>listaCaminos</code> - una lista de caminos del grafo del sistema entre dos v\u00e9rtices. Returns Devuelve un diccionario, en el que la clave es un arco y el valor un entero que representa el n\u00famero de veces que el arco aparece en el par\u00e1metro de entrada. Edge <code>int compareTo(Edge that)</code> Compares two edges by weight. <code>int either()</code> Returns either endpoint of this edge. <code>int other(int vertex)</code> Returns the endpoint of this edge that is different from the given vertex. <code>Double weight()</code> Returns the weight of this edge. List <code>boolean add(E e)</code> Appends the specified element to the end of this list (optional operation). <code>boolean contains(Object o)</code> Returns true if this list contains the specified element. <code>E get(int index)</code> Returns the element at the specified position in this list. <code>boolean isEmpty()</code> Returns true if this list contains no elements. <code>E remove(int index)</code> Removes the element at the specified position in this list (optional operation). <code>int size()</code> Returns the number of elements in this list. Map <code>boolean containsKey(Object key)</code> Returns true if this map contains a mapping for the specified key. <code>V get(Object key)</code> Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. <code>boolean isEmpty()</code> Returns true if this map contains no key-value mappings. <code>V put(K key, V value)</code> Associates the specified value with the specified key in this map. <code>V remove(Object key)</code> Removes the mapping for the specified key from this map if present. <code>int size()</code> Returns the number of key-value mappings in this map. <p>Nota: En la implementaci\u00f3n de estos m\u00e9todos, se gestionan listas de arcos. No es necesario conocer, ni gestionar los v\u00e9rtices conectados en los caminos incluidos en la lista de entrada.</p> Mostrar soluci\u00f3n <pre><code>private double pesoCamino(List&lt;Edge&gt; camino) {\n    double distancia = 0;\n    for (Edge arco : camino) {\n        distancia = distancia + arco.weight();\n    }\n    return distancia;\n}\n\n/**\n * Seleccionar el camino con el menor coste total.\n * @param listaCaminos una lista de caminos del grafo del sistema entre dos v\u00e9rtices.\n * @return La respuesta es un camino que sea el m\u00ednimo de la lista recibida.\n * Si hubieran varios caminos m\u00ednimos con el mismo coste, se puede retornar\n * cualquiera de ellos.\n */\npublic List&lt;Edge&gt; menorCamino(List&lt;List&lt;Edge&gt;&gt; listaCaminos) {\n    List&lt;Edge&gt; menorCamino = null;\n    double menorPeso = Double.MAX_VALUE;\n\n    for (List&lt;Edge&gt; camino : listaCaminos) {\n        double aux = pesoCamino(camino);\n        if (menorCamino == null || aux &lt; menorPeso) {\n            menorPeso = aux;\n            menorCamino = camino;\n        }\n    }\n    return menorCamino;\n}\n\n/**\n * Determinar cu\u00e1ntas veces aparece cada arco en una lista de caminos\n * @param listaCaminos una lista de caminos del grafo del sistema entre dos v\u00e9rtices.\n * @return devuelve un diccionario, en el que la clave es un arco y el valor un\n * entero que representa el n\u00famero de veces que el arco aparece en el par\u00e1metro de entrada.\n */\npublic Map&lt;Edge, Integer&gt; numeroVecesUsadoArco(List&lt;List&lt;Edge&gt;&gt; listaCaminos) {\n    // Diccionario\n    Map&lt;Edge, Integer&gt; diccionario = new HashMap&lt;Edge, Integer&gt;();\n\n    for (List&lt;Edge&gt; camino : listaCaminos) {\n        for (Edge arco : camino) {\n            if (diccionario.containsKey(arco)) {\n                int aux = diccionario.get(arco) + 1;\n                diccionario.put(arco, aux);\n            } else {\n                diccionario.put(arco, 1);\n            }\n        }\n    }\n    return diccionario;\n}\n</code></pre>","tags":["grafos"]},{"location":"exams/2021/extra_ex02/","title":"Extra ex02","text":"<p>Se quiere evaluar tres algoritmos que calculan cu\u00e1ntas veces aparecen los n\u00fameros en un rango de valores enteros en otra secuencia de enteros representada en un array desordenado y sin valores repetidos. Los tres algoritmos retornan los mismos valores y son correctos. La signatura de los tres algoritmos es: <code>buscar(int[] buscados, int inicio, int fin)</code>, donde: <code>buscados</code> es el array de enteros e <code>inicio</code> y <code>fin</code> (<code>inicio &lt;= fin</code>) determinan el rango de enteros a buscar.</p> <p>Por ejemplo: <code>buscados = [1, 9, 4, 5, -3, 8, 7]</code>; <code>inicio = 5, fin = 7</code>. Entonces, habr\u00eda que contar el n\u00famero de veces que aparecen los enteros de la secuencia: 5, 6, 7. El resultado ser\u00e1: 2, ya que el 5 aparece una vez, el 6 no aparece y el 7 aparece una vez. </p> <pre><code>public static int buscar1(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n    ordenaOptimo(buscados);\n\n    for (int unNumero = inicio; unNumero &lt;= fin; unNumero++) {\n        if (busquedaBinaria(buscados, unNumero) != -1) {\n            encontrados++;\n        }\n    }\n    return encontrados;\n}\n\npublic static int buscar2(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n\n    for (int unNumero = inicio; unNumero &lt;= fin; unNumero++) {\n        for (int i = 0; i &lt; buscados.length; i++) {\n            if (buscados[i] == unNumero) {\n                encontrados++;\n                break;\n            }\n        }\n    }\n    return encontrados;\n}\n\npublic static int buscar3(int[] buscados, int inicio, int fin) {\n    int encontrados = 0;\n    ordenaOptimo(buscados);\n\n    int principio = buscaMasCercano(buscados, inicio, true);\n    int final_ = buscaMasCercano(buscados, fin, false);\n    int dif = final_ - principio;\n\n    if ((principio &lt; 0 &amp;&amp; fin != buscados[final_]) ||\n        (principio == buscados.length - 1 &amp;&amp; inicio != buscados[principio])) {\n        dif--;\n    } else {\n        if (principio &gt;= 0 &amp;&amp; final_ &lt; buscados.length &amp;&amp;\n            inicio != buscados[principio] &amp;&amp; fin != buscados[final_]) {\n            dif--;\n        }\n        if (principio &gt;= 0 &amp;&amp; final_ &lt; buscados.length &amp;&amp;\n            inicio == buscados[principio] &amp;&amp; fin == buscados[final_]) {\n            dif++;\n        }\n    }\n    return dif;\n}\n</code></pre> <p>Se describen algunos aspectos sobre los m\u00e9todos auxiliares del c\u00f3digo:</p> <ul> <li><code>ordenaOptimo</code>: implementa un algoritmo de ordenaci\u00f3n del array en orden ascendente, y tiene una complejidad \\(n log n\\) (donde \\(n\\) es el tama\u00f1o del array que recibe como par\u00e1metro). Al completar este m\u00e9todo, el array de entrada estar\u00e1 ordenado.</li> <li><code>busquedaBinaria</code>: implementa un algoritmo de b\u00fasqueda binaria, de un entero, en un array ordenado; devuelve la posici\u00f3n del n\u00famero en el array, o -1 si no se encuentra en el array.</li> <li><code>buscaMasCercano</code>: en un array ordenado, busca la posici\u00f3n cuyo valor es el m\u00e1s pr\u00f3ximo al segundo par\u00e1metro. La implementaci\u00f3n de este m\u00e9todo emplea un algoritmo de b\u00fasqueda binaria de complejidad $log n.</li> <li>En el m\u00e9todo <code>buscar2</code>, se supone que el n\u00famero de veces que se ejecuta el segundo bucle es \\(N/2\\).</li> </ul> <p>\u00bfCu\u00e1l de los tres algoritmos se deber\u00eda utilizar en los siguientes casos? Justifique cada caso, para cada algoritmo, indicando la complejidad del algoritmo. \\(N\\) es el n\u00famero de elementos en el array y \\(M\\) es el n\u00famero de elementos en la secuencia de b\u00fasqueda <code>(fin \u2013 inicio + 1)</code>.</p> <ul> <li>(a) (1,5 puntos) \\(M=2\\) y \\(N\\) es n\u00famero muy grande.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad del m\u00e9todo <code>buscar1</code> es:</p> <p>\\(N log N\\), esto es <code>ordenarOptimo</code>;</p> <p>\\(M log N\\), esto es el bucle <code>for</code>;</p> <p>La complejidad depende de los valores \\(N\\) y \\(M\\).</p> <p>La complejidad del m\u00e9todo <code>buscar2</code> es: \\(M*N/2\\)</p> <p>La complejidad del m\u00e9todo <code>buscar3</code> es:</p> <p>\\(N log N\\), esto es <code>ordenarOptimo</code>;</p> <p>\\(2 log N\\), esto la complejidad de ejecuci\u00f3n 2 veces de <code>buscaMasCercano</code>.</p> <p>La complejidad es \\(N log N\\).</p> <ul> <li>(b) (1,5 puntos) \\(M = N\\), ambos n\u00fameros grandes. </li> </ul> Mostrar soluci\u00f3n <p>Caso 1, \\(M = 2\\):</p> <p>La complejidad de <code>buscar1</code> es \\(N log N\\);</p> <p>La complejidad de <code>buscar2</code> es \\(N\\);</p> <p>La complejidad de <code>buscar3</code> es \\(N log N\\);</p> <p>Es mejor algoritmo <code>buscar2</code>.</p> <p>Caso 2, \\(M = N\\):</p> <p>La complejidad de <code>buscar1</code> es \\(N log N\\);</p> <p>La complejidad de <code>buscar2</code> es \\(N2/2\\);</p> <p>La complejidad de <code>buscar3</code> es \\(N log N\\);</p> <p>Es mejor algoritmo <code>buscar1</code> o <code>buscar3</code>.</p> <p>Caso 3, \\(M &gt;&gt; N\\):</p> <p>La complejidad de <code>buscar1</code> es \\(M log N\\);</p> <p>La complejidad de <code>buscar2</code> es \\(M*N/2\\);</p> <p>La complejidad de <code>buscar3</code> es \\(N log N\\);</p> <p>Es mejor el algoritmo <code>buscar3</code>.</p> <ul> <li>(c) (2 puntos) \\(M\\) es bastante m\u00e1s grande que \\(N\\), y ambos son grandes.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p>","tags":["complejidad"]},{"location":"exams/2021/p1/","title":"Examen 2021 \u2014 Parcial 1","text":""},{"location":"exams/2021/p1/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un algoritmo para saber si un grafo no dirigido es ac\u00edclico, es decir, no tiene ciclos. Ejemplos:</p> <p></p> <p>Se pide:</p> <ul> <li>(a) (3,5 puntos) Dise\u00f1e el algoritmo tomando como referencia la siguiente signatura. <pre><code>boolean tieneCiclos(EdgeWeightedGraph g) {\n    //TODO a rellenar por el alumno}\n</code></pre> Primero, explique las estructuras de datos que necesita en el c\u00f3digo y qu\u00e9 uso se les va a dar. Segundo, implemente la soluci\u00f3n en Java. Nota: Puede desarrollar m\u00e9todos auxiliares si lo necesita.</li> </ul> <p>Puede utilizar los siguientes m\u00e9todos: </p> Mostrar soluci\u00f3n <pre><code>interface Solucion {\n    boolean tieneCiclos(EdgeWeightedGraph g);\n}\n</code></pre> <p>Soluci\u00f3n Iterativa:</p> <pre><code>class Iterativa implements Solucion {\n\n    @Override\n    public boolean tieneCiclos(EdgeWeightedGraph g) {\n\n        List&lt;Integer&gt; pendientes = new ArrayList&lt;Integer&gt;();\n        List&lt;Integer&gt; visitadosNodos = new ArrayList&lt;Integer&gt;();\n        List&lt;Edge&gt; visitadosArcos = new ArrayList&lt;Edge&gt;();\n\n        Integer nodo = 0;\n\n        for (int i = 0; i &lt; g.V(); i++) {\n\n            if (visitadosNodos.contains(i)) continue;\n\n            pendientes.add(i);\n\n            while (!pendientes.isEmpty()) {\n\n                nodo = pendientes.remove(0);\n                visitadosNodos.add(nodo);\n\n                for (Edge arco : g.adj(nodo)) {\n\n                    Integer otro = arco.other(nodo);\n\n                    if (!visitadosArcos.contains(arco) &amp;&amp;\n                        pendientes.contains(otro)) {\n                        return true; // ciclo detectado\n                    } else {\n                        if (!pendientes.contains(otro) &amp;&amp;\n                            !visitadosArcos.contains(arco)) {\n                            pendientes.add(otro);\n                        }\n                    }\n\n                    visitadosArcos.add(arco);\n                }\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <p>Soluci\u00f3n Recursiva:</p> <pre><code>class Recursiva implements Solucion {\n\n    @Override\n    public boolean tieneCiclos(EdgeWeightedGraph g) {\n\n        Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;();\n        Set&lt;Edge&gt; seenArcos = new HashSet&lt;Edge&gt;();\n\n        for (int v = 0; v &lt; g.V(); v++) {\n            if (seen.contains(v)) continue;\n\n            if (dfs(g, v, seen, seenArcos)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    boolean dfs(EdgeWeightedGraph g, int v,\n                Set&lt;Integer&gt; seen,\n                Set&lt;Edge&gt; seenArcos) {\n\n        if (seen.contains(v)) {\n            return true; // ciclo detectado\n        }\n\n        seen.add(v);\n\n        for (Edge e : g.adj(v)) {\n\n            if (seenArcos.contains(e)) continue;\n\n            seenArcos.add(e);\n            int neighbour = e.other(v);\n\n            if (dfs(g, neighbour, seen, seenArcos)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <ul> <li>(b) (0,5 putnos) \u00bfQu\u00e9 tipo de algoritmo ha dise\u00f1ado? Recursivo/iterativo (Razone su respuesta)</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p> <ul> <li>(c) (1 punto) Realice un c\u00e1lculo de la complejidad del algoritmo propuesto.</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p>"},{"location":"exams/2021/p1/#problema-2","title":"Problema 2","text":"<p>Como parte de un proyecto internacional, se quiere dise\u00f1ar un sistema que permite guardar y consultar el historial de posiciones de ciertos elementos. Se sabe que el sistema necesitar\u00e1 internamente un diccionario para guardar la informaci\u00f3n (<code>Clave=elemento</code>, <code>Valor=posici\u00f3n</code>).</p> <p>Se van a considerar s\u00f3lo las siguientes estructuras de datos para implementar el diccionario, que se implementar\u00e1n en las clases en par\u00e9ntesis:</p> <ul> <li>Array con duplicados (<code>DiccionarioArrayDuplicados</code>)</li> <li>Array ordenado sin duplicados (<code>DiccionarioArrayOrdenado</code>)</li> <li>\u00c1rbol binario de b\u00fasqueda (<code>DiccionarioArbol</code>)</li> <li>Tabla hash con listas (<code>DiccionarioHash</code>)</li> </ul> <p>Se pide:</p> <ul> <li>(a) (1,5 puntos) Dise\u00f1e un algoritmo que calcule la menor clave almacenada (<code>claveMin</code>), y otro que calcule el menor valor (<code>valorMin</code>), usando las siguientes signaturas y los m\u00e9todos de la interfaz <code>Diccionario&lt;K,V&gt;</code> especificados al final del enunciado: <pre><code>K claveMin(Diccionario d) {\n    //TODO a rellenar por el alumno\n}\nV valorMin(Diccionario d) {\n    //TODO a rellenar por el alumno\n}\n</code></pre></li> </ul> <p>Utilice el interfaz de <code>Diccionario&lt;K,V&gt;</code> que se muestra a continuaci\u00f3n:</p> <p></p> Mostrar soluci\u00f3n <pre><code>public K claveMin(Diccionario&lt;K, V&gt; d) {\n    K min = null;\n\n    for (K key : d.keys()) {\n        if (key.compareTo(min) &lt; 0) {\n            min = key;\n        }\n    }\n    return min;\n}\n</code></pre> <pre><code>public V valorMin(Diccionario&lt;K, V&gt; d) {\n    V min = null;\n\n    for (K key : d.keys()) {\n        V v = d.get(key);\n        if (v.compareTo(min) &lt; 0) {\n            min = v;\n        }\n    }\n    return min;\n}\n</code></pre> <ul> <li>(b) (0,5 puntos) Si <code>claveMin</code> y <code>valorMin</code> pudieran tener acceso a la estructura de datos interna de cada una de las implementaciones consideradas (p.e., la tabla hash en <code>DiccionarioHash</code>), \u00bfpodr\u00eda dise\u00f1arse una alternativa de menor complejidad?. Razone su respuesta sin escribir el algoritmo. </li> </ul> Mostrar soluci\u00f3n <p>Los m\u00e9todos implementados tienen complejidad en tiempo de ejecuci\u00f3n \\(O(n)\\), pero <code>claveMin</code> podr\u00eda usar ser m\u00e1s eficiente en <code>DiccionarioArrayOrdenado</code> y <code>DiccionarioArbol</code>, porque las claves est\u00e1n ordenadas. Para <code>valorMin</code> no ser\u00eda posible.</p> <p>El algoritmo para la interfaz tiene complejidad \\(O(n)\\), porque tiene que recorrer todas las claves y todos los valores.</p> <p>En <code>DiccionarioHash</code> y <code>DiccionarioArrayDuplicados</code> tambi\u00e9n habr\u00eda que recorrer todos los elementos, as\u00ed que la complejidad ser\u00eda similar.</p> <p>En <code>DiccionarioArrayOrdenado</code> y <code>DiccionarioArbol</code> las claves est\u00e1n ordenadas.</p> <p>Por tanto, en <code>DiccionarioArrayOrdenado</code> se podr\u00eda conseguir \\(O(1)\\) para <code>claveMin</code>, porque simplemente hay que acceder al primer elemento. En <code>DiccionarioArbol</code> tendr\u00edamos complejidad \\(O(log(n))\\), porque hay que recorrer toda la profundidad (\\(log2(n)\\), en un \u00e1rbol balanceado).</p> <p>Para <code>valorMin</code> no se podr\u00eda conseguir un algoritmo mejor porque los valores no est\u00e1n ordenados, s\u00f3lo las claves.</p> <p>Elija entre las implementaciones consideradas la mejor adaptada para cada uno de los siguientes usos del sistema. Razone su respuesta usando los criterios de complejidad.</p> <ul> <li>(c) (1 punto) Directorio de salas en la universidad. Consultas (<code>get</code>) frecuentes, actualizaciones (<code>put</code>, <code>remove</code>) poco frecuentes.</li> </ul> Mostrar soluci\u00f3n <p><code>DiccionarioHash</code>, porque tiene b\u00fasquedas muy r\u00e1pidas (\\(O(1)\\)). Adem\u00e1s, al haber pocas actualizaciones podremos dimensionar la tabla correctamente.</p> <ul> <li>(d) (1 punto) Registro de seguridad de la posici\u00f3n en cada hora de los miembros del personal. Consultas poco frecuentes, actualizaciones muy frecuentes y no se deben sobreescribir valores antiguos.</li> </ul> Mostrar soluci\u00f3n <p><code>DiccionarioArrayDuplicados</code>. No se deben sobreescribir valores, y es el \u00fanico con esa condici\u00f3n en caso de actualizaci\u00f3n. Adem\u00e1s, las consultas son \\(O(n)\\), pero priman las actualizaciones (\\(O(1)\\)).</p> <ul> <li>(e) (1 punto) Prevenci\u00f3n de colisiones de veh\u00edculos con actualizaciones y consultas cada minuto. Consultas y actualizaciones igual de frecuentes. </li> </ul> Mostrar soluci\u00f3n <p><code>DiccionarioHash</code>. Tanto consultas como actualizaciones tienen complejidad \\(O(1)\\).</p>"},{"location":"exams/2021/p1_ex01/","title":"P1 ex01","text":"<p>Se quiere desarrollar un algoritmo para saber si un grafo no dirigido es ac\u00edclico, es decir, no tiene ciclos. Ejemplos:</p> <p></p> <p>Se pide:</p> <ul> <li>(a) (3,5 puntos) Dise\u00f1e el algoritmo tomando como referencia la siguiente signatura. <pre><code>boolean tieneCiclos(EdgeWeightedGraph g) {\n    //TODO a rellenar por el alumno}\n</code></pre> Primero, explique las estructuras de datos que necesita en el c\u00f3digo y qu\u00e9 uso se les va a dar. Segundo, implemente la soluci\u00f3n en Java. Nota: Puede desarrollar m\u00e9todos auxiliares si lo necesita.</li> </ul> <p>Puede utilizar los siguientes m\u00e9todos: </p> Mostrar soluci\u00f3n <pre><code>interface Solucion {\n    boolean tieneCiclos(EdgeWeightedGraph g);\n}\n</code></pre> <p>Soluci\u00f3n Iterativa:</p> <pre><code>class Iterativa implements Solucion {\n\n    @Override\n    public boolean tieneCiclos(EdgeWeightedGraph g) {\n\n        List&lt;Integer&gt; pendientes = new ArrayList&lt;Integer&gt;();\n        List&lt;Integer&gt; visitadosNodos = new ArrayList&lt;Integer&gt;();\n        List&lt;Edge&gt; visitadosArcos = new ArrayList&lt;Edge&gt;();\n\n        Integer nodo = 0;\n\n        for (int i = 0; i &lt; g.V(); i++) {\n\n            if (visitadosNodos.contains(i)) continue;\n\n            pendientes.add(i);\n\n            while (!pendientes.isEmpty()) {\n\n                nodo = pendientes.remove(0);\n                visitadosNodos.add(nodo);\n\n                for (Edge arco : g.adj(nodo)) {\n\n                    Integer otro = arco.other(nodo);\n\n                    if (!visitadosArcos.contains(arco) &amp;&amp;\n                        pendientes.contains(otro)) {\n                        return true; // ciclo detectado\n                    } else {\n                        if (!pendientes.contains(otro) &amp;&amp;\n                            !visitadosArcos.contains(arco)) {\n                            pendientes.add(otro);\n                        }\n                    }\n\n                    visitadosArcos.add(arco);\n                }\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <p>Soluci\u00f3n Recursiva:</p> <pre><code>class Recursiva implements Solucion {\n\n    @Override\n    public boolean tieneCiclos(EdgeWeightedGraph g) {\n\n        Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;();\n        Set&lt;Edge&gt; seenArcos = new HashSet&lt;Edge&gt;();\n\n        for (int v = 0; v &lt; g.V(); v++) {\n            if (seen.contains(v)) continue;\n\n            if (dfs(g, v, seen, seenArcos)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    boolean dfs(EdgeWeightedGraph g, int v,\n                Set&lt;Integer&gt; seen,\n                Set&lt;Edge&gt; seenArcos) {\n\n        if (seen.contains(v)) {\n            return true; // ciclo detectado\n        }\n\n        seen.add(v);\n\n        for (Edge e : g.adj(v)) {\n\n            if (seenArcos.contains(e)) continue;\n\n            seenArcos.add(e);\n            int neighbour = e.other(v);\n\n            if (dfs(g, neighbour, seen, seenArcos)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n</code></pre> <ul> <li>(b) (0,5 putnos) \u00bfQu\u00e9 tipo de algoritmo ha dise\u00f1ado? Recursivo/iterativo (Razone su respuesta)</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p> <ul> <li>(c) (1 punto) Realice un c\u00e1lculo de la complejidad del algoritmo propuesto.</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n depender\u00e1 de la respuesta a la pregunta (a).</p>","tags":["complejidad","grafos"]},{"location":"exams/2021/p1_ex02/","title":"P1 ex02","text":"<p>Como parte de un proyecto internacional, se quiere dise\u00f1ar un sistema que permite guardar y consultar el historial de posiciones de ciertos elementos. Se sabe que el sistema necesitar\u00e1 internamente un diccionario para guardar la informaci\u00f3n (<code>Clave=elemento</code>, <code>Valor=posici\u00f3n</code>).</p> <p>Se van a considerar s\u00f3lo las siguientes estructuras de datos para implementar el diccionario, que se implementar\u00e1n en las clases en par\u00e9ntesis:</p> <ul> <li>Array con duplicados (<code>DiccionarioArrayDuplicados</code>)</li> <li>Array ordenado sin duplicados (<code>DiccionarioArrayOrdenado</code>)</li> <li>\u00c1rbol binario de b\u00fasqueda (<code>DiccionarioArbol</code>)</li> <li>Tabla hash con listas (<code>DiccionarioHash</code>)</li> </ul> <p>Se pide:</p> <ul> <li>(a) (1,5 puntos) Dise\u00f1e un algoritmo que calcule la menor clave almacenada (<code>claveMin</code>), y otro que calcule el menor valor (<code>valorMin</code>), usando las siguientes signaturas y los m\u00e9todos de la interfaz <code>Diccionario&lt;K,V&gt;</code> especificados al final del enunciado: <pre><code>K claveMin(Diccionario d) {\n    //TODO a rellenar por el alumno\n}\nV valorMin(Diccionario d) {\n    //TODO a rellenar por el alumno\n}\n</code></pre></li> </ul> <p>Utilice el interfaz de <code>Diccionario&lt;K,V&gt;</code> que se muestra a continuaci\u00f3n:</p> <p></p> Mostrar soluci\u00f3n <pre><code>public K claveMin(Diccionario&lt;K, V&gt; d) {\n    K min = null;\n\n    for (K key : d.keys()) {\n        if (key.compareTo(min) &lt; 0) {\n            min = key;\n        }\n    }\n    return min;\n}\n</code></pre> <pre><code>public V valorMin(Diccionario&lt;K, V&gt; d) {\n    V min = null;\n\n    for (K key : d.keys()) {\n        V v = d.get(key);\n        if (v.compareTo(min) &lt; 0) {\n            min = v;\n        }\n    }\n    return min;\n}\n</code></pre> <ul> <li>(b) (0,5 puntos) Si <code>claveMin</code> y <code>valorMin</code> pudieran tener acceso a la estructura de datos interna de cada una de las implementaciones consideradas (p.e., la tabla hash en <code>DiccionarioHash</code>), \u00bfpodr\u00eda dise\u00f1arse una alternativa de menor complejidad?. Razone su respuesta sin escribir el algoritmo. </li> </ul> Mostrar soluci\u00f3n <p>Los m\u00e9todos implementados tienen complejidad en tiempo de ejecuci\u00f3n \\(O(n)\\), pero <code>claveMin</code> podr\u00eda usar ser m\u00e1s eficiente en <code>DiccionarioArrayOrdenado</code> y <code>DiccionarioArbol</code>, porque las claves est\u00e1n ordenadas. Para <code>valorMin</code> no ser\u00eda posible.</p> <p>El algoritmo para la interfaz tiene complejidad \\(O(n)\\), porque tiene que recorrer todas las claves y todos los valores.</p> <p>En <code>DiccionarioHash</code> y <code>DiccionarioArrayDuplicados</code> tambi\u00e9n habr\u00eda que recorrer todos los elementos, as\u00ed que la complejidad ser\u00eda similar.</p> <p>En <code>DiccionarioArrayOrdenado</code> y <code>DiccionarioArbol</code> las claves est\u00e1n ordenadas.</p> <p>Por tanto, en <code>DiccionarioArrayOrdenado</code> se podr\u00eda conseguir \\(O(1)\\) para <code>claveMin</code>, porque simplemente hay que acceder al primer elemento. En <code>DiccionarioArbol</code> tendr\u00edamos complejidad \\(O(log(n))\\), porque hay que recorrer toda la profundidad (\\(log2(n)\\), en un \u00e1rbol balanceado).</p> <p>Para <code>valorMin</code> no se podr\u00eda conseguir un algoritmo mejor porque los valores no est\u00e1n ordenados, s\u00f3lo las claves.</p> <p>Elija entre las implementaciones consideradas la mejor adaptada para cada uno de los siguientes usos del sistema. Razone su respuesta usando los criterios de complejidad.</p> <ul> <li>(c) (1 punto) Directorio de salas en la universidad. Consultas (<code>get</code>) frecuentes, actualizaciones (<code>put</code>, <code>remove</code>) poco frecuentes.</li> </ul> Mostrar soluci\u00f3n <p><code>DiccionarioHash</code>, porque tiene b\u00fasquedas muy r\u00e1pidas (\\(O(1)\\)). Adem\u00e1s, al haber pocas actualizaciones podremos dimensionar la tabla correctamente.</p> <ul> <li>(d) (1 punto) Registro de seguridad de la posici\u00f3n en cada hora de los miembros del personal. Consultas poco frecuentes, actualizaciones muy frecuentes y no se deben sobreescribir valores antiguos.</li> </ul> Mostrar soluci\u00f3n <p><code>DiccionarioArrayDuplicados</code>. No se deben sobreescribir valores, y es el \u00fanico con esa condici\u00f3n en caso de actualizaci\u00f3n. Adem\u00e1s, las consultas son \\(O(n)\\), pero priman las actualizaciones (\\(O(1)\\)).</p> <ul> <li>(e) (1 punto) Prevenci\u00f3n de colisiones de veh\u00edculos con actualizaciones y consultas cada minuto. Consultas y actualizaciones igual de frecuentes. </li> </ul> Mostrar soluci\u00f3n <p><code>DiccionarioHash</code>. Tanto consultas como actualizaciones tienen complejidad \\(O(1)\\).</p>","tags":["complejidad"]},{"location":"exams/2021/p1r/","title":"Examen 2021 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2021/p1r/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un programa que analice un documento de texto y calcule el n!mero de veces que aparece cada palabra (<code>String</code>). El resultado es una lista de <code>ContadorPalabra</code>, que es una clase que se muestra a continuaci\u00f3n:</p> <pre><code>public class ContadorPalabra {\n    String nombre; // Nombre en el documento\n    int contador; //N\u00fam. de veces que aparece\n    ...\n    // Est\u00e1n disponibles los getters y setters\n}\n</code></pre> <p>En una fase inicial del programa, se crean dos hebras que analizan una mitad del documento. El resultado de cada hebra es una lista (<code>java.util.List&lt;ContadorPalabra&gt;</code>), con el contador de cada palabra de la mitad correspondiente. Los elementos de cada lista est\u00e1n ordenados por el atributo nombre de cada <code>ContadorPalabra</code>.</p> <p>En este ejercicio, se quiere desarrollar un m\u00e9todo para agregar las dos listas generadas de cada mitad. Se pide:</p> <ul> <li>(a) (1,5 puntos) Desarrolle el m\u00e9todo <code>Menor</code>, que recibe dos listas ordenadas y retorna el <code>ContadorPalabra</code> con la menor palabra en cualquiera de las dos mitades. </li> </ul> <pre><code>public ContadorPalabra Menor (\n    java.util.List&lt;ContadorPalabra&gt; ag1,\n    java.util.List&lt;ContadorPalabra&gt; ag2) { . . . }\n</code></pre> Mostrar soluci\u00f3n <pre><code>public ContadorPalabra Menor(\n        java.util.List&lt;ContadorPalabra&gt; ag1,\n        java.util.List&lt;ContadorPalabra&gt; ag2) {\n\n    ContadorPalabra p1 = ag1.get(0);\n    ContadorPalabra p2 = ag2.get(0);\n\n    if (ag1.size() == 0 || ag1 == null) \n        return ag2.get(0);\n\n    if (ag2.size() == 0 || ag2 == null) \n        return ag1.get(0);\n\n    if (p1.getNombre().compareTo(p2.getNombre()) &lt;= 0)\n        return ag1.get(0);\n\n    return ag2.get(0);\n}\n</code></pre> <ul> <li>(b) (3,5 puntos) Desarrolle el m\u00e9todo <code>Agregar</code>, que recibe dos listas y devuelve una lista ordenada que agregue los objetos <code>PalabraContador</code> de los par\u00e1metros de entrada. En concreto, calcula el valor de cada palabra en cada mitad en el documento. Este m\u00e9todo puede usar <code>Menor</code>, pero no es obligatorio. </li> </ul> <pre><code>public java.util.List&lt;ContadorPalabra&gt; Agregar(\njava.util.List&lt;ContadorPalabra&gt; ag1,\njava.util.List&lt;ContadorPalabra&gt; ag2))\n{ . . . }\n</code></pre> <p>Ejemplo: Los dos par\u00e1metros de entrada de <code>Agregar</code> o <code>Menor</code> podr\u00edan ser: <pre><code>Ag1 = { [\u201cadi\u00f3s\u201d, 3], [\u201cbueno\u201d, 1], [\u201chola\u201d, 2], [\u201cmalo\u201d, 4] }\nAg2 = { [\u201cadi\u00f3s\u201d, 4], [\u201cbueno\u201d, 7], [\u201cmalo\u201d, 2] }\n</code></pre></p> <p>La salida del m\u00e9todo <code>agregar</code> ser\u00eda: <pre><code>agregar = { [\u201cadi\u00f3s\u201d, 7], [\u201cbueno\u201d, 8], [\u201chola\u201d, 2], [\u201cmalo\u201d, 6] }\n</code></pre></p> <p>A continuaci\u00f3n se muestran algunos m\u00e9todos relevantes de la colecci\u00f3n <code>List</code>.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public java.util.List&lt;ContadorPalabra&gt; Agregar() {\n    ContadorPalabra min;\n    java.util.List&lt;ContadorPalabra&gt; agregado =\n        new java.util.ArrayList&lt;ContadorPalabra&gt;();\n\n    while ((ag1.size() != 0) || (ag2.size() != 0)) {\n        min = Menor(ag1, ag2);\n        ContadorPalabra aux = null;\n\n        if (ag1.size() &gt; 0) {\n            if (min.getNombre() == ag1.get(0).getNombre()) {\n                if (aux == null) {\n                    aux = ag1.remove(0);\n                }\n            }\n        }\n\n        if (ag2.size() &gt; 0) {\n            if (min.getNombre() == ag2.get(0).getNombre()) {\n                if (aux == null) {\n                    aux = ag2.remove(0);\n                } else {\n                    aux.setContador(\n                        aux.getContador() + ag2.get(0).getContador()\n                    );\n                    ag2.remove(0);\n                }\n            }\n        }\n\n        agregado.add(aux);\n    }\n    return agregado;\n}\n</code></pre>"},{"location":"exams/2021/p1r/#problema-2","title":"Problema 2","text":"<p>Se quiere desarrollar un sistema para calcular de forma eficiente las notas medias en la UPM a diferentes niveles. Nos interesan las notas medias a nivel de asignatura, a nivel de Escuela, y a nivel de Universidad. Se quiere que cada vez que se publique la nota de una asignatura se recalculen las medias a nivel de Escuela y Universidad, sin realizar operaciones innecesarias.</p> <p>Para ello, utilizaremos una estructura de \u00e1rbol de 3 niveles:</p> <ul> <li>El nodo ra\u00edz es la universidad (UPM).</li> <li>El nodo ra\u00edz (UPM) tiene un hijo por cada escuela (p.e., ETSIT, ETSAM).</li> <li>Cada escuela tiene un hijo por cada asignatura que se imparte en esa escuela (p.e., ADSW, CORE).</li> <li>Cada nodo tiene una referencia a todos sus hijos (<code>this.hijos</code>), y a su nodo padre (<code>this.padre</code>, que ser\u00e1 <code>null</code> para el nodo ra\u00edz).</li> </ul> <p>Inicialmente se propone una estrategia de carga ansiosa (eager loading), en la que cada vez que se actualiza una nota de una asignatura se actualizan las medias de todos los nodos necesarios.</p> <p>Se considera que actualizar un nodo es necesario cuando alguno de sus descendientes ha sido modificado desde el \u00faltimo c\u00e1lculo.</p> <p>Cada <code>Nodo</code> tiene los siguientes atributos:</p> <p></p> <p>Sea <code>E</code> el n\u00famero de escuelas, y <code>A</code> el n\u00famero de asignaturas, suponiendo que la distribuci%n de asignaturas por escuela es uniforme, se pide:</p> <ul> <li>(a) (2,5 puntos) Implementar los algoritmos para modificar y recuperar la nota media de un nodo para la estrategia de carga ansiosa, utilizando las siguientes firmas: <pre><code>void setNota(float nota, int peso) { // a rellenar por el alumno }\nfloat getNota() { // a rellenar por el alumno }\n</code></pre></li> </ul> Mostra soluci\u00f3n <pre><code>public float getNota() {\n    return this.nota;\n}\n\n/* \n * Actualiza la nota de este nodo y recalcula los antecesores.\n */\npublic void setNota(float nota, int peso) {\n    // Se podr\u00eda a\u00f1adir l\u00f3gica para solo modificar la nota\n    // de las Asignaturas, no del resto de nodos.\n    this.peso = peso;\n    this.nota = nota;\n\n    if (this.padre != null) {\n        recalcular(this.padre);\n    }\n}\n\npublic static void recalcular(Nodo raiz) {\n    float media = 0;\n    int peso = 0;\n\n    for (Nodo hijo : raiz.hijos) {\n        media += hijo.peso * hijo.nota;\n        peso += hijo.peso;\n    }\n\n    media = media / peso;\n    raiz.nota = media;\n    raiz.peso = peso;\n    raiz.actualizado = true;\n\n    if (raiz.padre != null) {\n        recalcular(raiz.padre);\n    }\n}\n</code></pre> <p>En el enunciado no se especifica el rol del peso, as\u00ed que se dan por v\u00e1lidas las soluciones que asumen el mismo peso para todos los nodos.</p> <ul> <li>(b) (0,5 puntos) Los algoritmos implementados, \u00bfSon recursivos o iterativos?.</li> </ul> Mostra soluci\u00f3n <p>La implementaci\u00f3n de <code>setNota</code> se basa en el m\u00e9todo calcular, que es recursivo. Se podr\u00eda implementar de manera iterativa.</p> <ul> <li>(c) (0,5 puntos) Estimar la complejidad de modificar la nota de 1 sola asignatura, y de modificar todas las asignaturas, en funci\u00f3n de <code>A</code> y <code>E</code>.</li> </ul> Mostra soluci\u00f3n <p>Al actualizar una asignatura, se debe recalcular la nota de la escuela, y luego de la universidad. Habr\u00e1 <code>A/E</code> asignaturas por escuela (distribuci\u00f3n uniforme). Por tanto:</p> <p>\\(O(setNota() = O(A/E + E)\\)</p> <p>\\(O(setNotaTodas) = O(A * (A/E + E))\\)</p> <p>Por completitud, la complejidad de consultar una nota es constante (ya se calcula en el `setNota).</p> <p>Para mejorar el rendimiento, se propone comparar la estrategia anterior con otra de carga perezosa (lazy loading), en la que s\u00f3lo se actualizan las notas necesarias al acceder a una nota desactualizada.</p> <ul> <li>(d) (0,5 puntos) Estime la complejidad de modificar 1 sola asignatura, y de modificar todas las asignaturas, para el caso de carga perezosa, en funci\u00f3n de <code>A</code> y <code>E</code>.</li> </ul> Mostra soluci\u00f3n <p>Con carga perezosa, cuando se modifica una nota se marcan los nodos superiores al nodo a actualizar como desactualizados. Esa operaci\u00f3n para cada asignatura depende s\u00f3lo del n\u00famero de niveles (en este caso, 3). Por tanto:</p> <p>\\(O(setNota() = O(1)\\)</p> <p>\\(O(setNotaTodas) = O(A)\\), es decir, \\(A * O(setNota1)\\)</p> <p>Aunque no se especifica en el enunciado, la complejidad de <code>getNota(UPM)</code> para esta estrategia tras haber modificado 1 o TODAS las notas, ser\u00eda:</p> <p>\\(O(getNota1(UPM)) = O((A/E) + E)\\), s\u00f3lo recalcula una de las ramas del \u00e1rbol.</p> <p>\\(O(getNotatodas) = O(A + E)\\), recalcula todos los nodos</p> <ul> <li>(e) (1 punto) En lugar de tener 3 niveles (universidad, escuela, asignatura), se modifica el \u00e1rbol para que sea un \u00e1rbol binario perfectamente balanceado (cada nodo padre tiene exactamente 2 hijos). Calcule la complejidad de acceder a la nota UPM para el caso de carga perezosa tras cambiar una sola asignatura, en funci\u00f3n de <code>A</code>.</li> </ul> Mostra soluci\u00f3n <p>Como hemos visto en el anterior apartado, la diferencia es que en un caso recalcula una rama, y en el otro recalcula el \u00e1rbol entero.</p> <p>En este caso, tendremos que calcular el n&amp;mero de niveles. Al tratarse de un \u00e1rbol binario, con un n\u00famero de hojas <code>A</code>, el n\u00famero de niveles ser\u00e1 \\(log2(A)\\).</p> <p>El n\u00famero total de nodos ser\u00e1 la suma de nodos en cada uno de los niveles:</p> <p>\\(N = A + A/2 + A/4 + ' 1 ~= 2*A\\)</p> <p>\\(O(getNota1(UPM)) = O(log(A))\\), en cada nodo se suman los dos nodos inferiores.</p> <p>\\(O(getNotaTodas) = O(N) = O(A)\\).</p>"},{"location":"exams/2021/p1r_ex01/","title":"P1r ex01","text":"<p>Se quiere desarrollar un programa que analice un documento de texto y calcule el n!mero de veces que aparece cada palabra (<code>String</code>). El resultado es una lista de <code>ContadorPalabra</code>, que es una clase que se muestra a continuaci\u00f3n:</p> <pre><code>public class ContadorPalabra {\n    String nombre; // Nombre en el documento\n    int contador; //N\u00fam. de veces que aparece\n    ...\n    // Est\u00e1n disponibles los getters y setters\n}\n</code></pre> <p>En una fase inicial del programa, se crean dos hebras que analizan una mitad del documento. El resultado de cada hebra es una lista (<code>java.util.List&lt;ContadorPalabra&gt;</code>), con el contador de cada palabra de la mitad correspondiente. Los elementos de cada lista est\u00e1n ordenados por el atributo nombre de cada <code>ContadorPalabra</code>.</p> <p>En este ejercicio, se quiere desarrollar un m\u00e9todo para agregar las dos listas generadas de cada mitad. Se pide:</p> <ul> <li>(a) (1,5 puntos) Desarrolle el m\u00e9todo <code>Menor</code>, que recibe dos listas ordenadas y retorna el <code>ContadorPalabra</code> con la menor palabra en cualquiera de las dos mitades. </li> </ul> <pre><code>public ContadorPalabra Menor (\n    java.util.List&lt;ContadorPalabra&gt; ag1,\n    java.util.List&lt;ContadorPalabra&gt; ag2) { . . . }\n</code></pre> Mostrar soluci\u00f3n <pre><code>public ContadorPalabra Menor(\n        java.util.List&lt;ContadorPalabra&gt; ag1,\n        java.util.List&lt;ContadorPalabra&gt; ag2) {\n\n    ContadorPalabra p1 = ag1.get(0);\n    ContadorPalabra p2 = ag2.get(0);\n\n    if (ag1.size() == 0 || ag1 == null) \n        return ag2.get(0);\n\n    if (ag2.size() == 0 || ag2 == null) \n        return ag1.get(0);\n\n    if (p1.getNombre().compareTo(p2.getNombre()) &lt;= 0)\n        return ag1.get(0);\n\n    return ag2.get(0);\n}\n</code></pre> <ul> <li>(b) (3,5 puntos) Desarrolle el m\u00e9todo <code>Agregar</code>, que recibe dos listas y devuelve una lista ordenada que agregue los objetos <code>PalabraContador</code> de los par\u00e1metros de entrada. En concreto, calcula el valor de cada palabra en cada mitad en el documento. Este m\u00e9todo puede usar <code>Menor</code>, pero no es obligatorio. </li> </ul> <pre><code>public java.util.List&lt;ContadorPalabra&gt; Agregar(\njava.util.List&lt;ContadorPalabra&gt; ag1,\njava.util.List&lt;ContadorPalabra&gt; ag2))\n{ . . . }\n</code></pre> <p>Ejemplo: Los dos par\u00e1metros de entrada de <code>Agregar</code> o <code>Menor</code> podr\u00edan ser: <pre><code>Ag1 = { [\u201cadi\u00f3s\u201d, 3], [\u201cbueno\u201d, 1], [\u201chola\u201d, 2], [\u201cmalo\u201d, 4] }\nAg2 = { [\u201cadi\u00f3s\u201d, 4], [\u201cbueno\u201d, 7], [\u201cmalo\u201d, 2] }\n</code></pre></p> <p>La salida del m\u00e9todo <code>agregar</code> ser\u00eda: <pre><code>agregar = { [\u201cadi\u00f3s\u201d, 7], [\u201cbueno\u201d, 8], [\u201chola\u201d, 2], [\u201cmalo\u201d, 6] }\n</code></pre></p> <p>A continuaci\u00f3n se muestran algunos m\u00e9todos relevantes de la colecci\u00f3n <code>List</code>.</p> <p></p> Mostrar soluci\u00f3n <pre><code>public java.util.List&lt;ContadorPalabra&gt; Agregar() {\n    ContadorPalabra min;\n    java.util.List&lt;ContadorPalabra&gt; agregado =\n        new java.util.ArrayList&lt;ContadorPalabra&gt;();\n\n    while ((ag1.size() != 0) || (ag2.size() != 0)) {\n        min = Menor(ag1, ag2);\n        ContadorPalabra aux = null;\n\n        if (ag1.size() &gt; 0) {\n            if (min.getNombre() == ag1.get(0).getNombre()) {\n                if (aux == null) {\n                    aux = ag1.remove(0);\n                }\n            }\n        }\n\n        if (ag2.size() &gt; 0) {\n            if (min.getNombre() == ag2.get(0).getNombre()) {\n                if (aux == null) {\n                    aux = ag2.remove(0);\n                } else {\n                    aux.setContador(\n                        aux.getContador() + ag2.get(0).getContador()\n                    );\n                    ag2.remove(0);\n                }\n            }\n        }\n\n        agregado.add(aux);\n    }\n    return agregado;\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2021/p1r_ex02/","title":"P1r ex02","text":"<p>Se quiere desarrollar un sistema para calcular de forma eficiente las notas medias en la UPM a diferentes niveles. Nos interesan las notas medias a nivel de asignatura, a nivel de Escuela, y a nivel de Universidad. Se quiere que cada vez que se publique la nota de una asignatura se recalculen las medias a nivel de Escuela y Universidad, sin realizar operaciones innecesarias.</p> <p>Para ello, utilizaremos una estructura de \u00e1rbol de 3 niveles:</p> <ul> <li>El nodo ra\u00edz es la universidad (UPM).</li> <li>El nodo ra\u00edz (UPM) tiene un hijo por cada escuela (p.e., ETSIT, ETSAM).</li> <li>Cada escuela tiene un hijo por cada asignatura que se imparte en esa escuela (p.e., ADSW, CORE).</li> <li>Cada nodo tiene una referencia a todos sus hijos (<code>this.hijos</code>), y a su nodo padre (<code>this.padre</code>, que ser\u00e1 <code>null</code> para el nodo ra\u00edz).</li> </ul> <p>Inicialmente se propone una estrategia de carga ansiosa (eager loading), en la que cada vez que se actualiza una nota de una asignatura se actualizan las medias de todos los nodos necesarios.</p> <p>Se considera que actualizar un nodo es necesario cuando alguno de sus descendientes ha sido modificado desde el \u00faltimo c\u00e1lculo.</p> <p>Cada <code>Nodo</code> tiene los siguientes atributos:</p> <p></p> <p>Sea <code>E</code> el n\u00famero de escuelas, y <code>A</code> el n\u00famero de asignaturas, suponiendo que la distribuci%n de asignaturas por escuela es uniforme, se pide:</p> <ul> <li>(a) (2,5 puntos) Implementar los algoritmos para modificar y recuperar la nota media de un nodo para la estrategia de carga ansiosa, utilizando las siguientes firmas: <pre><code>void setNota(float nota, int peso) { // a rellenar por el alumno }\nfloat getNota() { // a rellenar por el alumno }\n</code></pre></li> </ul> Mostra soluci\u00f3n <pre><code>public float getNota() {\n    return this.nota;\n}\n\n/* \n * Actualiza la nota de este nodo y recalcula los antecesores.\n */\npublic void setNota(float nota, int peso) {\n    // Se podr\u00eda a\u00f1adir l\u00f3gica para solo modificar la nota\n    // de las Asignaturas, no del resto de nodos.\n    this.peso = peso;\n    this.nota = nota;\n\n    if (this.padre != null) {\n        recalcular(this.padre);\n    }\n}\n\npublic static void recalcular(Nodo raiz) {\n    float media = 0;\n    int peso = 0;\n\n    for (Nodo hijo : raiz.hijos) {\n        media += hijo.peso * hijo.nota;\n        peso += hijo.peso;\n    }\n\n    media = media / peso;\n    raiz.nota = media;\n    raiz.peso = peso;\n    raiz.actualizado = true;\n\n    if (raiz.padre != null) {\n        recalcular(raiz.padre);\n    }\n}\n</code></pre> <p>En el enunciado no se especifica el rol del peso, as\u00ed que se dan por v\u00e1lidas las soluciones que asumen el mismo peso para todos los nodos.</p> <ul> <li>(b) (0,5 puntos) Los algoritmos implementados, \u00bfSon recursivos o iterativos?.</li> </ul> Mostra soluci\u00f3n <p>La implementaci\u00f3n de <code>setNota</code> se basa en el m\u00e9todo calcular, que es recursivo. Se podr\u00eda implementar de manera iterativa.</p> <ul> <li>(c) (0,5 puntos) Estimar la complejidad de modificar la nota de 1 sola asignatura, y de modificar todas las asignaturas, en funci\u00f3n de <code>A</code> y <code>E</code>.</li> </ul> Mostra soluci\u00f3n <p>Al actualizar una asignatura, se debe recalcular la nota de la escuela, y luego de la universidad. Habr\u00e1 <code>A/E</code> asignaturas por escuela (distribuci\u00f3n uniforme). Por tanto:</p> <p>\\(O(setNota() = O(A/E + E)\\)</p> <p>\\(O(setNotaTodas) = O(A * (A/E + E))\\)</p> <p>Por completitud, la complejidad de consultar una nota es constante (ya se calcula en el `setNota).</p> <p>Para mejorar el rendimiento, se propone comparar la estrategia anterior con otra de carga perezosa (lazy loading), en la que s\u00f3lo se actualizan las notas necesarias al acceder a una nota desactualizada.</p> <ul> <li>(d) (0,5 puntos) Estime la complejidad de modificar 1 sola asignatura, y de modificar todas las asignaturas, para el caso de carga perezosa, en funci\u00f3n de <code>A</code> y <code>E</code>.</li> </ul> Mostra soluci\u00f3n <p>Con carga perezosa, cuando se modifica una nota se marcan los nodos superiores al nodo a actualizar como desactualizados. Esa operaci\u00f3n para cada asignatura depende s\u00f3lo del n\u00famero de niveles (en este caso, 3). Por tanto:</p> <p>\\(O(setNota() = O(1)\\)</p> <p>\\(O(setNotaTodas) = O(A)\\), es decir, \\(A * O(setNota1)\\)</p> <p>Aunque no se especifica en el enunciado, la complejidad de <code>getNota(UPM)</code> para esta estrategia tras haber modificado 1 o TODAS las notas, ser\u00eda:</p> <p>\\(O(getNota1(UPM)) = O((A/E) + E)\\), s\u00f3lo recalcula una de las ramas del \u00e1rbol.</p> <p>\\(O(getNotatodas) = O(A + E)\\), recalcula todos los nodos</p> <ul> <li>(e) (1 punto) En lugar de tener 3 niveles (universidad, escuela, asignatura), se modifica el \u00e1rbol para que sea un \u00e1rbol binario perfectamente balanceado (cada nodo padre tiene exactamente 2 hijos). Calcule la complejidad de acceder a la nota UPM para el caso de carga perezosa tras cambiar una sola asignatura, en funci\u00f3n de <code>A</code>.</li> </ul> Mostra soluci\u00f3n <p>Como hemos visto en el anterior apartado, la diferencia es que en un caso recalcula una rama, y en el otro recalcula el \u00e1rbol entero.</p> <p>En este caso, tendremos que calcular el n&amp;mero de niveles. Al tratarse de un \u00e1rbol binario, con un n\u00famero de hojas <code>A</code>, el n\u00famero de niveles ser\u00e1 \\(log2(A)\\).</p> <p>El n\u00famero total de nodos ser\u00e1 la suma de nodos en cada uno de los niveles:</p> <p>\\(N = A + A/2 + A/4 + ' 1 ~= 2*A\\)</p> <p>\\(O(getNota1(UPM)) = O(log(A))\\), en cada nodo se suman los dos nodos inferiores.</p> <p>\\(O(getNotaTodas) = O(N) = O(A)\\).</p>","tags":["grafos"]},{"location":"exams/2021/p2/","title":"Examen 2021 \u2014 Parcial 2","text":""},{"location":"exams/2021/p2/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar una clase monitora <code>TorreControl</code> para gestionar una \u00fanica pista de aterrizaje de un aeropuerto, con acceso exclusivo por parte de objetos de la clase <code>Avion</code>, que ser\u00e1n las hebras. Los aviones pueden pedir a la torre de control aterrizar y despegar. Se pide desarrollar los siguientes m\u00e9todos:</p> <p></p> <ul> <li> <p>(a) (1,5 puntos) <code>public ... void avisoAterrizaje(Avion unAvion)</code>: Para la maniobra de aterrizaje, los aviones primero avisar\u00e1n a la torre de control (con este m\u00e9todo) de su intenci\u00f3n de aterrizar y despu\u00e9s preguntar\u00e1n por el permiso para poder aterrizar. Cuando la torre de control reciba un aviso de aterrizaje deber\u00e1 a\u00f1adir el avi\u00f3n que solicit\u00f3 el permiso a una lista. Esta lista se ordenar\u00e1 por el combustible que tengan los aviones, siendo el que tenga menos combustible el primero de la lista y el primero en aterrizar (en caso de haber dos aviones con el mismo combustible ser\u00e1 indiferente el orden de aterrizaje entre ellos).</p> </li> <li> <p>(b) (2 puntos) <code>public ... void permisoAterrizaje(Avion unAvion)</code>: Un avi\u00f3n invoca este m\u00e9todo para pedir permiso para aterrizar. Cuando la torre de control reciba la llamada de permiso de aterrizaje entonces solo dejar\u00e1 aterrizar al avi\u00f3n si lo tiene guardado en la lista de menos combustible y si la pista est\u00e1 libre. </p> </li> <li> <p>(c) (1,5 puntos) <code>public ... void permisoDespegue(Avion unAvion)</code>: Para la maniobra de despegue los aviones pedir\u00e1n permiso para despegar. Se supone que todos los aviones tienen el m\u00e1ximo de combustible y no hay prioridad, as\u00ed que cuando pidan despegar podr\u00e1n hacerlo siempre y cuando la pista est# libre.</p> </li> </ul> <p>Aclaraciones sobre el ejercicio:</p> <ul> <li> <p>En la clase <code>TorreControl</code> se controla cu\u00e1ndo la pista est\u00e1 ocupada o libre. La pista estar\u00e1 ocupada cuando un avi\u00f3n ha recibido permiso a trav\u00e9s de los m\u00e9todos <code>permisoAterrizaje</code> o <code>permisoDespegue</code>. La pista se debe marcar como ocupada dentro de este m\u00e9todo cuando un avi\u00f3n tiene permiso y se mantiene as\u00ed en un tiempo, representado como <code>Thread.sleep(random.nextInt(5000))</code>. Al expirar este temporizador, la pista se marcar\u00e1 como libre.</p> </li> <li> <p>Para simplificar este ejercicio, se supone que un avi\u00f3n mantiene constante su nivel de combustible, desde que notifica su intenci\u00f3n de aterrizar (con el m\u00e9todo <code>avisoAterrizaje</code>) hasta que recibe el permiso (con el m\u00e9todo <code>permisoAterrizaje</code>).</p> </li> <li> <p>Se dispone un m\u00e9todo (no es necesario implementarlo) que recibe una lista de aviones y retorna una lista de aviones ordenada de menor a mayor por el combustible del avi\u00f3n: <code>List&lt;Avion&gt; ordenarAvionesPorCompustible(List&lt;Avion&gt; listaAviones))</code>.</p> </li> </ul> <pre><code>// Ejemplo del posible c\u00f3digo de una hebra de la clase Avion\n\npublic class Avion extends Thread {\n\n    private TorreControl miTorre;\n    private int combustible;\n    private String matricula;\n\n    public Avion(TorreControl miTorre, String matricula, int combustible) {\n        this.miTorre = miTorre;\n        this.matricula = matricula;\n        this.combustible = combustible;\n    }\n\n    public int getCombustible() {\n        return this.combustible;\n    }\n\n    public String getMatricula() {\n        return this.matricula;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                this.miTorre.avisoAterrizaje(this);\n                this.miTorre.permisoAterrizaje(this);\n                this.miTorre.permisoDespegue(this);\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre> <pre><code>public static void main(String[] args) throws Exception {\n\n    TorreControl tc = new TorreControl(\"Barajas\");\n\n    new Avion(tc, \"aaa\", 30).start();\n    new Avion(tc, \"bbb\", 10).start();\n    new Avion(tc, \"ccc\", 20).start();\n    new Avion(tc, \"ddd\", 50).start();\n    new Avion(tc, \"eee\", 5).start();\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>import java.util.*;\n\npublic class TorreControl {\n\n    private String nombre;\n    private List&lt;Avion&gt; listaAterrizaje = new ArrayList&lt;Avion&gt;();\n    private volatile boolean pistaOcupada = false;\n    private Random random = new Random();\n\n    public TorreControl(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public synchronized void avisoAterrizaje(Avion miAvion) {\n        listaAterrizaje.add(miAvion);\n        // Se ha elegido esta forma de ordenaci\u00f3n pero puede hacerse de varias formas.\n        Collections.sort(this.listaAterrizaje, new OrdenarPorCombustible());\n        System.out.println(\n            \"Torre control - A\u00f1adido avi\u00f3n a la lista ordenada. \"\n            + this.listaAterrizaje.toString()\n        );\n    }\n\n    public synchronized void permisoAterrizaje(Avion miAvion) {\n        try {\n            System.out.println(\n                \"Torre control - Primer avi\u00f3n en lista: \"\n                + this.listaAterrizaje.get(0).toString()\n            );\n\n            while ((this.pistaOcupada == true) ||\n                   (listaAterrizaje.get(0) != miAvion)) {\n                wait();\n            }\n\n            this.pistaOcupada = true;\n            System.out.println(\n                \"Torre control - \"\n                + miAvion.toString()\n                + \" Aterrizando (regi\u00f3n cr\u00edtica).\"\n            );\n\n            // Duerme entre 0 y 5 seg. para simular el uso de la pista\n            Thread.sleep(random.nextInt(10000));\n\n            this.pistaOcupada = false;\n            listaAterrizaje.remove(0);\n            notifyAll();\n\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    public synchronized void permisoDespegue(Avion miAvion) {\n        try {\n            while (this.pistaOcupada == true) {\n                wait();\n            }\n\n            this.pistaOcupada = true;\n            System.out.println(\n                \"Torre control - \"\n                + miAvion.toString()\n                + \" Despegando (regi\u00f3n cr\u00edtica).\"\n            );\n\n            // Duerme entre 0 y 5 seg. para simular el uso de la pista\n            Thread.sleep(random.nextInt(10000));\n\n            this.pistaOcupada = false;\n            notifyAll();\n\n        } catch (InterruptedException ignored) {\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2021/p2/#problema-2","title":"Problema 2","text":"<p>Se desea implementar un sistema que simule un conjunto de jugadores de un equipo de f\u00fatbol americano, que est\u00e1n sedientos, y una persona que actuar\u00e1 como aguador. Cada jugador se encargar\u00e1 peri\u00f3dicamente de extraer un vaso de una lista de vasos compartida, y de llenarlo de agua de una botella tambi\u00e9n compartida. El aguador comprobar\u00e1 continuamente que haya disponibles vasos y agua en la botella, rellenando ambos en caso contrario. Tanto los jugadores como el aguador tienen que poder trabajar de forma concurrente.</p> <p>Se incluye la implementaci\u00f3n de las clases necesarias, adem\u00e1s del m\u00e9todo <code>ExtraordinarioP2.main</code>, que permite probar el programa con 20 jugadores y un aguador. </p> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n\npublic class ExtraordinarioP2 {\n\n    public static void main(String[] args) {\n        Botella botella = new Botella();\n        botella.litros = 100;\n\n        List&lt;Vaso&gt; vasos = new ArrayList&lt;Vaso&gt;();\n\n        Aguador aguador = new Aguador(botella, vasos);\n        aguador.start();\n\n        for (int i = 0; i &lt; 20; i++) {\n            Jugador jugador = new Jugador(botella, vasos);\n            jugador.start();\n        }\n    }\n}\n</code></pre> <pre><code>public class Vaso {\n    Integer capacidad;\n\n    public Vaso(int capacidad) {\n        this.capacidad = capacidad;\n    }\n}\n</code></pre> <pre><code>public class Botella {\n    Integer litros;\n}\n</code></pre> <pre><code>import java.util.List;\n\nclass Aguador extends Thread {\n\n    private Botella botella;\n    private List&lt;Vaso&gt; vasos;\n\n    public Aguador(Botella botella, List&lt;Vaso&gt; vasos) {\n        this.botella = botella;\n        this.vasos = vasos;\n    }\n\n    /*\n     * El aguador rellena la botella de agua, y pone vasos nuevos.\n     */\n    public void run() {\n        while (true) {\n            synchronized (this.botella) {\n                if (this.botella.litros &lt; 1) {\n                    System.out.println(\"Aguador rellena botella\");\n                    this.botella.litros = 10;\n                }\n            }\n\n            synchronized (this.vasos) {\n                if (this.vasos.size() &lt; 1) {\n                    for (int i = 0; i &lt; 10; i++) {\n                        this.vasos.add(new Vaso(1));\n                    }\n                    System.out.println(\"Aguador a\u00f1ade vaso\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>import java.util.List;\n\nclass Jugador extends Thread {\n\n    private Botella botella;\n    private List&lt;Vaso&gt; vasos;\n\n    public Jugador(Botella botella, List&lt;Vaso&gt; vasos) {\n        this.botella = botella;\n        this.vasos = vasos;\n    }\n\n    /*\n     * Cada jugador extrae un vaso, lo llena de agua y bebe.\n     */\n    public void run() {\n        Vaso vaso = null;\n\n        while (true) {\n            try {\n                System.out.println(\"Jugador intenta beber\");\n\n                synchronized (this.vasos) {\n                    if (this.vasos.size() &lt; 1) {\n                        continue;\n                    }\n                    if (vaso == null) {\n                        vaso = this.vasos.remove(0);\n                        System.out.println(\"Jugador ha cogido vaso\");\n                    }\n                }\n\n                synchronized (this.botella) {\n                    if (this.botella.litros &lt; vaso.capacidad) {\n                        continue;\n                    }\n                    Thread.sleep(500);\n                    this.botella.litros -= vaso.capacidad;\n                    System.out.println(\"Jugador ha bebido\");\n                }\n\n                // Tira el vaso\n                vaso = null;\n\n                Thread.sleep(6000);\n\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre> <p>Nota: Se recuerda que un bloque <code>synchronized</code> se asocia al objeto en el par\u00e1metro. Se garantiza exclusi\u00f3n mutua entre los bloques sincronizados que se invocan con el mismo objeto.</p> <ul> <li>(a) (2 puntos) \u00bfExiste alg\u00fan problema de acceso concurrente en esta implementaci\u00f3n? Si es as\u00ed, \u00bfDe qu\u00e9 tipo es? Justifique su respuesta.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed existe. Hay bloqueo exclusivo de los recursos, con espera, y en orden inverso: <code>Aguador</code> bloquea <code>botella</code> y luego <code>vasos</code>, mientras que <code>Jugador</code> bloquea los <code>vasos</code> primero.</p> <ul> <li>(b) (1 punto) Si existiera alg\u00fan problema \u00bfC\u00f3mo lo solucionar\u00eda?</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n m\u00e1s sencilla es invertir el orden del bloqueo en <code>Aguador</code> o en <code>Jugador</code>. Analizando el c\u00f3digo vemos que no se necesita bloquear sobre ambos recursos a la vez, as\u00ed que una mejor soluci\u00f3n ser\u00eda separar las dos regiones cr\u00edticas: primero bloquear <code>vasos</code>, acabar el bloque, y luego bloquear la <code>botella</code> (o viceversa).</p> <ul> <li>(c) (1 punto) Los <code>vasos</code> tienen una capacidad de 1 litro. Sin modificar la implementaci\u00f3n de <code>Jugador</code>, \u00bfCu\u00e1l es el n\u00famero m\u00e1ximo de jugadores que podr\u00edan beber por minuto?</li> </ul> Mostrar soluci\u00f3n <p>Nos piden el m\u00e1ximo, con lo que usaremos el caso mejor. Para que un jugador pueda beber, tiene que haber bloqueado los vasos (500ms de espera) y luego la botella (1000ms). Ese es el m\u00ednimo tiempo necesario por jugador, y durante el cual los recursos est\u00e1n bloqueados. El tiempo de espera tras beber no afecta, porque se puede aumentar el n\u00famero de jugadores.</p> <p>Por tanto, el n\u00famero m\u00e1ximo de jugadores ser\u00eda 60s/ (1.5s/1 jugador) = 40 jugadores.</p> <p>Para este m\u00e1ximo, hemos supuesto que el tiempo de procesamiento (bloqueo) por el aguador, el de las operaciones b\u00e1sicas y el consumido por los cambios de contexto son despreciables.</p> <p>Se podr\u00eda aumentar el n\u00famero de jugadores por minuto separando los dos bloques <code>synchronized</code> (ver respuesta anterior), de forma que el tiempo de espera se reparta entre los dos elementos. De esa forma, el primer jugador tardar\u00eda 1.5s en beber, pero los siguientes podr\u00edan tardar s\u00f3lo 1s (la espera sobre los vasos puede darse a la vez que la espera sobre la botella). En ese caso, en el primer minuto podr\u00eda haber 59 jugadores, y 60 en los siguientes.</p> <p>Si se considera que NO se puede aumentar el n\u00famero de jugadores en ExtraordinarioP2, el n\u00famero m\u00e1ximo ser\u00eda 20 (es el n\u00famero de jugadores que a\u00f1adimos), que podr\u00edan llegar a beber 2 veces en ese minuto (20 jugadores tardan 30 segundos en completar, que es menor que el tiempo de espera post-bebida).</p> <ul> <li>(d) (1 punto) Si se desease sustituir los bloques sincronizados por m\u00e9todos sincronizados \u00bfEn qu\u00e9 clase o clases los implementar\u00eda?</li> </ul> Mostrar soluci\u00f3n <p>Los m\u00e9todos sincronizados aplican un bloqueo sobre el objeto al que pertenecen. Por tanto, estos m\u00e9todos deben estar definidos sobre un objeto com\u00fan a todas las hebras. Esto descarta Jugador y Aguador. En este caso, el \u00fanico objeto compartido es Botella. Para bloquear sobre la lista de vasos, habr\u00eda que crear una clase que represente la lista.</p>"},{"location":"exams/2021/p2_ex01/","title":"P2 ex01","text":"<p>Se quiere desarrollar una clase monitora <code>TorreControl</code> para gestionar una \u00fanica pista de aterrizaje de un aeropuerto, con acceso exclusivo por parte de objetos de la clase <code>Avion</code>, que ser\u00e1n las hebras. Los aviones pueden pedir a la torre de control aterrizar y despegar. Se pide desarrollar los siguientes m\u00e9todos:</p> <p></p> <ul> <li> <p>(a) (1,5 puntos) <code>public ... void avisoAterrizaje(Avion unAvion)</code>: Para la maniobra de aterrizaje, los aviones primero avisar\u00e1n a la torre de control (con este m\u00e9todo) de su intenci\u00f3n de aterrizar y despu\u00e9s preguntar\u00e1n por el permiso para poder aterrizar. Cuando la torre de control reciba un aviso de aterrizaje deber\u00e1 a\u00f1adir el avi\u00f3n que solicit\u00f3 el permiso a una lista. Esta lista se ordenar\u00e1 por el combustible que tengan los aviones, siendo el que tenga menos combustible el primero de la lista y el primero en aterrizar (en caso de haber dos aviones con el mismo combustible ser\u00e1 indiferente el orden de aterrizaje entre ellos).</p> </li> <li> <p>(b) (2 puntos) <code>public ... void permisoAterrizaje(Avion unAvion)</code>: Un avi\u00f3n invoca este m\u00e9todo para pedir permiso para aterrizar. Cuando la torre de control reciba la llamada de permiso de aterrizaje entonces solo dejar\u00e1 aterrizar al avi\u00f3n si lo tiene guardado en la lista de menos combustible y si la pista est\u00e1 libre. </p> </li> <li> <p>(c) (1,5 puntos) <code>public ... void permisoDespegue(Avion unAvion)</code>: Para la maniobra de despegue los aviones pedir\u00e1n permiso para despegar. Se supone que todos los aviones tienen el m\u00e1ximo de combustible y no hay prioridad, as\u00ed que cuando pidan despegar podr\u00e1n hacerlo siempre y cuando la pista est# libre.</p> </li> </ul> <p>Aclaraciones sobre el ejercicio:</p> <ul> <li> <p>En la clase <code>TorreControl</code> se controla cu\u00e1ndo la pista est\u00e1 ocupada o libre. La pista estar\u00e1 ocupada cuando un avi\u00f3n ha recibido permiso a trav\u00e9s de los m\u00e9todos <code>permisoAterrizaje</code> o <code>permisoDespegue</code>. La pista se debe marcar como ocupada dentro de este m\u00e9todo cuando un avi\u00f3n tiene permiso y se mantiene as\u00ed en un tiempo, representado como <code>Thread.sleep(random.nextInt(5000))</code>. Al expirar este temporizador, la pista se marcar\u00e1 como libre.</p> </li> <li> <p>Para simplificar este ejercicio, se supone que un avi\u00f3n mantiene constante su nivel de combustible, desde que notifica su intenci\u00f3n de aterrizar (con el m\u00e9todo <code>avisoAterrizaje</code>) hasta que recibe el permiso (con el m\u00e9todo <code>permisoAterrizaje</code>).</p> </li> <li> <p>Se dispone un m\u00e9todo (no es necesario implementarlo) que recibe una lista de aviones y retorna una lista de aviones ordenada de menor a mayor por el combustible del avi\u00f3n: <code>List&lt;Avion&gt; ordenarAvionesPorCompustible(List&lt;Avion&gt; listaAviones))</code>.</p> </li> </ul> <pre><code>// Ejemplo del posible c\u00f3digo de una hebra de la clase Avion\n\npublic class Avion extends Thread {\n\n    private TorreControl miTorre;\n    private int combustible;\n    private String matricula;\n\n    public Avion(TorreControl miTorre, String matricula, int combustible) {\n        this.miTorre = miTorre;\n        this.matricula = matricula;\n        this.combustible = combustible;\n    }\n\n    public int getCombustible() {\n        return this.combustible;\n    }\n\n    public String getMatricula() {\n        return this.matricula;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                this.miTorre.avisoAterrizaje(this);\n                this.miTorre.permisoAterrizaje(this);\n                this.miTorre.permisoDespegue(this);\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre> <pre><code>public static void main(String[] args) throws Exception {\n\n    TorreControl tc = new TorreControl(\"Barajas\");\n\n    new Avion(tc, \"aaa\", 30).start();\n    new Avion(tc, \"bbb\", 10).start();\n    new Avion(tc, \"ccc\", 20).start();\n    new Avion(tc, \"ddd\", 50).start();\n    new Avion(tc, \"eee\", 5).start();\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>import java.util.*;\n\npublic class TorreControl {\n\n    private String nombre;\n    private List&lt;Avion&gt; listaAterrizaje = new ArrayList&lt;Avion&gt;();\n    private volatile boolean pistaOcupada = false;\n    private Random random = new Random();\n\n    public TorreControl(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public synchronized void avisoAterrizaje(Avion miAvion) {\n        listaAterrizaje.add(miAvion);\n        // Se ha elegido esta forma de ordenaci\u00f3n pero puede hacerse de varias formas.\n        Collections.sort(this.listaAterrizaje, new OrdenarPorCombustible());\n        System.out.println(\n            \"Torre control - A\u00f1adido avi\u00f3n a la lista ordenada. \"\n            + this.listaAterrizaje.toString()\n        );\n    }\n\n    public synchronized void permisoAterrizaje(Avion miAvion) {\n        try {\n            System.out.println(\n                \"Torre control - Primer avi\u00f3n en lista: \"\n                + this.listaAterrizaje.get(0).toString()\n            );\n\n            while ((this.pistaOcupada == true) ||\n                   (listaAterrizaje.get(0) != miAvion)) {\n                wait();\n            }\n\n            this.pistaOcupada = true;\n            System.out.println(\n                \"Torre control - \"\n                + miAvion.toString()\n                + \" Aterrizando (regi\u00f3n cr\u00edtica).\"\n            );\n\n            // Duerme entre 0 y 5 seg. para simular el uso de la pista\n            Thread.sleep(random.nextInt(10000));\n\n            this.pistaOcupada = false;\n            listaAterrizaje.remove(0);\n            notifyAll();\n\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    public synchronized void permisoDespegue(Avion miAvion) {\n        try {\n            while (this.pistaOcupada == true) {\n                wait();\n            }\n\n            this.pistaOcupada = true;\n            System.out.println(\n                \"Torre control - \"\n                + miAvion.toString()\n                + \" Despegando (regi\u00f3n cr\u00edtica).\"\n            );\n\n            // Duerme entre 0 y 5 seg. para simular el uso de la pista\n            Thread.sleep(random.nextInt(10000));\n\n            this.pistaOcupada = false;\n            notifyAll();\n\n        } catch (InterruptedException ignored) {\n        }\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2021/p2_ex02/","title":"P2 ex02","text":"<p>Se desea implementar un sistema que simule un conjunto de jugadores de un equipo de f\u00fatbol americano, que est\u00e1n sedientos, y una persona que actuar\u00e1 como aguador. Cada jugador se encargar\u00e1 peri\u00f3dicamente de extraer un vaso de una lista de vasos compartida, y de llenarlo de agua de una botella tambi\u00e9n compartida. El aguador comprobar\u00e1 continuamente que haya disponibles vasos y agua en la botella, rellenando ambos en caso contrario. Tanto los jugadores como el aguador tienen que poder trabajar de forma concurrente.</p> <p>Se incluye la implementaci\u00f3n de las clases necesarias, adem\u00e1s del m\u00e9todo <code>ExtraordinarioP2.main</code>, que permite probar el programa con 20 jugadores y un aguador. </p> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n\npublic class ExtraordinarioP2 {\n\n    public static void main(String[] args) {\n        Botella botella = new Botella();\n        botella.litros = 100;\n\n        List&lt;Vaso&gt; vasos = new ArrayList&lt;Vaso&gt;();\n\n        Aguador aguador = new Aguador(botella, vasos);\n        aguador.start();\n\n        for (int i = 0; i &lt; 20; i++) {\n            Jugador jugador = new Jugador(botella, vasos);\n            jugador.start();\n        }\n    }\n}\n</code></pre> <pre><code>public class Vaso {\n    Integer capacidad;\n\n    public Vaso(int capacidad) {\n        this.capacidad = capacidad;\n    }\n}\n</code></pre> <pre><code>public class Botella {\n    Integer litros;\n}\n</code></pre> <pre><code>import java.util.List;\n\nclass Aguador extends Thread {\n\n    private Botella botella;\n    private List&lt;Vaso&gt; vasos;\n\n    public Aguador(Botella botella, List&lt;Vaso&gt; vasos) {\n        this.botella = botella;\n        this.vasos = vasos;\n    }\n\n    /*\n     * El aguador rellena la botella de agua, y pone vasos nuevos.\n     */\n    public void run() {\n        while (true) {\n            synchronized (this.botella) {\n                if (this.botella.litros &lt; 1) {\n                    System.out.println(\"Aguador rellena botella\");\n                    this.botella.litros = 10;\n                }\n            }\n\n            synchronized (this.vasos) {\n                if (this.vasos.size() &lt; 1) {\n                    for (int i = 0; i &lt; 10; i++) {\n                        this.vasos.add(new Vaso(1));\n                    }\n                    System.out.println(\"Aguador a\u00f1ade vaso\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>import java.util.List;\n\nclass Jugador extends Thread {\n\n    private Botella botella;\n    private List&lt;Vaso&gt; vasos;\n\n    public Jugador(Botella botella, List&lt;Vaso&gt; vasos) {\n        this.botella = botella;\n        this.vasos = vasos;\n    }\n\n    /*\n     * Cada jugador extrae un vaso, lo llena de agua y bebe.\n     */\n    public void run() {\n        Vaso vaso = null;\n\n        while (true) {\n            try {\n                System.out.println(\"Jugador intenta beber\");\n\n                synchronized (this.vasos) {\n                    if (this.vasos.size() &lt; 1) {\n                        continue;\n                    }\n                    if (vaso == null) {\n                        vaso = this.vasos.remove(0);\n                        System.out.println(\"Jugador ha cogido vaso\");\n                    }\n                }\n\n                synchronized (this.botella) {\n                    if (this.botella.litros &lt; vaso.capacidad) {\n                        continue;\n                    }\n                    Thread.sleep(500);\n                    this.botella.litros -= vaso.capacidad;\n                    System.out.println(\"Jugador ha bebido\");\n                }\n\n                // Tira el vaso\n                vaso = null;\n\n                Thread.sleep(6000);\n\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }\n}\n</code></pre> <p>Nota: Se recuerda que un bloque <code>synchronized</code> se asocia al objeto en el par\u00e1metro. Se garantiza exclusi\u00f3n mutua entre los bloques sincronizados que se invocan con el mismo objeto.</p> <ul> <li>(a) (2 puntos) \u00bfExiste alg\u00fan problema de acceso concurrente en esta implementaci\u00f3n? Si es as\u00ed, \u00bfDe qu\u00e9 tipo es? Justifique su respuesta.</li> </ul> Mostrar soluci\u00f3n <p>S\u00ed existe. Hay bloqueo exclusivo de los recursos, con espera, y en orden inverso: <code>Aguador</code> bloquea <code>botella</code> y luego <code>vasos</code>, mientras que <code>Jugador</code> bloquea los <code>vasos</code> primero.</p> <ul> <li>(b) (1 punto) Si existiera alg\u00fan problema \u00bfC\u00f3mo lo solucionar\u00eda?</li> </ul> Mostrar soluci\u00f3n <p>La soluci\u00f3n m\u00e1s sencilla es invertir el orden del bloqueo en <code>Aguador</code> o en <code>Jugador</code>. Analizando el c\u00f3digo vemos que no se necesita bloquear sobre ambos recursos a la vez, as\u00ed que una mejor soluci\u00f3n ser\u00eda separar las dos regiones cr\u00edticas: primero bloquear <code>vasos</code>, acabar el bloque, y luego bloquear la <code>botella</code> (o viceversa).</p> <ul> <li>(c) (1 punto) Los <code>vasos</code> tienen una capacidad de 1 litro. Sin modificar la implementaci\u00f3n de <code>Jugador</code>, \u00bfCu\u00e1l es el n\u00famero m\u00e1ximo de jugadores que podr\u00edan beber por minuto?</li> </ul> Mostrar soluci\u00f3n <p>Nos piden el m\u00e1ximo, con lo que usaremos el caso mejor. Para que un jugador pueda beber, tiene que haber bloqueado los vasos (500ms de espera) y luego la botella (1000ms). Ese es el m\u00ednimo tiempo necesario por jugador, y durante el cual los recursos est\u00e1n bloqueados. El tiempo de espera tras beber no afecta, porque se puede aumentar el n\u00famero de jugadores.</p> <p>Por tanto, el n\u00famero m\u00e1ximo de jugadores ser\u00eda 60s/ (1.5s/1 jugador) = 40 jugadores.</p> <p>Para este m\u00e1ximo, hemos supuesto que el tiempo de procesamiento (bloqueo) por el aguador, el de las operaciones b\u00e1sicas y el consumido por los cambios de contexto son despreciables.</p> <p>Se podr\u00eda aumentar el n\u00famero de jugadores por minuto separando los dos bloques <code>synchronized</code> (ver respuesta anterior), de forma que el tiempo de espera se reparta entre los dos elementos. De esa forma, el primer jugador tardar\u00eda 1.5s en beber, pero los siguientes podr\u00edan tardar s\u00f3lo 1s (la espera sobre los vasos puede darse a la vez que la espera sobre la botella). En ese caso, en el primer minuto podr\u00eda haber 59 jugadores, y 60 en los siguientes.</p> <p>Si se considera que NO se puede aumentar el n\u00famero de jugadores en ExtraordinarioP2, el n\u00famero m\u00e1ximo ser\u00eda 20 (es el n\u00famero de jugadores que a\u00f1adimos), que podr\u00edan llegar a beber 2 veces en ese minuto (20 jugadores tardan 30 segundos en completar, que es menor que el tiempo de espera post-bebida).</p> <ul> <li>(d) (1 punto) Si se desease sustituir los bloques sincronizados por m\u00e9todos sincronizados \u00bfEn qu\u00e9 clase o clases los implementar\u00eda?</li> </ul> Mostrar soluci\u00f3n <p>Los m\u00e9todos sincronizados aplican un bloqueo sobre el objeto al que pertenecen. Por tanto, estos m\u00e9todos deben estar definidos sobre un objeto com\u00fan a todas las hebras. Esto descarta Jugador y Aguador. En este caso, el \u00fanico objeto compartido es Botella. Para bloquear sobre la lista de vasos, habr\u00eda que crear una clase que represente la lista.</p>","tags":["hebras"]},{"location":"exams/2021/p2r/","title":"Examen 2021 \u2014 Parcial 2 Recuperaci\u00f3n","text":""},{"location":"exams/2021/p2r/#problema-1","title":"Problema 1","text":"<p>El problema de los lectores/escritores est! planteado con un conjunto de hebras que comparten datos. Una parte de estas hebras (lectores) s\u00f3lo leen los datos, mientras que el resto (escritores) leen y escriben. Varios lectores pueden acceder simult\u00e1neamente a los datos compartidos, pero se debe evitar que mientras un escritor est\u00e1 accediendo a los datos acceda a ellos otra hebra de cualquier tipo.</p> <p>Las hebras correctas deben solicitar permiso para acceder los datos con <code>empiezaLeer</code> (lectores) o <code>empiezaEscribir</code> (escritores). Al terminar de usar los datos compartidos deben invocar a <code>terminaLeer</code> (lectores) o <code>terminaEscribir</code> (escritores). El acceso a los datos compartidos se hace fuera de este monitor. Si este protocolo para acceder a estos m\u00e9todos se satisface, se garantiza los requisitos del problema.</p> Modifier and Type Method Description void empiezaEscribir() M\u00e9todo que invoca una hebra escritora antes de comenzar a escribir void empiezaLeer() M\u00e9todo que invoca una hebra lectora antes de comenzar a leer void terminaEscribir() M\u00e9todo que invoca una hebra escritora al terminar de escribir void terminaLeer() M\u00e9todo que invoca una hebra lectora al terminar de leer <ul> <li>(a) (2,5 puntos) Sup\u00f3ngase que en este sistema hay dos instancias de los datos compartidos: <code>D1</code> y <code>D2</code>. Algunas hebras escritoras tienen que acceder con exclusi\u00f3n mutua simult\u00e1neamente a <code>D1</code> y <code>D2</code>, para cambiar los datos con coherencia. Es imprescindible hacerlo de esta forma. Justifique si en este supuesto podr\u00eda producir interbloqueos.</li> </ul> Mostrar soluci\u00f3n <p>Si se analizan las condiciones de Coffman:</p> <ol> <li>Exclusi\u00f3n mutua: Es as\u00ed, por el enunciado del problema;</li> <li>Tener y esperar: En los ejercicios que se han hecho, se usa este esquema (se podr\u00eda haber propuesto una implementaci\u00f3n alternativa);</li> <li>Sin expulsi\u00f3n: Al igual que en le caso anterior, no hay explusi\u00f3n. Se podr\u00eda proporcionar una alternativa;</li> <li>Espera circular: En el enunciado, se indica que hay dos instancias para acceder a los datos y no se especifica en el orden en el que se pueda hacer. Por tanto, puede que haya espera circular, como se muestra a continuaci\u00f3n. En este caso, <code>E1</code> intenta coger <code>D1</code> y <code>D2</code>, y <code>E2</code> intenta coger en el otro orden.</li> </ol> <p></p> <p>Se cumplen las cuatro condiciones, por lo que puede ocurrir un interbloqueo.</p> <ul> <li>(b) (2,5 puntos) A continuaci\u00f3n, se muestra una posible soluci\u00f3n al problema de los lectores/escritores. Analice este c\u00f3digo y justifique si es correcto. En caso contrario, indique los cambios necesarios para que este c\u00f3digo fuera una soluci\u00f3n correcta.</li> </ul> <pre><code>public class GestorLE2 {\n    int nLectores = 0;\n    boolean bloqueoLector = false;\n    boolean bloqueoEscritor = false;\n\n    public synchronized void empiezaLeer()\n            throws InterruptedException {\n        int nLectores = 0;\n        if (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir()\n            throws InterruptedException {\n        if (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer() {\n        nLectores--;\n        bloqueoLector = false;\n        notifyAll();\n    }\n\n    public synchronized void terminaEscribir() {\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>El c\u00f3digo es incorrecto. Hay que hacer los siguientes cambios:</p> <ul> <li>Los atributos tienen que ser privados;</li> <li>Los m\u00e9todos <code>wait</code>, tienen que estar en un bloque <code>while</code>;</li> <li>La declaraci\u00f3n <code>nLectores</code> en el m\u00e9todo <code>empiezaLeer</code> no tiene sentido;</li> <li>En el m\u00e9todo <code>terminaLeer</code> s\u00f3lo hay que asignar <code>true</code> a <code>bloqueoLector</code> cuando no hay lectores.</li> </ul> <pre><code>public class GestorLE {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n\n    public synchronized void empiezaLeer(int idLector)\n            throws InterruptedException {\n        int nLectores = 0;\n        while (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor)\n            throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2021/p2r/#problema-2","title":"Problema 2","text":"<p>La pr\u00e1ctica 4 inclu\u00eda un conjunto de trenes que se mov\u00edan de forma concurrente en su l\u00ednea de metro, con bastantes simplificaciones respecto a la realidad. Una de ellas es que no se controlaba que varios trenes puedan estar cargando/descargando pasajeros de forma simult\u00e1nea en un mismo anden.</p> <p>Se ha modificado el m\u00e9todo <code>irA</code> (el metodo que simulaba la entrada/salida en estaciones y en los tramos de l\u00ednea) para evitar que m!s de un tren pueda estar ocupando un and\u00e9n de la misma l\u00ednea y sentido, al mismo tiempo. Antes de entrar en la estaci\u00f3n el tren pide permiso para entrar, indicando por qu\u00e9 l\u00ednea se mueve y su sentido. En el metro de Madrid, cada l\u00ednea de metro tiene un and\u00e9n en cada sentido en todas las estaciones por las que pasa, que no comparte con ninguna otra l\u00ednea. El c\u00f3digo del m\u00e9todo <code>irA</code> queda de la siguiente forma (con simplificaciones). Se han insertado 2 l\u00edneas de c\u00f3digo (8 y 11): una para solicitar la entrada en la estaci\u00f3n antes de entrar y otra para indicar que un tren abandona el and\u00e9n de la estaci\u00f3n.</p> <p>El atributo <code>estacion</code> de la clase <code>Tren</code> representa la \u00faltima estaci\u00f3n a la que ha llegado el tren. Para que este c\u00f3digo funcione, la clase Estaci\u00f3n debe implementar los m\u00e9todos <code>permisoEntrada</code> y <code>salidaEstacion</code>. Se puede modificar el constructor de <code>Estaci\u00f3n</code> si fuera necesario.</p> <pre><code>01  TrayectoLineaMetro tr=linea.getSecuenciaMovimientos(origen,destino,ida);\n02  pasos.add(estacion);\n03  while (!tr.finMovimiento()) {\n04     Tramo c=tr.siguienteMovimiento();\n05     linea.getMapa().mueve(this, c);\n06     pasos.add(c.hasta());\n07     estacion=c.hasta();\n08     estacion.permisoEntrada(linea,ida);\n09     linea.getMapa().entraEnEstacion(this, c);\n10     linea.getMapa().desembarca(this, c.hasta());\n11     estacion.salidaEstacion(linea,ida);\n12  }\n13     if (!pasos.contains(destino))\n14     pasos.add(destino);\n</code></pre> <p>Asumiendo que los par\u00e1metros que se pasan al invocar un m\u00e9todo son correctos, es decir, no es necesario validarlos, y no hay ninguna restricci\u00f3n en la estructura de datos que se use en una soluci\u00f3n. Se pide:</p> <ul> <li>(a) (1 Punto) Incluir atributos en la clase <code>Estacion</code> que permitan saber los andenes de las l\u00edneas que pasan por esa estaci\u00f3n que est\u00e1n ocupados. Si es necesario modificar el constructor para inicializar esos atributos, se debe hacer en esta sub-pregunta.</li> </ul> <pre><code>// Constructor: id: identificador de estaci\u00f3n, posici\u00f3n de la estaci\u00f3n en el mapa,\n// tiempo de espera en los andenes, nombre de la estaci\u00f3n\npublic Estacion(int id, Vector posicion, double tiempo, String nombre) { ... }\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta, quiere entrar en la estaci\u00f3n\n... void permisoEntrada(LineaMetro l, boolean ida) { ... }\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta, abandona la estaci\u00f3n\n... void salidaEstacion(LineaMetro l, boolean ida) { ... }\n</code></pre> Mostrar soluci\u00f3n <p>Con esta soluci\u00f3n hacemos lo que nos piden en el ejercicio: no mas de un tren est\u00e1 descargando en un anden al mismo tiempo.</p> <pre><code>private Set&lt;LineaMetro&gt;[] andenes = new Set[2];\n\npublic EstacionS(int id, Vector posicion, double tiempo, String nombre) {\n    andenes[0] = new HashSet&lt;LineaMetro&gt;();\n    andenes[1] = new HashSet&lt;LineaMetro&gt;();\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// quiere entrar en la estaci\u00f3n\npublic synchronized void permisoEntrada(LineaMetro l, boolean ida) {\n    while (andenes[ida ? 1 : 0].contains(l)) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    andenes[ida ? 1 : 0].add(l);\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// abandona la estaci\u00f3n\npublic synchronized void salidaEstacion(LineaMetro l, boolean ida) {\n    if (!andenes[ida ? 1 : 0].contains(l)) {\n        throw new RuntimeException(\n            \"No podemos salir de un anden si no estamos dentro\"\n        );\n    }\n    andenes[ida ? 1 : 0].remove(l);\n    notifyAll();\n}\n</code></pre> <ul> <li>(b) (2 puntos) Implementar el m\u00e9todo <code>permisoEntrada</code> (incluida la cabecera) para que no m\u00e1s de un tren pueda estar ocupando un and\u00e9n en la estaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Con esta soluci\u00f3n vamos un poco mas alla de lo que nos piden en el ejercicio: no solo evitamos que varios trenes est\u00e1n descargando en un and\u00e9n, sino que adem!s los trenes no podr\u00e1n adelantarse entre ellos, cuando llegan a una estaci\u00f3n para descargar.</p> <pre><code>private Map&lt;LineaMetro, List&lt;Thread&gt;&gt;[] andenes = new Map[2];\n\npublic Estacion(int id, Vector posicion, double tiempo, String nombre) {\n    andenes[0] = new HashMap&lt;LineaMetro, List&lt;Thread&gt;&gt;();\n    andenes[1] = new HashMap&lt;LineaMetro, List&lt;Thread&gt;&gt;();\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// quiere entrar en la estaci\u00f3n\npublic synchronized void permisoEntrada(LineaMetro l, boolean ida) {\n    if (andenes[ida ? 1 : 0].get(l) == null) {\n        andenes[ida ? 1 : 0].put(l, new ArrayList&lt;Thread&gt;());\n    }\n\n    andenes[ida ? 1 : 0].get(l).add(Thread.currentThread());\n\n    while (andenes[ida ? 1 : 0].get(l).get(0) != Thread.currentThread()) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// abandona la estaci\u00f3n\npublic synchronized void salidaEstacion(LineaMetro l, boolean ida) {\n    if (andenes[ida ? 1 : 0].get(l).get(0) != Thread.currentThread()) {\n        throw new RuntimeException(\n            \"El tren que no esta en el anden no puede salir de la estacion\"\n        );\n    }\n\n    andenes[ida ? 1 : 0].get(l).remove(Thread.currentThread());\n    notifyAll();\n}\n</code></pre> <ul> <li>(c) (2 puntos) Implementar el m\u00e9todo <code>salidaEstacion</code> (incluida la cabecera) que libera el and\u00e9n y permite a otro tren que est\u00e1 esperando ocupar el and\u00e9n.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p>"},{"location":"exams/2021/p2r_ex01/","title":"P2r ex01","text":"<p>El problema de los lectores/escritores est! planteado con un conjunto de hebras que comparten datos. Una parte de estas hebras (lectores) s\u00f3lo leen los datos, mientras que el resto (escritores) leen y escriben. Varios lectores pueden acceder simult\u00e1neamente a los datos compartidos, pero se debe evitar que mientras un escritor est\u00e1 accediendo a los datos acceda a ellos otra hebra de cualquier tipo.</p> <p>Las hebras correctas deben solicitar permiso para acceder los datos con <code>empiezaLeer</code> (lectores) o <code>empiezaEscribir</code> (escritores). Al terminar de usar los datos compartidos deben invocar a <code>terminaLeer</code> (lectores) o <code>terminaEscribir</code> (escritores). El acceso a los datos compartidos se hace fuera de este monitor. Si este protocolo para acceder a estos m\u00e9todos se satisface, se garantiza los requisitos del problema.</p> Modifier and Type Method Description void empiezaEscribir() M\u00e9todo que invoca una hebra escritora antes de comenzar a escribir void empiezaLeer() M\u00e9todo que invoca una hebra lectora antes de comenzar a leer void terminaEscribir() M\u00e9todo que invoca una hebra escritora al terminar de escribir void terminaLeer() M\u00e9todo que invoca una hebra lectora al terminar de leer <ul> <li>(a) (2,5 puntos) Sup\u00f3ngase que en este sistema hay dos instancias de los datos compartidos: <code>D1</code> y <code>D2</code>. Algunas hebras escritoras tienen que acceder con exclusi\u00f3n mutua simult\u00e1neamente a <code>D1</code> y <code>D2</code>, para cambiar los datos con coherencia. Es imprescindible hacerlo de esta forma. Justifique si en este supuesto podr\u00eda producir interbloqueos.</li> </ul> Mostrar soluci\u00f3n <p>Si se analizan las condiciones de Coffman:</p> <ol> <li>Exclusi\u00f3n mutua: Es as\u00ed, por el enunciado del problema;</li> <li>Tener y esperar: En los ejercicios que se han hecho, se usa este esquema (se podr\u00eda haber propuesto una implementaci\u00f3n alternativa);</li> <li>Sin expulsi\u00f3n: Al igual que en le caso anterior, no hay explusi\u00f3n. Se podr\u00eda proporcionar una alternativa;</li> <li>Espera circular: En el enunciado, se indica que hay dos instancias para acceder a los datos y no se especifica en el orden en el que se pueda hacer. Por tanto, puede que haya espera circular, como se muestra a continuaci\u00f3n. En este caso, <code>E1</code> intenta coger <code>D1</code> y <code>D2</code>, y <code>E2</code> intenta coger en el otro orden.</li> </ol> <p></p> <p>Se cumplen las cuatro condiciones, por lo que puede ocurrir un interbloqueo.</p> <ul> <li>(b) (2,5 puntos) A continuaci\u00f3n, se muestra una posible soluci\u00f3n al problema de los lectores/escritores. Analice este c\u00f3digo y justifique si es correcto. En caso contrario, indique los cambios necesarios para que este c\u00f3digo fuera una soluci\u00f3n correcta.</li> </ul> <pre><code>public class GestorLE2 {\n    int nLectores = 0;\n    boolean bloqueoLector = false;\n    boolean bloqueoEscritor = false;\n\n    public synchronized void empiezaLeer()\n            throws InterruptedException {\n        int nLectores = 0;\n        if (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir()\n            throws InterruptedException {\n        if (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer() {\n        nLectores--;\n        bloqueoLector = false;\n        notifyAll();\n    }\n\n    public synchronized void terminaEscribir() {\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <p>El c\u00f3digo es incorrecto. Hay que hacer los siguientes cambios:</p> <ul> <li>Los atributos tienen que ser privados;</li> <li>Los m\u00e9todos <code>wait</code>, tienen que estar en un bloque <code>while</code>;</li> <li>La declaraci\u00f3n <code>nLectores</code> en el m\u00e9todo <code>empiezaLeer</code> no tiene sentido;</li> <li>En el m\u00e9todo <code>terminaLeer</code> s\u00f3lo hay que asignar <code>true</code> a <code>bloqueoLector</code> cuando no hay lectores.</li> </ul> <pre><code>public class GestorLE {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n\n    public synchronized void empiezaLeer(int idLector)\n            throws InterruptedException {\n        int nLectores = 0;\n        while (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor)\n            throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2021/p2r_ex02/","title":"P2r ex02","text":"<p>La pr\u00e1ctica 4 inclu\u00eda un conjunto de trenes que se mov\u00edan de forma concurrente en su l\u00ednea de metro, con bastantes simplificaciones respecto a la realidad. Una de ellas es que no se controlaba que varios trenes puedan estar cargando/descargando pasajeros de forma simult\u00e1nea en un mismo anden.</p> <p>Se ha modificado el m\u00e9todo <code>irA</code> (el metodo que simulaba la entrada/salida en estaciones y en los tramos de l\u00ednea) para evitar que m!s de un tren pueda estar ocupando un and\u00e9n de la misma l\u00ednea y sentido, al mismo tiempo. Antes de entrar en la estaci\u00f3n el tren pide permiso para entrar, indicando por qu\u00e9 l\u00ednea se mueve y su sentido. En el metro de Madrid, cada l\u00ednea de metro tiene un and\u00e9n en cada sentido en todas las estaciones por las que pasa, que no comparte con ninguna otra l\u00ednea. El c\u00f3digo del m\u00e9todo <code>irA</code> queda de la siguiente forma (con simplificaciones). Se han insertado 2 l\u00edneas de c\u00f3digo (8 y 11): una para solicitar la entrada en la estaci\u00f3n antes de entrar y otra para indicar que un tren abandona el and\u00e9n de la estaci\u00f3n.</p> <p>El atributo <code>estacion</code> de la clase <code>Tren</code> representa la \u00faltima estaci\u00f3n a la que ha llegado el tren. Para que este c\u00f3digo funcione, la clase Estaci\u00f3n debe implementar los m\u00e9todos <code>permisoEntrada</code> y <code>salidaEstacion</code>. Se puede modificar el constructor de <code>Estaci\u00f3n</code> si fuera necesario.</p> <pre><code>01  TrayectoLineaMetro tr=linea.getSecuenciaMovimientos(origen,destino,ida);\n02  pasos.add(estacion);\n03  while (!tr.finMovimiento()) {\n04     Tramo c=tr.siguienteMovimiento();\n05     linea.getMapa().mueve(this, c);\n06     pasos.add(c.hasta());\n07     estacion=c.hasta();\n08     estacion.permisoEntrada(linea,ida);\n09     linea.getMapa().entraEnEstacion(this, c);\n10     linea.getMapa().desembarca(this, c.hasta());\n11     estacion.salidaEstacion(linea,ida);\n12  }\n13     if (!pasos.contains(destino))\n14     pasos.add(destino);\n</code></pre> <p>Asumiendo que los par\u00e1metros que se pasan al invocar un m\u00e9todo son correctos, es decir, no es necesario validarlos, y no hay ninguna restricci\u00f3n en la estructura de datos que se use en una soluci\u00f3n. Se pide:</p> <ul> <li>(a) (1 Punto) Incluir atributos en la clase <code>Estacion</code> que permitan saber los andenes de las l\u00edneas que pasan por esa estaci\u00f3n que est\u00e1n ocupados. Si es necesario modificar el constructor para inicializar esos atributos, se debe hacer en esta sub-pregunta.</li> </ul> <pre><code>// Constructor: id: identificador de estaci\u00f3n, posici\u00f3n de la estaci\u00f3n en el mapa,\n// tiempo de espera en los andenes, nombre de la estaci\u00f3n\npublic Estacion(int id, Vector posicion, double tiempo, String nombre) { ... }\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta, quiere entrar en la estaci\u00f3n\n... void permisoEntrada(LineaMetro l, boolean ida) { ... }\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta, abandona la estaci\u00f3n\n... void salidaEstacion(LineaMetro l, boolean ida) { ... }\n</code></pre> Mostrar soluci\u00f3n <p>Con esta soluci\u00f3n hacemos lo que nos piden en el ejercicio: no mas de un tren est\u00e1 descargando en un anden al mismo tiempo.</p> <pre><code>private Set&lt;LineaMetro&gt;[] andenes = new Set[2];\n\npublic EstacionS(int id, Vector posicion, double tiempo, String nombre) {\n    andenes[0] = new HashSet&lt;LineaMetro&gt;();\n    andenes[1] = new HashSet&lt;LineaMetro&gt;();\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// quiere entrar en la estaci\u00f3n\npublic synchronized void permisoEntrada(LineaMetro l, boolean ida) {\n    while (andenes[ida ? 1 : 0].contains(l)) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    andenes[ida ? 1 : 0].add(l);\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// abandona la estaci\u00f3n\npublic synchronized void salidaEstacion(LineaMetro l, boolean ida) {\n    if (!andenes[ida ? 1 : 0].contains(l)) {\n        throw new RuntimeException(\n            \"No podemos salir de un anden si no estamos dentro\"\n        );\n    }\n    andenes[ida ? 1 : 0].remove(l);\n    notifyAll();\n}\n</code></pre> <ul> <li>(b) (2 puntos) Implementar el m\u00e9todo <code>permisoEntrada</code> (incluida la cabecera) para que no m\u00e1s de un tren pueda estar ocupando un and\u00e9n en la estaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Con esta soluci\u00f3n vamos un poco mas alla de lo que nos piden en el ejercicio: no solo evitamos que varios trenes est\u00e1n descargando en un and\u00e9n, sino que adem!s los trenes no podr\u00e1n adelantarse entre ellos, cuando llegan a una estaci\u00f3n para descargar.</p> <pre><code>private Map&lt;LineaMetro, List&lt;Thread&gt;&gt;[] andenes = new Map[2];\n\npublic Estacion(int id, Vector posicion, double tiempo, String nombre) {\n    andenes[0] = new HashMap&lt;LineaMetro, List&lt;Thread&gt;&gt;();\n    andenes[1] = new HashMap&lt;LineaMetro, List&lt;Thread&gt;&gt;();\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// quiere entrar en la estaci\u00f3n\npublic synchronized void permisoEntrada(LineaMetro l, boolean ida) {\n    if (andenes[ida ? 1 : 0].get(l) == null) {\n        andenes[ida ? 1 : 0].put(l, new ArrayList&lt;Thread&gt;());\n    }\n\n    andenes[ida ? 1 : 0].get(l).add(Thread.currentThread());\n\n    while (andenes[ida ? 1 : 0].get(l).get(0) != Thread.currentThread()) {\n        try {\n            wait();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// Indica cuando un tren que circula por la Linea l y sentido ida o vuelta,\n// abandona la estaci\u00f3n\npublic synchronized void salidaEstacion(LineaMetro l, boolean ida) {\n    if (andenes[ida ? 1 : 0].get(l).get(0) != Thread.currentThread()) {\n        throw new RuntimeException(\n            \"El tren que no esta en el anden no puede salir de la estacion\"\n        );\n    }\n\n    andenes[ida ? 1 : 0].get(l).remove(Thread.currentThread());\n    notifyAll();\n}\n</code></pre> <ul> <li>(c) (2 puntos) Implementar el m\u00e9todo <code>salidaEstacion</code> (incluida la cabecera) que libera el and\u00e9n y permite a otro tren que est\u00e1 esperando ocupar el and\u00e9n.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p>","tags":["complejidad"]},{"location":"exams/2022/extra/","title":"Examen 2022 \u2014 Extraordinario","text":""},{"location":"exams/2022/extra/#problema-1","title":"Problema 1","text":"<p>DIT Computers ha decidido implementar un nuevo sistema operativo revolucionario utilizando el lenguaje de programaci\u00f3n Java. La primera tarea ser\u00e1 implementar un sistema revolucionario de acceso a ficheros, para lo que decide subcontratar a alumnos de ADSW.</p> <p>Se propone un prototipo de un sistema de ficheros simplificado, que solo permite acceder a ficheros a partir de su nombre, y almacenar nuevos ficheros en el sistema. Habr\u00e1 cuatro clases en el sistema: </p> <ol> <li><code>Fichero</code>; </li> <li><code>Gestor</code>, que ser\u00e1 la clase principal; </li> <li><code>Disco</code>, que contendr\u00e1 un conjunto de ficheros; </li> <li><code>Cache</code>, para almacenar ficheros que han sido utilizados recientemente y evitar volver a buscarlos. </li> </ol> <p>La relaci\u00f3n entre estas clases se ve en el diagrama adjunto.</p> <p></p> <p>El <code>Gestor</code> deber\u00e1 permitir obtener (<code>get</code>) ficheros existentes o almacenar (<code>put</code>) ficheros nuevos. Internamente, un gestor tiene acceso a un elemento de tipo <code>Cache</code> y a varios de tipo <code>Disco</code>. Un fichero se obtiene a trav\u00e9s de su nombre. Para obtener un fichero, el gestor primero consulta si el fichero est\u00e1 disponible en su cach\u00e9 y, si no, consultar\u00e1 uno a uno a sus discos. En caso de no encontrar el fichero en ninguno de los discos, se devolver\u00e1 un <code>null</code>. Cuando el gestor obtiene el fichero de un disco, lo debe a\u00f1adir a su cach\u00e9 para que se encuentre m\u00e1s r\u00e1pido en el pr\u00f3ximo acceso. La cach\u00e9 tiene poca capacidad de almacenamiento. Cuando hay que guardar un fichero y no hay capacidad suficiente, se elimina el fichero m\u00e1s antiguo y se almacena el nuevo.</p> <p>A la hora de guardar el fichero, el gestor asumir\u00e1 que el fichero es nuevo, y lo guardar\u00e1 tanto en uno de sus discos, como en la cach\u00e9. Los ficheros deber\u00e1n distribuirse de manera uniforme entre todos los discos del gestor.</p> <p>Asuma que el resto de las clases ya est\u00e1n implementadas, de acuerdo al diagrama de clases del enunciado. Pueden a\u00f1adirse atributos a cualquiera de las clases, pero deber\u00e1 indicarse.</p> <ul> <li>(a) (1 punto) Desarrolle m\u00e9todo <code>get</code> de <code>Gestor</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Gestor {\n    private Disco[] discos;\n    private Cache cache;\n    private int puntero = 0;\n\n    public Gestor(Disco[] discos, Cache cache) {\n        this.discos = discos;\n        this.cache = cache;\n    }\n\n    public Archivo get(String nombre) {\n        Fichero a = this.cache.get(nombre);\n        if (a != null) {\n            a.accesos += 1;\n            return a;\n        }\n        for (Disco disco : this.discos) {\n            a = disco.get(nombre);\n            if (a == null) {\n                continue;\n            }\n            a.accesos += 1;\n            this.cache.put(a);\n            return a;\n        }\n        return null;\n    }\n\n}\n</code></pre> <ul> <li>(b) (1 punto) El m\u00e9todo <code>put</code> de <code>Gestor</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void put(Fichero a) {\n    this.discos[this.puntero].put(a);\n    this.puntero = (this.puntero + 1) % this.discos.length;\n}\n</code></pre> <ul> <li>(c) (2 puntos) En el diagrama de clases, <code>Disco</code> y <code>Cache</code> no especifican qu\u00e9 estructura de datos utilizan internamente para guardar los ficheros. Siendo <code>d</code> el n\u00famero de discos, <code>f</code> el n\u00famero de ficheros totales almacenados, <code>c</code> el n\u00famero m\u00e1ximo de ficheros que puede contener la cach\u00e9 (con <code>f &gt;&gt; c</code>), razone qu\u00e9 estructura de datos (p.e., Lista, Tabla Hash, etc.) utilizar\u00eda en <code>Disco</code> y en Cache para cumplir que:<ul> <li>Obtener un fichero reciente del <code>Gestor</code> sea como m\u00e1ximo \\(O(c)\\) en tiempo de ejecuci\u00f3n;</li> <li>Obtener un fichero cualquiera del <code>Gestor</code> sea como m\u00e1ximo \\(O(log(f))\\) en tiempo de ejecuci\u00f3n;</li> <li>Guardar un fichero en el <code>Gestor</code> sea como m\u00e1ximo \\(O(log(f))\\) en tiempo de ejecuci\u00f3n.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Las operaciones en Gestor tendr\u00e1n una complejidad:</p> <ul> <li><code>get()</code> en general es \\(O(t\\_get\\_cache + t\\_get\\_disco * d + t\\_put\\_cache)\\);</li> <li><code>get()</code> de un fichero reciente es \\(O(t\\_get\\_cache)\\);</li> <li><code>put()</code> es \\(O(t\\_put\\_cache + t\\_put\\_disco)\\).</li> </ul> <p>Por tanto, dados los requisitos en complejidad:</p> <ul> <li><code>Cache</code> podr\u00eda utilizar cualquiera de las estructuras que hemos visto. La m\u00e1s sencilla ser\u00eda una lista.</li> <li><code>Disco</code> deber\u00eda usar una estructura que permita complejidad logar\u00edtmica en <code>get</code> y <code>put</code>. Por ejemplo:<ul> <li>\u00c1rbol binario</li> <li><code>TreeMap</code></li> <li>Tambi\u00e9n ser\u00eda posible usar cualquiera de las opciones de Hash (\\(O(1)\\) en caso mejor, \\(O(f)\\) en caso peor), pero se necesitar\u00eda m\u00e1s almacenamiento para evitar colisiones.</li> </ul> </li> </ul> <ul> <li>(d) (1 punto) Se desea introducir nuevos tipos de gestores de ficheros con estrategias de acceso y almacenado diferentes. Explique qu\u00e9 cambios introducir\u00eda para permitirlo. \u00bfY si se quisiera tambi\u00e9n que <code>Disco</code> o <code>Cache</code> pudieran reemplazar al gestor de ficheros? Se valorar\u00e1 que los cambios se a\u00f1adan al diagrama UML, pero no ser\u00e1 necesario.</li> </ul> Mostrar soluci\u00f3n <p>Para la primera parte, simplemente ser\u00eda posible heredando de la clase <code>Gestor</code>. No obstante, eso forzar\u00eda a que el constructor de <code>Gestor</code> siguiera funcionando con esa firma.</p> <p>Para la segunda parte, y en general, lo recomendable ser\u00eda utilizar un Interfaz con los m\u00e9todos <code>get</code> y <code>put</code>, como se muestra en el diagrama adjunto.</p> <p>Como las 3 clases existentes contienen los m\u00e9todos necesarios con la misma firma, s\u00f3lo habr\u00eda que especificar la nueva herencia (implements).</p>"},{"location":"exams/2022/extra/#problema-2","title":"Problema 2","text":"<p>Se dispone de una clase <code>RedSocial</code> que representa una red social de amistad entre personas. En concreto, se quiere representar la relaci\u00f3n \u201cseguir a una persona\u201d. Para ello, se utiliza un grafo (<code>g</code>) dirigido para representar esta relaci\u00f3n: un v\u00e9rtice (nodo) representa una persona y un arco (arista) una relaci\u00f3n. En concreto <code>A</code> \u00e0 <code>B</code> representa que la persona <code>A</code> siga a la persona <code>B</code>. Este arco no implica que <code>B</code> sigua a <code>A</code>.</p> <p>En la clase <code>RedSocial</code> se utiliza un mapa (<code>Map&lt;Integer, String&gt; mapaPersonas</code>) que permite obtener el nombre de la persona de un v\u00e9rtice. El arco que representa la relaci\u00f3n \u201cseguir a una persona\u201d se modelar\u00e1 en un objeto de la clase <code>DirectedEdge</code>, con peso 1. La clase <code>RedSocial</code> se describa en el diagrama de clases adjuntado.</p> <p>En el sistema, se disponen las clases <code>DijkstraSP</code>, <code>EdgeWeightedDigraph</code> y <code>DirectedEdge</code>, para modelar el sistema. </p> <p></p> <ul> <li>(a) (1 punto) Desarrolle el m\u00e9todo <code>public double getMediaSeguidores()</code>, que devuelve el n\u00famero medio de seguidores en el grafo. </li> </ul> Mostrar soluci\u00f3n <pre><code>public double getMediaSeguidores() {\n    return (double) this.g.E()/this.g.V();\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Desarrolle el m\u00e9todo <code>public String getVerticeMasSeguidores()</code>, que devuelve el nombre de la persona que tiene m\u00e1s seguidores.</li> </ul> Mostrar soluci\u00f3n <pre><code>public String getVerticeMasSeguidores() {\n    int maxSeguidores = 0;\n    int vertice = 0;\n\n    for (int v = 0; v &lt; this.g.V(); v++) {\n        if (this.g.indegree(v) &gt; maxSeguidores) {\n            maxSeguidores = this.g.indegree(v);\n            vertice = v;\n        }\n    }\n\n    return this.mapaPersonas.get(vertice);\n}\n</code></pre> <ul> <li>(c) (2,5 putnos) Desarrolle el m\u00e9todo <code>public List&lt;String&gt; getListaMinimoAmigosComun(int verticeOrigen, int verticeDestino)</code>, que recibe por par\u00e1metro un v\u00e9rtice de origen y un v\u00e9rtice de destino y debe devolver una lista de <code>String</code> con el nombre de las personas de la cadena m\u00ednima de amistad entre el origen y el destino. Nota: ni el nombre de la persona origen ni destino deber\u00e1n aparecer en la lista.</li> </ul> Mostrar soluci\u00f3n <pre><code>public List&lt;String&gt; getListaMinimoAmigosComun(int verticeOrigen, int verticeDestino) {\n    List&lt;String&gt; amigos = new ArrayList&lt;String&gt;();\n    DijkstraSP d = new DijkstraSP(this.g, verticeOrigen);\n\n    if (d.pathTo(verticeDestino) != null) {\n        for (DirectedEdge e : d.pathTo(verticeDestino)) {\n            if (e.from() != verticeOrigen)\n                amigos.add(this.mapaPersonas.get(e.from()));\n        }\n    } else {\n        return null;\n    }\n\n    return amigos;\n}\n</code></pre>"},{"location":"exams/2022/extra_ex01/","title":"Extra ex01","text":"<p>DIT Computers ha decidido implementar un nuevo sistema operativo revolucionario utilizando el lenguaje de programaci\u00f3n Java. La primera tarea ser\u00e1 implementar un sistema revolucionario de acceso a ficheros, para lo que decide subcontratar a alumnos de ADSW.</p> <p>Se propone un prototipo de un sistema de ficheros simplificado, que solo permite acceder a ficheros a partir de su nombre, y almacenar nuevos ficheros en el sistema. Habr\u00e1 cuatro clases en el sistema: </p> <ol> <li><code>Fichero</code>; </li> <li><code>Gestor</code>, que ser\u00e1 la clase principal; </li> <li><code>Disco</code>, que contendr\u00e1 un conjunto de ficheros; </li> <li><code>Cache</code>, para almacenar ficheros que han sido utilizados recientemente y evitar volver a buscarlos. </li> </ol> <p>La relaci\u00f3n entre estas clases se ve en el diagrama adjunto.</p> <p></p> <p>El <code>Gestor</code> deber\u00e1 permitir obtener (<code>get</code>) ficheros existentes o almacenar (<code>put</code>) ficheros nuevos. Internamente, un gestor tiene acceso a un elemento de tipo <code>Cache</code> y a varios de tipo <code>Disco</code>. Un fichero se obtiene a trav\u00e9s de su nombre. Para obtener un fichero, el gestor primero consulta si el fichero est\u00e1 disponible en su cach\u00e9 y, si no, consultar\u00e1 uno a uno a sus discos. En caso de no encontrar el fichero en ninguno de los discos, se devolver\u00e1 un <code>null</code>. Cuando el gestor obtiene el fichero de un disco, lo debe a\u00f1adir a su cach\u00e9 para que se encuentre m\u00e1s r\u00e1pido en el pr\u00f3ximo acceso. La cach\u00e9 tiene poca capacidad de almacenamiento. Cuando hay que guardar un fichero y no hay capacidad suficiente, se elimina el fichero m\u00e1s antiguo y se almacena el nuevo.</p> <p>A la hora de guardar el fichero, el gestor asumir\u00e1 que el fichero es nuevo, y lo guardar\u00e1 tanto en uno de sus discos, como en la cach\u00e9. Los ficheros deber\u00e1n distribuirse de manera uniforme entre todos los discos del gestor.</p> <p>Asuma que el resto de las clases ya est\u00e1n implementadas, de acuerdo al diagrama de clases del enunciado. Pueden a\u00f1adirse atributos a cualquiera de las clases, pero deber\u00e1 indicarse.</p> <ul> <li>(a) (1 punto) Desarrolle m\u00e9todo <code>get</code> de <code>Gestor</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Gestor {\n    private Disco[] discos;\n    private Cache cache;\n    private int puntero = 0;\n\n    public Gestor(Disco[] discos, Cache cache) {\n        this.discos = discos;\n        this.cache = cache;\n    }\n\n    public Archivo get(String nombre) {\n        Fichero a = this.cache.get(nombre);\n        if (a != null) {\n            a.accesos += 1;\n            return a;\n        }\n        for (Disco disco : this.discos) {\n            a = disco.get(nombre);\n            if (a == null) {\n                continue;\n            }\n            a.accesos += 1;\n            this.cache.put(a);\n            return a;\n        }\n        return null;\n    }\n\n}\n</code></pre> <ul> <li>(b) (1 punto) El m\u00e9todo <code>put</code> de <code>Gestor</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void put(Fichero a) {\n    this.discos[this.puntero].put(a);\n    this.puntero = (this.puntero + 1) % this.discos.length;\n}\n</code></pre> <ul> <li>(c) (2 puntos) En el diagrama de clases, <code>Disco</code> y <code>Cache</code> no especifican qu\u00e9 estructura de datos utilizan internamente para guardar los ficheros. Siendo <code>d</code> el n\u00famero de discos, <code>f</code> el n\u00famero de ficheros totales almacenados, <code>c</code> el n\u00famero m\u00e1ximo de ficheros que puede contener la cach\u00e9 (con <code>f &gt;&gt; c</code>), razone qu\u00e9 estructura de datos (p.e., Lista, Tabla Hash, etc.) utilizar\u00eda en <code>Disco</code> y en Cache para cumplir que:<ul> <li>Obtener un fichero reciente del <code>Gestor</code> sea como m\u00e1ximo \\(O(c)\\) en tiempo de ejecuci\u00f3n;</li> <li>Obtener un fichero cualquiera del <code>Gestor</code> sea como m\u00e1ximo \\(O(log(f))\\) en tiempo de ejecuci\u00f3n;</li> <li>Guardar un fichero en el <code>Gestor</code> sea como m\u00e1ximo \\(O(log(f))\\) en tiempo de ejecuci\u00f3n.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Las operaciones en Gestor tendr\u00e1n una complejidad:</p> <ul> <li><code>get()</code> en general es \\(O(t\\_get\\_cache + t\\_get\\_disco * d + t\\_put\\_cache)\\);</li> <li><code>get()</code> de un fichero reciente es \\(O(t\\_get\\_cache)\\);</li> <li><code>put()</code> es \\(O(t\\_put\\_cache + t\\_put\\_disco)\\).</li> </ul> <p>Por tanto, dados los requisitos en complejidad:</p> <ul> <li><code>Cache</code> podr\u00eda utilizar cualquiera de las estructuras que hemos visto. La m\u00e1s sencilla ser\u00eda una lista.</li> <li><code>Disco</code> deber\u00eda usar una estructura que permita complejidad logar\u00edtmica en <code>get</code> y <code>put</code>. Por ejemplo:<ul> <li>\u00c1rbol binario</li> <li><code>TreeMap</code></li> <li>Tambi\u00e9n ser\u00eda posible usar cualquiera de las opciones de Hash (\\(O(1)\\) en caso mejor, \\(O(f)\\) en caso peor), pero se necesitar\u00eda m\u00e1s almacenamiento para evitar colisiones.</li> </ul> </li> </ul> <ul> <li>(d) (1 punto) Se desea introducir nuevos tipos de gestores de ficheros con estrategias de acceso y almacenado diferentes. Explique qu\u00e9 cambios introducir\u00eda para permitirlo. \u00bfY si se quisiera tambi\u00e9n que <code>Disco</code> o <code>Cache</code> pudieran reemplazar al gestor de ficheros? Se valorar\u00e1 que los cambios se a\u00f1adan al diagrama UML, pero no ser\u00e1 necesario.</li> </ul> Mostrar soluci\u00f3n <p>Para la primera parte, simplemente ser\u00eda posible heredando de la clase <code>Gestor</code>. No obstante, eso forzar\u00eda a que el constructor de <code>Gestor</code> siguiera funcionando con esa firma.</p> <p>Para la segunda parte, y en general, lo recomendable ser\u00eda utilizar un Interfaz con los m\u00e9todos <code>get</code> y <code>put</code>, como se muestra en el diagrama adjunto.</p> <p>Como las 3 clases existentes contienen los m\u00e9todos necesarios con la misma firma, s\u00f3lo habr\u00eda que especificar la nueva herencia (implements).</p>","tags":["grafos"]},{"location":"exams/2022/extra_ex02/","title":"Extra ex02","text":"<p>Se dispone de una clase <code>RedSocial</code> que representa una red social de amistad entre personas. En concreto, se quiere representar la relaci\u00f3n \u201cseguir a una persona\u201d. Para ello, se utiliza un grafo (<code>g</code>) dirigido para representar esta relaci\u00f3n: un v\u00e9rtice (nodo) representa una persona y un arco (arista) una relaci\u00f3n. En concreto <code>A</code> \u00e0 <code>B</code> representa que la persona <code>A</code> siga a la persona <code>B</code>. Este arco no implica que <code>B</code> sigua a <code>A</code>.</p> <p>En la clase <code>RedSocial</code> se utiliza un mapa (<code>Map&lt;Integer, String&gt; mapaPersonas</code>) que permite obtener el nombre de la persona de un v\u00e9rtice. El arco que representa la relaci\u00f3n \u201cseguir a una persona\u201d se modelar\u00e1 en un objeto de la clase <code>DirectedEdge</code>, con peso 1. La clase <code>RedSocial</code> se describa en el diagrama de clases adjuntado.</p> <p>En el sistema, se disponen las clases <code>DijkstraSP</code>, <code>EdgeWeightedDigraph</code> y <code>DirectedEdge</code>, para modelar el sistema. </p> <p></p> <ul> <li>(a) (1 punto) Desarrolle el m\u00e9todo <code>public double getMediaSeguidores()</code>, que devuelve el n\u00famero medio de seguidores en el grafo. </li> </ul> Mostrar soluci\u00f3n <pre><code>public double getMediaSeguidores() {\n    return (double) this.g.E()/this.g.V();\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) Desarrolle el m\u00e9todo <code>public String getVerticeMasSeguidores()</code>, que devuelve el nombre de la persona que tiene m\u00e1s seguidores.</li> </ul> Mostrar soluci\u00f3n <pre><code>public String getVerticeMasSeguidores() {\n    int maxSeguidores = 0;\n    int vertice = 0;\n\n    for (int v = 0; v &lt; this.g.V(); v++) {\n        if (this.g.indegree(v) &gt; maxSeguidores) {\n            maxSeguidores = this.g.indegree(v);\n            vertice = v;\n        }\n    }\n\n    return this.mapaPersonas.get(vertice);\n}\n</code></pre> <ul> <li>(c) (2,5 putnos) Desarrolle el m\u00e9todo <code>public List&lt;String&gt; getListaMinimoAmigosComun(int verticeOrigen, int verticeDestino)</code>, que recibe por par\u00e1metro un v\u00e9rtice de origen y un v\u00e9rtice de destino y debe devolver una lista de <code>String</code> con el nombre de las personas de la cadena m\u00ednima de amistad entre el origen y el destino. Nota: ni el nombre de la persona origen ni destino deber\u00e1n aparecer en la lista.</li> </ul> Mostrar soluci\u00f3n <pre><code>public List&lt;String&gt; getListaMinimoAmigosComun(int verticeOrigen, int verticeDestino) {\n    List&lt;String&gt; amigos = new ArrayList&lt;String&gt;();\n    DijkstraSP d = new DijkstraSP(this.g, verticeOrigen);\n\n    if (d.pathTo(verticeDestino) != null) {\n        for (DirectedEdge e : d.pathTo(verticeDestino)) {\n            if (e.from() != verticeOrigen)\n                amigos.add(this.mapaPersonas.get(e.from()));\n        }\n    } else {\n        return null;\n    }\n\n    return amigos;\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2022/p1/","title":"Examen 2022 \u2014 Parcial 1","text":""},{"location":"exams/2022/p1/#problema-1","title":"Problema 1","text":"<p>Un grafo multigrafo permite que haya varios arcos entre dos nodos. En una entidad bancaria se quiere modelar las transferencias ejecutadas entre los bancos durante un d\u00eda en una clase (<code>Banco</code>). En esta clase, se dispone de un atributo (<code>transferGrafo</code>) que es un multigrafo que modela estas transferencias:</p> <ul> <li>Un nodo modela un banco.   </li> <li>Un arco modela una transacci\u00f3n. Su peso representa la cantidad transferida.</li> </ul> <p>Una transferencia (la clase <code>Transfer</code>) se modela mediante los identificadores del banco origen y del banco destino, la cantidad, el nombre del ordenante y el nombre del beneficiario. Adem\u00e1s, se quiere relacionar cada arco del grafo con la informaci\u00f3n de su transferencia asociada. </p> <p>menorCamino</p> <code>public java.util.List&lt;Edge&gt; menorCamino(java.util.List&lt;java.util.List&lt;Edge&gt;&gt; listaCaminos)</code> Seleccionar el camino con el menor coste total. Parameters <code>listaCaminos</code> - una lista de caminos del grafo del sistema entre dos v\u00e9rtices. Returns La respuesta es un camino que sea el m\u00ednimo de la lista recibida. Si hubieran varios caminos m\u00ednimos con el mismo coste, se puede retornar cualquiera de ellos. <p>numeroVecesUsadoArco</p> <code>public java.util.Map&lt;Edge, java.lang.Integer&gt; numeroVecesUsadoArco(java.util.List&lt;java.util.List&lt;Edge&gt;&gt; listaCaminos)</code> Determina cu\u00e1ntas veces aparece cada arco en una lista de caminos Parameters <code>listaCaminos</code> - una lista de caminos del grafo del sistema entre dos v\u00e9rtices. Returns devuelve un diccionario, en el que la clave es un arco y el valor un entero que representa el n\u00famero de veces que el arco aparece en el par\u00e1metro de entrada. <p>Edge</p> Tipo M\u00e9todo Descripci\u00f3n int compareTo(Edge that) Compares two edges by weight. int either() Returns either endpoint of this edge. int other(int vertex) Returns the endpoint of this edge that is different from the given vertex. Double weight() Returns the weight of this edge. <p>List</p> Tipo M\u00e9todo Descripci\u00f3n boolean add(E e) Appends the specified element to the end of this list (optional operation). boolean contains(Object o) Returns true if this list contains the specified element. E get(int index) Returns the element at the specified position in this list. boolean isEmpty() Returns true if this list contains no elements. E remove(int index) Removes the element at the specified position in this list (optional operation). int size() Returns the number of elements in this list. <p>Map</p> Tipo M\u00e9todo Descripci\u00f3n boolean containsKey(Object key) Returns true if this map contains a mapping for the specified key. V get(Object key) Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. boolean isEmpty() Returns true if this map contains no key-value mappings. V put(K key, V value) Associates the specified value with the specified key in this map. V remove(Object key) Removes the mapping for the specified key from this map if present. int size() Returns the number of key-value mappings in this map. <p>Se pide:</p> <ul> <li>(a) (1,5 puntos) Proponga un atributo de una clase adecuada para relacionar un arco con su transferencia asociada y desarrolle el m\u00e9todo <code>ponerTransfer</code> para mantener esta relaci\u00f3n e integrar la transferencia en el grafo. </li> </ul> Mostrar soluci\u00f3n <pre><code>import edu.princeton.cs.algs4.*;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Banco {\n\n    private int nBancos;\n    private Map&lt;DirectedEdge, Transfer&gt; arcosTransfer;\n    private EdgeWeightedDigraph transferGrafo;\n\n    public Banco() {\n        this.arcosTransfer = new HashMap&lt;DirectedEdge, Transfer&gt;();\n        this.transferGrafo = new EdgeWeightedDigraph(nBancos);\n    }\n\n    /**\n     * A\u00f1adir una transferencia en el grafo y en la estructura que relacione\n     * una arista y su transferencia asociada\n     * @param transfer Transferencia a incluir\n     */\n    public void ponerTransfer(Transfer transfer) {\n        DirectedEdge arco = new DirectedEdge(\n            transfer.getBancoOrigen(),\n            transfer.getBancoDestino(),\n            transfer.getCantidad()\n        );\n        arcosTransfer.put(arco, transfer);\n        transferGrafo.addEdge(arco);\n    }\n\n    /**\n     * Calcular la cantidad neta de las transferencias ejecutadas\n     * durante un d\u00eda entre bank1 y bank2\n     * @param banco1 Identificador de un banco\n     * @param banco2 Identificador de otro banco\n     * @return cantidad neta durante un d\u00eda entre bank1 y bank2\n     */\n    public Double netoTransfer(int banco1, int banco2) {\n        double nBanco1 = 0;\n        double nBanco2 = 0;\n\n        if (banco1 &lt; 0 || banco1 &gt;= transferGrafo.V()) return null;\n        if (banco2 &lt; 0 || banco2 &gt;= transferGrafo.V()) return null;\n\n        // Calcular el total de dinero banco1 -&gt; banco2\n        for (DirectedEdge arco : transferGrafo.adj(banco1)) {\n            if (arco.to() == banco2) {\n                nBanco1 += arco.weight();\n            }\n        }\n\n        // Calcular el total de dinero banco2 -&gt; banco1\n        for (DirectedEdge arco : transferGrafo.adj(banco2)) {\n            if (arco.to() == banco1) {\n                nBanco2 += arco.weight();\n            }\n        }\n\n        return nBanco1 - nBanco2;\n    }\n\n    /**\n     * Generar la lista de las transferencias que ha generado\n     * el ordenante durante un d\u00eda\n     * @param ordenante Usuario que ordena la transferencia\n     * @return Lista de las transferencias de un ordenante\n     */\n    public List&lt;Transfer&gt; clienteTransfer(String ordenante) {\n        List&lt;Transfer&gt; lista = new ArrayList&lt;Transfer&gt;();\n\n        for (DirectedEdge arco : transferGrafo.edges()) {\n            Transfer transfer = arcosTransfer.get(arco);\n            if (transfer.getOrdenante().equals(ordenante)) {\n                lista.add(transfer);\n            }\n        }\n\n        return lista;\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Desarrolle el m\u00e9todo <code>netoTransfer</code> que retorne la cantidad de dinero neto transferido entre dos bancos en un d\u00eda. Habr\u00e1 que restar la cantidad de las transferencias entre los dos bancos.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p> <ul> <li>(c) (1,5 puntos) Desarrolle el m\u00e9todo <code>clienteTransfer</code> que retorne la lista no ordenada de las transferencias que ha ejecutado una persona (ordenante) durante un d\u00eda.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p> <p>NOTA: los grafos de U. Princeton usado en esta asignatura permiten crear multigrafos.</p>"},{"location":"exams/2022/p1/#problema-2","title":"Problema 2","text":"<p>Dado un conjunto de n\u00fameros, la distancia entre un elemento del conjunto y el resto del conjunto es la m\u00ednima diferencia entre ese n\u00famero y otro cualquiera del conjunto. Por ejemplo, la distancia de 10 en el conjunto {3,6,10,16,17} es 4, y la de 16 es 1. El elemento m\u00e1s aislado del conjunto es el elemento que tenga la distancia mayor. Si varios n\u00fameros tienen esa misma distancia mayor, el m\u00e1s aislado es uno cualquiera de ellos. En el conjunto anterior, el elemento m\u00e1s aislado es el 10. Podemos suponer que el conjunto tiene al menos un n\u00famero. Si solo hay uno, seria el m\u00e1s aislado y su distancia es infinito.</p> <pre><code>public class BSTAislados {\n\n    private Nodo ra\u00edz = null;\n\n    public int distancia(Nodo nodo) {\n        // SOLUCION Pregunta 2.c\n    }\n}\n</code></pre> <pre><code>public class Nodo {\n    public int numero;\n    public Nodo iz, der;\n    // Disponibles los getters y setters\n}\n</code></pre> <ul> <li>(a) (1,5 puntos) Se dispone un conjunto de n\u00fameros ordenado por el valor de los n\u00fameros con un array. No hay ninguna estructura de datos adicional, en relaci\u00f3n con el conjunto de n\u00fameros. \u00bfQu\u00e9 complejidad tendr\u00e1 el algoritmo m\u00e1s eficiente que calcule el n\u00famero m\u00e1s aislado del conjunto? Justifique la respuesta. No se est\u00e1 pidiendo una implementaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Si los n\u00fameros est\u00e1n ordenados por valor, los n\u00fameros m\u00e1s pr\u00f3ximos a uno dado son el anterior y el siguiente. La distancia de un n\u00famero es la menor de las diferencias con el anterior y el siguiente. Este es un c\u00e1lculo de complejidad constante y no depende del tama\u00f1o del conjunto. Pero el m\u00e1s aislado puede ser cualquiera de los n\u00fameros, porque, aunque est\u00e9n ordenados, la deferencia entre un n\u00famero y el siguiente puede ser cualquiera. Para calcular el m\u00e1s aislado hay que recorrer todo el array y calcular la distancia para cada posici\u00f3n, y el m\u00e1s aislado ser\u00e1 el que tenga distancia mayor. </p> <p>Complejidad \\(O(n)\\) donde \\(n\\) es el tama\u00f1o del conjunto.</p> <ul> <li>(b) (1,5 puntos) Se dispone un conjunto de n\u00fameros ordenado por el valor de los n\u00fameros con un \u00e1rbol binario. No hay ninguna estructura de datos adicional, en relaci\u00f3n con el conjunto de n\u00fameros. Se supone que los n\u00fameros que incluye el \u00e1rbol se han insertado de forma aleatoria y son valores aleatorios. \u00bfQu\u00e9 complejidad tendr\u00e1 el algoritmo m\u00e1s eficiente que calcule el n\u00famero m\u00e1s aislado del conjunto? Justifique la respuesta. No se est\u00e1 pidiendo una implementaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>En el caso de que representemos el conjunto mediante un \u00e1rbol binario seguimos necesitando recorrer todo el \u00e1rbol para encontrar el m\u00e1s aislado. La diferencia entre el valor de un nodo y cualquiera de sus descendientes directos o indirectos puede ser cualquiera. Podemos utilizar como algoritmos un algoritmo de recorrido del \u00e1rbol en orden. Recorreremos empezando por los n\u00fameros m\u00e1s peque\u00f1os y terminaremos con los grandes. En el recorrido del \u00e1rbol, actualizamos los tres \u00faltimos nodos visitados (por ejemplo, un array de tres elementos que incluye el nodo que visitamos y los dos anteriores, ese array puede ser un par\u00e1metro del m\u00e9todo que recorre los nodos o un atributo auxiliar). La distancia del nodo anterior al nodo que visitamos es la menor de las diferencias entre el pen\u00faltimo nodo, el ante-pen\u00faltimo y el que visitamos. La diferencia del primer nodo la calculamos en la segunda visita, y la \u00faltima visita calculamos la del \u00faltimo con el pen\u00faltimo. En total visitamos todos los nodos y el calculo de las distancias es constante.</p> <p>Complejidad de orden \\(O(n)\\) donde \\(n\\) es el tama\u00f1o del conjunto y del \u00e1rbol.</p> <ul> <li> <p>(c) (2 puntos) Se dispone de un \u00e1rbol binario que incluye el conjunto de n\u00fameros ordenado por el valor de cada n\u00famero que representan los nodos. Implemente el m\u00e9todo que devuelve la distancia del n\u00famero para el nodo en el par\u00e1metro. La respuesta debe incluir: </p> <ol> <li>La implementaci\u00f3n del algoritmo. La puntuaci\u00f3n de la pregunta ser\u00e1 mayor para soluciones m\u00e1s eficientes, y menor para las soluciones m\u00e1s ineficientes. En las clases <code>Nodo</code> y <code>BSTAislados</code> se puede incluir cualquier atributo o m\u00e9todo auxiliar.</li> <li>La complejidad del algoritmo implementado.</li> </ol> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class BSTAislados {\n    private Nodo raiz = null;\n\n    public int distancia(Nodo nodo) {\n        if (nodo.iz != null &amp;&amp; nodo.der != null) {\n            Nodo i = maxMenor(nodo.iz);\n            Nodo d = minMayor(nodo.der);\n            int dist = (Math.abs(nodo.numero - i.numero) &lt; Math.abs(nodo.numero - d.numero)) ?\n                        Math.abs(nodo.numero - i.numero) :\n                        Math.abs(nodo.numero - d.numero);\n            return dist;\n        }\n\n        Nodo otro = raiz;\n        int minDist = Integer.MAX_VALUE;\n\n        if (nodo.iz != null) {\n            Nodo i = maxMenor(nodo.iz);\n            minDist = Math.abs(nodo.numero - i.numero);\n        }\n\n        if (nodo.der != null) {\n            Nodo i = minMayor(nodo.der);\n            minDist = Math.abs(nodo.numero - i.numero);\n        }\n\n        while (otro != null) {\n            if (Math.abs(nodo.numero - otro.numero) &lt; minDist)\n                minDist = Math.abs(nodo.numero - otro.numero);\n\n            if (nodo.numero &lt; otro.numero)\n                otro = otro.iz;\n            else\n                otro = otro.der;\n        }\n\n        return minDist;\n    }\n\n    private Nodo maxMenor(Nodo n) {\n        if (n.der == null)\n            return n;\n        Nodo d = n.der;\n        while (d.der != null)\n            d = d.der;\n        return d;\n    }\n\n    private Nodo minMayor(Nodo n) {\n        if (n.iz == null)\n            return n;\n        Nodo i = n.iz;\n        while (i.iz != null)\n            i = i.iz;\n        return i;\n    }\n}\n</code></pre> <p>Si un nodo tiene descendientes izquierdo y derecho, el n\u00famero menor m\u00e1s pr\u00f3ximo es el mayor del sub-\u00e1rbol izquierdo, el nodo m\u00e1s abajo por las ramas derechas del sub\u00e1rbol izquierdo. Y el mayor m\u00e1s pr\u00f3ximo es el menor del sub-\u00e1rbol derecho, que es el que se encuentra m\u00e1s abajo por las ramas izquierdas del sub-\u00e1rbol derecho. Si el nodo no tiene descendientes, el nodo m\u00e1s pr\u00f3ximo es uno de sus antecesores hasta llegar a la ra\u00edz y si tiene un solo descendiente puede ser el m\u00e1s pr\u00f3ximo de su rama descendiente, o uno de sus antecesores hasta la ra\u00edz. Si es un antecesor, tiene que ser un nodo en el camino que va desde la ra\u00edz hasta el nodo. Si la profundidad del \u00e1rbol es \\(log n\\), y buscamos el mayor menor o el menor mayor, como mucho recorremos \\(log n\\) nodos. Si recorremos desde la ra\u00edz hasta el nodo, como mucho recorremos \\(log n\\) nodos (cuando el nodo no tiene descendientes). Si recorremos desde la ra\u00edz al nodo y desde el nodo por su descendiente, en total el recorrido como mucho es \\(log n\\).</p> <p>Complejidad \\(O(log n)\\).</p>"},{"location":"exams/2022/p1_ex01/","title":"P1 ex01","text":"<p>Un grafo multigrafo permite que haya varios arcos entre dos nodos. En una entidad bancaria se quiere modelar las transferencias ejecutadas entre los bancos durante un d\u00eda en una clase (<code>Banco</code>). En esta clase, se dispone de un atributo (<code>transferGrafo</code>) que es un multigrafo que modela estas transferencias:</p> <ul> <li>Un nodo modela un banco.   </li> <li>Un arco modela una transacci\u00f3n. Su peso representa la cantidad transferida.</li> </ul> <p>Una transferencia (la clase <code>Transfer</code>) se modela mediante los identificadores del banco origen y del banco destino, la cantidad, el nombre del ordenante y el nombre del beneficiario. Adem\u00e1s, se quiere relacionar cada arco del grafo con la informaci\u00f3n de su transferencia asociada. </p> <p>menorCamino</p> <code>public java.util.List&lt;Edge&gt; menorCamino(java.util.List&lt;java.util.List&lt;Edge&gt;&gt; listaCaminos)</code> Seleccionar el camino con el menor coste total. Parameters <code>listaCaminos</code> - una lista de caminos del grafo del sistema entre dos v\u00e9rtices. Returns La respuesta es un camino que sea el m\u00ednimo de la lista recibida. Si hubieran varios caminos m\u00ednimos con el mismo coste, se puede retornar cualquiera de ellos. <p>numeroVecesUsadoArco</p> <code>public java.util.Map&lt;Edge, java.lang.Integer&gt; numeroVecesUsadoArco(java.util.List&lt;java.util.List&lt;Edge&gt;&gt; listaCaminos)</code> Determina cu\u00e1ntas veces aparece cada arco en una lista de caminos Parameters <code>listaCaminos</code> - una lista de caminos del grafo del sistema entre dos v\u00e9rtices. Returns devuelve un diccionario, en el que la clave es un arco y el valor un entero que representa el n\u00famero de veces que el arco aparece en el par\u00e1metro de entrada. <p>Edge</p> Tipo M\u00e9todo Descripci\u00f3n int compareTo(Edge that) Compares two edges by weight. int either() Returns either endpoint of this edge. int other(int vertex) Returns the endpoint of this edge that is different from the given vertex. Double weight() Returns the weight of this edge. <p>List</p> Tipo M\u00e9todo Descripci\u00f3n boolean add(E e) Appends the specified element to the end of this list (optional operation). boolean contains(Object o) Returns true if this list contains the specified element. E get(int index) Returns the element at the specified position in this list. boolean isEmpty() Returns true if this list contains no elements. E remove(int index) Removes the element at the specified position in this list (optional operation). int size() Returns the number of elements in this list. <p>Map</p> Tipo M\u00e9todo Descripci\u00f3n boolean containsKey(Object key) Returns true if this map contains a mapping for the specified key. V get(Object key) Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. boolean isEmpty() Returns true if this map contains no key-value mappings. V put(K key, V value) Associates the specified value with the specified key in this map. V remove(Object key) Removes the mapping for the specified key from this map if present. int size() Returns the number of key-value mappings in this map. <p>Se pide:</p> <ul> <li>(a) (1,5 puntos) Proponga un atributo de una clase adecuada para relacionar un arco con su transferencia asociada y desarrolle el m\u00e9todo <code>ponerTransfer</code> para mantener esta relaci\u00f3n e integrar la transferencia en el grafo. </li> </ul> Mostrar soluci\u00f3n <pre><code>import edu.princeton.cs.algs4.*;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Banco {\n\n    private int nBancos;\n    private Map&lt;DirectedEdge, Transfer&gt; arcosTransfer;\n    private EdgeWeightedDigraph transferGrafo;\n\n    public Banco() {\n        this.arcosTransfer = new HashMap&lt;DirectedEdge, Transfer&gt;();\n        this.transferGrafo = new EdgeWeightedDigraph(nBancos);\n    }\n\n    /**\n     * A\u00f1adir una transferencia en el grafo y en la estructura que relacione\n     * una arista y su transferencia asociada\n     * @param transfer Transferencia a incluir\n     */\n    public void ponerTransfer(Transfer transfer) {\n        DirectedEdge arco = new DirectedEdge(\n            transfer.getBancoOrigen(),\n            transfer.getBancoDestino(),\n            transfer.getCantidad()\n        );\n        arcosTransfer.put(arco, transfer);\n        transferGrafo.addEdge(arco);\n    }\n\n    /**\n     * Calcular la cantidad neta de las transferencias ejecutadas\n     * durante un d\u00eda entre bank1 y bank2\n     * @param banco1 Identificador de un banco\n     * @param banco2 Identificador de otro banco\n     * @return cantidad neta durante un d\u00eda entre bank1 y bank2\n     */\n    public Double netoTransfer(int banco1, int banco2) {\n        double nBanco1 = 0;\n        double nBanco2 = 0;\n\n        if (banco1 &lt; 0 || banco1 &gt;= transferGrafo.V()) return null;\n        if (banco2 &lt; 0 || banco2 &gt;= transferGrafo.V()) return null;\n\n        // Calcular el total de dinero banco1 -&gt; banco2\n        for (DirectedEdge arco : transferGrafo.adj(banco1)) {\n            if (arco.to() == banco2) {\n                nBanco1 += arco.weight();\n            }\n        }\n\n        // Calcular el total de dinero banco2 -&gt; banco1\n        for (DirectedEdge arco : transferGrafo.adj(banco2)) {\n            if (arco.to() == banco1) {\n                nBanco2 += arco.weight();\n            }\n        }\n\n        return nBanco1 - nBanco2;\n    }\n\n    /**\n     * Generar la lista de las transferencias que ha generado\n     * el ordenante durante un d\u00eda\n     * @param ordenante Usuario que ordena la transferencia\n     * @return Lista de las transferencias de un ordenante\n     */\n    public List&lt;Transfer&gt; clienteTransfer(String ordenante) {\n        List&lt;Transfer&gt; lista = new ArrayList&lt;Transfer&gt;();\n\n        for (DirectedEdge arco : transferGrafo.edges()) {\n            Transfer transfer = arcosTransfer.get(arco);\n            if (transfer.getOrdenante().equals(ordenante)) {\n                lista.add(transfer);\n            }\n        }\n\n        return lista;\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Desarrolle el m\u00e9todo <code>netoTransfer</code> que retorne la cantidad de dinero neto transferido entre dos bancos en un d\u00eda. Habr\u00e1 que restar la cantidad de las transferencias entre los dos bancos.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p> <ul> <li>(c) (1,5 puntos) Desarrolle el m\u00e9todo <code>clienteTransfer</code> que retorne la lista no ordenada de las transferencias que ha ejecutado una persona (ordenante) durante un d\u00eda.</li> </ul> Mostrar soluci\u00f3n <p>Vac\u00edo</p> <p>NOTA: los grafos de U. Princeton usado en esta asignatura permiten crear multigrafos.</p>","tags":["grafos","princeton"]},{"location":"exams/2022/p1_ex02/","title":"P1 ex02","text":"<p>Dado un conjunto de n\u00fameros, la distancia entre un elemento del conjunto y el resto del conjunto es la m\u00ednima diferencia entre ese n\u00famero y otro cualquiera del conjunto. Por ejemplo, la distancia de 10 en el conjunto {3,6,10,16,17} es 4, y la de 16 es 1. El elemento m\u00e1s aislado del conjunto es el elemento que tenga la distancia mayor. Si varios n\u00fameros tienen esa misma distancia mayor, el m\u00e1s aislado es uno cualquiera de ellos. En el conjunto anterior, el elemento m\u00e1s aislado es el 10. Podemos suponer que el conjunto tiene al menos un n\u00famero. Si solo hay uno, seria el m\u00e1s aislado y su distancia es infinito.</p> <pre><code>public class BSTAislados {\n\n    private Nodo ra\u00edz = null;\n\n    public int distancia(Nodo nodo) {\n        // SOLUCION Pregunta 2.c\n    }\n}\n</code></pre> <pre><code>public class Nodo {\n    public int numero;\n    public Nodo iz, der;\n    // Disponibles los getters y setters\n}\n</code></pre> <ul> <li>(a) (1,5 puntos) Se dispone un conjunto de n\u00fameros ordenado por el valor de los n\u00fameros con un array. No hay ninguna estructura de datos adicional, en relaci\u00f3n con el conjunto de n\u00fameros. \u00bfQu\u00e9 complejidad tendr\u00e1 el algoritmo m\u00e1s eficiente que calcule el n\u00famero m\u00e1s aislado del conjunto? Justifique la respuesta. No se est\u00e1 pidiendo una implementaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>Si los n\u00fameros est\u00e1n ordenados por valor, los n\u00fameros m\u00e1s pr\u00f3ximos a uno dado son el anterior y el siguiente. La distancia de un n\u00famero es la menor de las diferencias con el anterior y el siguiente. Este es un c\u00e1lculo de complejidad constante y no depende del tama\u00f1o del conjunto. Pero el m\u00e1s aislado puede ser cualquiera de los n\u00fameros, porque, aunque est\u00e9n ordenados, la deferencia entre un n\u00famero y el siguiente puede ser cualquiera. Para calcular el m\u00e1s aislado hay que recorrer todo el array y calcular la distancia para cada posici\u00f3n, y el m\u00e1s aislado ser\u00e1 el que tenga distancia mayor. </p> <p>Complejidad \\(O(n)\\) donde \\(n\\) es el tama\u00f1o del conjunto.</p> <ul> <li>(b) (1,5 puntos) Se dispone un conjunto de n\u00fameros ordenado por el valor de los n\u00fameros con un \u00e1rbol binario. No hay ninguna estructura de datos adicional, en relaci\u00f3n con el conjunto de n\u00fameros. Se supone que los n\u00fameros que incluye el \u00e1rbol se han insertado de forma aleatoria y son valores aleatorios. \u00bfQu\u00e9 complejidad tendr\u00e1 el algoritmo m\u00e1s eficiente que calcule el n\u00famero m\u00e1s aislado del conjunto? Justifique la respuesta. No se est\u00e1 pidiendo una implementaci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <p>En el caso de que representemos el conjunto mediante un \u00e1rbol binario seguimos necesitando recorrer todo el \u00e1rbol para encontrar el m\u00e1s aislado. La diferencia entre el valor de un nodo y cualquiera de sus descendientes directos o indirectos puede ser cualquiera. Podemos utilizar como algoritmos un algoritmo de recorrido del \u00e1rbol en orden. Recorreremos empezando por los n\u00fameros m\u00e1s peque\u00f1os y terminaremos con los grandes. En el recorrido del \u00e1rbol, actualizamos los tres \u00faltimos nodos visitados (por ejemplo, un array de tres elementos que incluye el nodo que visitamos y los dos anteriores, ese array puede ser un par\u00e1metro del m\u00e9todo que recorre los nodos o un atributo auxiliar). La distancia del nodo anterior al nodo que visitamos es la menor de las diferencias entre el pen\u00faltimo nodo, el ante-pen\u00faltimo y el que visitamos. La diferencia del primer nodo la calculamos en la segunda visita, y la \u00faltima visita calculamos la del \u00faltimo con el pen\u00faltimo. En total visitamos todos los nodos y el calculo de las distancias es constante.</p> <p>Complejidad de orden \\(O(n)\\) donde \\(n\\) es el tama\u00f1o del conjunto y del \u00e1rbol.</p> <ul> <li> <p>(c) (2 puntos) Se dispone de un \u00e1rbol binario que incluye el conjunto de n\u00fameros ordenado por el valor de cada n\u00famero que representan los nodos. Implemente el m\u00e9todo que devuelve la distancia del n\u00famero para el nodo en el par\u00e1metro. La respuesta debe incluir: </p> <ol> <li>La implementaci\u00f3n del algoritmo. La puntuaci\u00f3n de la pregunta ser\u00e1 mayor para soluciones m\u00e1s eficientes, y menor para las soluciones m\u00e1s ineficientes. En las clases <code>Nodo</code> y <code>BSTAislados</code> se puede incluir cualquier atributo o m\u00e9todo auxiliar.</li> <li>La complejidad del algoritmo implementado.</li> </ol> </li> </ul> Mostrar soluci\u00f3n <pre><code>public class BSTAislados {\n    private Nodo raiz = null;\n\n    public int distancia(Nodo nodo) {\n        if (nodo.iz != null &amp;&amp; nodo.der != null) {\n            Nodo i = maxMenor(nodo.iz);\n            Nodo d = minMayor(nodo.der);\n            int dist = (Math.abs(nodo.numero - i.numero) &lt; Math.abs(nodo.numero - d.numero)) ?\n                        Math.abs(nodo.numero - i.numero) :\n                        Math.abs(nodo.numero - d.numero);\n            return dist;\n        }\n\n        Nodo otro = raiz;\n        int minDist = Integer.MAX_VALUE;\n\n        if (nodo.iz != null) {\n            Nodo i = maxMenor(nodo.iz);\n            minDist = Math.abs(nodo.numero - i.numero);\n        }\n\n        if (nodo.der != null) {\n            Nodo i = minMayor(nodo.der);\n            minDist = Math.abs(nodo.numero - i.numero);\n        }\n\n        while (otro != null) {\n            if (Math.abs(nodo.numero - otro.numero) &lt; minDist)\n                minDist = Math.abs(nodo.numero - otro.numero);\n\n            if (nodo.numero &lt; otro.numero)\n                otro = otro.iz;\n            else\n                otro = otro.der;\n        }\n\n        return minDist;\n    }\n\n    private Nodo maxMenor(Nodo n) {\n        if (n.der == null)\n            return n;\n        Nodo d = n.der;\n        while (d.der != null)\n            d = d.der;\n        return d;\n    }\n\n    private Nodo minMayor(Nodo n) {\n        if (n.iz == null)\n            return n;\n        Nodo i = n.iz;\n        while (i.iz != null)\n            i = i.iz;\n        return i;\n    }\n}\n</code></pre> <p>Si un nodo tiene descendientes izquierdo y derecho, el n\u00famero menor m\u00e1s pr\u00f3ximo es el mayor del sub-\u00e1rbol izquierdo, el nodo m\u00e1s abajo por las ramas derechas del sub\u00e1rbol izquierdo. Y el mayor m\u00e1s pr\u00f3ximo es el menor del sub-\u00e1rbol derecho, que es el que se encuentra m\u00e1s abajo por las ramas izquierdas del sub-\u00e1rbol derecho. Si el nodo no tiene descendientes, el nodo m\u00e1s pr\u00f3ximo es uno de sus antecesores hasta llegar a la ra\u00edz y si tiene un solo descendiente puede ser el m\u00e1s pr\u00f3ximo de su rama descendiente, o uno de sus antecesores hasta la ra\u00edz. Si es un antecesor, tiene que ser un nodo en el camino que va desde la ra\u00edz hasta el nodo. Si la profundidad del \u00e1rbol es \\(log n\\), y buscamos el mayor menor o el menor mayor, como mucho recorremos \\(log n\\) nodos. Si recorremos desde la ra\u00edz hasta el nodo, como mucho recorremos \\(log n\\) nodos (cuando el nodo no tiene descendientes). Si recorremos desde la ra\u00edz al nodo y desde el nodo por su descendiente, en total el recorrido como mucho es \\(log n\\).</p> <p>Complejidad \\(O(log n)\\).</p>","tags":["complejidad"]},{"location":"exams/2022/p1r/","title":"Examen 2022 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2022/p1r/#problema-1","title":"Problema 1","text":"<p>Utilizando el modelo de datos de la pr\u00e1ctica 2 donde un v\u00e9rtice representaba un actor y una arista representa la pel\u00edcula en la que han colaborado ambos actores. Se disponen las clases <code>GraphLoader</code>, <code>Movie</code> y <code>DijkstraSP</code> que podemos utilizar para resolver el problema. Y en el campo <code>EdgeWeightedDigraph g</code> de la clase <code>GraphLoader</code> tenemos ya cargado el grafo de actores y pel\u00edculas. Seg\u00fan el siguiente diagrama de clases:</p> <p></p> <p>Clase <code>EdgeWeightedDigraph</code></p> Tipo M\u00e9todo Descripci\u00f3n void <code>addEdge(DirectedEdge e)</code> Adds the directed edge to this edge-weighted digraph. Iterable <code>adj(int v)</code> Returns the directed edges incident from vertex v. int <code>E()</code> Returns the number of edges in this edge-weighted digraph. Iterable <code>edges()</code> Returns all directed edges in this edge-weighted digraph. int <code>V()</code> Returns the number of vertices in this edge-weighted digraph. <p>Clase <code>DijkstraSP</code></p> Constructor Descripci\u00f3n <code>DijkstraSP(EdgeWeightedDigraph G, int s)</code> Computes a shortest-paths tree from the source vertex s to every other vertex in the edge-weighted digraph G. Tipo M\u00e9todo Descripci\u00f3n double <code>distTo(int v)</code> Returns the length of a shortest path from the source vertex s to vertex v. Iterable <code>pathTo(int v)</code> Returns a shortest path from the source vertex s to vertex v. <p>Clase <code>DirectedEdge</code> </p> Tipo M\u00e9todo Descripci\u00f3n int <code>from()</code> Returns the tail vertex of the directed edge. int <code>to()</code> Returns the head vertex of the directed edge. double <code>weight()</code> Returns the weight of the directed edge. <p>Se pide:</p> <ul> <li>(a) (1 punto) Desarrolle el m\u00e9todo <code>obtenerIndiceMayor</code>: Recibe un array de enteros y devuelve un <code>int</code> con el \u00edndice de la posici\u00f3n con el valor mayor. En caso de empate, se puede devolver cualquiera de los n \u00edndices que empatan: <code>public int obtenerIndiceMayor(int[] array)</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int obtenerIndiceMayor(int[] array) {\n    if (array == null || array.length == 0)\n        return -1; // null or empty\n\n    int largest = 0;\n    for (int i = 1; i &lt; array.length; i++) {\n        if (array[i] &gt; array[largest])\n            largest = i;\n    }\n\n    return largest; // position of the first largest found\n}\n</code></pre> <ul> <li>(b) (2 punto) El algoritmo Dijkstra calcula el \u00e1rbol de caminos m\u00e1s cortos desde un nodo. El constructor calcula este algoritmo y proporciona un m\u00e9todo (<code>pathTo</code>) para obtener el camino m\u00ednimo desde el origen. Se pide desarrollar el m\u00e9todo <code>actorCentralDesdeOrigen</code> que retorna un array, cuyo tama\u00f1o es el n\u00famero de v\u00e9rtices (en el grafo) y sus valores son el n\u00famero de veces que aparece el v\u00e9rtice en cualquier camino: <code>public int[] actorCentralDesdeOrigen(int origen)</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int[] actorCentralDesdeOrigen(int origen) {\n    int[] btw = new int[this.g.V()];\n\n    for (int destino = origen + 1; destino &lt; this.g.V(); destino++) {\n        if ((origen != destino) &amp;&amp; (g.pathTo(destino) != null)) {\n            for (DirectedEdge e : g.pathTo(destino)) {\n                if (e.to() != destino)\n                    btw[e.to()]++;\n            }\n        }\n    }\n\n    return btw;\n}\n</code></pre> <ul> <li>(c) (2 punto) Desarrolle el m\u00e9todo que retorne el actor m\u00e1s central del grafo. Para ello, hay que calcular el actor m\u00e1s central entre los \u00e1rboles de caminos de los v\u00e9rtices del grafo: <code>public String actorCentral()</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public String actorCentral() {\n    int[] btw = new int[this.g.V()];\n\n    for (int origen = 0; origen &lt; this.g.V(); origen++) {\n        DijkstraSP d = new DijkstraSP(this.g, origen);\n        int[] aux = this.actorCentralDesdeOrigen(origen);\n\n        for (int i = 0; i &lt; this.g.V(); i++) { // corregido inicializaci\u00f3n de i\n            btw[i] += aux[i];\n        }\n    }\n\n    int actor = obtenerIndiceMayor(btw);\n    Map&lt;Integer, String&gt; actorsMapInverted = this.getActorsMapInverted();\n    return actorsMapInverted.get(actor);\n}\n</code></pre> <p>Nota: es muy aconsejable desarrollar estos m\u00e9todos en el mismo orden y desarrollar el tercer m\u00e9todo usando los dos anteriores.</p>"},{"location":"exams/2022/p1r/#problema-2","title":"Problema 2","text":"<p>Se dispone de un array de n\u00fameros enteros, que incluye <code>n</code> secuencias repetidas de n\u00fameros ordenados ascendentemente del 1 al <code>m</code>. Por ejemplo, si <code>m</code> es 8, y <code>n</code> es 4, el contenido del array ser\u00e1:</p> <p><code>[1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8]</code></p> <p>Se ha ordenado el array (en sentido ascendente) con los algoritmos que se muestran posteriormente. En algunas respuestas hay que contestar cantidades de ejecuci\u00f3n de c\u00f3digo, basado en los valores gen\u00e9ricos de <code>n</code> y <code>m</code>. En este caso, se pueden contestar las cantidades aproximadas como <code>n2.m</code>, <code>n.log m</code> o <code>n.m2</code>:</p> <ul> <li>(a) (1 punto) Ordenaci\u00f3n por intercambio (burbuja): \u00bfCu\u00e1ntas comparaciones (en la l\u00ednea 6) de n\u00famero hacemos? Una implementaci\u00f3n del algoritmo ser\u00eda:</li> </ul> <p>Intercambio: <pre><code>01 public static void sort(int[] data) {\n02     boolean changed;\n03     do {\n04         changed = false;\n05         for (int i = 0; i &lt; data.length - 1; i++) {\n06             if (data[i] &gt; data[i + 1]) {\n07                 swap(data, i, i + 1);\n08                 changed = true;\n09             }\n10         }\n11     } while (changed);\n12 }\n</code></pre></p> Mostrar soluci\u00f3n <p>N\u00famero de comparaciones: \\((n x m - 1) x ((m-1)x(n-1)+1)\\). El bucle interior <code>for</code> se ejecuta siempre \\(m x n \u2013 1\\) veces (la longitud del array menos una vez). El bucle <code>while</code> va haciendo desplazamientos para todos los n\u00fameros de la secuencia, menos los \\(1 (m-1)\\), y desplaza todas las secuencias menos la \u00faltima que ya estar\u00e1 ordenada al final \\((n-1)\\), el algoritmo necesita una \u00faltima ejecuci\u00f3n de <code>for</code> para comprobar que todo est\u00e1 ordenado.</p> <ul> <li>(b) (1 punto) Ordenaci\u00f3n por selecci\u00f3n: \u00bfCu\u00e1ntas comparaciones de n\u00famero se ejecutan en el algoritmo mostrado al ordenar un array?</li> </ul> <p>Selecci\u00f3n: <pre><code>01 public static void sort(int[] data) {\n02     for (int i = 0; i &lt; data.length - 1; i++) {\n03         int j = min(data, i, data.length);\n04         swap(data, i, j);\n05    }\n06 }\n07 private static int min(int[] data, int a, int z) {\n08     int m = a;\n09     for (int i = a; i &lt; z; i++)\n10         if (data[i] &lt; data[m])\n11             m = i;\n12     return m;\n13 }\n</code></pre></p> Mostrar soluci\u00f3n <p>N\u00famero de comparaciones: \\((n x m) x (1 + n x m) / 2\\). El algoritmo de selecci\u00f3n ejecuta la primera vez el m\u00e9todo <code>min</code> para valores de 0 a <code>data.length-1</code>, el siguiente para 1 a <code>data.length-1</code>, el siguiente de 2 a <code>data.length-1</code>, y el \u00faltimo de <code>data.length-2</code> a <code>data.length-2</code>. Eso es el sumatorio de <code>n=1</code> a <code>data.length-1</code>, que es la expresi\u00f3n dada.</p> <ul> <li>(c) (1 punto) Ordenaci\u00f3n por mergesort: \u00bfCu\u00e1ntas ejecuciones del cuerpo de la sentencia <code>while</code> (l\u00ednea 10) se ejecutan al ordenar un array?. A continuaci\u00f3n, se muestra una implementaci\u00f3n de este algoritmo:</li> </ul> <pre><code>01 public static void sort(int[] datos) {\n02     if (datos.length &lt; 2)\n03         return;\n04     int m = datos.length / 2;\n05     int[] izq = Arrays.copyOfRange(datos, 0, m);\n06     int[] der = Arrays.copyOfRange(datos, m, datos.length);\n07     sort(izq);\n08     sort(der);\n09     int dest = 0; int i = 0; int d = 0;\n10     while (i &lt; izq.length || d &lt; der.length) {\n11         if (d == der.length) {\n12             datos[dest++] = izq[i++];\n13             continue;\n14         }\n15         if (i == izq.length) {\n16             datos[dest++] = der[d++];\n17             continue;\n18         }\n19         if (izq[i] &lt; der[d])\n20             datos[dest++] = izq[i++];\n21         else\n22             datos[dest++] = der[d++];\n23     }\n24 }\n</code></pre> <p>NOTA: El siguiente m\u00e9todo es est\u00e1tico en la clase <code>Arrays</code>. Copia el rango especificado del array original en un array nuevo.</p> <pre><code>static int [] copyOfRange(int[] original, int from, int to)\n</code></pre> Mostrar soluci\u00f3n <p>N\u00famero de comparaciones: \\((m x n) log2 (n x m)\\) La complejidad de mergesort es siempre igual y el n\u00famero de vueltas del bucle <code>while</code> depende de las multiplicidades de \\(m x n\\) de 2. Pero siempre ser\u00e1 un valor aproximadamente el dado.</p> <ul> <li>(d) (1,5 puntos) Se quiere desarrollar el m\u00e9todo <code>secuenciasRepetidas</code> que recibe un array de enteros y devuelve un valor l\u00f3gico, que indica si el contenido del array es una secuencia correcta, como se describe en este enunciado; antes de retornar, el m\u00e9todo actualiza dos atributos <code>m</code> y <code>n</code> con los valores de <code>m</code> y <code>n</code> descritos en este enunciado. <pre><code>public boolean secuenciasRepetidas(int[] data)\n</code></pre></li> </ul> <p>Las secuencias deben aparecer completas (por ejemplo, <code>[1,2,3,1,2]</code> devolver\u00e1 falso; <code>n</code> y <code>m</code> son n\u00fameros mayores o iguales a 1, pero la secuencia puede ser \u00fanica (por ejemplo, si <code>n = 1</code>, <code>m = 3</code>, <code>[1,2,3]</code> devuelve verdadero; si <code>n = 1</code> y <code>m = 1</code>, <code>[1]</code> devuelve verdadero); las secuencias empiezan por 1 y la diferencia entre t\u00e9rminos es 1. La puntuaci\u00f3n de la pregunta ser\u00e1 mayor para soluciones m\u00e1s eficientes, y menor para las soluciones m\u00e1s ineficientes.</p> Mostrar soluci\u00f3n <pre><code>private int m, n;\n\npublic boolean secuenciasRepetidas(int[] data) {\n    int m = 1;\n    if (data.length == 0 | data[0] != 1) return false;\n\n    while (m &lt; data.length + 1 &amp;&amp; data[m - 1] == m)\n        m++;\n\n    m--;\n\n    if (m == data.length) {\n        this.m = m;\n        this.n = 1;\n        return true;\n    }\n\n    if (data[m] != 1 || data.length % m != 0) return false;\n\n    int i = m;\n    while (i &lt; data.length &amp;&amp; data[i] == (i % m + 1))\n        i++;\n\n    if (i != data.length) return false;\n\n    this.m = m;\n    this.n = data.length / m;\n    return true;\n}\n</code></pre> <ul> <li>(e) (0,5 puntos) Calcular la complejidad del algoritmo implementado en la pregunta (d).</li> </ul> Mostrar soluci\u00f3n <p>La complejidad de esta implementaci\u00f3n es lineal. \\(O(n)\\) donde <code>n=data.length</code>. O bien el bucle de la l\u00ednea 6 recorre todo el array y el m\u00e9todo termina, o el bucle de la l\u00ednea 16 termina de recorrer el array, o en alg\u00fan momento anterior el m\u00e9todo detecta que el patr\u00f3n buscado no se encuentra en el array y el m\u00e9todo termina.</p>"},{"location":"exams/2022/p1r_ex01/","title":"P1r ex01","text":"<p>Utilizando el modelo de datos de la pr\u00e1ctica 2 donde un v\u00e9rtice representaba un actor y una arista representa la pel\u00edcula en la que han colaborado ambos actores. Se disponen las clases <code>GraphLoader</code>, <code>Movie</code> y <code>DijkstraSP</code> que podemos utilizar para resolver el problema. Y en el campo <code>EdgeWeightedDigraph g</code> de la clase <code>GraphLoader</code> tenemos ya cargado el grafo de actores y pel\u00edculas. Seg\u00fan el siguiente diagrama de clases:</p> <p></p> <p>Clase <code>EdgeWeightedDigraph</code></p> Tipo M\u00e9todo Descripci\u00f3n void <code>addEdge(DirectedEdge e)</code> Adds the directed edge to this edge-weighted digraph. Iterable <code>adj(int v)</code> Returns the directed edges incident from vertex v. int <code>E()</code> Returns the number of edges in this edge-weighted digraph. Iterable <code>edges()</code> Returns all directed edges in this edge-weighted digraph. int <code>V()</code> Returns the number of vertices in this edge-weighted digraph. <p>Clase <code>DijkstraSP</code></p> Constructor Descripci\u00f3n <code>DijkstraSP(EdgeWeightedDigraph G, int s)</code> Computes a shortest-paths tree from the source vertex s to every other vertex in the edge-weighted digraph G. Tipo M\u00e9todo Descripci\u00f3n double <code>distTo(int v)</code> Returns the length of a shortest path from the source vertex s to vertex v. Iterable <code>pathTo(int v)</code> Returns a shortest path from the source vertex s to vertex v. <p>Clase <code>DirectedEdge</code> </p> Tipo M\u00e9todo Descripci\u00f3n int <code>from()</code> Returns the tail vertex of the directed edge. int <code>to()</code> Returns the head vertex of the directed edge. double <code>weight()</code> Returns the weight of the directed edge. <p>Se pide:</p> <ul> <li>(a) (1 punto) Desarrolle el m\u00e9todo <code>obtenerIndiceMayor</code>: Recibe un array de enteros y devuelve un <code>int</code> con el \u00edndice de la posici\u00f3n con el valor mayor. En caso de empate, se puede devolver cualquiera de los n \u00edndices que empatan: <code>public int obtenerIndiceMayor(int[] array)</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int obtenerIndiceMayor(int[] array) {\n    if (array == null || array.length == 0)\n        return -1; // null or empty\n\n    int largest = 0;\n    for (int i = 1; i &lt; array.length; i++) {\n        if (array[i] &gt; array[largest])\n            largest = i;\n    }\n\n    return largest; // position of the first largest found\n}\n</code></pre> <ul> <li>(b) (2 punto) El algoritmo Dijkstra calcula el \u00e1rbol de caminos m\u00e1s cortos desde un nodo. El constructor calcula este algoritmo y proporciona un m\u00e9todo (<code>pathTo</code>) para obtener el camino m\u00ednimo desde el origen. Se pide desarrollar el m\u00e9todo <code>actorCentralDesdeOrigen</code> que retorna un array, cuyo tama\u00f1o es el n\u00famero de v\u00e9rtices (en el grafo) y sus valores son el n\u00famero de veces que aparece el v\u00e9rtice en cualquier camino: <code>public int[] actorCentralDesdeOrigen(int origen)</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int[] actorCentralDesdeOrigen(int origen) {\n    int[] btw = new int[this.g.V()];\n\n    for (int destino = origen + 1; destino &lt; this.g.V(); destino++) {\n        if ((origen != destino) &amp;&amp; (g.pathTo(destino) != null)) {\n            for (DirectedEdge e : g.pathTo(destino)) {\n                if (e.to() != destino)\n                    btw[e.to()]++;\n            }\n        }\n    }\n\n    return btw;\n}\n</code></pre> <ul> <li>(c) (2 punto) Desarrolle el m\u00e9todo que retorne el actor m\u00e1s central del grafo. Para ello, hay que calcular el actor m\u00e1s central entre los \u00e1rboles de caminos de los v\u00e9rtices del grafo: <code>public String actorCentral()</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public String actorCentral() {\n    int[] btw = new int[this.g.V()];\n\n    for (int origen = 0; origen &lt; this.g.V(); origen++) {\n        DijkstraSP d = new DijkstraSP(this.g, origen);\n        int[] aux = this.actorCentralDesdeOrigen(origen);\n\n        for (int i = 0; i &lt; this.g.V(); i++) { // corregido inicializaci\u00f3n de i\n            btw[i] += aux[i];\n        }\n    }\n\n    int actor = obtenerIndiceMayor(btw);\n    Map&lt;Integer, String&gt; actorsMapInverted = this.getActorsMapInverted();\n    return actorsMapInverted.get(actor);\n}\n</code></pre> <p>Nota: es muy aconsejable desarrollar estos m\u00e9todos en el mismo orden y desarrollar el tercer m\u00e9todo usando los dos anteriores.</p>","tags":["complejidad"]},{"location":"exams/2022/p1r_ex02/","title":"P1r ex02","text":"<p>Se dispone de un array de n\u00fameros enteros, que incluye <code>n</code> secuencias repetidas de n\u00fameros ordenados ascendentemente del 1 al <code>m</code>. Por ejemplo, si <code>m</code> es 8, y <code>n</code> es 4, el contenido del array ser\u00e1:</p> <p><code>[1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8]</code></p> <p>Se ha ordenado el array (en sentido ascendente) con los algoritmos que se muestran posteriormente. En algunas respuestas hay que contestar cantidades de ejecuci\u00f3n de c\u00f3digo, basado en los valores gen\u00e9ricos de <code>n</code> y <code>m</code>. En este caso, se pueden contestar las cantidades aproximadas como <code>n2.m</code>, <code>n.log m</code> o <code>n.m2</code>:</p> <ul> <li>(a) (1 punto) Ordenaci\u00f3n por intercambio (burbuja): \u00bfCu\u00e1ntas comparaciones (en la l\u00ednea 6) de n\u00famero hacemos? Una implementaci\u00f3n del algoritmo ser\u00eda:</li> </ul> <p>Intercambio: <pre><code>01 public static void sort(int[] data) {\n02     boolean changed;\n03     do {\n04         changed = false;\n05         for (int i = 0; i &lt; data.length - 1; i++) {\n06             if (data[i] &gt; data[i + 1]) {\n07                 swap(data, i, i + 1);\n08                 changed = true;\n09             }\n10         }\n11     } while (changed);\n12 }\n</code></pre></p> Mostrar soluci\u00f3n <p>N\u00famero de comparaciones: \\((n x m - 1) x ((m-1)x(n-1)+1)\\). El bucle interior <code>for</code> se ejecuta siempre \\(m x n \u2013 1\\) veces (la longitud del array menos una vez). El bucle <code>while</code> va haciendo desplazamientos para todos los n\u00fameros de la secuencia, menos los \\(1 (m-1)\\), y desplaza todas las secuencias menos la \u00faltima que ya estar\u00e1 ordenada al final \\((n-1)\\), el algoritmo necesita una \u00faltima ejecuci\u00f3n de <code>for</code> para comprobar que todo est\u00e1 ordenado.</p> <ul> <li>(b) (1 punto) Ordenaci\u00f3n por selecci\u00f3n: \u00bfCu\u00e1ntas comparaciones de n\u00famero se ejecutan en el algoritmo mostrado al ordenar un array?</li> </ul> <p>Selecci\u00f3n: <pre><code>01 public static void sort(int[] data) {\n02     for (int i = 0; i &lt; data.length - 1; i++) {\n03         int j = min(data, i, data.length);\n04         swap(data, i, j);\n05    }\n06 }\n07 private static int min(int[] data, int a, int z) {\n08     int m = a;\n09     for (int i = a; i &lt; z; i++)\n10         if (data[i] &lt; data[m])\n11             m = i;\n12     return m;\n13 }\n</code></pre></p> Mostrar soluci\u00f3n <p>N\u00famero de comparaciones: \\((n x m) x (1 + n x m) / 2\\). El algoritmo de selecci\u00f3n ejecuta la primera vez el m\u00e9todo <code>min</code> para valores de 0 a <code>data.length-1</code>, el siguiente para 1 a <code>data.length-1</code>, el siguiente de 2 a <code>data.length-1</code>, y el \u00faltimo de <code>data.length-2</code> a <code>data.length-2</code>. Eso es el sumatorio de <code>n=1</code> a <code>data.length-1</code>, que es la expresi\u00f3n dada.</p> <ul> <li>(c) (1 punto) Ordenaci\u00f3n por mergesort: \u00bfCu\u00e1ntas ejecuciones del cuerpo de la sentencia <code>while</code> (l\u00ednea 10) se ejecutan al ordenar un array?. A continuaci\u00f3n, se muestra una implementaci\u00f3n de este algoritmo:</li> </ul> <pre><code>01 public static void sort(int[] datos) {\n02     if (datos.length &lt; 2)\n03         return;\n04     int m = datos.length / 2;\n05     int[] izq = Arrays.copyOfRange(datos, 0, m);\n06     int[] der = Arrays.copyOfRange(datos, m, datos.length);\n07     sort(izq);\n08     sort(der);\n09     int dest = 0; int i = 0; int d = 0;\n10     while (i &lt; izq.length || d &lt; der.length) {\n11         if (d == der.length) {\n12             datos[dest++] = izq[i++];\n13             continue;\n14         }\n15         if (i == izq.length) {\n16             datos[dest++] = der[d++];\n17             continue;\n18         }\n19         if (izq[i] &lt; der[d])\n20             datos[dest++] = izq[i++];\n21         else\n22             datos[dest++] = der[d++];\n23     }\n24 }\n</code></pre> <p>NOTA: El siguiente m\u00e9todo es est\u00e1tico en la clase <code>Arrays</code>. Copia el rango especificado del array original en un array nuevo.</p> <pre><code>static int [] copyOfRange(int[] original, int from, int to)\n</code></pre> Mostrar soluci\u00f3n <p>N\u00famero de comparaciones: \\((m x n) log2 (n x m)\\) La complejidad de mergesort es siempre igual y el n\u00famero de vueltas del bucle <code>while</code> depende de las multiplicidades de \\(m x n\\) de 2. Pero siempre ser\u00e1 un valor aproximadamente el dado.</p> <ul> <li>(d) (1,5 puntos) Se quiere desarrollar el m\u00e9todo <code>secuenciasRepetidas</code> que recibe un array de enteros y devuelve un valor l\u00f3gico, que indica si el contenido del array es una secuencia correcta, como se describe en este enunciado; antes de retornar, el m\u00e9todo actualiza dos atributos <code>m</code> y <code>n</code> con los valores de <code>m</code> y <code>n</code> descritos en este enunciado. <pre><code>public boolean secuenciasRepetidas(int[] data)\n</code></pre></li> </ul> <p>Las secuencias deben aparecer completas (por ejemplo, <code>[1,2,3,1,2]</code> devolver\u00e1 falso; <code>n</code> y <code>m</code> son n\u00fameros mayores o iguales a 1, pero la secuencia puede ser \u00fanica (por ejemplo, si <code>n = 1</code>, <code>m = 3</code>, <code>[1,2,3]</code> devuelve verdadero; si <code>n = 1</code> y <code>m = 1</code>, <code>[1]</code> devuelve verdadero); las secuencias empiezan por 1 y la diferencia entre t\u00e9rminos es 1. La puntuaci\u00f3n de la pregunta ser\u00e1 mayor para soluciones m\u00e1s eficientes, y menor para las soluciones m\u00e1s ineficientes.</p> Mostrar soluci\u00f3n <pre><code>private int m, n;\n\npublic boolean secuenciasRepetidas(int[] data) {\n    int m = 1;\n    if (data.length == 0 | data[0] != 1) return false;\n\n    while (m &lt; data.length + 1 &amp;&amp; data[m - 1] == m)\n        m++;\n\n    m--;\n\n    if (m == data.length) {\n        this.m = m;\n        this.n = 1;\n        return true;\n    }\n\n    if (data[m] != 1 || data.length % m != 0) return false;\n\n    int i = m;\n    while (i &lt; data.length &amp;&amp; data[i] == (i % m + 1))\n        i++;\n\n    if (i != data.length) return false;\n\n    this.m = m;\n    this.n = data.length / m;\n    return true;\n}\n</code></pre> <ul> <li>(e) (0,5 puntos) Calcular la complejidad del algoritmo implementado en la pregunta (d).</li> </ul> Mostrar soluci\u00f3n <p>La complejidad de esta implementaci\u00f3n es lineal. \\(O(n)\\) donde <code>n=data.length</code>. O bien el bucle de la l\u00ednea 6 recorre todo el array y el m\u00e9todo termina, o el bucle de la l\u00ednea 16 termina de recorrer el array, o en alg\u00fan momento anterior el m\u00e9todo detecta que el patr\u00f3n buscado no se encuentra en el array y el m\u00e9todo termina.</p>","tags":["complejidad"]},{"location":"exams/2022/p2/","title":"Examen 2022 \u2014 Parcial 2","text":""},{"location":"exams/2022/p2/#problema-1","title":"Problema 1","text":"<p>Se dispone un puente elevado para autom\u00f3viles. Se quiere desarrollar un sistema de seguridad que impide que haya m\u00e1s de 10 veh\u00edculos simult\u00e1neamente en el puente y con un peso total mayor que 15.000 Kg.</p> <p>Cuando un veh\u00edculo quiere entrar en el puente, ejecuta el m\u00e9todo <code>entrarPuente</code> y cuando lo abandona, ejecuta el m\u00e9todo <code>salirPuente</code>. Las ambulancias tienen que invocar el m\u00e9todo <code>entrarPuenteAmbulancia</code> para tener prioridad en el acceso.</p> <ul> <li>(a) (1,5 puntos) Desarrolle el monitor con las restricciones indicadas como se muestra en la plantilla que se muestra a continuaci\u00f3n. NOTA: El par\u00e1metro peso en cada m\u00e9todo se refiere al peso del veh\u00edculo. No es imprescindible proporcionar una soluci\u00f3n sin hambruna. Si lo hubiera se deber\u00eda indicarlo y justificarlo.</li> </ul> <pre><code>public class GestorPuenteSeguro {\n    private static final int pesoMax = 15000;\n    private static final int nVehiculosMax = 10;\n    . . .\n\n    /*\n     * Un veh\u00edculo invoca este m\u00e9todo para entrar en el puente. Se bloquea para no exceder en\n     * el n\u00famero de veh\u00edculos, el peso total en el puente o si hay ambulancias esperando.\n     */\n    . . . void entrarPuente(int peso) . . .\n\n    /*\n     * Una ambulancia invoca este m\u00e9todo para entrar en el puente. Se bloquea para no exceder en\n     * el n\u00famero de veh\u00edculos o el peso total en el puente.\n     */\n    . . . void entrarPuenteAmbulanica(int peso) . . .\n\n    /*\n     * Los veh\u00edculos invocan este m\u00e9todo cuando van a salir del puente\n     */\n    . . . void salirPuente(int peso) . . .\n}\n</code></pre> Mostrar soluci\u00f3n <p>A continuaci\u00f3n, se propone una soluci\u00f3n al enunciado, que satisface los requisitos de sincronizaci\u00f3n condicional generales planteados. Adem\u00e1s, se asegura que no van a ocurrir interbloqueos.</p> <p>Esta soluci\u00f3n no evita la hambruna. Si continuamente intentan a entrar ambulancias, podr\u00eda ocurrir que ning\u00fan coche podr\u00eda acceder. Igualmente, los veh\u00edculos con poco peso tienen m\u00e1s probabilidad de entrar al puente que los veh\u00edculos con mayor peso. En situaciones desfavorables, podr\u00eda ocurrir la hambruna para los veh\u00edculos m\u00e1s pesados.</p> <pre><code>package es.upm.dit.adsw.puente_limitado;\n\npublic class PuenteSeguro {\n    private int pesoEnPuente = 0;\n    private int nVehiculos = 0;\n    private int nAmbulanciasEsperando = 0;\n    private static final int pesoMaximo = 15000;\n    private static final int nVehiculosMaximo = 10;\n\n    public synchronized void entrarPuente(int peso) throws InterruptedException {\n        while ((peso + pesoEnPuente &gt; pesoMaximo) ||\n               (nVehiculos &gt;= nVehiculosMaximo) ||\n               (nAmbulanciasEsperando &gt; 0)) {\n            wait();\n        }\n        pesoEnPuente = pesoEnPuente + peso;\n        nVehiculos++;\n    }\n\n    public synchronized void entrarPuenteAmbulancia(int peso) throws InterruptedException {\n        nAmbulanciasEsperando++;\n        while ((peso + pesoEnPuente &gt; pesoMaximo) ||\n               (nVehiculos &gt;= nVehiculosMaximo)) {\n            wait();\n        }\n        nAmbulanciasEsperando--;\n        pesoEnPuente = pesoEnPuente + peso;\n        nVehiculos++;\n    }\n\n    public synchronized void salirPuente(int peso) throws InterruptedException {\n        pesoEnPuente = pesoEnPuente - peso;\n        nVehiculos--;\n        notifyAll();\n    }\n}\n</code></pre>"},{"location":"exams/2022/p2/#problema-2","title":"Problema 2","text":"<p>El problema de los lectores/escritores est\u00e1 compuesto de un conjunto de hebras que comparten datos. Las hebras lectoras (<code>Lectora</code>) s\u00f3lo leen los datos, mientras que las hebras escritoras (<code>Escritora</code>) leen y escriben los datos. Varios lectoras pueden acceder simult\u00e1neamente a los datos compartidos, mientras que una escritora tiene que acceder con exclusi\u00f3n mutua con otros lectores o escritores. A continuaci\u00f3n, se muestra una implementaci\u00f3n muy sencilla de un monitor que gestione a las hebras lectoras y escritoras para acceder a los datos compartidos:</p> <pre><code>public class GestorLE implements Gestor {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n    private int nEscritores = 0;\n\n    public synchronized void empiezaLeer(int idLector) throws InterruptedException {\n        while (bloqueoEscritor)\n            wait();\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector)\n            wait();\n        nEscritores++;\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre> <p>El c\u00f3digo de las hebras lectoras y escritoras est\u00e1 implementado como un bucle acotado que solicitan el acceso a los datos (<code>empiezaLeer</code> / <code>empiezaEscribir</code>), usan los datos durante un tiempo aleatorio, terminan el acceso a los datos (<code>terminLeer</code> / <code>terminaEscribir</code>) y est\u00e1n ociosos durante un tiempo aleatorio. Las clases <code>Lectora</code> y <code>Escritora</code> extienden <code>Thread</code> y que su constructor recibe como par\u00e1metro una instancia de <code>GestorLE</code> y su identificador.</p> <ul> <li>(a) (0,5 puntos) Analice y justifique si el monitor en este enunciado puede producir inanici\u00f3n o hambruna.</li> </ul> Mostrar soluci\u00f3n <p>Esa soluci\u00f3n puede tener inanici\u00f3n. Por ejemplo, 2 lectores y un escritor. El primer lector pide acceso y se lo da el gestor. El escritor intenta entrar y queda bloqueado. Antes de que termine de leer el primer lector, el segundo lector empieza a leer. El primer lector termina de leer (pero el segundo est\u00e1 leyendo y el escritor sigue bloqueado). Antes de que termine el segundo lector, el primero empieza a leer, y despu\u00e9s termina el segundo (el escritor sigue bloqueado), y seguimos as\u00ed indefinidamente, y los lectores entre ellos no dejar trabajar al escritor.</p> <ul> <li>(b) (1,5 puntos) Escribe una clase con un m\u00e9todo <code>main</code>, que construye un <code>GestorLE</code>, dos hebras lectoras y dos hebras escritoras, cuyos par\u00e1metros son un identificador de la hebra y un objeto de la clase <code>GestorLE</code> para su sincronizaci\u00f3n. Los identificadores de las hebras ser\u00e1n respectivamente 1, 2, 3 y 4. La prueba debe arrancar las hebras, los objetos necesarios y escribir un mensaje por consola informando que todas las hebras hayan terminado su ejecuci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <pre><code>public static void main(String[] args) {\n    GestorLE gestor = new GestorLE();\n    Lector lector = new Lector(gestor, 1);\n    Escritor escritor = new Escritor(gestor, 3);\n    Lector lector2 = new Lector(gestor, 2);\n    Escritor escritor4 = new Escritor(gestor, 4);\n\n    lector.start();\n    lector2.start();\n    escritor.start();\n    escritor4.start();\n\n    try {\n        lector.join();\n        lector2.join();\n        escritor.join();\n        escritor4.join();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    System.out.println(\u00e1Todos han terminado\u00e1);\n}\n</code></pre> <ul> <li>(c) (1,5 puntos) Cambie la clase <code>GestorLE</code> de este enunciado para que dos hebras escritoras no puedan acceder a los datos, antes de que al menos una hebra haya accedido despu\u00e9s de la \u00faltima escritura. En este caso, habr#a que bloquear a la segunda escritora, antes de que accediera a los datos alguna hebra lectora.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorLE2 implements Gestor {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n    private int nEscritores = 0;\n    private boolean leido = true;\n\n    public synchronized void empiezaLeer(int idLector) throws InterruptedException {\n        while (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector || !leido) {\n            wait();\n        }\n        nEscritores++;\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        leido = true;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        leido = false;\n        notifyAll();\n    }\n}\n</code></pre> <ul> <li>(d) (1,5 puntos) Cambie la clase <code>GestorLE</code> de este enunciado para que no puedan acceder m\u00e1s de tres lecturas para una misma escritura (no se puede leer en mismo dato mas de tres veces).</li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorLE3 implements Gestor {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n    private int nEscritores = 0;\n    private int lecturas = 0;\n\n    public synchronized void empiezaLeer(int idLector) throws InterruptedException {\n        while (bloqueoEscritor || lecturas &gt; 2) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n        lecturas++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        nEscritores++;\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        lecturas = 0;\n        notifyAll();\n    }\n}\n</code></pre> <p>En los dos \u00faltimos ejercicios, no es necesario reescribir por completo la clase <code>GestorLE</code>. Es suficiente indicar donde se incluyen las nuevas l\u00edneas de c\u00f3digo, o el n\u00famero de l\u00edneas que haya que borrar.</p>"},{"location":"exams/2022/p2_ex01/","title":"P2 ex01","text":"<p>Se dispone un puente elevado para autom\u00f3viles. Se quiere desarrollar un sistema de seguridad que impide que haya m\u00e1s de 10 veh\u00edculos simult\u00e1neamente en el puente y con un peso total mayor que 15.000 Kg.</p> <p>Cuando un veh\u00edculo quiere entrar en el puente, ejecuta el m\u00e9todo <code>entrarPuente</code> y cuando lo abandona, ejecuta el m\u00e9todo <code>salirPuente</code>. Las ambulancias tienen que invocar el m\u00e9todo <code>entrarPuenteAmbulancia</code> para tener prioridad en el acceso.</p> <ul> <li>(a) (1,5 puntos) Desarrolle el monitor con las restricciones indicadas como se muestra en la plantilla que se muestra a continuaci\u00f3n. NOTA: El par\u00e1metro peso en cada m\u00e9todo se refiere al peso del veh\u00edculo. No es imprescindible proporcionar una soluci\u00f3n sin hambruna. Si lo hubiera se deber\u00eda indicarlo y justificarlo.</li> </ul> <pre><code>public class GestorPuenteSeguro {\n    private static final int pesoMax = 15000;\n    private static final int nVehiculosMax = 10;\n    . . .\n\n    /*\n     * Un veh\u00edculo invoca este m\u00e9todo para entrar en el puente. Se bloquea para no exceder en\n     * el n\u00famero de veh\u00edculos, el peso total en el puente o si hay ambulancias esperando.\n     */\n    . . . void entrarPuente(int peso) . . .\n\n    /*\n     * Una ambulancia invoca este m\u00e9todo para entrar en el puente. Se bloquea para no exceder en\n     * el n\u00famero de veh\u00edculos o el peso total en el puente.\n     */\n    . . . void entrarPuenteAmbulanica(int peso) . . .\n\n    /*\n     * Los veh\u00edculos invocan este m\u00e9todo cuando van a salir del puente\n     */\n    . . . void salirPuente(int peso) . . .\n}\n</code></pre> Mostrar soluci\u00f3n <p>A continuaci\u00f3n, se propone una soluci\u00f3n al enunciado, que satisface los requisitos de sincronizaci\u00f3n condicional generales planteados. Adem\u00e1s, se asegura que no van a ocurrir interbloqueos.</p> <p>Esta soluci\u00f3n no evita la hambruna. Si continuamente intentan a entrar ambulancias, podr\u00eda ocurrir que ning\u00fan coche podr\u00eda acceder. Igualmente, los veh\u00edculos con poco peso tienen m\u00e1s probabilidad de entrar al puente que los veh\u00edculos con mayor peso. En situaciones desfavorables, podr\u00eda ocurrir la hambruna para los veh\u00edculos m\u00e1s pesados.</p> <pre><code>package es.upm.dit.adsw.puente_limitado;\n\npublic class PuenteSeguro {\n    private int pesoEnPuente = 0;\n    private int nVehiculos = 0;\n    private int nAmbulanciasEsperando = 0;\n    private static final int pesoMaximo = 15000;\n    private static final int nVehiculosMaximo = 10;\n\n    public synchronized void entrarPuente(int peso) throws InterruptedException {\n        while ((peso + pesoEnPuente &gt; pesoMaximo) ||\n               (nVehiculos &gt;= nVehiculosMaximo) ||\n               (nAmbulanciasEsperando &gt; 0)) {\n            wait();\n        }\n        pesoEnPuente = pesoEnPuente + peso;\n        nVehiculos++;\n    }\n\n    public synchronized void entrarPuenteAmbulancia(int peso) throws InterruptedException {\n        nAmbulanciasEsperando++;\n        while ((peso + pesoEnPuente &gt; pesoMaximo) ||\n               (nVehiculos &gt;= nVehiculosMaximo)) {\n            wait();\n        }\n        nAmbulanciasEsperando--;\n        pesoEnPuente = pesoEnPuente + peso;\n        nVehiculos++;\n    }\n\n    public synchronized void salirPuente(int peso) throws InterruptedException {\n        pesoEnPuente = pesoEnPuente - peso;\n        nVehiculos--;\n        notifyAll();\n    }\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2022/p2_ex02/","title":"P2 ex02","text":"<p>El problema de los lectores/escritores est\u00e1 compuesto de un conjunto de hebras que comparten datos. Las hebras lectoras (<code>Lectora</code>) s\u00f3lo leen los datos, mientras que las hebras escritoras (<code>Escritora</code>) leen y escriben los datos. Varios lectoras pueden acceder simult\u00e1neamente a los datos compartidos, mientras que una escritora tiene que acceder con exclusi\u00f3n mutua con otros lectores o escritores. A continuaci\u00f3n, se muestra una implementaci\u00f3n muy sencilla de un monitor que gestione a las hebras lectoras y escritoras para acceder a los datos compartidos:</p> <pre><code>public class GestorLE implements Gestor {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n    private int nEscritores = 0;\n\n    public synchronized void empiezaLeer(int idLector) throws InterruptedException {\n        while (bloqueoEscritor)\n            wait();\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector)\n            wait();\n        nEscritores++;\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        notifyAll();\n    }\n}\n</code></pre> <p>El c\u00f3digo de las hebras lectoras y escritoras est\u00e1 implementado como un bucle acotado que solicitan el acceso a los datos (<code>empiezaLeer</code> / <code>empiezaEscribir</code>), usan los datos durante un tiempo aleatorio, terminan el acceso a los datos (<code>terminLeer</code> / <code>terminaEscribir</code>) y est\u00e1n ociosos durante un tiempo aleatorio. Las clases <code>Lectora</code> y <code>Escritora</code> extienden <code>Thread</code> y que su constructor recibe como par\u00e1metro una instancia de <code>GestorLE</code> y su identificador.</p> <ul> <li>(a) (0,5 puntos) Analice y justifique si el monitor en este enunciado puede producir inanici\u00f3n o hambruna.</li> </ul> Mostrar soluci\u00f3n <p>Esa soluci\u00f3n puede tener inanici\u00f3n. Por ejemplo, 2 lectores y un escritor. El primer lector pide acceso y se lo da el gestor. El escritor intenta entrar y queda bloqueado. Antes de que termine de leer el primer lector, el segundo lector empieza a leer. El primer lector termina de leer (pero el segundo est\u00e1 leyendo y el escritor sigue bloqueado). Antes de que termine el segundo lector, el primero empieza a leer, y despu\u00e9s termina el segundo (el escritor sigue bloqueado), y seguimos as\u00ed indefinidamente, y los lectores entre ellos no dejar trabajar al escritor.</p> <ul> <li>(b) (1,5 puntos) Escribe una clase con un m\u00e9todo <code>main</code>, que construye un <code>GestorLE</code>, dos hebras lectoras y dos hebras escritoras, cuyos par\u00e1metros son un identificador de la hebra y un objeto de la clase <code>GestorLE</code> para su sincronizaci\u00f3n. Los identificadores de las hebras ser\u00e1n respectivamente 1, 2, 3 y 4. La prueba debe arrancar las hebras, los objetos necesarios y escribir un mensaje por consola informando que todas las hebras hayan terminado su ejecuci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <pre><code>public static void main(String[] args) {\n    GestorLE gestor = new GestorLE();\n    Lector lector = new Lector(gestor, 1);\n    Escritor escritor = new Escritor(gestor, 3);\n    Lector lector2 = new Lector(gestor, 2);\n    Escritor escritor4 = new Escritor(gestor, 4);\n\n    lector.start();\n    lector2.start();\n    escritor.start();\n    escritor4.start();\n\n    try {\n        lector.join();\n        lector2.join();\n        escritor.join();\n        escritor4.join();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    System.out.println(\u00e1Todos han terminado\u00e1);\n}\n</code></pre> <ul> <li>(c) (1,5 puntos) Cambie la clase <code>GestorLE</code> de este enunciado para que dos hebras escritoras no puedan acceder a los datos, antes de que al menos una hebra haya accedido despu\u00e9s de la \u00faltima escritura. En este caso, habr#a que bloquear a la segunda escritora, antes de que accediera a los datos alguna hebra lectora.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorLE2 implements Gestor {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n    private int nEscritores = 0;\n    private boolean leido = true;\n\n    public synchronized void empiezaLeer(int idLector) throws InterruptedException {\n        while (bloqueoEscritor) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector || !leido) {\n            wait();\n        }\n        nEscritores++;\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        leido = true;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        leido = false;\n        notifyAll();\n    }\n}\n</code></pre> <ul> <li>(d) (1,5 puntos) Cambie la clase <code>GestorLE</code> de este enunciado para que no puedan acceder m\u00e1s de tres lecturas para una misma escritura (no se puede leer en mismo dato mas de tres veces).</li> </ul> Mostrar soluci\u00f3n <pre><code>public class GestorLE3 implements Gestor {\n    private boolean bloqueoEscritor = false;\n    private boolean bloqueoLector = false;\n    private int nLectores = 0;\n    private int nEscritores = 0;\n    private int lecturas = 0;\n\n    public synchronized void empiezaLeer(int idLector) throws InterruptedException {\n        while (bloqueoEscritor || lecturas &gt; 2) {\n            wait();\n        }\n        bloqueoLector = true;\n        nLectores++;\n        lecturas++;\n    }\n\n    public synchronized void empiezaEscribir(int idEscritor) throws InterruptedException {\n        while (bloqueoEscritor || bloqueoLector) {\n            wait();\n        }\n        nEscritores++;\n        bloqueoEscritor = true;\n    }\n\n    public synchronized void terminaLeer(int idLector) {\n        nLectores--;\n        if (nLectores == 0) {\n            bloqueoLector = false;\n            notifyAll();\n        }\n    }\n\n    public synchronized void terminaEscribir(int idEscritor) {\n        nEscritores--;\n        bloqueoEscritor = false;\n        lecturas = 0;\n        notifyAll();\n    }\n}\n</code></pre> <p>En los dos \u00faltimos ejercicios, no es necesario reescribir por completo la clase <code>GestorLE</code>. Es suficiente indicar donde se incluyen las nuevas l\u00edneas de c\u00f3digo, o el n\u00famero de l\u00edneas que haya que borrar.</p>","tags":["hebras"]},{"location":"exams/2023/p1/","title":"Examen 2023 \u2014 Parcial 1","text":""},{"location":"exams/2023/p1/#problema-1","title":"Problema 1","text":"<p>El siguiente c\u00f3digo ofrece una implementaci\u00f3n de un algoritmo de potenciaci\u00f3n de dos n\u00fameros (\\(a^b\\)):</p> <pre><code>static int potenciaLenta(int a, int b) {\n    if(b == 0) {\n        return 1;\n    }\n    return a * potenciaLenta(a, b-1);\n}\n</code></pre> <ul> <li>(a) (0.5 puntos) Exprese, en funci\u00f3n de \\(a\\) y \\(b\\), la complejidad del algoritmo implementado en <code>potenciaLenta</code>. Puede suponer que la multiplicaci\u00f3n de dos n\u00fameros es \\(O(1)\\).</li> </ul> Mostrar soluci\u00f3n <p>\\(T(a, b) = T(a, b-1) + O(1)\\) y \\(T(a, 0) = O(1)\\).</p> <p>Por tanto: \\(T(b) = O(b)\\).</p> <p>En otras palabras: la complejidad es \\(O(n)\\), siendo \\(n=b\\).</p> <p>-(b) (0.5 puntos) Reimplemente el algoritmo de <code>potenciaLenta</code> usando \u00fanicamente c\u00f3digo iterativo.</p> Mostrar soluci\u00f3n <pre><code>    static int potenciaLentaIt(int n, int p) {\n        int res = 1;\n        for(int i=0; i&lt;p; i++) {\n            res = res * n;\n        }\n        return res;\n    }\n</code></pre> <ul> <li>(c) (1.5 puntos) Dise\u00f1e e implemente un algoritmo de potenciaci\u00f3n con complejidad logar\u00edtmica basado en la estrategia de \"divide y vencer\u00e1s\".</li> </ul> <p>Su algoritmo deber\u00eda aprovechar que \\(a^b = (a^2)^{b/2}\\). Recuerde que tanto la base como el exponente siempre deben ser un n\u00famero entero.</p> Mostrar soluci\u00f3n <pre><code>    static int potenciaOptimizada(int n, int p) {\n        if(p == 0) {\n            return 1;\n        }\n        if (p % 2 == 0) {\n            return potenciaOptimizada(n*n, p/2);\n        }\n        else {\n            return n * potenciaOptimizada(n*n, (p-1)/2);\n        }\n    }\n</code></pre>"},{"location":"exams/2023/p1/#problema-2","title":"Problema 2","text":"<p>Dado el siguiente c\u00f3digo:</p> <pre><code>static void funcion(int a[]) {    \n    int start = 0;\n    while (start &lt; a.length) {      \n        int pos = start;    \n        for (int i = start + 1; i &lt; a.length; i++)     {\n            if (a[i] &gt; a[start]){\n                pos++;\n            }\n        }\n\n        if (pos == start) {\n            start++;\n        } else {\n            int element = a[start];\n            a[start] = a[pos];\n            a[pos] = element;\n        }\n        System.out.println(pos);\n    }\n}\n</code></pre> <p>Se pide:</p> <ul> <li> <p>(a) (2 puntos) \u00bfQu\u00e9 valor tendr\u00e1 el array <code>arr</code> tras ejecutar la instrucci\u00f3n <code>funcion(arr);</code> y qu\u00e9 texto se mostrar\u00e1 por consola durante su ejecuci\u00f3n en los siguientes casos?</p> <ul> <li>Cuando <code>int[] arr = {1, 4, 3, 2, 5}</code>;</li> <li>Cuando <code>int[] arr = {1, 2, 3, 2, 1}</code>;</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Salida por consola: <pre><code>4\n0\n1\n2\n3\n4\n</code></pre> Y <code>arr = {5, 4, 3, 2, 1}</code></p> <ul> <li>(b) (0.5 puntos) Estime el orden de complejidad del algoritmo. Razone su respuesta.</li> </ul> Mostrar soluci\u00f3n <p>\\(O(n)\\), siendo \\(n\\) el tama\u00f1o del array <code>a</code>.</p>"},{"location":"exams/2023/p1/#problema-3","title":"Problema 3","text":"<p>Tenemos un \u00e1rbol binario de b\u00fasqueda en el que almacenamos direcciones <code>IP</code>. Las direcciones <code>IP</code> son objetos de la clase <code>IP</code>, que tiene como atributos los cuatro bytes por los que se compone una <code>IP</code>; siendo el primer byte el n\u00famero decimal situado m\u00e1s a la izquierda y el \u00faltimo byte, el situado a la derecha (ej: en la <code>IP</code> 192.168.1.0, el primer byte representa el 192, el segundo el 168, el tercero el 1 y el cuarto el 0).</p> <p>El \u00e1rbol binario cuenta con los m\u00e9todos habituales de un diccionario. Sus nodos tienen referencias a los hijos izquierdo y derecho, y un objeto <code>IP</code> que sirve tanto de clave como de valor.</p> <pre><code>classDiagram\n    direction RL\n    Arbol -- Nodo\n    Nodo -- IP\n    IP &lt;|-- Comparable~IP~\n    class Arbol{\n      +Nodo raiz\n      +put(IP ip)\n      +get(IP ip) IP\n      +remove(IP ip) IP\n      +clear(IP ip)\n      ipsEnRango(IP inicio, IP final) int\n    }\n    class Nodo {\n        +IP ip\n        +Nodo hijoIzquierdo\n        +Nodo hijoDerecho\n    }\n    class Comparable~IP~{\n        &lt;&lt;interface&gt;&gt;\n        +compareTo(IP other)\n    }\n    class IP{\n      +byte primero\n      +byte segundo\n      +byte tercero\n      +byte cuarto\n    }\n</code></pre> <p>\u00c1rbol de ejemplo:</p> <pre><code>flowchart TD\n    style ip1 r:75px;\n    style ip2 r:75px;\n    style ip3 r:75px;\n    style ip4 r:75px;\n    style ip5 r:75px;\n    style ip6 r:75px;\n    style ip7 r:75px;\n\n    ip1((127.0.0.1))\n    ip2((10.10.10.10))\n    ip3((192.168.1.0))\n    ip4((8.8.8.8))\n    ip5((8.8.4.4))\n    ip6((255.255.255.255))\n    ip7((192.168.0.0))\n\n    ip1 --&gt; ip4\n    ip1 --&gt; ip3\n    ip4 --&gt; ip5\n    ip4 --&gt; ip2\n    ip3 --&gt; ip7\n    ip3 --&gt; ip6\n</code></pre> <ul> <li>(a) (1 punto) La clase IP deber\u00eda implementar la interfaz <code>Comparable&lt;IP&gt;</code>, identifique y desarrolle los m\u00e9todos necesarios para cumplir con dicha interfaz.</li> </ul> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es <pre><code>  @Override\n  public int compareTo(IP o) {\n  if(primero &gt; o.primero) return  1;\n  if(primero &lt; o.primero) return -1;\n  if(segundo &gt; o.segundo) return  1;\n  if(segundo &lt; o.segundo) return -1;\n  if(tercero &gt; o.tercero) return  1;\n  if(tercero &lt; o.tercero) return -1;\n  if(cuarto  &gt; o.cuarto ) return  1;\n  if(cuarto  &lt; o.cuarto ) return -1;\n  return 0;\n}\n</code></pre></p> <ul> <li>(b) (2 puntos) Queremos dise\u00f1ar un m\u00e9todo del \u00e1rbol que nos permita comprobar cuantas IP de las almacenadas est\u00e1n dentro de un rango dado como par\u00e1metro (extremos incluidos). Desarrolle el cuerpo del m\u00e9todo que tendr\u00e1 esta cabecera: <code>public int ipsEnRango(IP inicio, IP final)</code>. En el \u00e1rbol de ejemplo, si invocamos el m\u00e9todo con los par\u00e1metros inicio = 8.8.8.8 y final = 192.168.0.0, el resultado deber\u00e1 ser 4.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int ipsEnRango(IP inicio, IP final) {\n  return ipsEnRango(raiz, inicio, final);\n  }\n\npublic int ipsEnRango(Nodo nodo, IP inicio, IP final) {\n  if ( null == n ) return 0;\n  if (n.ip.compareTo(start)&gt;=0 &amp;&amp; n.ip.compareTo(end)&lt;=0)\n    return 1+ipsEnRango(start, end, n.hijoIzquierdo)+ipsEnRango(start, end, n.hijoDerecho);\n  return ipsEnRango(start, end, n.hijoIzquierdo)+ipsEnRango(start, end, n.hijoDerecho);\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfCu\u00e1l es la complejidad del algoritmo desarrollado?</li> </ul> Mostrar soluci\u00f3n <p>Para comprobar que nodos forman parte del rango debemos recorrer todas las partes del \u00e1rbol que pudieran pertenecer al rango, haciendo que la complejidad sea \\(O(n)\\).</p> <ul> <li>(d) (1 punto) Si en vez de un \u00e1rbol binario, se guardaran las <code>IP</code> en un array ordenado, \u00bfQu\u00e9 complejidad tendr\u00eda el m\u00e9todo desarrollado en el apartado 2? Razone su respuesta. No es necesario escribir el c\u00f3digo, pero puede utilizarse como apoyo a la justificaci\u00f3n de la respuesta.</li> </ul> Mostrar soluci\u00f3n <p>Si contamos con un array ordenado, la complejidad ser\u00e1 \\(O(log(n))\\). Utilizando b\u00fasqueda binaria podemos obtener las posiciones en el array del primer y \u00faltimo elemento que pertenecen al rango y despu\u00e9s simplemente restarlas para obtener cuantos elementos hay entre ambas.</p>"},{"location":"exams/2023/p1_ex01/","title":"P1 ex01","text":"<p>El siguiente c\u00f3digo ofrece una implementaci\u00f3n de un algoritmo de potenciaci\u00f3n de dos n\u00fameros (\\(a^b\\)):</p> <pre><code>static int potenciaLenta(int a, int b) {\n    if(b == 0) {\n        return 1;\n    }\n    return a * potenciaLenta(a, b-1);\n}\n</code></pre> <ul> <li>(a) (0.5 puntos) Exprese, en funci\u00f3n de \\(a\\) y \\(b\\), la complejidad del algoritmo implementado en <code>potenciaLenta</code>. Puede suponer que la multiplicaci\u00f3n de dos n\u00fameros es \\(O(1)\\).</li> </ul> Mostrar soluci\u00f3n <p>\\(T(a, b) = T(a, b-1) + O(1)\\) y \\(T(a, 0) = O(1)\\).</p> <p>Por tanto: \\(T(b) = O(b)\\).</p> <p>En otras palabras: la complejidad es \\(O(n)\\), siendo \\(n=b\\).</p> <p>-(b) (0.5 puntos) Reimplemente el algoritmo de <code>potenciaLenta</code> usando \u00fanicamente c\u00f3digo iterativo.</p> Mostrar soluci\u00f3n <pre><code>    static int potenciaLentaIt(int n, int p) {\n        int res = 1;\n        for(int i=0; i&lt;p; i++) {\n            res = res * n;\n        }\n        return res;\n    }\n</code></pre> <ul> <li>(c) (1.5 puntos) Dise\u00f1e e implemente un algoritmo de potenciaci\u00f3n con complejidad logar\u00edtmica basado en la estrategia de \"divide y vencer\u00e1s\".</li> </ul> <p>Su algoritmo deber\u00eda aprovechar que \\(a^b = (a^2)^{b/2}\\). Recuerde que tanto la base como el exponente siempre deben ser un n\u00famero entero.</p> Mostrar soluci\u00f3n <pre><code>    static int potenciaOptimizada(int n, int p) {\n        if(p == 0) {\n            return 1;\n        }\n        if (p % 2 == 0) {\n            return potenciaOptimizada(n*n, p/2);\n        }\n        else {\n            return n * potenciaOptimizada(n*n, (p-1)/2);\n        }\n    }\n</code></pre>","tags":["grafos","princeton"]},{"location":"exams/2023/p1_ex02/","title":"P1 ex02","text":"<p>Dado el siguiente c\u00f3digo:</p> <pre><code>static void funcion(int a[]) {    \n    int start = 0;\n    while (start &lt; a.length) {      \n        int pos = start;    \n        for (int i = start + 1; i &lt; a.length; i++)     {\n            if (a[i] &gt; a[start]){\n                pos++;\n            }\n        }\n\n        if (pos == start) {\n            start++;\n        } else {\n            int element = a[start];\n            a[start] = a[pos];\n            a[pos] = element;\n        }\n        System.out.println(pos);\n    }\n}\n</code></pre> <p>Se pide:</p> <ul> <li> <p>(a) (2 puntos) \u00bfQu\u00e9 valor tendr\u00e1 el array <code>arr</code> tras ejecutar la instrucci\u00f3n <code>funcion(arr);</code> y qu\u00e9 texto se mostrar\u00e1 por consola durante su ejecuci\u00f3n en los siguientes casos?</p> <ul> <li>Cuando <code>int[] arr = {1, 4, 3, 2, 5}</code>;</li> <li>Cuando <code>int[] arr = {1, 2, 3, 2, 1}</code>;</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Salida por consola: <pre><code>4\n0\n1\n2\n3\n4\n</code></pre> Y <code>arr = {5, 4, 3, 2, 1}</code></p> <ul> <li>(b) (0.5 puntos) Estime el orden de complejidad del algoritmo. Razone su respuesta.</li> </ul> Mostrar soluci\u00f3n <p>\\(O(n)\\), siendo \\(n\\) el tama\u00f1o del array <code>a</code>.</p>","tags":["grafos","princeton"]},{"location":"exams/2023/p1_ex03/","title":"P1 ex03","text":"<p>Tenemos un \u00e1rbol binario de b\u00fasqueda en el que almacenamos direcciones <code>IP</code>. Las direcciones <code>IP</code> son objetos de la clase <code>IP</code>, que tiene como atributos los cuatro bytes por los que se compone una <code>IP</code>; siendo el primer byte el n\u00famero decimal situado m\u00e1s a la izquierda y el \u00faltimo byte, el situado a la derecha (ej: en la <code>IP</code> 192.168.1.0, el primer byte representa el 192, el segundo el 168, el tercero el 1 y el cuarto el 0).</p> <p>El \u00e1rbol binario cuenta con los m\u00e9todos habituales de un diccionario. Sus nodos tienen referencias a los hijos izquierdo y derecho, y un objeto <code>IP</code> que sirve tanto de clave como de valor.</p> <pre><code>classDiagram\n    direction RL\n    Arbol -- Nodo\n    Nodo -- IP\n    IP &lt;|-- Comparable~IP~\n    class Arbol{\n      +Nodo raiz\n      +put(IP ip)\n      +get(IP ip) IP\n      +remove(IP ip) IP\n      +clear(IP ip)\n      ipsEnRango(IP inicio, IP final) int\n    }\n    class Nodo {\n        +IP ip\n        +Nodo hijoIzquierdo\n        +Nodo hijoDerecho\n    }\n    class Comparable~IP~{\n        &lt;&lt;interface&gt;&gt;\n        +compareTo(IP other)\n    }\n    class IP{\n      +byte primero\n      +byte segundo\n      +byte tercero\n      +byte cuarto\n    }\n</code></pre> <p>\u00c1rbol de ejemplo:</p> <pre><code>flowchart TD\n    style ip1 r:75px;\n    style ip2 r:75px;\n    style ip3 r:75px;\n    style ip4 r:75px;\n    style ip5 r:75px;\n    style ip6 r:75px;\n    style ip7 r:75px;\n\n    ip1((127.0.0.1))\n    ip2((10.10.10.10))\n    ip3((192.168.1.0))\n    ip4((8.8.8.8))\n    ip5((8.8.4.4))\n    ip6((255.255.255.255))\n    ip7((192.168.0.0))\n\n    ip1 --&gt; ip4\n    ip1 --&gt; ip3\n    ip4 --&gt; ip5\n    ip4 --&gt; ip2\n    ip3 --&gt; ip7\n    ip3 --&gt; ip6\n</code></pre> <ul> <li>(a) (1 punto) La clase IP deber\u00eda implementar la interfaz <code>Comparable&lt;IP&gt;</code>, identifique y desarrolle los m\u00e9todos necesarios para cumplir con dicha interfaz.</li> </ul> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es <pre><code>  @Override\n  public int compareTo(IP o) {\n  if(primero &gt; o.primero) return  1;\n  if(primero &lt; o.primero) return -1;\n  if(segundo &gt; o.segundo) return  1;\n  if(segundo &lt; o.segundo) return -1;\n  if(tercero &gt; o.tercero) return  1;\n  if(tercero &lt; o.tercero) return -1;\n  if(cuarto  &gt; o.cuarto ) return  1;\n  if(cuarto  &lt; o.cuarto ) return -1;\n  return 0;\n}\n</code></pre></p> <ul> <li>(b) (2 puntos) Queremos dise\u00f1ar un m\u00e9todo del \u00e1rbol que nos permita comprobar cuantas IP de las almacenadas est\u00e1n dentro de un rango dado como par\u00e1metro (extremos incluidos). Desarrolle el cuerpo del m\u00e9todo que tendr\u00e1 esta cabecera: <code>public int ipsEnRango(IP inicio, IP final)</code>. En el \u00e1rbol de ejemplo, si invocamos el m\u00e9todo con los par\u00e1metros inicio = 8.8.8.8 y final = 192.168.0.0, el resultado deber\u00e1 ser 4.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int ipsEnRango(IP inicio, IP final) {\n  return ipsEnRango(raiz, inicio, final);\n  }\n\npublic int ipsEnRango(Nodo nodo, IP inicio, IP final) {\n  if ( null == n ) return 0;\n  if (n.ip.compareTo(start)&gt;=0 &amp;&amp; n.ip.compareTo(end)&lt;=0)\n    return 1+ipsEnRango(start, end, n.hijoIzquierdo)+ipsEnRango(start, end, n.hijoDerecho);\n  return ipsEnRango(start, end, n.hijoIzquierdo)+ipsEnRango(start, end, n.hijoDerecho);\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfCu\u00e1l es la complejidad del algoritmo desarrollado?</li> </ul> Mostrar soluci\u00f3n <p>Para comprobar que nodos forman parte del rango debemos recorrer todas las partes del \u00e1rbol que pudieran pertenecer al rango, haciendo que la complejidad sea \\(O(n)\\).</p> <ul> <li>(d) (1 punto) Si en vez de un \u00e1rbol binario, se guardaran las <code>IP</code> en un array ordenado, \u00bfQu\u00e9 complejidad tendr\u00eda el m\u00e9todo desarrollado en el apartado 2? Razone su respuesta. No es necesario escribir el c\u00f3digo, pero puede utilizarse como apoyo a la justificaci\u00f3n de la respuesta.</li> </ul> Mostrar soluci\u00f3n <p>Si contamos con un array ordenado, la complejidad ser\u00e1 \\(O(log(n))\\). Utilizando b\u00fasqueda binaria podemos obtener las posiciones en el array del primer y \u00faltimo elemento que pertenecen al rango y despu\u00e9s simplemente restarlas para obtener cuantos elementos hay entre ambas.</p>","tags":["grafos","princeton"]},{"location":"exams/2023/p2/","title":"Examen 2023 \u2014 Parcial 2","text":""},{"location":"exams/2023/p2/#problema-1","title":"Problema 1","text":"<p>Se desea controlar el acceso de un conjunto de hebras (<code>Hebra</code>) a un recurso compartido (<code>Recurso</code>). El acceso al recurso ser\u00e1 mediante exclusi\u00f3n mutua. El recurso se considerar\u00e1 ocupado desde que que se invoca <code>tomar</code> hasta que se invoca <code>liberar</code>. Si el recurso ya est\u00e1 ocupado al invocar <code>tomar</code>, se bloquear\u00e1 la ejecuci\u00f3n hasta que deje de estarlo.</p> <p>Adem\u00e1s, se quiere separar a las hebras en grupos (<code>Grupo</code>) y hacer que el acceso de cada grupo al recurso sea equitativo. Para ello, el recurso permitir\u00e1 acceder al recurso de esta manera: primero al grupo con identificador 0, luego al grupo con identificador 1, etc. Cuando se alcance el n\u00famero m\u00e1ximo de grupos (<code>numGrupos</code>), se volver\u00e1 a dar acceso al grupo 0. Si un grupo intenta leer los datos, deber\u00e1 esperar hasta que sea su turno, incluso aunque el recurso no est\u00e9 en uso en ese momento.</p> <p>Dentro de un mismo grupo, el orden de acceso al recurso de cada hebra se deja a su elecci\u00f3n como desarrollador.</p> <p>La clase <code>Hebra</code> ya est\u00e1 implementada correctamente. Suponga que la implementaci\u00f3n es equivalente invocar <code>this.grupo.tomar()</code> y <code>this.grupo.liberar()</code>, en ese orden, un n\u00famero determinado de veces.</p> <pre><code>graph TD;\nh0[&lt;u&gt;h0: Hebra&lt;/u&gt;];\nh1[&lt;u&gt;h1: Hebra&lt;/u&gt;];\nh2[&lt;u&gt;h2: Hebra&lt;/u&gt;];\ng0[&lt;u&gt;g0: Grupo&lt;/u&gt;];\ng1[&lt;u&gt;g1: Grupo&lt;/u&gt;];\nrec[&lt;u&gt;recurso: Recurso&lt;/u&gt;];\nh0 --&gt; |tomar| g0;\nh0 --&gt; |liberar| g0;\nh1 --&gt; |tomar| g0;\nh1 --&gt; |liberar| g0;\nh2 --&gt; |tomar| g1;\nh2 --&gt; |liberar| g1;\ng0 --&gt; |tomar| rec;\ng0 --&gt; |liberar| rec;\ng1 --&gt; |tomar| rec;\ng1 --&gt; |liberar| rec;\n</code></pre> <pre><code>public static void main(String[] args) {\n  Recurso rec = new Recurso(2);\n  Grupo g0 = new Grupo(rec, 0);\n  Grupo g1 = new Grupo(rec, 1);\n  //\n  // C\u00f3digo a a\u00f1adir\n  //\n  System.out.println(\"Todas las hebras han acabado\");\n}\n</code></pre> <pre><code>classDiagram\nclass Thread {\n     start()\n     join()\n}\nGrupo &lt;|-- Hebra\nRecurso &lt;|-- Grupo\nThread &lt;|-- Hebra : extends\n  class Hebra {\n    Hebra(Grupo)\n    run(): void\n  }\n  class Grupo {\n    Grupo(Recurso rec, int id)\n    tomar()\n    liberar()\n  }\n  class Recurso {\n    Recurso(numGrupos: int)\n    tomar(int)\n    liberar(int)\n    isOcupado(): boolean\n  }\n</code></pre> <p>Se pide:</p> <ul> <li>(a) (1 punto) Complete el m\u00e9todo <code>main</code> para replicar el escenario mostrado en el diagrama de objetos. Debe esperar a que todas las hebras terminen su ejecuci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <pre><code>public static void main(String[] args) {\n  Recurso rec = new Recurso(2);\n  Grupo g0 = new Grupo(rec, 0);\n  Grupo g1 = new Grupo(rec, 1);\n  //\n  // C\u00f3digo a a\u00f1adir\n  //\n\n  Hebra h1 = new Hebra(g0);\n  Hebra h2 = new Hebra(g0);\n  Hebra h3 = new Hebra(g1);\n  // Iniciar las hebras\n  h0.start();\n  h1.start();\n  h2.start();\n  // Esperar a que terminen\n  h0.join();\n  h1.join();\n  h2.join();\n  System.out.println(\"Todas las hebras han acabado\");\n}\n</code></pre> <ul> <li>(b) (1, puntos) Implemente la clase <code>Grupo</code>. Razone, para cada uno de sus m\u00e9todos, si debe ser sincronizado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Grupo {\n    private Recurso rec;\n    private int id;\n    public Grupo(Recurso rec, int id) {\n        this.rec = rec;\n        this.id = id;\n    }\n\n    // La sincronizaci\u00f3n se realiza con Recurso\n    // S\u00f3lo ser\u00eda necesario sincronizar si se usaran\n    // datos de esta clase.\n    // p.e., una cola para las hebras.\n    public void tomar() throws InterruptedException {\n        this.rec.tomar(this.id);\n    }\n\n    // Mismos motivos que en tomar\n    public void liberar() throws InterruptedException {\n        this.rec.liberar(this.id);\n    }\n}\n</code></pre> <ul> <li>(c) (3 puntos) Implemente la clase <code>Recurso</code>. Razone, para cada uno de sus m\u00e9todos, si debe ser sincronizado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Recurso {\n    private boolean ocupado = false;\n    private int numGrupos;\n    private int turno;\n    public Recurso(int numGrupos) {\n        this.numGrupos = numGrupos;\n        this.turno = 0;\n        this.ocupado = false;\n    }\n\n    // Debe ser sincronizado para controlar el acceso exclusivo a ocupado y turno\n    public synchronized void tomar(int id) throws InterruptedException {\n        while(this.ocupado || this.turno != id) {\n            wait();\n        }\n        this.ocupado = true;\n    }\n\n    // Debe ser sincronizado para controlar el acceso exclusivo a ocupado y turno\n    public synchronized void liberar(int id) throws InterruptedException {\n        assert id == turno; // Opcional\n        this.turno = (this.turno+1) % this.numGrupos;\n        this.ocupado = false;\n        this.notifyAll(); // Despetar a todos, porque hay diferentes id de grupo\n    }\n\n    // Sincronizado porque puede haber modificaci\u00f3n concurrente en tomar o liberar.\n    // Podr\u00edan usarse otros mecanismos (p.e., volatile)\n    public synchronized boolean isOcupado() {\n        return this.ocupado;\n    }\n}\n</code></pre> <ul> <li>(d) (0,5 puntos) En su soluci\u00f3n de los apartados anteriores, \u00bfpuede haber problemas de inanici\u00f3n? Razone su respuesta. </li> </ul> Mostrar soluci\u00f3n <p>En la soluci\u00f3n dada no hay ning\u00fan control de orden de acceso de las hebras de un mismo grupo al recurso. Puede haber inanici\u00f3n.</p> <p>Podr\u00eda evitarse implementando alg\u00fan control simple como una cola FIFO.</p>"},{"location":"exams/2023/p2/#problema-2","title":"Problema 2","text":"<p>Se nos proporcionan las siguientes clases para modelar un grafo, muy similares a las utilizadas en los laboratorios: <pre><code>class Nodo {\n    public String id;\n    public boolean infectado; \n    public List&lt;Arista&gt; vecinos;\n    public Nodo(String id) {\n        this.id = id; \n        this.infectado = false;\n        this.vecinos = new ArrayList&lt;&gt;();\n    }\n    public void addVecino(Nodo vecino, int peso) {\n        vecinos.add(new Arista(vecino, this, peso));\n    }      \n}  \n\nclass Arista {     \n    public Nodo a, b;     \n    public int peso;      \n    public Arista(Nodo a, Nodo b, int peso) {\n        this.a = a; \n        this.b = b; \n        this.peso = peso; \n    }\n    public Nodo contrario(Nodo nodo) {\n    if(a.equals(nodo)) return b;\n    return a;\n    }\n}  \nclass Grafo {\n    public List&lt;Nodo&gt; nodos;\n    public Grafo() {\n        nodos = new ArrayList&lt;&gt;();\n    }\n}\n</code></pre> Este conjunto de clases nos permiten modelar un grafo no dirigido y con pesos. La diferencia con el c\u00f3digo utilizado en los laboratorios es la clase <code>Arista</code>, que se utiliza para conectar dos <code>Nodo</code> y su peso representa la distancia a la que se encuentran dichos nodos. El m\u00e9todo <code>contrario</code> de la clase <code>Arista</code> recibe como par\u00e1metro uno de los <code>Nodo</code> de los extremos de la arista y devuelve el otro. El atributo <code>vecinos</code> de la clase <code>Nodo</code> ahora es una lista de objetos <code>Arista</code> que llevan a los vecinos. Se proporciona, adem\u00e1s, el siguiente grafo de ejemplo:</p> <p></p> <p>Queremos utilizar este modelo de grafos para simular la propagaci\u00f3n de un virus. Los nodos pueden estar infectados, esto se refleja en el atributo <code>infectado</code>, y pueden propagar el virus a sus vecinos. Un nodo infectado, contagia el virus a todos sus vecinos que est\u00e9n a una distancia menor o igual a 4. Para saber la distancia entre dos nodos, podemos comprobar el peso de la arista que los conecta. Cuando un nodo contagia a uno de sus vecinos, ese nodo vecino contagiar\u00e1 a su vez a sus vecinos, que a su vez contagiar\u00e1n a sus vecinos, etc, creando una reacci\u00f3n en cadena.</p> <ul> <li>(a) (0,5 puntos) Suponiendo que en el ejemplo, el nodo 'A' est\u00e1 infectado, al simular la propagaci\u00f3n del virus \u00bfcu\u00e1ntos nodos quedar\u00e1n infectados?</li> </ul> Mostrar soluci\u00f3n <p>N/A</p> <ul> <li>(b) (2,5 puntos) Implemente el m\u00e9todo <code>simulaContagios</code> de la clase <code>Grafo</code>, que reciba un <code>Nodo</code> como par\u00e1metro. Este m\u00e9todo deber\u00e1 cambiar el estado de este nodo a infectado y simular la propagaci\u00f3n del virus, seg\u00fan las reglas explicadas anteriormente. El m\u00e9todo debe devolver el n\u00famero de nodos del grafo que han quedado infectados tras la propagaci\u00f3n del virus. Nota: El algoritmo a desarollar es similar al de calcular los vecinos de orden n del Laboratorio 3.</li> </ul> Mostrar soluci\u00f3n <p>N/A</p> <ul> <li>(c) (1 punto) Implemente el m\u00e9todo <code>inmunes</code> que debe devolver un conjunto con los <code>Nodo</code> que no pueden ser contagiados por ning\u00fan otro <code>Nodo</code> con las reglas de propagaci\u00f3n dadas.</li> </ul> Mostrar soluci\u00f3n <p>N/A</p>"},{"location":"exams/2023/p2_ex01/","title":"P2 ex01","text":"<p>Se desea controlar el acceso de un conjunto de hebras (<code>Hebra</code>) a un recurso compartido (<code>Recurso</code>). El acceso al recurso ser\u00e1 mediante exclusi\u00f3n mutua. El recurso se considerar\u00e1 ocupado desde que que se invoca <code>tomar</code> hasta que se invoca <code>liberar</code>. Si el recurso ya est\u00e1 ocupado al invocar <code>tomar</code>, se bloquear\u00e1 la ejecuci\u00f3n hasta que deje de estarlo.</p> <p>Adem\u00e1s, se quiere separar a las hebras en grupos (<code>Grupo</code>) y hacer que el acceso de cada grupo al recurso sea equitativo. Para ello, el recurso permitir\u00e1 acceder al recurso de esta manera: primero al grupo con identificador 0, luego al grupo con identificador 1, etc. Cuando se alcance el n\u00famero m\u00e1ximo de grupos (<code>numGrupos</code>), se volver\u00e1 a dar acceso al grupo 0. Si un grupo intenta leer los datos, deber\u00e1 esperar hasta que sea su turno, incluso aunque el recurso no est\u00e9 en uso en ese momento.</p> <p>Dentro de un mismo grupo, el orden de acceso al recurso de cada hebra se deja a su elecci\u00f3n como desarrollador.</p> <p>La clase <code>Hebra</code> ya est\u00e1 implementada correctamente. Suponga que la implementaci\u00f3n es equivalente invocar <code>this.grupo.tomar()</code> y <code>this.grupo.liberar()</code>, en ese orden, un n\u00famero determinado de veces.</p> <pre><code>graph TD;\nh0[&lt;u&gt;h0: Hebra&lt;/u&gt;];\nh1[&lt;u&gt;h1: Hebra&lt;/u&gt;];\nh2[&lt;u&gt;h2: Hebra&lt;/u&gt;];\ng0[&lt;u&gt;g0: Grupo&lt;/u&gt;];\ng1[&lt;u&gt;g1: Grupo&lt;/u&gt;];\nrec[&lt;u&gt;recurso: Recurso&lt;/u&gt;];\nh0 --&gt; |tomar| g0;\nh0 --&gt; |liberar| g0;\nh1 --&gt; |tomar| g0;\nh1 --&gt; |liberar| g0;\nh2 --&gt; |tomar| g1;\nh2 --&gt; |liberar| g1;\ng0 --&gt; |tomar| rec;\ng0 --&gt; |liberar| rec;\ng1 --&gt; |tomar| rec;\ng1 --&gt; |liberar| rec;\n</code></pre> <pre><code>public static void main(String[] args) {\n  Recurso rec = new Recurso(2);\n  Grupo g0 = new Grupo(rec, 0);\n  Grupo g1 = new Grupo(rec, 1);\n  //\n  // C\u00f3digo a a\u00f1adir\n  //\n  System.out.println(\"Todas las hebras han acabado\");\n}\n</code></pre> <pre><code>classDiagram\nclass Thread {\n     start()\n     join()\n}\nGrupo &lt;|-- Hebra\nRecurso &lt;|-- Grupo\nThread &lt;|-- Hebra : extends\n  class Hebra {\n    Hebra(Grupo)\n    run(): void\n  }\n  class Grupo {\n    Grupo(Recurso rec, int id)\n    tomar()\n    liberar()\n  }\n  class Recurso {\n    Recurso(numGrupos: int)\n    tomar(int)\n    liberar(int)\n    isOcupado(): boolean\n  }\n</code></pre> <p>Se pide:</p> <ul> <li>(a) (1 punto) Complete el m\u00e9todo <code>main</code> para replicar el escenario mostrado en el diagrama de objetos. Debe esperar a que todas las hebras terminen su ejecuci\u00f3n.</li> </ul> Mostrar soluci\u00f3n <pre><code>public static void main(String[] args) {\n  Recurso rec = new Recurso(2);\n  Grupo g0 = new Grupo(rec, 0);\n  Grupo g1 = new Grupo(rec, 1);\n  //\n  // C\u00f3digo a a\u00f1adir\n  //\n\n  Hebra h1 = new Hebra(g0);\n  Hebra h2 = new Hebra(g0);\n  Hebra h3 = new Hebra(g1);\n  // Iniciar las hebras\n  h0.start();\n  h1.start();\n  h2.start();\n  // Esperar a que terminen\n  h0.join();\n  h1.join();\n  h2.join();\n  System.out.println(\"Todas las hebras han acabado\");\n}\n</code></pre> <ul> <li>(b) (1, puntos) Implemente la clase <code>Grupo</code>. Razone, para cada uno de sus m\u00e9todos, si debe ser sincronizado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Grupo {\n    private Recurso rec;\n    private int id;\n    public Grupo(Recurso rec, int id) {\n        this.rec = rec;\n        this.id = id;\n    }\n\n    // La sincronizaci\u00f3n se realiza con Recurso\n    // S\u00f3lo ser\u00eda necesario sincronizar si se usaran\n    // datos de esta clase.\n    // p.e., una cola para las hebras.\n    public void tomar() throws InterruptedException {\n        this.rec.tomar(this.id);\n    }\n\n    // Mismos motivos que en tomar\n    public void liberar() throws InterruptedException {\n        this.rec.liberar(this.id);\n    }\n}\n</code></pre> <ul> <li>(c) (3 puntos) Implemente la clase <code>Recurso</code>. Razone, para cada uno de sus m\u00e9todos, si debe ser sincronizado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public class Recurso {\n    private boolean ocupado = false;\n    private int numGrupos;\n    private int turno;\n    public Recurso(int numGrupos) {\n        this.numGrupos = numGrupos;\n        this.turno = 0;\n        this.ocupado = false;\n    }\n\n    // Debe ser sincronizado para controlar el acceso exclusivo a ocupado y turno\n    public synchronized void tomar(int id) throws InterruptedException {\n        while(this.ocupado || this.turno != id) {\n            wait();\n        }\n        this.ocupado = true;\n    }\n\n    // Debe ser sincronizado para controlar el acceso exclusivo a ocupado y turno\n    public synchronized void liberar(int id) throws InterruptedException {\n        assert id == turno; // Opcional\n        this.turno = (this.turno+1) % this.numGrupos;\n        this.ocupado = false;\n        this.notifyAll(); // Despetar a todos, porque hay diferentes id de grupo\n    }\n\n    // Sincronizado porque puede haber modificaci\u00f3n concurrente en tomar o liberar.\n    // Podr\u00edan usarse otros mecanismos (p.e., volatile)\n    public synchronized boolean isOcupado() {\n        return this.ocupado;\n    }\n}\n</code></pre> <ul> <li>(d) (0,5 puntos) En su soluci\u00f3n de los apartados anteriores, \u00bfpuede haber problemas de inanici\u00f3n? Razone su respuesta. </li> </ul> Mostrar soluci\u00f3n <p>En la soluci\u00f3n dada no hay ning\u00fan control de orden de acceso de las hebras de un mismo grupo al recurso. Puede haber inanici\u00f3n.</p> <p>Podr\u00eda evitarse implementando alg\u00fan control simple como una cola FIFO.</p>","tags":["concurrencia"]},{"location":"exams/2023/p2_ex02/","title":"P2 ex02","text":"<p>Se nos proporcionan las siguientes clases para modelar un grafo, muy similares a las utilizadas en los laboratorios: <pre><code>class Nodo {\n    public String id;\n    public boolean infectado; \n    public List&lt;Arista&gt; vecinos;\n    public Nodo(String id) {\n        this.id = id; \n        this.infectado = false;\n        this.vecinos = new ArrayList&lt;&gt;();\n    }\n    public void addVecino(Nodo vecino, int peso) {\n        vecinos.add(new Arista(vecino, this, peso));\n    }      \n}  \n\nclass Arista {     \n    public Nodo a, b;     \n    public int peso;      \n    public Arista(Nodo a, Nodo b, int peso) {\n        this.a = a; \n        this.b = b; \n        this.peso = peso; \n    }\n    public Nodo contrario(Nodo nodo) {\n    if(a.equals(nodo)) return b;\n    return a;\n    }\n}  \nclass Grafo {\n    public List&lt;Nodo&gt; nodos;\n    public Grafo() {\n        nodos = new ArrayList&lt;&gt;();\n    }\n}\n</code></pre> Este conjunto de clases nos permiten modelar un grafo no dirigido y con pesos. La diferencia con el c\u00f3digo utilizado en los laboratorios es la clase <code>Arista</code>, que se utiliza para conectar dos <code>Nodo</code> y su peso representa la distancia a la que se encuentran dichos nodos. El m\u00e9todo <code>contrario</code> de la clase <code>Arista</code> recibe como par\u00e1metro uno de los <code>Nodo</code> de los extremos de la arista y devuelve el otro. El atributo <code>vecinos</code> de la clase <code>Nodo</code> ahora es una lista de objetos <code>Arista</code> que llevan a los vecinos. Se proporciona, adem\u00e1s, el siguiente grafo de ejemplo:</p> <p></p> <p>Queremos utilizar este modelo de grafos para simular la propagaci\u00f3n de un virus. Los nodos pueden estar infectados, esto se refleja en el atributo <code>infectado</code>, y pueden propagar el virus a sus vecinos. Un nodo infectado, contagia el virus a todos sus vecinos que est\u00e9n a una distancia menor o igual a 4. Para saber la distancia entre dos nodos, podemos comprobar el peso de la arista que los conecta. Cuando un nodo contagia a uno de sus vecinos, ese nodo vecino contagiar\u00e1 a su vez a sus vecinos, que a su vez contagiar\u00e1n a sus vecinos, etc, creando una reacci\u00f3n en cadena.</p> <ul> <li>(a) (0,5 puntos) Suponiendo que en el ejemplo, el nodo 'A' est\u00e1 infectado, al simular la propagaci\u00f3n del virus \u00bfcu\u00e1ntos nodos quedar\u00e1n infectados?</li> </ul> Mostrar soluci\u00f3n <p>N/A</p> <ul> <li>(b) (2,5 puntos) Implemente el m\u00e9todo <code>simulaContagios</code> de la clase <code>Grafo</code>, que reciba un <code>Nodo</code> como par\u00e1metro. Este m\u00e9todo deber\u00e1 cambiar el estado de este nodo a infectado y simular la propagaci\u00f3n del virus, seg\u00fan las reglas explicadas anteriormente. El m\u00e9todo debe devolver el n\u00famero de nodos del grafo que han quedado infectados tras la propagaci\u00f3n del virus. Nota: El algoritmo a desarollar es similar al de calcular los vecinos de orden n del Laboratorio 3.</li> </ul> Mostrar soluci\u00f3n <p>N/A</p> <ul> <li>(c) (1 punto) Implemente el m\u00e9todo <code>inmunes</code> que debe devolver un conjunto con los <code>Nodo</code> que no pueden ser contagiados por ning\u00fan otro <code>Nodo</code> con las reglas de propagaci\u00f3n dadas.</li> </ul> Mostrar soluci\u00f3n <p>N/A</p>","tags":["grafos"]},{"location":"exams/2024/extra/","title":"Examen 2024 \u2014 Extraordinario","text":""},{"location":"exams/2024/extra/#problema-1","title":"Problema 1","text":"<p>Considere la clase ArrayDoble, con los atributos descritos en el diagrama de debajo. El atributo array es un array de enteros de dimensi\u00f3n n. Los elementos est\u00e1n separados en dos partes. Los i primeros elementos de este array son n\u00fameros impares ordenados de menor a mayor. Los \u00faltimos n-i elementos son n\u00fameros pares ordenados de menor a mayor. Puede haber posiciones vac\u00edas, cuyo valor ser\u00e1 null, pero solo al final de cada una de las partes (par e impar). Tambi\u00e9n puede haber valores repetidos. A continuaci\u00f3n, se puede ver un ejemplo del contenido de este array:</p> <p></p> <p></p> <p>Se pide, considerando como parcialmente v\u00e1lidas las implementaciones que apliquen simplificaciones y no cumplan todos los requisitos (p.e., que no consideren elementos duplicados):</p> <ul> <li>(a) (1.5 puntos) Implemente el m\u00e9todo buscar. Este m\u00e9todo debe devolver true cuando el valor buscado se encuentre en el array, y false en el resto de los casos. Su complejidad debe ser menor que O(n). Justifique su elecci\u00f3n de algoritmo. Puede crear tantos m\u00e9todos auxiliares como considere adecuados.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo buscar aplica b\u00fasqueda binaria sobre la parte adecuada del array. En el caso peor, su complejidad ser\u00e1 O(log(n)). <pre><code>public int posicion(Integer valor, int a, int z) {\n    while (a &lt; z) {\n        int m = (a + z) / 2;\n\n        if (this.array[m] == null) {\n            z = m;\n            continue;\n        }\n\n        if (this.array[m] == valor) {\n            while (m &gt; a &amp;&amp; this.array[m - 1] == valor) {\n                m--;\n            }\n            return m;\n        }\n\n        if (this.array[m] &lt; valor) {\n            a = m + 1;\n        } else {\n            z = m;\n        }\n    }\n    return a;\n}\n\npublic boolean buscar(Integer valor) {\n    int a = 0;\n    int z = i;\n\n    if (valor % 2 == 0) {\n        a = i;\n        z = this.array.length;\n    }\n\n    int pos = this.posicion(valor, a, z);\n    if (pos &lt; this.array.length) {\n        return this.array[pos] == valor;\n    }\n    return false;\n}\n</code></pre></p> <ul> <li>(b) (2.5 puntos) Implemente el m\u00e9todo eliminar. Tras ejecutar este m\u00e9todo, ning\u00fan elemento del array debe coincidir con ese valor, y las condiciones del enunciado sobre el orden de los valores y la posici\u00f3n de los valores null deben seguir cumpli\u00e9ndose.</li> </ul> Mostrar soluci\u00f3n <p>Hay al menos dos alternativas a la hora de eliminar un elemento impar. Pueden desplazarse todos los elementos a la derecha del borrado o s\u00f3lo desplazarse los impares. En el primer caso, deber\u00e1 decrementarse el valor de i, en el segundo el valor de i se mantiene.</p> <pre><code>public void eliminar(Integer valor) {\n    int a = 0;\n    int z = i;\n\n    if (valor % 2 == 0) {\n        a = i;\n        z = this.array.length;\n    }\n\n    int izquierda = this.posicion(valor, a, z);\n    if (izquierda &gt;= z || this.array[izquierda] != valor) {\n        return;\n    }\n\n    int derecha = izquierda + 1;\n    while (derecha &lt; z &amp;&amp; valor == this.array[derecha]) {\n        derecha++;\n    }\n\n    while (derecha &lt; z) {\n        this.array[izquierda++] = this.array[derecha++];\n    }\n}\n</code></pre>"},{"location":"exams/2024/extra/#problema-2","title":"Problema 2","text":"<p>En este problema se trabajar\u00e1 con una tabla hash que almacena los nombres de los alumnos de un curso y sus respectivas notas. La tabla hash funciona con direccionamiento abierto. La resoluci\u00f3n de las colisiones se realizar\u00e1 mediante el m\u00e9todo de la exploraci\u00f3n cuadr\u00e1tica. Esto significa que si al insertar un elemento en la tabla hash se produce una colisi\u00f3n, se elegir\u00e1 una nueva posici\u00f3n mediante la f\u00f3rmula (posicion + i^2) % tabla.length, donde i es el n\u00famero de intentos de reubicaci\u00f3n en la tabla y la operaci\u00f3n % es el m\u00f3dulo que devuelve el resto de la divisi\u00f3n.</p> <p>Se proporciona el siguiente c\u00f3digo que realiza la acci\u00f3n de insertar un elemento en la tabla hash:</p> <pre><code>/**\n * El m\u00e9todo insertar trata de a\u00f1adir un elemento a la tabla hash.\n * Si al calcular la posici\u00f3n de insercci\u00f3n se produce una colisi\u00f3n, busca una\n * nueva posici\u00f3n mediante exploraci\u00f3n cuadr\u00e1tica.\n * Si ya exist\u00eda un elemento con la misma clave, actualiza su valor.\n * Si no se puede insertar un elemento porque la tabla est\u00e1 llena, devolver\u00e1 false.\n * @param alumno Elemento que se insertar\u00e1\n * @return true si se ha podido insertar el elemento en la tabla\n */\n\npublic boolean insertar(ElementoDeTabla alumno) {\n    int pos = hash(alumno.getNombre());\n    int intento = 0;\n    while (intento &lt; tabla.length) {\n        int posicionPrueba = (pos + intento * intento) % tabla.length;\n        if (tabla[posicionPrueba] == null) {\n            tabla[posicionPrueba] = alumno;\n            return true;\n        }\n        else if (tabla[posicionPrueba].getNombre().equals(alumno.getNombre())) {\n            tabla[posicionPrueba].setNota(alumno.getNota());\n            return true;\n        }\n        else {\n            intento++;\n        }\n    }\n    return false;\n}\n</code></pre> <p></p> <p>Se pide: - (a) (1 punto) Suponga que se tiene una tabla hash como la descrita de tama\u00f1o 7. Inserte los siguientes elementos en la tabla hash en el orden que se presentan. Muestre el estado de la tabla despu\u00e9s de cada inserci\u00f3n.</p> Nombre Alejandro David Diego Fernando Javier Miguel Nota 10 10 10 10 10 10 hash(nombre) 2 5 5 1 6 6 Mostrar soluci\u00f3n <ul> <li> <ol> <li>Alejandro se coloca sin colisiones en la posici\u00f3n 2</li> </ol> </li> <li> <ol> <li>David se coloca sin colisiones en la posici\u00f3n 5</li> </ol> </li> <li> <ol> <li>Diego colisiona en la posici\u00f3n 5, la siguiente prueba (5 + 1*1) % 7 = 6 es v\u00e1lida</li> </ol> </li> <li> <ol> <li>Fernando se coloca sin colisiones en la posici\u00f3n 1</li> </ol> </li> <li> <ol> <li>Javier colisiona en la posici\u00f3n 6, la siguiente prueba (6 + 1*1) % 7 = 0 es v\u00e1lida</li> </ol> </li> <li> <ol> <li>Miguel colisiona en la posici\u00f3n 6, la siguiente prueba (6 + 11) % 7 = 0 tambi\u00e9n colisiona, la siguiente prueba (6 + 22) % 7 = 3 es v\u00e1lida</li> </ol> </li> </ul> <p></p> <ul> <li>(b) (1 punto) Razone la complejidad algor\u00edtmica de la operaci\u00f3n de inserci\u00f3n en la tabla hash descrita. Suponga los casos en los que el n\u00famero de elementos que contiene la tabla es:<ul> <li>mucho menor que el tama\u00f1o de la tabla.</li> <li>similar al tama\u00f1o de la tabla.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Si el n\u00famero de elementos que contiene la tabla es mucho menor que el tama\u00f1o de la tabla, la complejidad algor\u00edtmica es O(1) ya que se inserta en la primera posici\u00f3n disponible o tras pocas pruebas.</p> <p>Si el n\u00famero de elementos que contiene la tabla es similar al tama\u00f1o de la tabla, la complejidad algor\u00edtmica es O(n) ya que se debe recorrer la tabla completa para encontrar una posici\u00f3n disponible.</p> <ul> <li>(c) (2 puntos) Implemente el m\u00e9todo buscar(String nombre) que recibe el nombre de un alumno y retorna el objeto ElementoDeTabla correspondiente o null si no lo encuentra.</li> </ul> Mostrar soluci\u00f3n <pre><code>public ElementoDeTabla buscar(String nombre) {\n    int pos = hash(nombre);\n    int intento = 0;\n\n    while (intento &lt; tabla.length) {\n        int posicionPrueba = (pos + intento * intento) % tabla.length;\n        if (tabla[posicionPrueba] == null) {\n            break;\n        } else if (tabla[posicionPrueba].getNombre().equals(nombre)) {\n            return tabla[posicionPrueba];\n        } else {\n            intento++;\n        }\n    }\n\n    return null;\n}\n</code></pre> <p>Suponga ahora que debido a la cantidad de elementos que se quieren almacenar, se decide cambiar el tipo de tabla hash a una tabla con direccionamiento cerrado. En este caso los elementos que colisionen se almacenar\u00e1n en una lista que se encuentra en la posici\u00f3n que gener\u00f3 la colisi\u00f3n. Puede asumir que la tabla se ha inicializado con listas vac\u00edas en cada posici\u00f3n.</p> <ul> <li>(d) (2 puntos) Implemente el m\u00e9todo insertar(ElementoDeTabla alumno) que inserta un nuevo elemento en la tabla hash con direccionamiento cerrado. En caso de colisi\u00f3n, el nuevo elemento se debe agregar a la lista que se encuentra en la posici\u00f3n que gener\u00f3 la colisi\u00f3n. Si ya existe un elemento con el mismo nombre, debe reemplazar su valor.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void insertar(ElementoDeTabla alumno) {\n    int pos = hash(alumno.getNombre());\n\n    for (ElementoDeTabla e : tabla[pos]) {\n        if (e.getNombre().equals(alumno.getNombre())) {\n            e.setNota(alumno.getNota());\n            return;\n        }\n    }\n\n    tabla[pos].add(alumno);\n}\n</code></pre>"},{"location":"exams/2024/extra/#problema-3","title":"Problema 3","text":"<p>La pregunta consiste en simular la gesti\u00f3n de una gasolinera. La gasolinera tiene una cantidad limitada de surtidores y dep\u00f3sitos de diferentes tipos de combustibles (Gasolina y Diesel). Los veh\u00edculos y los camiones cisterna representan hebras que interact\u00faan con la gasolinera y una taquilla de cobro/pago.</p> <p>Monitor Gasolinera:     - Controla el acceso a los surtidores y dep\u00f3sitos de combustible.     - Se inicializa con un n\u00famero de surtidores. Los dep\u00f3sitos se inicializan con 100 que ser\u00e1 el tama\u00f1o m\u00e1ximo.     - Permite la entrada de veh\u00edculos si hay surtidores disponibles.     - Permite a los veh\u00edculos repostar si hay suficiente combustible en el dep\u00f3sito e inmediatamente despu\u00e9s el veh\u00edculo sale de la gasolinera.     - Permite a un cami\u00f3n cisterna rellenar un dep\u00f3sito si el nivel est\u00e1 por debajo del 10%, pero solo puede haber un cami\u00f3n repostando.</p> <p>Monitor Taquilla:     - Controla los pagos y cobros de la gasolinera y solo tiene una ventanilla para atender.     - Permite que un veh\u00edculo pague por el combustible repostado y permite que un cami\u00f3n cisterna cobre por el combustible rellenado. Actualizando el dinero en caja.</p> <p>Comportamiento de la hebra Veh\u00edculo:     - Cada veh\u00edculo tiene un nombre y un tipo de combustible que usa. Un veh\u00edculo:         - Entra en la gasolinera (si hay surtidores disponibles).         - Reposta una cantidad espec\u00edfica de combustible y sale inmediatamente despu\u00e9s.         - Paga en la taquilla indicando el dinero a pagar.</p> <p>Comportamiento de la hebra Cami\u00f3n Cisterna (no es un Veh\u00edculo):     - Cada cami\u00f3n cisterna tiene un nombre y un tipo de combustible que puede rellenar.     - Un cami\u00f3n cisterna:         - Rellena un dep\u00f3sito de la gasolinera (si el nivel de combustible est\u00e1 por debajo del 10%).         - Cobra en la taquilla indicando el dinero que debe cobrar.</p> <p>Diagrama de clases:</p> <p></p> <p>Se pide:</p> <p>Desarrolla el c\u00f3digo del monitor Gasolinera: - (a) (1 punto) Implementa el m\u00e9todo <pre><code>public synchronized void entrar(String nombre) throws InterruptedException\n</code></pre></p> Mostrar soluci\u00f3n <p>FALTA.</p> <ul> <li>(b) (1,5 puntos) Implementa el m\u00e9todo <pre><code>public synchronized void repostarYSalir(String nombre, Combustible tipo, int cantidad) throws InterruptedException\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>FALTA.</p> <ul> <li>(c) (1,5 puntos) Implementa el m\u00e9todo  <pre><code>public synchronized void rellenarDeposito(String nombre, Combustible tipo, int cantidad) throws InterruptedException\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>FALTA.</p> <p>Desarrolla el c\u00f3digo del monitor Taquilla:</p> <ul> <li>(d) (0,5 puntos) Implementa el m\u00e9todo <pre><code>public synchronized void pagar(String nombre, int cantidad, Combustible tipo) throws InterruptedException\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>FALTA.</p> <ul> <li>(e) (0,5 puntos) Implementa el m\u00e9todo <pre><code>public synchronized void cobrar(String nombre, int cantidad, Combustible tipo) throws InterruptedException\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>FALTA.</p>"},{"location":"exams/2024/extra/#problema-4","title":"Problema 4","text":"<p>Durante la construcci\u00f3n de una nueva ciudad, se est\u00e1 planificando el despliegue de la red de Internet. Para extender la red, se han empezado a instalar cables de red entre las casas, asegurando que, si una casa tiene conexi\u00f3n a Internet, todas las casas conectadas a ella tambi\u00e9n la tengan. La salida de la red de la ciudad se realiza con cables de fibra \u00f3ptica que se conectan a una de las casas, d\u00e1ndole acceso a Internet.</p> <p>Este escenario se modela como un grafo no dirigido, donde los nodos son las casas y las aristas son los cables de red. En el siguiente diagrama se puede ver c\u00f3mo se han dise\u00f1ado las clases que modelan el grafo adjunto.</p> <p></p> <ul> <li>(a) (3 puntos) Por problemas de presupuesto, inicialmente solo se contar\u00e1 con un cable de fibra \u00f3ptica para conectar la red de Internet a la ciudad. Este cable se debe conectar de manera que la cantidad de casas que tengan acceso a Internet sea la m\u00e1xima posible. Implemente el m\u00e9todo nodoPreferido() en la clase GrafoCiudad que retorne el nodo al que se debe conectar la fibra \u00f3ptica para que el mayor n\u00famero de casas tenga conexi\u00f3n. Si hay varias opciones v\u00e1lidas, devuelva cualquiera de ellas.</li> </ul> Mostrar soluci\u00f3n <p>En este apartado se debe buscar la componente conexa m\u00e1s grande del grafo y devolver cualquiera de los nodos que pertenezcan a esa componente. Una posible soluci\u00f3n es:</p> <pre><code>public Nodo nodoPreferido() {\n    Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n    int maxEncontrado = 0;\n    Nodo maxNodo = null;\n\n    for (Nodo n : casas) {\n        if (visitados.contains(n)) continue;\n        Set&lt;Nodo&gt; conectados = getConectados(n);\n        if (maxEncontrado &lt; conectados.size()) {\n            maxEncontrado = conectados.size();\n            maxNodo = n;\n        }\n        visitados.addAll(conectados);\n    }\n\n    return maxNodo;\n}\n\npublic Set&lt;Nodo&gt; getConectados(Nodo origen) {\n    Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n    List&lt;Nodo&gt; porVisitar = new ArrayList&lt;&gt;();\n\n    visitados.add(origen);\n    porVisitar.add(origen);\n\n    while (!porVisitar.isEmpty()) {\n        Nodo n = porVisitar.remove(0);\n        for (Arista a : n.cablesConectados) {\n            Nodo vecino = a.getOtroNodo(n);\n            if (!visitados.contains(vecino)) {\n                visitados.add(vecino);\n                porVisitar.add(vecino);\n            }\n        }\n    }\n\n    return visitados;\n}\n</code></pre> <ul> <li>(b) (2 puntos) Cuando avanza la construcci\u00f3n de la ciudad, se decide poner nuevos cables de fibra \u00f3ptica que traigan la conexi\u00f3n desde fuera de la ciudad. Los cables de fibra se conectar\u00e1n a una sola casa, de la misma manera que en el apartado anterior. En esta ocasi\u00f3n, se necesita conocer el n\u00famero m\u00ednimo de cables de fibra necesarios para dar conexi\u00f3n a todas las casas. Implemente el m\u00e9todo cablesMinimos() en la clase GrafoCiudad que retorne el n\u00famero de cables necesarios para garantizar la conectividad de todas las casas.</li> </ul> Mostrar soluci\u00f3n <p>En este apartado se debe calcular el n\u00famero de componentes conexas que forman el grafo</p> <pre><code>public int cablesMinimos() {\n    Set&lt;Nodo&gt; visitados = new HashSet();\n    int componentes = 0;\n    for (Nodo n : casas) {\n        if (visitados.contains(n)) continue;\n        visitados.addAll(getConectados(n));\n        componentes++;\n    }\n    return componentes;\n}\n</code></pre>"},{"location":"exams/2024/extra_ex01/","title":"Extra ex01","text":"<p>Considere la clase ArrayDoble, con los atributos descritos en el diagrama de debajo. El atributo array es un array de enteros de dimensi\u00f3n n. Los elementos est\u00e1n separados en dos partes. Los i primeros elementos de este array son n\u00fameros impares ordenados de menor a mayor. Los \u00faltimos n-i elementos son n\u00fameros pares ordenados de menor a mayor. Puede haber posiciones vac\u00edas, cuyo valor ser\u00e1 null, pero solo al final de cada una de las partes (par e impar). Tambi\u00e9n puede haber valores repetidos. A continuaci\u00f3n, se puede ver un ejemplo del contenido de este array:</p> <p></p> <p></p> <p>Se pide, considerando como parcialmente v\u00e1lidas las implementaciones que apliquen simplificaciones y no cumplan todos los requisitos (p.e., que no consideren elementos duplicados):</p> <ul> <li>(a) (1.5 puntos) Implemente el m\u00e9todo buscar. Este m\u00e9todo debe devolver true cuando el valor buscado se encuentre en el array, y false en el resto de los casos. Su complejidad debe ser menor que O(n). Justifique su elecci\u00f3n de algoritmo. Puede crear tantos m\u00e9todos auxiliares como considere adecuados.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo buscar aplica b\u00fasqueda binaria sobre la parte adecuada del array. En el caso peor, su complejidad ser\u00e1 O(log(n)). <pre><code>public int posicion(Integer valor, int a, int z) {\n    while (a &lt; z) {\n        int m = (a + z) / 2;\n\n        if (this.array[m] == null) {\n            z = m;\n            continue;\n        }\n\n        if (this.array[m] == valor) {\n            while (m &gt; a &amp;&amp; this.array[m - 1] == valor) {\n                m--;\n            }\n            return m;\n        }\n\n        if (this.array[m] &lt; valor) {\n            a = m + 1;\n        } else {\n            z = m;\n        }\n    }\n    return a;\n}\n\npublic boolean buscar(Integer valor) {\n    int a = 0;\n    int z = i;\n\n    if (valor % 2 == 0) {\n        a = i;\n        z = this.array.length;\n    }\n\n    int pos = this.posicion(valor, a, z);\n    if (pos &lt; this.array.length) {\n        return this.array[pos] == valor;\n    }\n    return false;\n}\n</code></pre></p> <ul> <li>(b) (2.5 puntos) Implemente el m\u00e9todo eliminar. Tras ejecutar este m\u00e9todo, ning\u00fan elemento del array debe coincidir con ese valor, y las condiciones del enunciado sobre el orden de los valores y la posici\u00f3n de los valores null deben seguir cumpli\u00e9ndose.</li> </ul> Mostrar soluci\u00f3n <p>Hay al menos dos alternativas a la hora de eliminar un elemento impar. Pueden desplazarse todos los elementos a la derecha del borrado o s\u00f3lo desplazarse los impares. En el primer caso, deber\u00e1 decrementarse el valor de i, en el segundo el valor de i se mantiene.</p> <pre><code>public void eliminar(Integer valor) {\n    int a = 0;\n    int z = i;\n\n    if (valor % 2 == 0) {\n        a = i;\n        z = this.array.length;\n    }\n\n    int izquierda = this.posicion(valor, a, z);\n    if (izquierda &gt;= z || this.array[izquierda] != valor) {\n        return;\n    }\n\n    int derecha = izquierda + 1;\n    while (derecha &lt; z &amp;&amp; valor == this.array[derecha]) {\n        derecha++;\n    }\n\n    while (derecha &lt; z) {\n        this.array[izquierda++] = this.array[derecha++];\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2024/extra_ex02/","title":"Extra ex02","text":"<p>En este problema se trabajar\u00e1 con una tabla hash que almacena los nombres de los alumnos de un curso y sus respectivas notas. La tabla hash funciona con direccionamiento abierto. La resoluci\u00f3n de las colisiones se realizar\u00e1 mediante el m\u00e9todo de la exploraci\u00f3n cuadr\u00e1tica. Esto significa que si al insertar un elemento en la tabla hash se produce una colisi\u00f3n, se elegir\u00e1 una nueva posici\u00f3n mediante la f\u00f3rmula (posicion + i^2) % tabla.length, donde i es el n\u00famero de intentos de reubicaci\u00f3n en la tabla y la operaci\u00f3n % es el m\u00f3dulo que devuelve el resto de la divisi\u00f3n.</p> <p>Se proporciona el siguiente c\u00f3digo que realiza la acci\u00f3n de insertar un elemento en la tabla hash:</p> <pre><code>/**\n * El m\u00e9todo insertar trata de a\u00f1adir un elemento a la tabla hash.\n * Si al calcular la posici\u00f3n de insercci\u00f3n se produce una colisi\u00f3n, busca una\n * nueva posici\u00f3n mediante exploraci\u00f3n cuadr\u00e1tica.\n * Si ya exist\u00eda un elemento con la misma clave, actualiza su valor.\n * Si no se puede insertar un elemento porque la tabla est\u00e1 llena, devolver\u00e1 false.\n * @param alumno Elemento que se insertar\u00e1\n * @return true si se ha podido insertar el elemento en la tabla\n */\n\npublic boolean insertar(ElementoDeTabla alumno) {\n    int pos = hash(alumno.getNombre());\n    int intento = 0;\n    while (intento &lt; tabla.length) {\n        int posicionPrueba = (pos + intento * intento) % tabla.length;\n        if (tabla[posicionPrueba] == null) {\n            tabla[posicionPrueba] = alumno;\n            return true;\n        }\n        else if (tabla[posicionPrueba].getNombre().equals(alumno.getNombre())) {\n            tabla[posicionPrueba].setNota(alumno.getNota());\n            return true;\n        }\n        else {\n            intento++;\n        }\n    }\n    return false;\n}\n</code></pre> <p></p> <p>Se pide: - (a) (1 punto) Suponga que se tiene una tabla hash como la descrita de tama\u00f1o 7. Inserte los siguientes elementos en la tabla hash en el orden que se presentan. Muestre el estado de la tabla despu\u00e9s de cada inserci\u00f3n.</p> Nombre Alejandro David Diego Fernando Javier Miguel Nota 10 10 10 10 10 10 hash(nombre) 2 5 5 1 6 6 Mostrar soluci\u00f3n <ul> <li> <ol> <li>Alejandro se coloca sin colisiones en la posici\u00f3n 2</li> </ol> </li> <li> <ol> <li>David se coloca sin colisiones en la posici\u00f3n 5</li> </ol> </li> <li> <ol> <li>Diego colisiona en la posici\u00f3n 5, la siguiente prueba (5 + 1*1) % 7 = 6 es v\u00e1lida</li> </ol> </li> <li> <ol> <li>Fernando se coloca sin colisiones en la posici\u00f3n 1</li> </ol> </li> <li> <ol> <li>Javier colisiona en la posici\u00f3n 6, la siguiente prueba (6 + 1*1) % 7 = 0 es v\u00e1lida</li> </ol> </li> <li> <ol> <li>Miguel colisiona en la posici\u00f3n 6, la siguiente prueba (6 + 11) % 7 = 0 tambi\u00e9n colisiona, la siguiente prueba (6 + 22) % 7 = 3 es v\u00e1lida</li> </ol> </li> </ul> <p></p> <ul> <li>(b) (1 punto) Razone la complejidad algor\u00edtmica de la operaci\u00f3n de inserci\u00f3n en la tabla hash descrita. Suponga los casos en los que el n\u00famero de elementos que contiene la tabla es:<ul> <li>mucho menor que el tama\u00f1o de la tabla.</li> <li>similar al tama\u00f1o de la tabla.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Si el n\u00famero de elementos que contiene la tabla es mucho menor que el tama\u00f1o de la tabla, la complejidad algor\u00edtmica es O(1) ya que se inserta en la primera posici\u00f3n disponible o tras pocas pruebas.</p> <p>Si el n\u00famero de elementos que contiene la tabla es similar al tama\u00f1o de la tabla, la complejidad algor\u00edtmica es O(n) ya que se debe recorrer la tabla completa para encontrar una posici\u00f3n disponible.</p> <ul> <li>(c) (2 puntos) Implemente el m\u00e9todo buscar(String nombre) que recibe el nombre de un alumno y retorna el objeto ElementoDeTabla correspondiente o null si no lo encuentra.</li> </ul> Mostrar soluci\u00f3n <pre><code>public ElementoDeTabla buscar(String nombre) {\n    int pos = hash(nombre);\n    int intento = 0;\n\n    while (intento &lt; tabla.length) {\n        int posicionPrueba = (pos + intento * intento) % tabla.length;\n        if (tabla[posicionPrueba] == null) {\n            break;\n        } else if (tabla[posicionPrueba].getNombre().equals(nombre)) {\n            return tabla[posicionPrueba];\n        } else {\n            intento++;\n        }\n    }\n\n    return null;\n}\n</code></pre> <p>Suponga ahora que debido a la cantidad de elementos que se quieren almacenar, se decide cambiar el tipo de tabla hash a una tabla con direccionamiento cerrado. En este caso los elementos que colisionen se almacenar\u00e1n en una lista que se encuentra en la posici\u00f3n que gener\u00f3 la colisi\u00f3n. Puede asumir que la tabla se ha inicializado con listas vac\u00edas en cada posici\u00f3n.</p> <ul> <li>(d) (2 puntos) Implemente el m\u00e9todo insertar(ElementoDeTabla alumno) que inserta un nuevo elemento en la tabla hash con direccionamiento cerrado. En caso de colisi\u00f3n, el nuevo elemento se debe agregar a la lista que se encuentra en la posici\u00f3n que gener\u00f3 la colisi\u00f3n. Si ya existe un elemento con el mismo nombre, debe reemplazar su valor.</li> </ul> Mostrar soluci\u00f3n <pre><code>public void insertar(ElementoDeTabla alumno) {\n    int pos = hash(alumno.getNombre());\n\n    for (ElementoDeTabla e : tabla[pos]) {\n        if (e.getNombre().equals(alumno.getNombre())) {\n            e.setNota(alumno.getNota());\n            return;\n        }\n    }\n\n    tabla[pos].add(alumno);\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2024/extra_ex03/","title":"Extra ex03","text":"<p>La pregunta consiste en simular la gesti\u00f3n de una gasolinera. La gasolinera tiene una cantidad limitada de surtidores y dep\u00f3sitos de diferentes tipos de combustibles (Gasolina y Diesel). Los veh\u00edculos y los camiones cisterna representan hebras que interact\u00faan con la gasolinera y una taquilla de cobro/pago.</p> <p>Monitor Gasolinera:     - Controla el acceso a los surtidores y dep\u00f3sitos de combustible.     - Se inicializa con un n\u00famero de surtidores. Los dep\u00f3sitos se inicializan con 100 que ser\u00e1 el tama\u00f1o m\u00e1ximo.     - Permite la entrada de veh\u00edculos si hay surtidores disponibles.     - Permite a los veh\u00edculos repostar si hay suficiente combustible en el dep\u00f3sito e inmediatamente despu\u00e9s el veh\u00edculo sale de la gasolinera.     - Permite a un cami\u00f3n cisterna rellenar un dep\u00f3sito si el nivel est\u00e1 por debajo del 10%, pero solo puede haber un cami\u00f3n repostando.</p> <p>Monitor Taquilla:     - Controla los pagos y cobros de la gasolinera y solo tiene una ventanilla para atender.     - Permite que un veh\u00edculo pague por el combustible repostado y permite que un cami\u00f3n cisterna cobre por el combustible rellenado. Actualizando el dinero en caja.</p> <p>Comportamiento de la hebra Veh\u00edculo:     - Cada veh\u00edculo tiene un nombre y un tipo de combustible que usa. Un veh\u00edculo:         - Entra en la gasolinera (si hay surtidores disponibles).         - Reposta una cantidad espec\u00edfica de combustible y sale inmediatamente despu\u00e9s.         - Paga en la taquilla indicando el dinero a pagar.</p> <p>Comportamiento de la hebra Cami\u00f3n Cisterna (no es un Veh\u00edculo):     - Cada cami\u00f3n cisterna tiene un nombre y un tipo de combustible que puede rellenar.     - Un cami\u00f3n cisterna:         - Rellena un dep\u00f3sito de la gasolinera (si el nivel de combustible est\u00e1 por debajo del 10%).         - Cobra en la taquilla indicando el dinero que debe cobrar.</p> <p>Diagrama de clases:</p> <p></p> <p>Se pide:</p> <p>Desarrolla el c\u00f3digo del monitor Gasolinera: - (a) (1 punto) Implementa el m\u00e9todo <pre><code>public synchronized void entrar(String nombre) throws InterruptedException\n</code></pre></p> Mostrar soluci\u00f3n <p>FALTA.</p> <ul> <li>(b) (1,5 puntos) Implementa el m\u00e9todo <pre><code>public synchronized void repostarYSalir(String nombre, Combustible tipo, int cantidad) throws InterruptedException\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>FALTA.</p> <ul> <li>(c) (1,5 puntos) Implementa el m\u00e9todo  <pre><code>public synchronized void rellenarDeposito(String nombre, Combustible tipo, int cantidad) throws InterruptedException\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>FALTA.</p> <p>Desarrolla el c\u00f3digo del monitor Taquilla:</p> <ul> <li>(d) (0,5 puntos) Implementa el m\u00e9todo <pre><code>public synchronized void pagar(String nombre, int cantidad, Combustible tipo) throws InterruptedException\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>FALTA.</p> <ul> <li>(e) (0,5 puntos) Implementa el m\u00e9todo <pre><code>public synchronized void cobrar(String nombre, int cantidad, Combustible tipo) throws InterruptedException\n</code></pre></li> </ul> Mostrar soluci\u00f3n <p>FALTA.</p>","tags":["hebras"]},{"location":"exams/2024/extra_ex04/","title":"Extra ex04","text":"<p>Durante la construcci\u00f3n de una nueva ciudad, se est\u00e1 planificando el despliegue de la red de Internet. Para extender la red, se han empezado a instalar cables de red entre las casas, asegurando que, si una casa tiene conexi\u00f3n a Internet, todas las casas conectadas a ella tambi\u00e9n la tengan. La salida de la red de la ciudad se realiza con cables de fibra \u00f3ptica que se conectan a una de las casas, d\u00e1ndole acceso a Internet.</p> <p>Este escenario se modela como un grafo no dirigido, donde los nodos son las casas y las aristas son los cables de red. En el siguiente diagrama se puede ver c\u00f3mo se han dise\u00f1ado las clases que modelan el grafo adjunto.</p> <p></p> <ul> <li>(a) (3 puntos) Por problemas de presupuesto, inicialmente solo se contar\u00e1 con un cable de fibra \u00f3ptica para conectar la red de Internet a la ciudad. Este cable se debe conectar de manera que la cantidad de casas que tengan acceso a Internet sea la m\u00e1xima posible. Implemente el m\u00e9todo nodoPreferido() en la clase GrafoCiudad que retorne el nodo al que se debe conectar la fibra \u00f3ptica para que el mayor n\u00famero de casas tenga conexi\u00f3n. Si hay varias opciones v\u00e1lidas, devuelva cualquiera de ellas.</li> </ul> Mostrar soluci\u00f3n <p>En este apartado se debe buscar la componente conexa m\u00e1s grande del grafo y devolver cualquiera de los nodos que pertenezcan a esa componente. Una posible soluci\u00f3n es:</p> <pre><code>public Nodo nodoPreferido() {\n    Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n    int maxEncontrado = 0;\n    Nodo maxNodo = null;\n\n    for (Nodo n : casas) {\n        if (visitados.contains(n)) continue;\n        Set&lt;Nodo&gt; conectados = getConectados(n);\n        if (maxEncontrado &lt; conectados.size()) {\n            maxEncontrado = conectados.size();\n            maxNodo = n;\n        }\n        visitados.addAll(conectados);\n    }\n\n    return maxNodo;\n}\n\npublic Set&lt;Nodo&gt; getConectados(Nodo origen) {\n    Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n    List&lt;Nodo&gt; porVisitar = new ArrayList&lt;&gt;();\n\n    visitados.add(origen);\n    porVisitar.add(origen);\n\n    while (!porVisitar.isEmpty()) {\n        Nodo n = porVisitar.remove(0);\n        for (Arista a : n.cablesConectados) {\n            Nodo vecino = a.getOtroNodo(n);\n            if (!visitados.contains(vecino)) {\n                visitados.add(vecino);\n                porVisitar.add(vecino);\n            }\n        }\n    }\n\n    return visitados;\n}\n</code></pre> <ul> <li>(b) (2 puntos) Cuando avanza la construcci\u00f3n de la ciudad, se decide poner nuevos cables de fibra \u00f3ptica que traigan la conexi\u00f3n desde fuera de la ciudad. Los cables de fibra se conectar\u00e1n a una sola casa, de la misma manera que en el apartado anterior. En esta ocasi\u00f3n, se necesita conocer el n\u00famero m\u00ednimo de cables de fibra necesarios para dar conexi\u00f3n a todas las casas. Implemente el m\u00e9todo cablesMinimos() en la clase GrafoCiudad que retorne el n\u00famero de cables necesarios para garantizar la conectividad de todas las casas.</li> </ul> Mostrar soluci\u00f3n <p>En este apartado se debe calcular el n\u00famero de componentes conexas que forman el grafo</p> <pre><code>public int cablesMinimos() {\n    Set&lt;Nodo&gt; visitados = new HashSet();\n    int componentes = 0;\n    for (Nodo n : casas) {\n        if (visitados.contains(n)) continue;\n        visitados.addAll(getConectados(n));\n        componentes++;\n    }\n    return componentes;\n}\n</code></pre>","tags":["grafos"]},{"location":"exams/2024/p1/","title":"Examen 2024 \u2014 Parcial 1","text":""},{"location":"exams/2024/p1/#problema-1","title":"Problema 1","text":"<p>Dada la clase <code>FraseCelebre</code>, que se utiliza para almacenar informaci\u00f3n sobre frases c\u00e9lebres, incluyendo el a\u00f1o en que se dijo la frase, el autor de la frase, y la frase en s\u00ed. Se debe desarrollar el c\u00f3digo necesario para que sus objetos puedan ser ordenados. El criterio de ordenaci\u00f3n es, primero se debe ordenar por a\u00f1o de m\u00e1s actual a m\u00e1s antigua y segundo por orden alfab\u00e9tico del nombre del autor.</p> <pre><code>public class FraseCelebre {\n\n    // Atributos de la clase\n    private int anio;        // A\u00f1o en que se dijo la frase\n    private String autor;    // Autor de la frase\n    private String frase;    // La frase c\u00e9lebre\n\n    // Constructor de la clase\n    public FraseCelebre(int anio, String autor, String frase) {\n        this.anio = anio;\n        this.autor = autor;\n        this.frase = frase;\n    }\n\n    // M\u00e9todos getters y setters para los atributos\n    ...\n}\n</code></pre> <p>Se pide:</p> <ul> <li>(a) (2 puntos) Modifique, a\u00f1ade o desarrolle el c\u00f3digo necesario para que tras la ejecuci\u00f3n del siguiente c\u00f3digo de ejemplo se muestre por consola las frases c\u00e9lebres ordenadas con el criterio de ordenaci\u00f3n indicado. </li> </ul> Mostrar soluci\u00f3n <pre><code>public class FraseCelebre implements Comparable&lt;FraseCelebre&gt; {\n\n    // Atributos de la clase, getters y setters\n    ...\n\n    // M\u00e9todo compareTo para comparar objetos FraseCelebre\n    @Override\n    public int compareTo(FraseCelebre otraFrase) {\n\n        // Primero compara por a\u00f1o\n        int comparacionAnio = Integer.compare(this.anio, otraFrase.anio);\n\n        // Se devuelve el valor negado para que el orden sea de m\u00e1s moderna a m\u00e1s antigua\n        if (comparacionAnio != 0)\n            return -comparacionAnio;\n\n        // Segundo criterio: se compara por el nombre del autor\n        return this.autor.compareTo(otraFrase.autor);\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Desarrolle el m\u00e9todo <code>public static String calcularModaDeAutores(ArrayList&lt;FraseCelebre&gt; array)</code>, que recibe como par\u00e1metro un <code>ArrayList</code> de objetos <code>FraseCelebre</code> y calcule la moda de los autores de las frases c\u00e9lebres del <code>ArrayList</code>. La moda se define como el valor que m\u00e1s se repite en un conjunto de datos. En caso de que haya m\u00e1s de un autor tenga la m\u00e1xima frecuencia, el m\u00e9todo puede retornar cualquiera de ellos.</li> </ul> <pre><code>public static void main(String[] args) {\n\n    ArrayList&lt;FraseCelebre&gt; frases = new ArrayList&lt;&gt;();\n\n    frases.add(new FraseCelebre(\n            1942,\n            \"Pablo Picasso\",\n            \"La inspiraci\u00f3n existe, pero tiene que encontrarte trabajando.\"\n    ));\n\n    frases.add(new FraseCelebre(\n            1993,\n            \"Stephen King\",\n            \"El talento es m\u00e1s barato que la sal. Lo que separa al talentoso del exitoso es un mont\u00f3n de trabajo duro.\"\n    ));\n\n    frases.add(new FraseCelebre(\n            1870,\n            \"Thomas A. Edison\",\n            \"El genio es un 1% inspiraci\u00f3n y un 99% transpiraci\u00f3n.\"\n    ));\n\n    frases.add(new FraseCelebre(\n            1963,\n            \"Rosa Parks\",\n            \"Nunca debes tener miedo de lo que haces cuando es lo correcto.\"\n    ));\n\n    frases.add(new FraseCelebre(\n            1963,\n            \"Rosa Parks\",\n            \"Para traer el cambio, debes no tener miedo de tomar el primer paso. Nosotros mostraremos el camino con un acto de coraje.\"\n    ));\n\n    Collections.sort(frases);\n\n    for (FraseCelebre frase : frases) {\n        System.out.println(frase);\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para calcular la moda de los autores\npublic static String calcularModaDeAutores(ArrayList&lt;FraseCelebre&gt; array) {\n\n    Map&lt;String, Integer&gt; frecuenciaAutores = new HashMap&lt;String, Integer&gt;();\n    int maxFrecuencia = 0;\n    String moda = null;\n\n    for (FraseCelebre frase : array) {\n        String autor = frase.getAutor();\n        int nuevaFrecuencia;\n\n        // Verificamos si el mapa ya contiene el autor\n        if (frecuenciaAutores.get(autor) != null) {\n            // Si el autor ya est\u00e1 en el mapa, incrementamos su frecuencia\n            nuevaFrecuencia = frecuenciaAutores.get(autor) + 1;\n        } else {\n            // Si el autor no est\u00e1 en el mapa, su frecuencia es 1\n            nuevaFrecuencia = 1;\n        }\n\n        frecuenciaAutores.put(autor, nuevaFrecuencia);\n\n        // Actualizamos la moda si se supera la frecuencia m\u00e1xima\n        if (nuevaFrecuencia &gt; maxFrecuencia) {\n            maxFrecuencia = nuevaFrecuencia;\n            moda = autor;\n        }\n    }\n\n    return moda;\n}\n</code></pre>"},{"location":"exams/2024/p1/#problema-2","title":"Problema 2","text":"<p>Se disponen las siguientes clases que representan \u00e1rboles de b\u00fasqueda binaria:</p> <pre><code>public class Nodo {\n    int clave;\n    int valor;\n    Nodo iz, der;\n    // ...\n}\n\npublic class BST {\n\n    private Nodo raiz;\n\n    /**\n     * Este m\u00e9todo calcula el n\u00famero de nodos que tienen un valor\n     * igual al par\u00e1metro dado.\n     *\n     * @param unValor El valor para el c\u00e1lculo\n     * @return El n\u00famero de nodos que tengan un valor igual al par\u00e1metro\n     */\n    public int cuentaValores(int unValor) {\n        // ...\n    }\n\n    /**\n     * Este m\u00e9todo calcula el n\u00famero de nodos cuya clave est\u00e1 incluida\n     * en el rango proporcionado por los par\u00e1metros.\n     *\n     * @param minClave N\u00famero menor en el rango\n     * @param maxClave N\u00famero mayor en el rango\n     * @return El n\u00famero de nodos cuya clave est\u00e1 en el rango\n     */\n    public int cuentaClaves(int minClave, int maxClave) {\n        // ...\n    }\n\n    public int m() {\n        return m(raiz);\n    }\n\n    private int m(Nodo nodo) {\n        if (nodo == null)\n            return 0;\n\n        int i = m(nodo.iz);\n        int j = m(nodo.der);\n\n        return 1 + i + j;\n    }\n}\n</code></pre> <p>Nota: En relaci\u00f3n a los m\u00e9todos solicitados en las preguntas (a), (b), y (c):</p> <ul> <li>En la evaluaci\u00f3n de estas preguntas, se tendr\u00e1 en cuenta la complejidad de la soluci\u00f3n elegida. En la calificaci\u00f3n, se valorar\u00e1 la complejidad de la soluci\u00f3n propuesta.</li> <li>No se puede cambiar la signatura de estas clases. Si son necesarios m\u00e9todos auxiliares podr\u00e1n incluirse m\u00e9todos o atributos adicionales, pero habr\u00e1 que mantener su signatura.</li> </ul> <p>Se puede suponer que los \u00e1rboles que soportan estas clases son \u00e1rboles equilibrados. Se pide:</p> <ul> <li>(a) (1,5 puntos) Implemente el m\u00e9todo <code>cuentaValores</code>, seg\u00fan la especificaci\u00f3n descrito en el c\u00f3digo mostrado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuentaValores(int unValor) {\n    return cuentaValores(raiz, unValor, 0);\n}\n\nprivate int cuentaValores(Nodo n, int unValor, int num) {\n    if (n == null)\n        return num;\n\n    if (n.valor == unValor)\n        num++;\n\n    num = cuentaValores(n.iz, unValor, num);\n    num = cuentaValores(n.der, unValor, num);\n\n    return num;\n}\n</code></pre> <ul> <li>(b) (0,5 puntos) Calcule la complejidad de la soluci\u00f3n implementada de la clase <code>cuentaValores</code>. </li> </ul> Mostrar soluci\u00f3n <p>La complejidad de esta implementaci\u00f3n es \\(N\\), donde \\(N\\) es el n\u00famero de elementos del \u00e1rbol. La implementaci\u00f3n recorre el \u00e1rbol con un algoritmo de pre-orden. Hay que recorrer el \u00e1rbol entero porque los valores pueden estar ubicados en cualquier parte del \u00e1rbol.</p> <ul> <li>(c) (2 puntos) Implemente el m\u00e9todo <code>cuentaClaves</code>. <code>cuentaClaves</code> devuelve el n\u00famero de nodos que tiene como clave una clave mayor que <code>minClave</code> y menor que <code>maxClave</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuentaClaves(int minClave, int maxClave) {\n    return cuentaClaves(raiz, minClave, maxClave, 0);\n}\n\nprivate int cuentaClaves(Nodo n, int minClave, int maxClave, int num) {\n    if (n == null)\n        return num;\n\n    if (n.clave &gt; minClave &amp;&amp; n.clave &lt; maxClave) {\n        num++;\n        num = cuentaClaves(n.iz, minClave, maxClave, num);\n        num = cuentaClaves(n.der, minClave, maxClave, num);\n        return num;\n    }\n\n    if (n.clave &lt;= minClave)\n        return cuentaClaves(n.der, minClave, maxClave, num);\n\n    if (n.clave &gt;= maxClave)\n        return cuentaClaves(n.iz, minClave, maxClave, num);\n\n    return num;\n}\n</code></pre> <ul> <li>(d) (1 punto) \u00bfCu\u00e1l es la funcionalidad del m\u00e9todo <code>m</code>? </li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo <code>m</code> es una implementaci\u00f3n del m\u00e9todo <code>size</code> de <code>Diccionario</code>. Esta implementaci\u00f3n cuenta el n\u00famero de elementos del \u00e1rbol, recorriendo todo el \u00e1rbol.</p> <ul> <li>(e) (0,5 puntos) \u00bfCu\u00e1l es la complejidad del m\u00e9todo <code>m</code>? </li> </ul> Mostrar soluci\u00f3n <p>Es un algoritmo de complejidad \\(N\\). Suponiendo que el \u00e1rbol es equilibrado, la funci\u00f3n de recurrencia de el algoritmo que se utiliza es:</p> <p>\\(T(n)=O(1)+T(n-1/2)+T(n-1/2)=O(1)+T(n-1)=O(n)\\)</p> <ul> <li>(f) (0,5 puntos) \u00bfQu\u00e9 tipo de funci\u00f3n es la implementaci\u00f3n del m\u00e9todo <code>m</code>? <ol> <li>Una funci\u00f3n pre-orden</li> <li>Una funci\u00f3n en-orden</li> <li>Una funci\u00f3n post-orden</li> </ol> </li> </ul> Mostrar soluci\u00f3n <p>La implementaci\u00f3n es una funci\u00f3n de post-orden. Primero recorre el sub-\u00e1rbol izquierdo, despu\u00e9s el derecho, y finalmente la funci\u00f3n de visita es sumar l1 y los valores devueltos por el recorrido de la izquierda y la derecha.</p>"},{"location":"exams/2024/p1_ex01/","title":"P1 ex01","text":"<p>Dada la clase <code>FraseCelebre</code>, que se utiliza para almacenar informaci\u00f3n sobre frases c\u00e9lebres, incluyendo el a\u00f1o en que se dijo la frase, el autor de la frase, y la frase en s\u00ed. Se debe desarrollar el c\u00f3digo necesario para que sus objetos puedan ser ordenados. El criterio de ordenaci\u00f3n es, primero se debe ordenar por a\u00f1o de m\u00e1s actual a m\u00e1s antigua y segundo por orden alfab\u00e9tico del nombre del autor.</p> <pre><code>public class FraseCelebre {\n\n    // Atributos de la clase\n    private int anio;        // A\u00f1o en que se dijo la frase\n    private String autor;    // Autor de la frase\n    private String frase;    // La frase c\u00e9lebre\n\n    // Constructor de la clase\n    public FraseCelebre(int anio, String autor, String frase) {\n        this.anio = anio;\n        this.autor = autor;\n        this.frase = frase;\n    }\n\n    // M\u00e9todos getters y setters para los atributos\n    ...\n}\n</code></pre> <p>Se pide:</p> <ul> <li>(a) (2 puntos) Modifique, a\u00f1ade o desarrolle el c\u00f3digo necesario para que tras la ejecuci\u00f3n del siguiente c\u00f3digo de ejemplo se muestre por consola las frases c\u00e9lebres ordenadas con el criterio de ordenaci\u00f3n indicado. </li> </ul> Mostrar soluci\u00f3n <pre><code>public class FraseCelebre implements Comparable&lt;FraseCelebre&gt; {\n\n    // Atributos de la clase, getters y setters\n    ...\n\n    // M\u00e9todo compareTo para comparar objetos FraseCelebre\n    @Override\n    public int compareTo(FraseCelebre otraFrase) {\n\n        // Primero compara por a\u00f1o\n        int comparacionAnio = Integer.compare(this.anio, otraFrase.anio);\n\n        // Se devuelve el valor negado para que el orden sea de m\u00e1s moderna a m\u00e1s antigua\n        if (comparacionAnio != 0)\n            return -comparacionAnio;\n\n        // Segundo criterio: se compara por el nombre del autor\n        return this.autor.compareTo(otraFrase.autor);\n    }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Desarrolle el m\u00e9todo <code>public static String calcularModaDeAutores(ArrayList&lt;FraseCelebre&gt; array)</code>, que recibe como par\u00e1metro un <code>ArrayList</code> de objetos <code>FraseCelebre</code> y calcule la moda de los autores de las frases c\u00e9lebres del <code>ArrayList</code>. La moda se define como el valor que m\u00e1s se repite en un conjunto de datos. En caso de que haya m\u00e1s de un autor tenga la m\u00e1xima frecuencia, el m\u00e9todo puede retornar cualquiera de ellos.</li> </ul> <pre><code>public static void main(String[] args) {\n\n    ArrayList&lt;FraseCelebre&gt; frases = new ArrayList&lt;&gt;();\n\n    frases.add(new FraseCelebre(\n            1942,\n            \"Pablo Picasso\",\n            \"La inspiraci\u00f3n existe, pero tiene que encontrarte trabajando.\"\n    ));\n\n    frases.add(new FraseCelebre(\n            1993,\n            \"Stephen King\",\n            \"El talento es m\u00e1s barato que la sal. Lo que separa al talentoso del exitoso es un mont\u00f3n de trabajo duro.\"\n    ));\n\n    frases.add(new FraseCelebre(\n            1870,\n            \"Thomas A. Edison\",\n            \"El genio es un 1% inspiraci\u00f3n y un 99% transpiraci\u00f3n.\"\n    ));\n\n    frases.add(new FraseCelebre(\n            1963,\n            \"Rosa Parks\",\n            \"Nunca debes tener miedo de lo que haces cuando es lo correcto.\"\n    ));\n\n    frases.add(new FraseCelebre(\n            1963,\n            \"Rosa Parks\",\n            \"Para traer el cambio, debes no tener miedo de tomar el primer paso. Nosotros mostraremos el camino con un acto de coraje.\"\n    ));\n\n    Collections.sort(frases);\n\n    for (FraseCelebre frase : frases) {\n        System.out.println(frase);\n    }\n}\n</code></pre> Mostrar soluci\u00f3n <pre><code>// M\u00e9todo para calcular la moda de los autores\npublic static String calcularModaDeAutores(ArrayList&lt;FraseCelebre&gt; array) {\n\n    Map&lt;String, Integer&gt; frecuenciaAutores = new HashMap&lt;String, Integer&gt;();\n    int maxFrecuencia = 0;\n    String moda = null;\n\n    for (FraseCelebre frase : array) {\n        String autor = frase.getAutor();\n        int nuevaFrecuencia;\n\n        // Verificamos si el mapa ya contiene el autor\n        if (frecuenciaAutores.get(autor) != null) {\n            // Si el autor ya est\u00e1 en el mapa, incrementamos su frecuencia\n            nuevaFrecuencia = frecuenciaAutores.get(autor) + 1;\n        } else {\n            // Si el autor no est\u00e1 en el mapa, su frecuencia es 1\n            nuevaFrecuencia = 1;\n        }\n\n        frecuenciaAutores.put(autor, nuevaFrecuencia);\n\n        // Actualizamos la moda si se supera la frecuencia m\u00e1xima\n        if (nuevaFrecuencia &gt; maxFrecuencia) {\n            maxFrecuencia = nuevaFrecuencia;\n            moda = autor;\n        }\n    }\n\n    return moda;\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2024/p1_ex02/","title":"P1 ex02","text":"<p>Se disponen las siguientes clases que representan \u00e1rboles de b\u00fasqueda binaria:</p> <pre><code>public class Nodo {\n    int clave;\n    int valor;\n    Nodo iz, der;\n    // ...\n}\n\npublic class BST {\n\n    private Nodo raiz;\n\n    /**\n     * Este m\u00e9todo calcula el n\u00famero de nodos que tienen un valor\n     * igual al par\u00e1metro dado.\n     *\n     * @param unValor El valor para el c\u00e1lculo\n     * @return El n\u00famero de nodos que tengan un valor igual al par\u00e1metro\n     */\n    public int cuentaValores(int unValor) {\n        // ...\n    }\n\n    /**\n     * Este m\u00e9todo calcula el n\u00famero de nodos cuya clave est\u00e1 incluida\n     * en el rango proporcionado por los par\u00e1metros.\n     *\n     * @param minClave N\u00famero menor en el rango\n     * @param maxClave N\u00famero mayor en el rango\n     * @return El n\u00famero de nodos cuya clave est\u00e1 en el rango\n     */\n    public int cuentaClaves(int minClave, int maxClave) {\n        // ...\n    }\n\n    public int m() {\n        return m(raiz);\n    }\n\n    private int m(Nodo nodo) {\n        if (nodo == null)\n            return 0;\n\n        int i = m(nodo.iz);\n        int j = m(nodo.der);\n\n        return 1 + i + j;\n    }\n}\n</code></pre> <p>Nota: En relaci\u00f3n a los m\u00e9todos solicitados en las preguntas (a), (b), y (c):</p> <ul> <li>En la evaluaci\u00f3n de estas preguntas, se tendr\u00e1 en cuenta la complejidad de la soluci\u00f3n elegida. En la calificaci\u00f3n, se valorar\u00e1 la complejidad de la soluci\u00f3n propuesta.</li> <li>No se puede cambiar la signatura de estas clases. Si son necesarios m\u00e9todos auxiliares podr\u00e1n incluirse m\u00e9todos o atributos adicionales, pero habr\u00e1 que mantener su signatura.</li> </ul> <p>Se puede suponer que los \u00e1rboles que soportan estas clases son \u00e1rboles equilibrados. Se pide:</p> <ul> <li>(a) (1,5 puntos) Implemente el m\u00e9todo <code>cuentaValores</code>, seg\u00fan la especificaci\u00f3n descrito en el c\u00f3digo mostrado.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuentaValores(int unValor) {\n    return cuentaValores(raiz, unValor, 0);\n}\n\nprivate int cuentaValores(Nodo n, int unValor, int num) {\n    if (n == null)\n        return num;\n\n    if (n.valor == unValor)\n        num++;\n\n    num = cuentaValores(n.iz, unValor, num);\n    num = cuentaValores(n.der, unValor, num);\n\n    return num;\n}\n</code></pre> <ul> <li>(b) (0,5 puntos) Calcule la complejidad de la soluci\u00f3n implementada de la clase <code>cuentaValores</code>. </li> </ul> Mostrar soluci\u00f3n <p>La complejidad de esta implementaci\u00f3n es \\(N\\), donde \\(N\\) es el n\u00famero de elementos del \u00e1rbol. La implementaci\u00f3n recorre el \u00e1rbol con un algoritmo de pre-orden. Hay que recorrer el \u00e1rbol entero porque los valores pueden estar ubicados en cualquier parte del \u00e1rbol.</p> <ul> <li>(c) (2 puntos) Implemente el m\u00e9todo <code>cuentaClaves</code>. <code>cuentaClaves</code> devuelve el n\u00famero de nodos que tiene como clave una clave mayor que <code>minClave</code> y menor que <code>maxClave</code>.</li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuentaClaves(int minClave, int maxClave) {\n    return cuentaClaves(raiz, minClave, maxClave, 0);\n}\n\nprivate int cuentaClaves(Nodo n, int minClave, int maxClave, int num) {\n    if (n == null)\n        return num;\n\n    if (n.clave &gt; minClave &amp;&amp; n.clave &lt; maxClave) {\n        num++;\n        num = cuentaClaves(n.iz, minClave, maxClave, num);\n        num = cuentaClaves(n.der, minClave, maxClave, num);\n        return num;\n    }\n\n    if (n.clave &lt;= minClave)\n        return cuentaClaves(n.der, minClave, maxClave, num);\n\n    if (n.clave &gt;= maxClave)\n        return cuentaClaves(n.iz, minClave, maxClave, num);\n\n    return num;\n}\n</code></pre> <ul> <li>(d) (1 punto) \u00bfCu\u00e1l es la funcionalidad del m\u00e9todo <code>m</code>? </li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo <code>m</code> es una implementaci\u00f3n del m\u00e9todo <code>size</code> de <code>Diccionario</code>. Esta implementaci\u00f3n cuenta el n\u00famero de elementos del \u00e1rbol, recorriendo todo el \u00e1rbol.</p> <ul> <li>(e) (0,5 puntos) \u00bfCu\u00e1l es la complejidad del m\u00e9todo <code>m</code>? </li> </ul> Mostrar soluci\u00f3n <p>Es un algoritmo de complejidad \\(N\\). Suponiendo que el \u00e1rbol es equilibrado, la funci\u00f3n de recurrencia de el algoritmo que se utiliza es:</p> <p>\\(T(n)=O(1)+T(n-1/2)+T(n-1/2)=O(1)+T(n-1)=O(n)\\)</p> <ul> <li>(f) (0,5 puntos) \u00bfQu\u00e9 tipo de funci\u00f3n es la implementaci\u00f3n del m\u00e9todo <code>m</code>? <ol> <li>Una funci\u00f3n pre-orden</li> <li>Una funci\u00f3n en-orden</li> <li>Una funci\u00f3n post-orden</li> </ol> </li> </ul> Mostrar soluci\u00f3n <p>La implementaci\u00f3n es una funci\u00f3n de post-orden. Primero recorre el sub-\u00e1rbol izquierdo, despu\u00e9s el derecho, y finalmente la funci\u00f3n de visita es sumar l1 y los valores devueltos por el recorrido de la izquierda y la derecha.</p>","tags":["complejidad"]},{"location":"exams/2024/p1r/","title":"Examen 2024 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2024/p1r/#problema-1","title":"Problema 1","text":"<p>En esta asignatura se ha trabajado en la representaci\u00f3n de las partidas de ajedrez. Se pide desarrollar los siguientes m\u00e9todos:</p> <ul> <li>(a) (1,5 puntos) <code>CompararTableros</code>: <pre><code>public boolean compararPiezas(Pieza p1, Pieza p2)\n</code></pre></li> </ul> <p>Este m\u00e9todo comprueba si dos piezas coinciden: el mismo tipo y bando</p> Parameters <code>p1</code> - primera pieza para la comparaci\u00f3n <code>p2</code> - segundo pieza para la comparaci\u00f3n Returnso devuelve <code>true</code> si las piezas coinciden Mostrar soluci\u00f3n <pre><code>public boolean compararPiezas(Pieza p1, Pieza p2) {\n    if (p1 == null &amp;&amp; p2 == null) {\n        return true;\n    }\n\n    if (p1 != null &amp;&amp; p2 != null) {\n        if (p1.getTipo() == p2.getTipo()) {\n            if (p1.getBando() == p2.getBando()) {\n                return true;\n            }\n        }\n    }\n\n    // Una de las piezas es null y la otra no\n    return false;\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) <code>compararTableros</code>:</li> </ul> <pre><code>public boolean compararTableros(Tablero t1, Tablero t2)\n</code></pre> <p>Este m\u00e9todo comprueba si dos tableros coinciden: tienen que tener el mismo n\u00famero de piezas y las mismas piezas en todas las posiciones.</p> Parameters <code>t1</code> - primer tablero para la comparaci\u00f3n <code>t2</code> - segundo tablero para la comparaci\u00f3n Returns Devuelve <code>true</code> si los tableros coinciden Mostrar soluci\u00f3n <pre><code>public boolean compararTableros(Tablero t1, Tablero t2) {\n    Pieza[][] p1 = t1.getTablero();\n    Pieza[][] p2 = t2.getTablero();\n\n    for (int i = 0; i &lt; 8; i++) {\n        for (int j = 0; j &lt; 8; j++) {\n            if (!compararPiezas(p1[i][j], p2[i][j])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n</code></pre> <ul> <li>(c) (2 puntos) <code>compararPartidas</code> <pre><code>public boolean compararPartidas(Partida p1, Partida p2)\n</code></pre></li> </ul> <p>Este m\u00e9todo comprueba si dos partidas coinciden: tienen el mismo n\u00famero de tableros, el mismo orden y los tableros coinciden</p> Parameters <code>p1</code> - primera partida para la comparaci\u00f3n <code>p2</code> - segunda partida para la comparaci\u00f3n Returns Devuelve <code>true</code> si las partidas coinciden Mostrar soluci\u00f3n <pre><code>public boolean compararPartidas(Partida p1, Partida p2) {\n    if (p1.turnos.size() != p2.turnos.size()) {\n        return false;\n    }\n\n    for (int i = 0; i &lt; p1.turnos.size(); i++) {\n        if (!compararTableros(p1.turnos.get(i), p2.turnos.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n</code></pre>"},{"location":"exams/2024/p1r/#problema-2","title":"Problema 2","text":"<p>Se desea implementar una estructura capaz de almacenar direcciones IP \u00fanicas y un algoritmo para consultar las direcciones almacenadas de manera eficiente. Esta estructura se basar\u00e1 en un \u00e1rbol binario de b\u00fasqueda (BST). Dado que la aplicaci\u00f3n que usa esta estructura ser\u00e1 desplegada en un router empotrado, se decide almacenar el \u00e1rbol en forma de array de tama\u00f1o fijo. Para ello, se procede de la siguiente manera. La posici\u00f3n <code>0</code> del array contendr\u00e1 el nodo ra\u00edz. Dado un nodo en la posici\u00f3n <code>i</code>, su hijo izquierdo se encontrar\u00e1 en la posici\u00f3n <code>2*i+1</code>, y su hijo derecho en la posici\u00f3n <code>2*i+2</code>. Las posiciones con valor null corresponden a nodos que no existen en el BST. El siguiente es un ejemplo del estado del comienzo del array tras insertar 5 direcciones IP:</p> <p></p> <p>Se proporciona una clase <code>IP</code>, que representa direcciones IPv4. Esta clase implementa <code>Comparable</code> de manera adecuada y tiene un m\u00e9todo <code>toString()</code> que devuelve la representaci\u00f3n en texto de la IP. Adem\u00e1s, se dispone del esqueleto de la clase, llamada <code>BSTSet</code>.</p> <pre><code>public class BSTSet {\n    private IP[] array;\n\n    public BSTSet() {\n        this.array = new IP[1023];\n    }\n\n    /**\n     * Imprime todas las direcciones contenidas en el \u00e1rbol, en\n     * orden ascendente.\n     */\n    public void imprimir() {\n        ...\n    }\n\n    /**\n     * Devuelve true si la direcci\u00f3n especificada est\u00e1 en el \u00e1rbol.\n     * Complejidad: O(log(n)) con el tama\u00f1o del array.\n     *\n     * @param ip direcci\u00f3n a encontrar\n     * @return true si la direcci\u00f3n ha sido encontrada\n     */\n    public boolean contains(IP ip) {\n        ...\n    }\n\n    ...\n}\n</code></pre> <p>Se pide:</p> <ul> <li>(a) (1.5 puntos) Desarrolle el m\u00e9todo <code>imprimir()</code>, que muestre por pantalla todas las direcciones IP almacenadas en el BST en orden ascendente.</li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * Imprime todas las direcciones contenidas en el \u00e1rbol, en orden\n * ascendente.\n */\npublic void imprimir() {\n    imprimir(0);\n}\n\nprivate void imprimir(int pos) {\n    if (pos &gt;= this.array.length || this.array[pos] == null) {\n        return;\n    }\n\n    imprimir(pos * 2 + 1);\n    System.out.println(this.array[pos]);\n    imprimir(pos * 2 + 2);\n}\n</code></pre> <ul> <li>(b) (2.5 puntos) Desarrolle el m\u00e9todo <code>contains(IP ip)</code>. Recuerde que el m\u00e9todo debe tener un orden de complejidad \\(O(log(n))\\), siendo \\(n\\) el tama\u00f1o del array.</li> </ul> Mostrar soluci\u00f3n <pre><code>public boolean contains(IP ip) {\n    int pos = 0;\n\n    while (pos &lt; this.array.length) {\n        IP actual = this.array[pos];\n\n        if (actual == null) {\n            return false;\n        }\n\n        int cmp = ip.cmp(actual);\n\n        if (cmp == 0) {\n            return true;\n        } else if (cmp &lt; 0) {\n            pos = pos * 2 + 1;\n        } else {\n            pos = pos * 2 + 2;\n        }\n    }\n\n    return false;\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfCu\u00e1l es la ocupaci\u00f3n m\u00e1xima del array (n\u00famero m\u00e1ximo de direcciones IP que podr\u00e1 almacenar) en esta implementaci\u00f3n de BST si el nodo ra\u00edz contiene la direcci\u00f3n 0.0.0.1? Para una direcci\u00f3n IP del tipo A.B.C.D (con A, B, C y D entre 0 y 255), la implementaci\u00f3n de <code>Comparable</code> compara los elementos A, B, C y D individualmente y en orden. Por ejemplo, la direcci\u00f3n 10.0.0.2 es menor que 10.0.0.3 y 10.0.1.1, pero mayor que 10.0.0.1.</li> </ul> Mostrar soluci\u00f3n <p>Sabemos que al menos habr\u00e1 1 IP (la ra\u00edz). De los 1022 huecos restantes, dado que es un BST, supongamos que los huecos se dividen de forma igualitaria entre mayores (511) y menores (511). S\u00f3lo hay una posible posici\u00f3n menor (0.0.0.0), el resto (510) estar\u00e1n vac\u00edas. Por tanto, dado que las IPs se insertan en el orden adecuado, la ocupaci\u00f3n ser\u00eda: 1 + 511 + 1 = 513 IPs.</p> <p>Ahora bien, nuestra suposici\u00f3n s\u00f3lo se cumple si hay suficientes huecos para un \u00e1rbol sim\u00e9trico. Veamos c\u00f3mo crece el n\u00famero de posiciones en funci\u00f3n de la profundidad:</p> <ul> <li>A profundidad 0 hay 1 hueco y 1 posici\u00f3n.</li> <li>A profundidad 1 habr\u00e1 2 huecos. Con un total de 1 + 2 = 3 posiciones.</li> <li>A profundidad 2 habr\u00e1 4 huecos. Con un total de 3 + 4 = 7 posiciones.</li> <li>A profundidad 3 habr\u00e1 8 huecos. Con un total de 7 + 8 = 15 posiciones.</li> <li>A profundidad \\(k\\) habr\u00e1 \\(2\u02c6(k+1)-1\\) posiciones. Por lo que para \\(n\\) posiciones: \\(n = 2(k+1)-1 \\Rightarrow k = log_2(n+1) - 1\\)</li> </ul> <p>Por tanto, con 1023 posiciones habr\u00eda espacio para 9 niveles completos de \u00e1rbol binario.</p> <p>Tambi\u00e9n podr\u00edamos concluir que, dado que cada nivel se rellena \u201cde izquierda a derecha\u201d (las posiciones m\u00e1s bajas son valores menores para cada nivel), la ocupaci\u00f3n m\u00e1xima en este caso ser\u00eda igual hasta 1023+512=1535 huecos.</p>"},{"location":"exams/2024/p1r_ex01/","title":"P1r ex01","text":"<p>En esta asignatura se ha trabajado en la representaci\u00f3n de las partidas de ajedrez. Se pide desarrollar los siguientes m\u00e9todos:</p> <ul> <li>(a) (1,5 puntos) <code>CompararTableros</code>: <pre><code>public boolean compararPiezas(Pieza p1, Pieza p2)\n</code></pre></li> </ul> <p>Este m\u00e9todo comprueba si dos piezas coinciden: el mismo tipo y bando</p> Parameters <code>p1</code> - primera pieza para la comparaci\u00f3n <code>p2</code> - segundo pieza para la comparaci\u00f3n Returnso devuelve <code>true</code> si las piezas coinciden Mostrar soluci\u00f3n <pre><code>public boolean compararPiezas(Pieza p1, Pieza p2) {\n    if (p1 == null &amp;&amp; p2 == null) {\n        return true;\n    }\n\n    if (p1 != null &amp;&amp; p2 != null) {\n        if (p1.getTipo() == p2.getTipo()) {\n            if (p1.getBando() == p2.getBando()) {\n                return true;\n            }\n        }\n    }\n\n    // Una de las piezas es null y la otra no\n    return false;\n}\n</code></pre> <ul> <li>(b) (1,5 puntos) <code>compararTableros</code>:</li> </ul> <pre><code>public boolean compararTableros(Tablero t1, Tablero t2)\n</code></pre> <p>Este m\u00e9todo comprueba si dos tableros coinciden: tienen que tener el mismo n\u00famero de piezas y las mismas piezas en todas las posiciones.</p> Parameters <code>t1</code> - primer tablero para la comparaci\u00f3n <code>t2</code> - segundo tablero para la comparaci\u00f3n Returns Devuelve <code>true</code> si los tableros coinciden Mostrar soluci\u00f3n <pre><code>public boolean compararTableros(Tablero t1, Tablero t2) {\n    Pieza[][] p1 = t1.getTablero();\n    Pieza[][] p2 = t2.getTablero();\n\n    for (int i = 0; i &lt; 8; i++) {\n        for (int j = 0; j &lt; 8; j++) {\n            if (!compararPiezas(p1[i][j], p2[i][j])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n</code></pre> <ul> <li>(c) (2 puntos) <code>compararPartidas</code> <pre><code>public boolean compararPartidas(Partida p1, Partida p2)\n</code></pre></li> </ul> <p>Este m\u00e9todo comprueba si dos partidas coinciden: tienen el mismo n\u00famero de tableros, el mismo orden y los tableros coinciden</p> Parameters <code>p1</code> - primera partida para la comparaci\u00f3n <code>p2</code> - segunda partida para la comparaci\u00f3n Returns Devuelve <code>true</code> si las partidas coinciden Mostrar soluci\u00f3n <pre><code>public boolean compararPartidas(Partida p1, Partida p2) {\n    if (p1.turnos.size() != p2.turnos.size()) {\n        return false;\n    }\n\n    for (int i = 0; i &lt; p1.turnos.size(); i++) {\n        if (!compararTableros(p1.turnos.get(i), p2.turnos.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2024/p1r_ex02/","title":"P1r ex02","text":"<p>Se desea implementar una estructura capaz de almacenar direcciones IP \u00fanicas y un algoritmo para consultar las direcciones almacenadas de manera eficiente. Esta estructura se basar\u00e1 en un \u00e1rbol binario de b\u00fasqueda (BST). Dado que la aplicaci\u00f3n que usa esta estructura ser\u00e1 desplegada en un router empotrado, se decide almacenar el \u00e1rbol en forma de array de tama\u00f1o fijo. Para ello, se procede de la siguiente manera. La posici\u00f3n <code>0</code> del array contendr\u00e1 el nodo ra\u00edz. Dado un nodo en la posici\u00f3n <code>i</code>, su hijo izquierdo se encontrar\u00e1 en la posici\u00f3n <code>2*i+1</code>, y su hijo derecho en la posici\u00f3n <code>2*i+2</code>. Las posiciones con valor null corresponden a nodos que no existen en el BST. El siguiente es un ejemplo del estado del comienzo del array tras insertar 5 direcciones IP:</p> <p></p> <p>Se proporciona una clase <code>IP</code>, que representa direcciones IPv4. Esta clase implementa <code>Comparable</code> de manera adecuada y tiene un m\u00e9todo <code>toString()</code> que devuelve la representaci\u00f3n en texto de la IP. Adem\u00e1s, se dispone del esqueleto de la clase, llamada <code>BSTSet</code>.</p> <pre><code>public class BSTSet {\n    private IP[] array;\n\n    public BSTSet() {\n        this.array = new IP[1023];\n    }\n\n    /**\n     * Imprime todas las direcciones contenidas en el \u00e1rbol, en\n     * orden ascendente.\n     */\n    public void imprimir() {\n        ...\n    }\n\n    /**\n     * Devuelve true si la direcci\u00f3n especificada est\u00e1 en el \u00e1rbol.\n     * Complejidad: O(log(n)) con el tama\u00f1o del array.\n     *\n     * @param ip direcci\u00f3n a encontrar\n     * @return true si la direcci\u00f3n ha sido encontrada\n     */\n    public boolean contains(IP ip) {\n        ...\n    }\n\n    ...\n}\n</code></pre> <p>Se pide:</p> <ul> <li>(a) (1.5 puntos) Desarrolle el m\u00e9todo <code>imprimir()</code>, que muestre por pantalla todas las direcciones IP almacenadas en el BST en orden ascendente.</li> </ul> Mostrar soluci\u00f3n <pre><code>/**\n * Imprime todas las direcciones contenidas en el \u00e1rbol, en orden\n * ascendente.\n */\npublic void imprimir() {\n    imprimir(0);\n}\n\nprivate void imprimir(int pos) {\n    if (pos &gt;= this.array.length || this.array[pos] == null) {\n        return;\n    }\n\n    imprimir(pos * 2 + 1);\n    System.out.println(this.array[pos]);\n    imprimir(pos * 2 + 2);\n}\n</code></pre> <ul> <li>(b) (2.5 puntos) Desarrolle el m\u00e9todo <code>contains(IP ip)</code>. Recuerde que el m\u00e9todo debe tener un orden de complejidad \\(O(log(n))\\), siendo \\(n\\) el tama\u00f1o del array.</li> </ul> Mostrar soluci\u00f3n <pre><code>public boolean contains(IP ip) {\n    int pos = 0;\n\n    while (pos &lt; this.array.length) {\n        IP actual = this.array[pos];\n\n        if (actual == null) {\n            return false;\n        }\n\n        int cmp = ip.cmp(actual);\n\n        if (cmp == 0) {\n            return true;\n        } else if (cmp &lt; 0) {\n            pos = pos * 2 + 1;\n        } else {\n            pos = pos * 2 + 2;\n        }\n    }\n\n    return false;\n}\n</code></pre> <ul> <li>(c) (1 punto) \u00bfCu\u00e1l es la ocupaci\u00f3n m\u00e1xima del array (n\u00famero m\u00e1ximo de direcciones IP que podr\u00e1 almacenar) en esta implementaci\u00f3n de BST si el nodo ra\u00edz contiene la direcci\u00f3n 0.0.0.1? Para una direcci\u00f3n IP del tipo A.B.C.D (con A, B, C y D entre 0 y 255), la implementaci\u00f3n de <code>Comparable</code> compara los elementos A, B, C y D individualmente y en orden. Por ejemplo, la direcci\u00f3n 10.0.0.2 es menor que 10.0.0.3 y 10.0.1.1, pero mayor que 10.0.0.1.</li> </ul> Mostrar soluci\u00f3n <p>Sabemos que al menos habr\u00e1 1 IP (la ra\u00edz). De los 1022 huecos restantes, dado que es un BST, supongamos que los huecos se dividen de forma igualitaria entre mayores (511) y menores (511). S\u00f3lo hay una posible posici\u00f3n menor (0.0.0.0), el resto (510) estar\u00e1n vac\u00edas. Por tanto, dado que las IPs se insertan en el orden adecuado, la ocupaci\u00f3n ser\u00eda: 1 + 511 + 1 = 513 IPs.</p> <p>Ahora bien, nuestra suposici\u00f3n s\u00f3lo se cumple si hay suficientes huecos para un \u00e1rbol sim\u00e9trico. Veamos c\u00f3mo crece el n\u00famero de posiciones en funci\u00f3n de la profundidad:</p> <ul> <li>A profundidad 0 hay 1 hueco y 1 posici\u00f3n.</li> <li>A profundidad 1 habr\u00e1 2 huecos. Con un total de 1 + 2 = 3 posiciones.</li> <li>A profundidad 2 habr\u00e1 4 huecos. Con un total de 3 + 4 = 7 posiciones.</li> <li>A profundidad 3 habr\u00e1 8 huecos. Con un total de 7 + 8 = 15 posiciones.</li> <li>A profundidad \\(k\\) habr\u00e1 \\(2\u02c6(k+1)-1\\) posiciones. Por lo que para \\(n\\) posiciones: \\(n = 2(k+1)-1 \\Rightarrow k = log_2(n+1) - 1\\)</li> </ul> <p>Por tanto, con 1023 posiciones habr\u00eda espacio para 9 niveles completos de \u00e1rbol binario.</p> <p>Tambi\u00e9n podr\u00edamos concluir que, dado que cada nivel se rellena \u201cde izquierda a derecha\u201d (las posiciones m\u00e1s bajas son valores menores para cada nivel), la ocupaci\u00f3n m\u00e1xima en este caso ser\u00eda igual hasta 1023+512=1535 huecos.</p>","tags":["complejidad"]},{"location":"exams/2024/p2/","title":"Examen 2024 \u2014 Parcial 2","text":""},{"location":"exams/2024/p2/#problema-1","title":"Problema 1","text":"<p>El examen consiste en implementar un sistema concurrente que simule el funcionamiento de un refugio de gatos.</p> <p>En este refugio, los gatos ser\u00e1n representados por hebras que pueden realizar diferentes actividades (dormir, comer, jugar) y un alimentador que se encarga de a\u00f1adir comida a la sala de alimentaci\u00f3n. Cada gato solo puede hacer una acci\u00f3n a la vez y elige su acci\u00f3n de forma aleatoria. La acci\u00f3n de dormir se realiza simplemente haciendo un sleep().</p> <p>Requisitos:</p> <p>Sala de Alimentaci\u00f3n:     - Es un monitor donde los gatos deben entrar en orden de llegada.     - La sala tiene un contador de cantidad de comida. Puede haber una cantidad infinita de comida.     - Los gatos pueden entrar si hay huecos libres, siguiendo el orden de llegada.     - La sala puede albergar hasta un n\u00famero espec\u00edfico de gatos, determinado por el constructor del monitor.     - Un gato sale de la sala de alimentaci\u00f3n despu\u00e9s de comer una cantidad de comida aleatoria entre 1 y 10, que se restar\u00e1 del contador de comida.     - Si la sala est\u00e1 llena, el gato se queda esperando en la cola.</p> <p>Sala de Juegos:     - Es otro monitor donde los gatos pueden entrar si hay huecos libres.     - No es necesario que los gatos entren en orden de llegada.     - Si la sala est\u00e1 llena, el gato se quedar\u00e1 esperando.</p> <p>Comportamiento de la hebra Alimentador:     - Es una hebra que a\u00f1ade comida a la sala de alimentaci\u00f3n.     - A\u00f1ade una cantidad de comida aleatoria.</p> <p>Se ofrece el c\u00f3digo del m\u00e9todo run() de la hebra Alimentador y un ejemplo del m\u00e9todo main(). Diagrama de clases:</p> <p></p> <p>Ejemplo de main: <pre><code>public static void main(String[] args) {\n    SalaAlimentacion salaAlimentacion = new SalaAlimentacion(4, 50);\n    SalaJuegos salaJuegos = new SalaJuegos(3);\n    Alimentador alimentador = new Alimentador(salaAlimentacion);\n    alimentador.start();\n\n    ArrayList&lt;Gato&gt; gatos = new ArrayList&lt;&gt;();\n    for (int i = 1; i &lt;= 100; i++) {\n        Gato gato = new Gato(\"Gato-\" + i, salaAlimentacion, salaJuegos);\n        gatos.add(gato);\n        gato.start();\n    }\n}\n</code></pre></p> <p>Ejemplo de run de la clase Alimentador: <pre><code>public void run() {\n    Random rand = new Random();\n    try {\n        while (true) {\n            int cantidadComida = rand.nextInt(10);\n            salaAlimentacion.a\u00f1adirComida(cantidadComida);\n            Thread.sleep(rand.nextInt(4000));\n        }\n    } catch (InterruptedException ignored) {\n    }\n}\n</code></pre></p> <p>SE PIDE: Desarrolla el c\u00f3digo del monitor SalaAlimentaci\u00f3n: - (a) (1,5 puntos) Implementa el m\u00e9todo public synchronized void entrar(Gato gato) throws InterruptedException</p> <ul> <li> <p>(b) (1,5 punto) Implementa el m\u00e9todo public synchronized void comerYSalir(Gato gato, int cantidadComida) throws InterruptedException</p> </li> <li> <p>(c) (1 punto) Implementa el m\u00e9todo public synchronized void a\u00f1adirComida(int cantidad) throws InterruptedException</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>public synchronized void entrar(Gato gato) throws InterruptedException {\n    while (this.gatosEnSala.size() &gt;= this.capacidad || \n           (this.colaEspera.size() &gt; 0 &amp;&amp; this.colaEspera.get(0) != gato)) {\n        if (!this.colaEspera.contains(gato)) {\n            this.colaEspera.add(gato);\n            System.out.println(gato.getName() + \" est\u00e1 esperando para entrar a la sala de alimentaci\u00f3n.\");\n        }\n        wait();\n    }\n\n    if (this.colaEspera.contains(gato)) {\n        this.colaEspera.remove(gato); // Quitar el gato de la cola de espera cuando se despierte\n    }\n\n    this.gatosEnSala.add(gato);\n    System.out.println(gato.getName() + \" entr\u00f3 a la sala de alimentaci\u00f3n.\");\n    notifyAll();\n}\n\npublic synchronized void comerYSalir(Gato gato, int cantidadComida) throws InterruptedException {\n    while (!this.gatosEnSala.contains(gato) || this.cantidadComida &lt; cantidadComida) {\n        wait();\n    }\n\n    this.cantidadComida -= cantidadComida;\n    this.gatosEnSala.remove(gato);\n    System.out.println(gato.getName() + \" comi\u00f3 \" + cantidadComida +\n                       \" unidades de comida. Comida restante: \" + this.cantidadComida);\n    notifyAll();\n}\n\npublic synchronized void a\u00f1adirComida(int cantidad) throws InterruptedException {\n    this.cantidadComida += cantidad;\n    System.out.println(\"Alimentador a\u00f1adi\u00f3 \" + cantidad +\n                       \" unidades de comida. Comida disponible: \" + this.cantidadComida);\n    notifyAll();\n}\n</code></pre> <p>Desarrolla el c\u00f3digo del monitor SalaJuegos:</p> <ul> <li> <p>(d) (0,5 puntos) Implementa el m\u00e9todo public synchronized void entrar() throws InterruptedException</p> </li> <li> <p>(e) (0,5 puntos) Implementa el m\u00e9todo public synchronized void salir() throws InterruptedException</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>public synchronized void entrar() throws InterruptedException {\n    while (this.gatosDentro &gt;= this.capacidadGatos) {\n        wait();\n    }\n    this.gatosDentro++;\n    System.out.println(\"Entr\u00f3 un gato a la sala de juegos. Gatos dentro: \" + gatosDentro);\n}\n\npublic synchronized void salir() throws InterruptedException {\n    if (this.gatosDentro &gt; 0) {\n        this.gatosDentro--;\n    }\n    System.out.println(\"Sali\u00f3 un gato de la sala de juegos. Gatos dentro: \" + gatosDentro);\n    notifyAll();\n}\n</code></pre>"},{"location":"exams/2024/p2/#problema-2","title":"Problema 2","text":"<p>Durante la construcci\u00f3n de una nueva ciudad se est\u00e1 planificando el despliegue de la red de Internet. Para extender la red se han empezado a instalar cables de red entre las casas, haciendo que, si una casa tiene conexi\u00f3n a Internet, todas las casas conectadas a ella tambi\u00e9n la tengan. La salida de la red de la ciudad se realiza con cables de fibra \u00f3ptica que se conectan a una de las casas d\u00e1ndole acceso a Internet.</p> <p>Este escenario modela como un grafo no dirigido, donde los nodos son las casas y las aristas son los cables de red. En el siguiente diagrama se puede ver como se han dise\u00f1ado las clases que modelan el grafo adjunto.</p> <p></p> <ul> <li>(a) (2 puntos) Por problemas de presupuesto, inicialmente solo se contar\u00e1 con 1 cable de fibra \u00f3ptica para conectar la red de Internet a la ciudad. Este cable se debe conectar de manera que la cantidad de casas que tengan acceso a Internet sea la m\u00e1xima posible. Implemente el m\u00e9todo casasConectadas(Nodo nodoConectado) en la clase GrafoCiudad que retorne la cantidad de casas que tendr\u00edan acceso a Internet si se conectara el cable de fibra \u00f3ptica al nodo nodoConectado.</li> </ul> Mostrar soluci\u00f3n <p>Opci\u00f3n BST: <pre><code>public int casasConectadas(Nodo nodoConectado) {\n        Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n        List&lt;Nodo&gt; aVisitar = new ArrayList&lt;&gt;();\n\n        aVisitar.add(nodoConectado);\n        visitados.add(nodoConectado);\n\n        while (!aVisitar.isEmpty()) {\n            Nodo actual = aVisitar.remove(0);\n            for (Arista arista : actual.cablesConectados) {\n                Nodo vecino = arista.getOtroNodo(actual);\n                if (!visitados.contains(vecino)) {\n                    visitados.add(vecino);\n                    aVisitar.add(vecino);\n                }\n            }\n        }\n\n        return visitados.size();\n    }\n    ```\n\n    Opci\u00f3n Dijkstra\n    ```java\npublic int casasConectadasDijkstra(Nodo nodoConectado) {\n    HashMap&lt;Nodo, Double&gt; distancias = dijkstra(nodoConectado);\n    return distancias.size();\n}\n\nprivate void relax(Arista arista, Nodo nodoConectado, HashMap&lt;Nodo, Double&gt; distancias,\n                   List&lt;Nodo&gt; aVisitar) {\n    Nodo vecino = arista.getOtroNodo(nodoConectado);\n    double nuevaDistancia = distancias.get(nodoConectado) + arista.longitud;\n\n    if (!distancias.containsKey(vecino) || distancias.get(vecino) &gt; nuevaDistancia) {\n        distancias.put(vecino, nuevaDistancia);\n        if (!aVisitar.contains(vecino))\n            aVisitar.add(vecino);\n    }\n}\n\nprivate Nodo extraerMenor(List&lt;Nodo&gt; aVisitar, HashMap&lt;Nodo, Double&gt; distancias) {\n    Nodo menor = aVisitar.get(0);\n    for (Nodo nodo : aVisitar) {\n        if (distancias.get(nodo) &lt; distancias.get(menor)) {\n            menor = nodo;\n        }\n    }\n    aVisitar.remove(menor);\n    return menor;\n}\n\nprivate HashMap&lt;Nodo, Double&gt; dijkstra(Nodo nodoConectado) {\n    Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n    HashMap&lt;Nodo, Double&gt; distancias = new HashMap&lt;&gt;();\n    List&lt;Nodo&gt; aVisitar = new ArrayList&lt;&gt;();\n\n    aVisitar.add(nodoConectado);\n    distancias.put(nodoConectado, 0.0);\n\n    while (!aVisitar.isEmpty()) {\n        Nodo actual = extraerMenor(aVisitar, distancias);\n        visitados.add(actual);\n\n        for (Arista arista : actual.cablesConectados) {\n            if (visitados.contains(arista.getOtroNodo(actual))) {\n                continue;\n            }\n            relax(arista, actual, distancias, aVisitar);\n        }\n    }\n\n    return distancias;\n}\n</code></pre></p> <ul> <li>(b) (3 puntos) Desafortunadamente, el cable utilizado dentro de la ciudad no es de la mejor calidad y se ha detectado que las casas m\u00e1s alejadas de la casa conectada a la fibra \u00f3ptica tienen problemas de conexi\u00f3n. El umbral de distancia para que una casa tenga problemas de conexi\u00f3n es de 1000 metros, guardado en la constante DISTANCIA_MAXIMA en la clase <code>GrafoCiudad</code>. Implemente el m\u00e9todo <code>casasConProblemasConexion(Nodo nodoConectado)</code> en la clase <code>GrafoCiudad</code> que retorne la cantidad de casas que tendr\u00edan problemas de conexi\u00f3n si se conectara el cable de fibra \u00f3ptica al nodo <code>nodoConectado</code>. Nota: las casas con problemas de conexi\u00f3n deben tener acceso a Internet.</li> </ul> Mostrar soluci\u00f3n <p>Opci\u00f3n BST: <pre><code>public int casasConProblemasConexion(Nodo nodoConectado) {\n    List&lt;Nodo&gt; aVisitar = new ArrayList&lt;&gt;();\n    HashMap&lt;Nodo, Double&gt; distancias = new HashMap&lt;&gt;();\n\n    aVisitar.add(nodoConectado);\n    distancias.put(nodoConectado, 0.0);\n\n    while (!aVisitar.isEmpty()) {\n        Nodo actual = aVisitar.remove(0);\n\n        for (Arista arista : actual.cablesConectados) {\n            Nodo vecino = arista.getOtroNodo(actual);\n            double nuevaDistancia = distancias.get(actual) + arista.longitud;\n\n            if (!distancias.containsKey(vecino) || distancias.get(vecino) &gt; nuevaDistancia) {\n                distancias.put(vecino, nuevaDistancia);\n                aVisitar.add(vecino);\n            }\n        }\n    }\n\n    int contador = 0;\n    for (Nodo casa : distancias.keySet()) {\n        if (distancias.get(casa) &gt; DISTANCIA_MAXIMA) {\n            contador++;\n        }\n    }\n\n    return contador;\n}\n</code></pre></p> <p>Opci\u00f3n Dijkstra: <pre><code>public int casasConProblemasConexionDijkstra(Nodo nodoConectado) {\n    HashMap&lt;Nodo, Double&gt; distancias = dijkstra(nodoConectado);\n    int contador = 0;\n\n    for (Nodo casa : distancias.keySet()) {\n        if (distancias.get(casa) &gt; DISTANCIA_MAXIMA) {\n            contador++;\n        }\n    }\n\n    return contador;\n}\n</code></pre></p>"},{"location":"exams/2024/p2_ex01/","title":"P2 ex01","text":"<p>El examen consiste en implementar un sistema concurrente que simule el funcionamiento de un refugio de gatos.</p> <p>En este refugio, los gatos ser\u00e1n representados por hebras que pueden realizar diferentes actividades (dormir, comer, jugar) y un alimentador que se encarga de a\u00f1adir comida a la sala de alimentaci\u00f3n. Cada gato solo puede hacer una acci\u00f3n a la vez y elige su acci\u00f3n de forma aleatoria. La acci\u00f3n de dormir se realiza simplemente haciendo un sleep().</p> <p>Requisitos:</p> <p>Sala de Alimentaci\u00f3n:     - Es un monitor donde los gatos deben entrar en orden de llegada.     - La sala tiene un contador de cantidad de comida. Puede haber una cantidad infinita de comida.     - Los gatos pueden entrar si hay huecos libres, siguiendo el orden de llegada.     - La sala puede albergar hasta un n\u00famero espec\u00edfico de gatos, determinado por el constructor del monitor.     - Un gato sale de la sala de alimentaci\u00f3n despu\u00e9s de comer una cantidad de comida aleatoria entre 1 y 10, que se restar\u00e1 del contador de comida.     - Si la sala est\u00e1 llena, el gato se queda esperando en la cola.</p> <p>Sala de Juegos:     - Es otro monitor donde los gatos pueden entrar si hay huecos libres.     - No es necesario que los gatos entren en orden de llegada.     - Si la sala est\u00e1 llena, el gato se quedar\u00e1 esperando.</p> <p>Comportamiento de la hebra Alimentador:     - Es una hebra que a\u00f1ade comida a la sala de alimentaci\u00f3n.     - A\u00f1ade una cantidad de comida aleatoria.</p> <p>Se ofrece el c\u00f3digo del m\u00e9todo run() de la hebra Alimentador y un ejemplo del m\u00e9todo main(). Diagrama de clases:</p> <p></p> <p>Ejemplo de main: <pre><code>public static void main(String[] args) {\n    SalaAlimentacion salaAlimentacion = new SalaAlimentacion(4, 50);\n    SalaJuegos salaJuegos = new SalaJuegos(3);\n    Alimentador alimentador = new Alimentador(salaAlimentacion);\n    alimentador.start();\n\n    ArrayList&lt;Gato&gt; gatos = new ArrayList&lt;&gt;();\n    for (int i = 1; i &lt;= 100; i++) {\n        Gato gato = new Gato(\"Gato-\" + i, salaAlimentacion, salaJuegos);\n        gatos.add(gato);\n        gato.start();\n    }\n}\n</code></pre></p> <p>Ejemplo de run de la clase Alimentador: <pre><code>public void run() {\n    Random rand = new Random();\n    try {\n        while (true) {\n            int cantidadComida = rand.nextInt(10);\n            salaAlimentacion.a\u00f1adirComida(cantidadComida);\n            Thread.sleep(rand.nextInt(4000));\n        }\n    } catch (InterruptedException ignored) {\n    }\n}\n</code></pre></p> <p>SE PIDE: Desarrolla el c\u00f3digo del monitor SalaAlimentaci\u00f3n: - (a) (1,5 puntos) Implementa el m\u00e9todo public synchronized void entrar(Gato gato) throws InterruptedException</p> <ul> <li> <p>(b) (1,5 punto) Implementa el m\u00e9todo public synchronized void comerYSalir(Gato gato, int cantidadComida) throws InterruptedException</p> </li> <li> <p>(c) (1 punto) Implementa el m\u00e9todo public synchronized void a\u00f1adirComida(int cantidad) throws InterruptedException</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>public synchronized void entrar(Gato gato) throws InterruptedException {\n    while (this.gatosEnSala.size() &gt;= this.capacidad || \n           (this.colaEspera.size() &gt; 0 &amp;&amp; this.colaEspera.get(0) != gato)) {\n        if (!this.colaEspera.contains(gato)) {\n            this.colaEspera.add(gato);\n            System.out.println(gato.getName() + \" est\u00e1 esperando para entrar a la sala de alimentaci\u00f3n.\");\n        }\n        wait();\n    }\n\n    if (this.colaEspera.contains(gato)) {\n        this.colaEspera.remove(gato); // Quitar el gato de la cola de espera cuando se despierte\n    }\n\n    this.gatosEnSala.add(gato);\n    System.out.println(gato.getName() + \" entr\u00f3 a la sala de alimentaci\u00f3n.\");\n    notifyAll();\n}\n\npublic synchronized void comerYSalir(Gato gato, int cantidadComida) throws InterruptedException {\n    while (!this.gatosEnSala.contains(gato) || this.cantidadComida &lt; cantidadComida) {\n        wait();\n    }\n\n    this.cantidadComida -= cantidadComida;\n    this.gatosEnSala.remove(gato);\n    System.out.println(gato.getName() + \" comi\u00f3 \" + cantidadComida +\n                       \" unidades de comida. Comida restante: \" + this.cantidadComida);\n    notifyAll();\n}\n\npublic synchronized void a\u00f1adirComida(int cantidad) throws InterruptedException {\n    this.cantidadComida += cantidad;\n    System.out.println(\"Alimentador a\u00f1adi\u00f3 \" + cantidad +\n                       \" unidades de comida. Comida disponible: \" + this.cantidadComida);\n    notifyAll();\n}\n</code></pre> <p>Desarrolla el c\u00f3digo del monitor SalaJuegos:</p> <ul> <li> <p>(d) (0,5 puntos) Implementa el m\u00e9todo public synchronized void entrar() throws InterruptedException</p> </li> <li> <p>(e) (0,5 puntos) Implementa el m\u00e9todo public synchronized void salir() throws InterruptedException</p> </li> </ul> Mostrar soluci\u00f3n <pre><code>public synchronized void entrar() throws InterruptedException {\n    while (this.gatosDentro &gt;= this.capacidadGatos) {\n        wait();\n    }\n    this.gatosDentro++;\n    System.out.println(\"Entr\u00f3 un gato a la sala de juegos. Gatos dentro: \" + gatosDentro);\n}\n\npublic synchronized void salir() throws InterruptedException {\n    if (this.gatosDentro &gt; 0) {\n        this.gatosDentro--;\n    }\n    System.out.println(\"Sali\u00f3 un gato de la sala de juegos. Gatos dentro: \" + gatosDentro);\n    notifyAll();\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2024/p2_ex02/","title":"P2 ex02","text":"<p>Durante la construcci\u00f3n de una nueva ciudad se est\u00e1 planificando el despliegue de la red de Internet. Para extender la red se han empezado a instalar cables de red entre las casas, haciendo que, si una casa tiene conexi\u00f3n a Internet, todas las casas conectadas a ella tambi\u00e9n la tengan. La salida de la red de la ciudad se realiza con cables de fibra \u00f3ptica que se conectan a una de las casas d\u00e1ndole acceso a Internet.</p> <p>Este escenario modela como un grafo no dirigido, donde los nodos son las casas y las aristas son los cables de red. En el siguiente diagrama se puede ver como se han dise\u00f1ado las clases que modelan el grafo adjunto.</p> <p></p> <ul> <li>(a) (2 puntos) Por problemas de presupuesto, inicialmente solo se contar\u00e1 con 1 cable de fibra \u00f3ptica para conectar la red de Internet a la ciudad. Este cable se debe conectar de manera que la cantidad de casas que tengan acceso a Internet sea la m\u00e1xima posible. Implemente el m\u00e9todo casasConectadas(Nodo nodoConectado) en la clase GrafoCiudad que retorne la cantidad de casas que tendr\u00edan acceso a Internet si se conectara el cable de fibra \u00f3ptica al nodo nodoConectado.</li> </ul> Mostrar soluci\u00f3n <p>Opci\u00f3n BST: <pre><code>public int casasConectadas(Nodo nodoConectado) {\n        Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n        List&lt;Nodo&gt; aVisitar = new ArrayList&lt;&gt;();\n\n        aVisitar.add(nodoConectado);\n        visitados.add(nodoConectado);\n\n        while (!aVisitar.isEmpty()) {\n            Nodo actual = aVisitar.remove(0);\n            for (Arista arista : actual.cablesConectados) {\n                Nodo vecino = arista.getOtroNodo(actual);\n                if (!visitados.contains(vecino)) {\n                    visitados.add(vecino);\n                    aVisitar.add(vecino);\n                }\n            }\n        }\n\n        return visitados.size();\n    }\n    ```\n\n    Opci\u00f3n Dijkstra\n    ```java\npublic int casasConectadasDijkstra(Nodo nodoConectado) {\n    HashMap&lt;Nodo, Double&gt; distancias = dijkstra(nodoConectado);\n    return distancias.size();\n}\n\nprivate void relax(Arista arista, Nodo nodoConectado, HashMap&lt;Nodo, Double&gt; distancias,\n                   List&lt;Nodo&gt; aVisitar) {\n    Nodo vecino = arista.getOtroNodo(nodoConectado);\n    double nuevaDistancia = distancias.get(nodoConectado) + arista.longitud;\n\n    if (!distancias.containsKey(vecino) || distancias.get(vecino) &gt; nuevaDistancia) {\n        distancias.put(vecino, nuevaDistancia);\n        if (!aVisitar.contains(vecino))\n            aVisitar.add(vecino);\n    }\n}\n\nprivate Nodo extraerMenor(List&lt;Nodo&gt; aVisitar, HashMap&lt;Nodo, Double&gt; distancias) {\n    Nodo menor = aVisitar.get(0);\n    for (Nodo nodo : aVisitar) {\n        if (distancias.get(nodo) &lt; distancias.get(menor)) {\n            menor = nodo;\n        }\n    }\n    aVisitar.remove(menor);\n    return menor;\n}\n\nprivate HashMap&lt;Nodo, Double&gt; dijkstra(Nodo nodoConectado) {\n    Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n    HashMap&lt;Nodo, Double&gt; distancias = new HashMap&lt;&gt;();\n    List&lt;Nodo&gt; aVisitar = new ArrayList&lt;&gt;();\n\n    aVisitar.add(nodoConectado);\n    distancias.put(nodoConectado, 0.0);\n\n    while (!aVisitar.isEmpty()) {\n        Nodo actual = extraerMenor(aVisitar, distancias);\n        visitados.add(actual);\n\n        for (Arista arista : actual.cablesConectados) {\n            if (visitados.contains(arista.getOtroNodo(actual))) {\n                continue;\n            }\n            relax(arista, actual, distancias, aVisitar);\n        }\n    }\n\n    return distancias;\n}\n</code></pre></p> <ul> <li>(b) (3 puntos) Desafortunadamente, el cable utilizado dentro de la ciudad no es de la mejor calidad y se ha detectado que las casas m\u00e1s alejadas de la casa conectada a la fibra \u00f3ptica tienen problemas de conexi\u00f3n. El umbral de distancia para que una casa tenga problemas de conexi\u00f3n es de 1000 metros, guardado en la constante DISTANCIA_MAXIMA en la clase <code>GrafoCiudad</code>. Implemente el m\u00e9todo <code>casasConProblemasConexion(Nodo nodoConectado)</code> en la clase <code>GrafoCiudad</code> que retorne la cantidad de casas que tendr\u00edan problemas de conexi\u00f3n si se conectara el cable de fibra \u00f3ptica al nodo <code>nodoConectado</code>. Nota: las casas con problemas de conexi\u00f3n deben tener acceso a Internet.</li> </ul> Mostrar soluci\u00f3n <p>Opci\u00f3n BST: <pre><code>public int casasConProblemasConexion(Nodo nodoConectado) {\n    List&lt;Nodo&gt; aVisitar = new ArrayList&lt;&gt;();\n    HashMap&lt;Nodo, Double&gt; distancias = new HashMap&lt;&gt;();\n\n    aVisitar.add(nodoConectado);\n    distancias.put(nodoConectado, 0.0);\n\n    while (!aVisitar.isEmpty()) {\n        Nodo actual = aVisitar.remove(0);\n\n        for (Arista arista : actual.cablesConectados) {\n            Nodo vecino = arista.getOtroNodo(actual);\n            double nuevaDistancia = distancias.get(actual) + arista.longitud;\n\n            if (!distancias.containsKey(vecino) || distancias.get(vecino) &gt; nuevaDistancia) {\n                distancias.put(vecino, nuevaDistancia);\n                aVisitar.add(vecino);\n            }\n        }\n    }\n\n    int contador = 0;\n    for (Nodo casa : distancias.keySet()) {\n        if (distancias.get(casa) &gt; DISTANCIA_MAXIMA) {\n            contador++;\n        }\n    }\n\n    return contador;\n}\n</code></pre></p> <p>Opci\u00f3n Dijkstra: <pre><code>public int casasConProblemasConexionDijkstra(Nodo nodoConectado) {\n    HashMap&lt;Nodo, Double&gt; distancias = dijkstra(nodoConectado);\n    int contador = 0;\n\n    for (Nodo casa : distancias.keySet()) {\n        if (distancias.get(casa) &gt; DISTANCIA_MAXIMA) {\n            contador++;\n        }\n    }\n\n    return contador;\n}\n</code></pre></p>","tags":["grafos"]},{"location":"exams/2024/pract/","title":"Examen 2024 \u2014 Pr\u00e1cticas","text":""},{"location":"exams/2024/pract/#problema-1","title":"Problema 1","text":"<ul> <li>(a) (6 puntos) En relaci\u00f3n al m\u00e9todo getPuntuacionMediana, se quiere modificar con la siguiente signatura:</li> </ul> <pre><code>/**\n* Este m\u00e9todo devuelve la mediana en el rango especificado en la lista\n* ordenada de los tableros.\n* @param min N\u00famero menor en el rango\n* @param max N\u00famero mayor en el rango\n* @return La mediana en el rango.\n*/\npublic int getPuntuacionMediana(int min, int max){ . . .}\n</code></pre> <p>Notas:     - Min y max se refieren a \u00edndices en la lista que se usa.     - Suponga que los par\u00e1metros min y max que se reciben son v\u00e1lidos.</p> Mostrar soluci\u00f3n <pre><code>public int getPuntuacionMediana(int min, int max) {\n    // Se usa la divisi\u00f3n entera\n    int mediana = (max + min) / 2;\n\n    if ((mediana) % 2 == 0) {\n        return tableros.get(mediana).getPuntuacion();\n    } else {\n        int pos1 = tableros.get(mediana).getPuntuacion();\n        int pos2 = tableros.get(mediana + 1).getPuntuacion();\n        // En estos casos, la mediana ser\u00e1 un float. En este caso,\n        // se utiliza la divisi\u00f3n entera, como indica la signatura.\n        return (pos1 + pos2) / 2;\n    }\n}\n</code></pre>"},{"location":"exams/2024/pract/#problema-2","title":"Problema 2","text":"<p>Suponga que se tiene una variable tableroPruebas que contiene un tablero con las piezas dispuestas como en la imagen siguiente. Dise\u00f1e una prueba que compruebe que se calculan correctamente las puntuaciones de cada uno de los bandos.</p> <p></p> Pieza Puntos Rey 100 Reina 9 Torre 5 Alfil 3 Caballo 3 Pe\u00f3n 1 Mostrar soluci\u00f3n <pre><code>@Test\npublic void pruebaExamen() {\n    assertEquals(122, tableroPruebas.getPuntuacionBando(Bando.BLANCAS));\n    assertEquals(125, tableroPruebas.getPuntuacionBando(Bando.NEGRA));\n}\n</code></pre>"},{"location":"exams/2024/pract/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (6 puntos) Desarrolle el m\u00e9todo getPorcentajeTablerosConVentaja(Bando bando) en la clase GestorTableros. Este m\u00e9todo debe devolver un n\u00famero decimal que represente el tanto por ciento de tableros en que el bando que se pasa como par\u00e1metro tiene una puntuaci\u00f3n superior al bando contrario. <pre><code>public double getPorcentajeTablerosConVentaja(Bando bando)\n</code></pre></li> </ul> Mostrar Soluci\u00f3n <pre><code>public double getPorcentajeTablerosConVentaja(Bando bando) {\n    return getTablerosConVentaja(bando) / tableros.size();\n}\n\npublic List&lt;Tablero&gt; getTablerosConVentaja(Bando bando) {\n    Bando contrario;\n    if (bando == Bando.BLANCAS) {\n        contrario = Bando.NEGRAS;\n    } else {\n        contrario = Bando.BLANCAS;\n    }\n\n    List&lt;Tablero&gt; tablerosConVentaja = new ArrayList&lt;&gt;();\n    for (Tablero tablero : tableros) {\n        if (tablero.getPuntuacionBando(bando) &gt; tablero.getPuntuacionBando(contrario)) {\n            tablerosConVentaja.add(tablero);\n        }\n    }\n\n    return tablerosConVentaja;\n}\n</code></pre>"},{"location":"exams/2024/pract/#problema-4","title":"Problema 4","text":"<ul> <li>(a) (4 puntos) Modifique el m\u00e9todo getTablerosConPuntuacionMinima para convertirlo en getTablerosConPuntuacionMaxima, que devuelva todos los tableros que tengan una puntuaci\u00f3n igual o inferior a la que se pase como par\u00e1metro.</li> </ul> <pre><code>public List&lt;Tablero&gt; getTablerosConPuntuacionMaxima(int puntuacion)\n</code></pre> Mostrar soluci\u00f3n <pre><code>public List&lt;Tablero&gt; getTablerosConPuntuacionMaxima(int puntuacion) {\n    int posicion = tableros.size();\n    for (int i = 0; i &lt; tableros.size(); i++) {\n        if (tableros.get(i).getPuntuacion() &gt; puntuacion) {\n            posicion = i;\n            break;\n        }\n    }\n    return tableros.subList(0, posicion);\n}\n</code></pre>"},{"location":"exams/2024/pract/#problema-5","title":"Problema 5","text":"<p>En la pr\u00e1ctica 2 emple\u00e1bamos diferentes implementaciones de diccionarios para localizar la partida de un cierto tablero. En este ejercicio vamos a emplear la siguiente implementaci\u00f3n de la clase Tablero y las siguientes pruebas JUnit. La implementaci\u00f3n de Tablero ser\u00e1 igual que ten\u00edamos en el enunciado o soluci\u00f3n de la pr\u00e1ctica, salvo lo que incluimos a continuaci\u00f3n:</p> <pre><code>1  public class Tablero {\n2      // Resto es como enunciado/soluci\u00f3n pr\u00e1ctica\n3      @Override\n4      public boolean equals(Object obj) {\n5          if (obj == null) {\n6              return false;\n7          }\n8          if (obj instanceof Tablero) {\n9              Tablero other = (Tablero) obj;\n10             return\n11                 this.representacion.equals(\n12                     other.representacion);\n13         }\n14         return false;\n15     }\n16     @Override\n17     public int hashCode() {\n18         return 7;\n19     }\n20 }\n</code></pre> <pre><code>1  class TestTableroMap {\n2      @Test\n3      void test1() {\n4          doTest(\"data/t1.txt\");\n5      }\n6      @Test\n7      void test2() {\n8          doTest(\"data/t2.txt\");\n9      }\n10     private void doTest(String file) {\n11         try {\n12             List&lt;Partida&gt; partidas =\n13                 LectorPartidas.leerPartidas(file);\n14             List&lt;Tablero&gt; tableros = new ArrayList&lt;Tablero&gt;();\n15             Map&lt;Tablero, Partida&gt; tablero2Partida =\n16                 new HashMap&lt;Tablero, Partida&gt;();\n17             for (Partida partida : partidas) {\n18                 tableros.addAll(partida.turnos);\n19                 for (Tablero t : partida.turnos)\n20                     tablero2Partida.put(t, partida);\n21             }\n22             assertEquals(tableros.size(),\n23                          tablero2Partida.keySet().size());\n24             for (Partida partida : partidas)\n25                 for (Tablero t : partida.turnos)\n26                     assertEquals(partida, tablero2Partida.get(t));\n27         } catch (Exception e) {\n28             fail();\n29         }\n30     }\n31 }\n</code></pre> <p>Las pruebas que incluimos utilizan dos ficheros:     - t1.txt: es un fichero con 5 partidas y cada partida 3 tableros. Los 15 tableros tienen todos representaciones de fichas deferentes.     - t2.txt: es un fichero con 5 partidas y cada partida 3 tableros. Pero todas las partidas tienen un tablero con una representaci\u00f3n de fichas iguales a otro tablero de otra partida.</p> <p>Se pide:</p> <ul> <li>(a) (4 puntos) Con estas implementaciones de pruebas y Tablero, cuales de las pruebas fallan o tienen errores y cuales son pruebas correctas. Si la respuesta para alguna prueba es que falla o tiene error, justificar el motivo del fallo.</li> </ul> Mostrar Soluci\u00f3n <p>Las dos pruebas comprueban que un tablero no remplaza a otro tablero en el mapa, y como todos los tablaros tienen el mismo hashCode, una clave remplaza a otro cuando dos claves son iguales. Las claves son iguales cuando las representaciones son iguales.</p> <p>t1.txt no tiene tableros con representaciones iguales. La prueba test1 no falla</p> <p>t2.txt tiene tableros con representaciones iguales. La prueba test2 falla.</p> <ul> <li>(b) (6 puntos) Cambiamos la l\u00ednea 16 de las pruebas por la siguiente l\u00ednea: <pre><code>new TreeMap&lt;Tablero,Partida&gt;();\n</code></pre> Cambiar la clase Tablero para que las pruebas test1 y test2 funcionen correctamente. Se debe incluir cualquier cambio incluido en la soluci\u00f3n de la pr\u00e1ctica, que no estuviese incluido en el enunciado que inclu\u00eda inicialmente la pr\u00e1ctica, y que sean necesarios para que las dos pruebas funcionen.</li> </ul> Mostrar Soluci\u00f3n <p>Para utilizar TreeMap Tablero tiene que implementar Comparable y los Tableros no pueden ser iguales cuando comparamos dos tableros. Actualizamos Tablero de la siguiente forma: <pre><code>public class Tablero implements Comparable&lt;Tablero&gt; {\n    private static int ID=0;\n    private int id=ID++;\n    @Override\n    public int compareTo(Tablero o) {\n        if (representacion.equals(o.representacion))\n            return id-o.id;\n        return representacion.compareTo(o.representacion);\n    }\n}\n</code></pre> El orden de los tableros primero depende de la representaci\u00f3n y para representaci\u00f3n iguales del identificador de tablero. Con esta soluci\u00f3n evitamos que el \u00e1rbol est\u00e9 desequilibrado, si fuse al rev\u00e9s e insertamos en el tablero en el mismo orden que creamos los tableros, quedar\u00eda desequilibrado."},{"location":"exams/2024/pract_ex01/","title":"Pract ex01","text":"<ul> <li>(a) (6 puntos) En relaci\u00f3n al m\u00e9todo getPuntuacionMediana, se quiere modificar con la siguiente signatura:</li> </ul> <pre><code>/**\n* Este m\u00e9todo devuelve la mediana en el rango especificado en la lista\n* ordenada de los tableros.\n* @param min N\u00famero menor en el rango\n* @param max N\u00famero mayor en el rango\n* @return La mediana en el rango.\n*/\npublic int getPuntuacionMediana(int min, int max){ . . .}\n</code></pre> <p>Notas:     - Min y max se refieren a \u00edndices en la lista que se usa.     - Suponga que los par\u00e1metros min y max que se reciben son v\u00e1lidos.</p> Mostrar soluci\u00f3n <pre><code>public int getPuntuacionMediana(int min, int max) {\n    // Se usa la divisi\u00f3n entera\n    int mediana = (max + min) / 2;\n\n    if ((mediana) % 2 == 0) {\n        return tableros.get(mediana).getPuntuacion();\n    } else {\n        int pos1 = tableros.get(mediana).getPuntuacion();\n        int pos2 = tableros.get(mediana + 1).getPuntuacion();\n        // En estos casos, la mediana ser\u00e1 un float. En este caso,\n        // se utiliza la divisi\u00f3n entera, como indica la signatura.\n        return (pos1 + pos2) / 2;\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2024/pract_ex02/","title":"Pract ex02","text":"<p>Suponga que se tiene una variable tableroPruebas que contiene un tablero con las piezas dispuestas como en la imagen siguiente. Dise\u00f1e una prueba que compruebe que se calculan correctamente las puntuaciones de cada uno de los bandos.</p> <p></p> Pieza Puntos Rey 100 Reina 9 Torre 5 Alfil 3 Caballo 3 Pe\u00f3n 1 Mostrar soluci\u00f3n <pre><code>@Test\npublic void pruebaExamen() {\n    assertEquals(122, tableroPruebas.getPuntuacionBando(Bando.BLANCAS));\n    assertEquals(125, tableroPruebas.getPuntuacionBando(Bando.NEGRA));\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2024/pract_ex03/","title":"Pract ex03","text":"<ul> <li>(a) (6 puntos) Desarrolle el m\u00e9todo getPorcentajeTablerosConVentaja(Bando bando) en la clase GestorTableros. Este m\u00e9todo debe devolver un n\u00famero decimal que represente el tanto por ciento de tableros en que el bando que se pasa como par\u00e1metro tiene una puntuaci\u00f3n superior al bando contrario. <pre><code>public double getPorcentajeTablerosConVentaja(Bando bando)\n</code></pre></li> </ul> Mostrar Soluci\u00f3n <pre><code>public double getPorcentajeTablerosConVentaja(Bando bando) {\n    return getTablerosConVentaja(bando) / tableros.size();\n}\n\npublic List&lt;Tablero&gt; getTablerosConVentaja(Bando bando) {\n    Bando contrario;\n    if (bando == Bando.BLANCAS) {\n        contrario = Bando.NEGRAS;\n    } else {\n        contrario = Bando.BLANCAS;\n    }\n\n    List&lt;Tablero&gt; tablerosConVentaja = new ArrayList&lt;&gt;();\n    for (Tablero tablero : tableros) {\n        if (tablero.getPuntuacionBando(bando) &gt; tablero.getPuntuacionBando(contrario)) {\n            tablerosConVentaja.add(tablero);\n        }\n    }\n\n    return tablerosConVentaja;\n}\n</code></pre>","tags":["hebras"]},{"location":"exams/2024/pract_ex04/","title":"Pract ex04","text":"<ul> <li>(a) (4 puntos) Modifique el m\u00e9todo getTablerosConPuntuacionMinima para convertirlo en getTablerosConPuntuacionMaxima, que devuelva todos los tableros que tengan una puntuaci\u00f3n igual o inferior a la que se pase como par\u00e1metro.</li> </ul> <pre><code>public List&lt;Tablero&gt; getTablerosConPuntuacionMaxima(int puntuacion)\n</code></pre> Mostrar soluci\u00f3n <pre><code>public List&lt;Tablero&gt; getTablerosConPuntuacionMaxima(int puntuacion) {\n    int posicion = tableros.size();\n    for (int i = 0; i &lt; tableros.size(); i++) {\n        if (tableros.get(i).getPuntuacion() &gt; puntuacion) {\n            posicion = i;\n            break;\n        }\n    }\n    return tableros.subList(0, posicion);\n}\n</code></pre>","tags":["grafos"]},{"location":"exams/2024/pract_ex05/","title":"Pract ex05","text":"<p>En la pr\u00e1ctica 2 emple\u00e1bamos diferentes implementaciones de diccionarios para localizar la partida de un cierto tablero. En este ejercicio vamos a emplear la siguiente implementaci\u00f3n de la clase Tablero y las siguientes pruebas JUnit. La implementaci\u00f3n de Tablero ser\u00e1 igual que ten\u00edamos en el enunciado o soluci\u00f3n de la pr\u00e1ctica, salvo lo que incluimos a continuaci\u00f3n:</p> <pre><code>1  public class Tablero {\n2      // Resto es como enunciado/soluci\u00f3n pr\u00e1ctica\n3      @Override\n4      public boolean equals(Object obj) {\n5          if (obj == null) {\n6              return false;\n7          }\n8          if (obj instanceof Tablero) {\n9              Tablero other = (Tablero) obj;\n10             return\n11                 this.representacion.equals(\n12                     other.representacion);\n13         }\n14         return false;\n15     }\n16     @Override\n17     public int hashCode() {\n18         return 7;\n19     }\n20 }\n</code></pre> <pre><code>1  class TestTableroMap {\n2      @Test\n3      void test1() {\n4          doTest(\"data/t1.txt\");\n5      }\n6      @Test\n7      void test2() {\n8          doTest(\"data/t2.txt\");\n9      }\n10     private void doTest(String file) {\n11         try {\n12             List&lt;Partida&gt; partidas =\n13                 LectorPartidas.leerPartidas(file);\n14             List&lt;Tablero&gt; tableros = new ArrayList&lt;Tablero&gt;();\n15             Map&lt;Tablero, Partida&gt; tablero2Partida =\n16                 new HashMap&lt;Tablero, Partida&gt;();\n17             for (Partida partida : partidas) {\n18                 tableros.addAll(partida.turnos);\n19                 for (Tablero t : partida.turnos)\n20                     tablero2Partida.put(t, partida);\n21             }\n22             assertEquals(tableros.size(),\n23                          tablero2Partida.keySet().size());\n24             for (Partida partida : partidas)\n25                 for (Tablero t : partida.turnos)\n26                     assertEquals(partida, tablero2Partida.get(t));\n27         } catch (Exception e) {\n28             fail();\n29         }\n30     }\n31 }\n</code></pre> <p>Las pruebas que incluimos utilizan dos ficheros:     - t1.txt: es un fichero con 5 partidas y cada partida 3 tableros. Los 15 tableros tienen todos representaciones de fichas deferentes.     - t2.txt: es un fichero con 5 partidas y cada partida 3 tableros. Pero todas las partidas tienen un tablero con una representaci\u00f3n de fichas iguales a otro tablero de otra partida.</p> <p>Se pide:</p> <ul> <li>(a) (4 puntos) Con estas implementaciones de pruebas y Tablero, cuales de las pruebas fallan o tienen errores y cuales son pruebas correctas. Si la respuesta para alguna prueba es que falla o tiene error, justificar el motivo del fallo.</li> </ul> Mostrar Soluci\u00f3n <p>Las dos pruebas comprueban que un tablero no remplaza a otro tablero en el mapa, y como todos los tablaros tienen el mismo hashCode, una clave remplaza a otro cuando dos claves son iguales. Las claves son iguales cuando las representaciones son iguales.</p> <p>t1.txt no tiene tableros con representaciones iguales. La prueba test1 no falla</p> <p>t2.txt tiene tableros con representaciones iguales. La prueba test2 falla.</p> <ul> <li>(b) (6 puntos) Cambiamos la l\u00ednea 16 de las pruebas por la siguiente l\u00ednea: <pre><code>new TreeMap&lt;Tablero,Partida&gt;();\n</code></pre> Cambiar la clase Tablero para que las pruebas test1 y test2 funcionen correctamente. Se debe incluir cualquier cambio incluido en la soluci\u00f3n de la pr\u00e1ctica, que no estuviese incluido en el enunciado que inclu\u00eda inicialmente la pr\u00e1ctica, y que sean necesarios para que las dos pruebas funcionen.</li> </ul> Mostrar Soluci\u00f3n <p>Para utilizar TreeMap Tablero tiene que implementar Comparable y los Tableros no pueden ser iguales cuando comparamos dos tableros. Actualizamos Tablero de la siguiente forma: <pre><code>public class Tablero implements Comparable&lt;Tablero&gt; {\n    private static int ID=0;\n    private int id=ID++;\n    @Override\n    public int compareTo(Tablero o) {\n        if (representacion.equals(o.representacion))\n            return id-o.id;\n        return representacion.compareTo(o.representacion);\n    }\n}\n</code></pre> El orden de los tableros primero depende de la representaci\u00f3n y para representaci\u00f3n iguales del identificador de tablero. Con esta soluci\u00f3n evitamos que el \u00e1rbol est\u00e9 desequilibrado, si fuse al rev\u00e9s e insertamos en el tablero en el mismo orden que creamos los tableros, quedar\u00eda desequilibrado.","tags":["complejidad"]},{"location":"exams/2025/extra/","title":"Examen 2025 \u2014 Extraordinario","text":""},{"location":"exams/2025/extra/#problema-1","title":"Problema 1","text":"<p>Se quiere desarrollar un algoritmo al que llamaremos split sort. Este algoritmo es similar a la fase de merge en merge sort. Se parte de dos arrays <code>a</code> y <code>b</code>, de igual tama\u00f1o, sin elementos repetidos y ya ordenados de menor a mayor. A diferencia de merge, nuestro split sort funciona en el sitio (in place). Tras aplicar el algoritmo:</p> <ul> <li>Los menores elementos deben quedar en <code>a</code></li> <li>Los mayores elementos deben quedar en <code>b</code></li> <li>Tanto <code>a</code> como <code>b</code> siguen estando ordenados correctamente</li> <li>El conjunto de n\u00fameros (es decir, n\u00fameros contenidos en <code>a</code> o <code>b</code>) siguen siendo los mismos</li> </ul> <p>Por ejemplo, si partimos de <code>a = [1, 3, 5, 7]; b = [2, 4, 6, 8]</code>, el resultado ser\u00eda <code>a = [1, 2, 3, 4]; b = [5, 6, 7, 8]</code>.</p> <p>Se pide:</p> <ul> <li>(a) (0.5 puntos) Describir al menos 5 casos en los que probar este c\u00f3digo y el resultado esperado. Se valorar\u00e1 que los casos sean distintos y representativos.</li> </ul> Mostrar soluci\u00f3n <p>Casos de prueba para el m\u00e9todo <code>splitSort</code>:</p> <ul> <li>Caso 1: <code>a = [1, 3, 5, 7]</code>, <code>b = [2, 4, 6, 8]</code> \u2192 Resultado esperado: <code>a = [1, 2, 3, 4]</code>, <code>b = [5, 6, 7, 8]</code></li> <li>Caso 2: <code>a = [10, 20, 30]</code>, <code>b = [15, 25, 35]</code> \u2192 Resultado esperado: <code>a = [10, 15, 20]</code>, <code>b = [25, 30, 35]</code></li> <li>Caso 3: <code>a = [5, 10]</code>, <code>b = [1, 2]</code> \u2192 Resultado esperado: <code>a = [1, 2]</code>, <code>b = [5, 10]</code></li> <li>Caso 4: <code>a = [1000, 2000]</code>, <code>b = [1500, 2500]</code> \u2192 Resultado esperado: <code>a = [1000, 1500]</code>, <code>b = [2000, 2500]</code></li> <li>Caso 5: <code>a = [3]</code>, <code>b = [4]</code> \u2192 Resultado esperado: <code>a = [3]</code>, <code>b = [4]</code></li> </ul> <ul> <li> <p>(b) (4 puntos) Desarrollar el c\u00f3digo del m\u00e9todo <code>void splitSort(int[] a, int[] b)</code>. Se valorar\u00e1:</p> <ul> <li>Que los arrays contengan los mismos elementos al final</li> <li>Que <code>a</code> contenga los elementos menores y <code>b</code> los mayores</li> <li>Que ambos arrays est\u00e9n ordenados al terminar</li> <li>No se permite crear nuevos arrays ni listas. Solo pueden modificarse <code>a</code> y <code>b</code>.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo <code>splitSort</code> en Java: <pre><code>public static void splitSort(int[] a, int[] b) {\n  int n = a.length;\n  int m = b.length;\n\n  for (int i = 0; i &lt; n; i++) {\n    if (a[i] &gt; b[0]) {\n      // Intercambiar a[i] con el menor de b\n      int temp = a[i];\n      a[i] = b[0];\n      b[0] = temp;\n\n      // Reordenar b (insertion sort para mantenerlo ordenado)\n      int j = 0;\n      while (j + 1 &lt; m &amp;&amp; b[j] &gt; b[j + 1]) {\n        int aux = b[j];\n        b[j] = b[j + 1];\n        b[j + 1] = aux;\n        j++;\n      }\n    }\n  }\n}\n</code></pre></p> <ul> <li>(c) (0.5 puntos) Escribir el c\u00f3digo necesario para probar el m\u00e9todo <code>splitSort</code> en al menos 1 caso. </li> </ul> Mostrar soluci\u00f3n <pre><code>@Test\npublic void testTodosMenoresEnB() {\n  int[] a = {10, 12, 14};\n  int[] b = {1, 2, 3};\n  Ejercicio4.splitSort(a, b);\n  assertSortedSplit(new int[]{1, 2, 3}, new int[]{10, 12, 14}, a, b);\n}\n\n@Test\npublic void testYaOrdenado() {\n  int[] a = {1, 2, 3};\n  int[] b = {4, 5, 6};\n  Ejercicio4.splitSort(a, b);\n  assertSortedSplit(new int[]{1, 2, 3}, new int[]{4, 5, 6}, a, b);\n}\n</code></pre>"},{"location":"exams/2025/extra/#problema-2","title":"Problema 2","text":"<p>La multiplicaci\u00f3n de n\u00fameros enteros grandes es costosa para los ordenadores, por lo que existen t\u00e9cnicas como el algoritmo de Karatsuba que hacen m\u00e1s eficiente este c\u00e1lculo. El algoritmo de Karatsuba utiliza la t\u00e9cnica de divide y vencer\u00e1s. Se basa en dividir los n\u00fameros a multiplicar en partes m\u00e1s peque\u00f1as (m\u00e1s sencillas de manejar), operar sobre ellas y luego combinar los resultados para obtener el producto final. Por simplicidad, se asume que todas las operaciones se realizan con variables de tipo <code>int</code>.</p> <p>Dados dos n\u00fameros enteros \\(x\\) e \\(y\\), se pueden representar como: \\vspace{-0.2cm} \\begin{equation} x = a \\cdot 10^n + b \\hspace{3cm} y = c \\cdot 10^n + d \\end{equation} \\vspace{-0.2cm} donde \\(a\\), \\(b\\), \\(c\\) y \\(d\\) son enteros, y \\(2n\\) es el n\u00famero total de d\u00edgitos que tienen tanto \\(x\\) como \\(y\\).</p> <p>El algoritmo de Karatsuba nos indica que: \\vspace{-0.2cm} \\begin{equation} x \\cdot y = ac \\cdot 10^{2n} + (ad + bc) \\cdot 10^n + bd \\end{equation} \\vspace{-0.2cm} Esto se puede reescribir como: \\vspace{-0.2cm} \\begin{equation} x \\cdot y = z_1 \\cdot 10^{2n} + z_2 \\cdot 10^n + z_3 \\end{equation} \\vspace{-0.2cm} donde\\footnotemark: \\(z_1 = ac\\), \\(z_3 = bd\\), \\(z_2 = (a + b)(c + d) - z_1 - z_3\\)</p> <p>\\footnotetext{No es necesario para resolver el ejercicio. Para obtener \\(z_2\\), partimos de la identidad \\((a + b)(c + d) = ac + ad + bc + bd = z_1 + ad + bc + z_3\\). Despejando, \\(ad + bc = (a + b)(c + d) - z_1 - z_3\\), por tanto, \\(z_2 = ad + bc = (a + b)(c + d) - z_1 - z_3\\).}</p> <p>As\u00ed, en lugar de realizar 4 multiplicaciones (\\(ac\\), \\(ad\\), \\(bc\\), y \\(bd\\)), solo se hacen 3 multiplicaciones (\\(z_1\\), \\(z_3\\), y \\((a+b)(c+d)\\)) y algunas operaciones m\u00e1s r\u00e1pidas como sumas y restas. Esta idea se puede aplicar de forma recursiva, hasta que se multipliquen \u00fanicamente n\u00fameros de un solo d\u00edgito.</p>"},{"location":"exams/2025/extra/#ejemplo","title":"Ejemplo","text":"<p>Supongamos que se desea multiplicar los n\u00fameros \\(x = 56341032\\) e \\(y = 72916764\\). Primero, se dividen ambos n\u00fameros en dos partes:</p> <ul> <li>\\(x = 56341032 = 5634 \\cdot 10^4 + 1032 \\Rightarrow a = 5634,\\, b = 1032\\)</li> <li>\\(y = 72916764 = 7291 \\cdot 10^4 + 6764 \\Rightarrow c = 7291,\\, d = 6764\\)</li> </ul> <p>Entonces, aplicamos la f\u00f3rmula anterior:</p> <ul> <li>\\(z_1 = ac = 5634 \\cdot 7291\\)</li> <li>\\(z_3 = bd = 1032 \\cdot 6764\\)</li> <li>\\(z_2 = (a + b)(c + d) - z_1 - z_3 = (5634 + 1032)(7291 + 6764) - z_1 - z_3 = 6666 \\cdot 14055 - z_1 - z_3\\)</li> </ul> <p>Finalmente, el resultado se obtiene como: \\vspace{-0.2cm} \\begin{equation} x \\cdot y = z_1 \\cdot 10^8 + z_2 \\cdot 10^4 + z_3 \\end{equation} \\vspace{-0.2cm} Para calcular \\(z_1\\), \\(z_2\\) y \\(z_3\\), se aplicar\u00eda recursivamente el algoritmo de Karatsuba a las parejas: \\vspace{-0.1cm} \\begin{equation} (5634, 7291)\\hspace{2cm}(1032, 6764)\\hspace{2cm}(6666, 14055) \\end{equation} \\vspace{-1.0cm}</p> <p>\\subsection*{Preguntas}</p> <ul> <li>(a) (1 punto) Razone c\u00f3mo se aplicar\u00eda este algoritmo para multiplicar los n\u00fameros 34 y 78. \u00bfCu\u00e1ntas veces deber\u00eda llamarse al m\u00e9todo <code>karatsuba(int x, int y)</code> y con qu\u00e9 par\u00e1metros?</li> </ul> Mostrar soluci\u00f3n <p>Para multiplicar los n\u00fameros 34 y 78 utilizando el algoritmo de Karatsuba, primero dividimos ambos n\u00fameros en dos partes: \\begin{itemize}   \\item \\(x = 34 = 3 \\cdot 10 + 4 \\Rightarrow a = 3, b = 4\\)   \\item \\(y = 78 = 7 \\cdot 10 + 8 \\Rightarrow c = 7, d = 8\\) \\end{itemize} Calculamos: \\begin{itemize}   \\item \\(z_1 = ac = 3 \\cdot 7 \\Rightarrow karatsuba(3,7) = 21\\)    \\item \\(z_3 = bd = 4 \\cdot 8 \\Rightarrow karatsuba(4,8) = 32\\)   \\item \\(z_2 = (a+b)(c+d) - z_1 - z_3 = (3 + 4)(7 + 8) - z_1 - z_3 = 7 \\cdot 15 - z_1 - z_3 \\Rightarrow karatsuba(7,15) = 105\\) \\end{itemize}</p> <p>Expandiendo <code>karatsuba(7,15)</code>: \\begin{itemize}   \\item \\(x = 7 = 0 \\cdot 10 + 7 \\Rightarrow a = 0, b = 7\\)   \\item \\(y = 15 = 1 \\cdot 10 + 5 \\Rightarrow c = 1, d = 5\\)   \\item \\(z_1 = ac = 0 \\cdot 1 \\Rightarrow karatsuba(0,1) = 0\\)    \\item \\(z_3 = bd = 7 \\cdot 5 \\Rightarrow karatsuba(7,5) = 35\\)    \\item \\(z_2 = (a+b)(c+d) - z_1 - z_3 = (0 + 7)(1 + 5) - z_1 - z_3 = 7 \\cdot 6 - z_1 - z_3 \\Rightarrow karatsuba(7,6) = 42\\)  \\end{itemize}</p> <p>Con esto ya contestar\u00edamos a la pregunta ya que tenemos todas las llamadas recursivas a <code>karatsuba</code>:</p> \\[\\begin{center} \\texttt{karatsuba(34,78)} \\hspace{1cm} \\texttt{karatsuba(3,7)} \\hspace{1cm} \\texttt{karatsuba(4,8)} \\hspace{1cm} \\texttt{karatsuba(7,15)}\\\\ \\texttt{karatsuba(0,1)} \\hspace{1cm} \\texttt{karatsuba(7,5)} \\hspace{1cm} \\texttt{karatsuba(7,6)} \\end{center}\\] <p>En total, se llama al m\u00e9todo <code>karatsuba</code> 7 veces, la original m\u00e1s 6 llamadas recursivas.</p> <p>Si queremos completar el c\u00e1lculo (no se pide en el ejercicio), reconstruimos primero karatsuba(7,15) como:</p> <ul> <li>\\(z_2 = 42 - 35 = 7\\)</li> <li>\\(7 \\cdot 15 = z_1\\cdot 100 + z_2 \\cdot 10 + z_3 = 0 \\cdot 100 + 7 \\cdot 10 + 35 = 0 + 70 + 35 = 105\\)</li> </ul> <p>Finalmente, reconstruimos el resultado de la multiplicaci\u00f3n original:</p> <ul> <li>\\(z_2 = 105 - 21 - 32 = 52\\)</li> <li>\\(34 \\cdot 78 = z_1 \\cdot 100 + z_2 \\cdot 10 + z_3 = 21 \\cdot 100 + 52 \\cdot 10 + 32 = 2100 + 520 + 32 = 2652\\)</li> </ul> <ul> <li> <p>(b) (2 puntos) Realice una implementaci\u00f3n del algoritmo de Karatsuba en Java. Para ello, implemente un m\u00e9todo <code>karatsuba</code> que reciba como par\u00e1metros dos n\u00fameros enteros <code>x</code> e <code>y</code> y devuelva el resultado de la multiplicaci\u00f3n utilizando dicho algoritmo. La cabecera del m\u00e9todo es <code>public int karatsuba(int x, int y)</code>. El m\u00e9todo no puede realizar multiplicaciones de n\u00fameros de m\u00e1s de un d\u00edgito y todas las multiplicaciones se realizan utilizando el algoritmo de Karatsuba. Se asume que los n\u00fameros <code>x</code> e <code>y</code>, con los que se invoca inicialmente el m\u00e9todo, tendr\u00e1n el mismo n\u00famero de d\u00edgitos. Suponga que existen los siguientes m\u00e9todos auxiliares:</p> </li> <li> <p><code>static int[] splitint(int num, int digitos)</code> que recibe un n\u00famero entero <code>num</code> y un n\u00famero de d\u00edgitos. El m\u00e9todo parte el n\u00famero <code>num</code> en dos partes de <code>digitos</code> d\u00edgitos cada una y devuelve un array con las dos partes. Por ejemplo, si <code>num = 12345678</code> y <code>digitos = 4</code>, el m\u00e9todo devolver\u00e1 el array <code>[1234, 5678]</code>. El m\u00e9todo rellena con ceros a la izquierda si es necesario. Si <code>num = 123</code> y <code>digitos = 2</code>, el m\u00e9todo devolver\u00e1 el array <code>[01, 23]</code>.</p> </li> <li><code>static int length(int num)</code> que recibe un n\u00famero entero <code>num</code> y devuelve el n\u00famero de d\u00edgitos que tiene. Por ejemplo, si <code>num = 12345</code>, el m\u00e9todo devolver\u00e1 <code>5</code>.</li> <li><code>static int pow10(int num, int exp)</code> que recibe un n\u00famero entero <code>num</code> y un exponente <code>exp</code>, y devuelve como resultado <code>num</code> con <code>exp</code> ceros a la izquierda. Por ejemplo, si <code>num = 123</code> y <code>exp = 2</code>, el m\u00e9todo devolver\u00e1 <code>12300</code>.</li> </ul> Mostrar soluci\u00f3n <p>Implementaci\u00f3n en Java:</p> <pre><code>public static int karatsuba(int x, int y) {\n  if (x &lt; 10 &amp;&amp; y &lt; 10) {\n    return x * y;\n  }\n\n  int n = (Math.max(length(x), length(y))+1) / 2; // Redondeamos hacia arriba para dividir en dos partes\n\n  int[] xParts = splitint(x, n);\n  int[] yParts = splitint(y, n);\n  int a = xParts[0];\n  int b = xParts[1];\n  int c = yParts[0];\n  int d = yParts[1];\n\n  int z1 = karatsuba(a, c);\n  int z3 = karatsuba(b, d);\n  int z2 = karatsuba(a + b, c + d) - z1 - z3;\n\n  return z1 * pow10(1, 2 * n) + z2 * pow10(1, n) + z3;\n}\n</code></pre> <ul> <li>(c) (2 puntos) En este tipo de algoritmos recursivos, es com\u00fan que se realicen m\u00faltiples llamadas al mismo m\u00e9todo con los mismos par\u00e1metros. Una forma de optimizar estos algoritmos es a\u00f1adir una cache para evitar estos c\u00e1lculos repetidos. Esto significa que, si se llama al m\u00e9todo <code>karatsuba</code> con los mismos par\u00e1metros que en una llamada anterior, se devolver\u00e1 el resultado ya calculado en lugar de volver a calcularlo. Sin repetir el c\u00f3digo del m\u00e9todo del apartado anterior, indique que modificaciones har\u00eda para implementar esta cache. </li> </ul> <p>Nota: No es necesario preocuparse por posibles desbordamientos del tipo <code>int</code>. Se asume que los casos de prueba no exceder\u00e1n su l\u00edmite.</p> Mostrar soluci\u00f3n <p>Para implementar una cache, se puede utilizar un <code>Map</code> para almacenar los resultados ya calculados. Aqu\u00ed est\u00e1 la modificaci\u00f3n del m\u00e9todo <code>karatsuba</code>:</p> <pre><code>  // Fuera del m\u00e9todo\n  private static Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;();\n\n  public static int karatsuba(int x, int y) {\n    String key = x + \",\" + y;\n    if (cache.containsKey(key)) {\n      return cache.get(key);\n    }\n\n    // el resto del c\u00f3digo es igual al anterior\n\n    cache.put(key, result); \n    return result;\n  }\n</code></pre>"},{"location":"exams/2025/extra/#problema-3","title":"Problema 3","text":"<p>Tres hebras Java de dos tipos diferentes, tipos A y B, entran en una sala para intercambiar tokens. Las hebras de tipo A solo salen de la sala cuando han intercambiado tokens con las dos hebras de tipo B, y las hebras de tipo B intercambian un solo token, cada una, con la hebra de tipo A. Las tres hebras no salen de la sala mientras que todas no han intercambiado sus tokens, y cuando las tres han intercambiado deben salir de la sala y m\u00e1s adelante volver a entrar para iniciar nuevos intercambios. Las hebras solo empiezan a intercambiar tokens cuando est\u00e1n las tres en la sala.</p> <ul> <li>(a) (5 puntos) Desarrollar un monitor Java que represente la ejecuci\u00f3n de las hebras en la sala. En esta implementaci\u00f3n, para que una hebra B salga de la sala, la hebra A con la que intercambian token debe haber intercambiado con dos hebras de tipo B. Mientras las 3 hebras est\u00e1n realizando el intercambio, ninguna otra hebra puede entrar en la sala. El monitor Java de la sala debe implementar el siguiente interfaz Java:</li> </ul> <pre><code> public interface ISalaTokens {\n\n    // Entrada en la sala de la hebra A. Entra con 2 tokens y el resultado es un array \n    // con los dos tokens que le dan las hebras B\n    String[] entraA(String token1, String token2) throws InterruptedException;\n\n    // Entrada en la sala de las hebras B con 1 token cada una y el resultado es el token\n    // que le ha dado la hebra A\n    String entraB(String token) throws InterruptedException;    \n}\n</code></pre> <p>Podemos suponer que el c\u00f3digo de las hebras es el siguiente: <pre><code>\\noindent\n\\begin{minipage}[t]{0.48\\linewidth}\n\\raggedright\n\\begin{lstlisting}[\n  language=Java,\n  keywordstyle=\\color{blue}\\bfseries,\n  commentstyle=\\color{gray}\\itshape,\n  stringstyle=\\color{red},\n  identifierstyle=\\color{black},\n  basicstyle=\\ttfamily\\small,\n  frame=single,\n  breaklines=true\n]\n// Hebra de tipo A\nprivate Set&lt;String&gt; colec=new HashSet&lt;String&gt;();\nprivate ISalaTokens sala;\nprivate String[] tokens = new String[2]; \npublic void run() {\n  while (true) {\n    tokens=buscarTokensA();\n    if (!colec.contains(tokens[0]) &amp;&amp; \n        !colec.contains(tokens[1]))\n      tokens=sala.entraA(tokens[0],tokens[1]);\n    colec.add(tokens[0]); colec.add(tokens[1]);\n  }\n}\n\\end{lstlisting}\n\\end{minipage}%\n\\hfill\n\\begin{minipage}[t]{0.48\\linewidth}\n\\raggedleft\n\\begin{lstlisting}[\n  language=Java,\n  keywordstyle=\\color{blue}\\bfseries,\n  commentstyle=\\color{gray}\\itshape,\n  stringstyle=\\color{red},\n  identifierstyle=\\color{black},\n  basicstyle=\\ttfamily\\small,\n  frame=single,\n  breaklines=true\n]\n// Hebra de tipo B\nprivate Set&lt;String&gt; colec=new HashSet&lt;String&gt;();\nprivate ISalaTokens sala;\nprivate String token=null;\npublic void run() {\n  while (true) {\n    token=buscarTokenB();\n    if (!colec.contains(token))\n      token=sala.entraB(token);\n    colec.add(token);\n  }\n}\n\\end{lstlisting}\n\\end{minipage}%\n</code></pre></p> <p>Nota: Suponga que los m\u00e9todos <code>buscarTokensA</code> y <code>buscarTokenB</code> est\u00e1n implementados y devuelven los tokens necesarios para el intercambio.</p> Mostrar soluci\u00f3n <pre><code>public class SalaTokens implements ISalaTokens {\n    private boolean esperandoA= false;\n    private int esperandoB = 0;\n    private String[] tokensB=new String[2];\n    private String[] tokensA=new String[2];\n\n    private boolean aPreparado = false;\n    private int numBesperaA = 0;\n\n    public synchronized String[] entraA(String token1, String token2) throws InterruptedException {\n        esperandoA=true;\n        while (esperandoB &lt; 2) {\n            wait();\n        }\n\n        aPreparado = true;\n        tokensA[0]=token1;\n        tokensA[1]=token2;\n        numBesperaA = 0;\n        notifyAll();\n\n        while (numBesperaA &lt; 2) {\n            wait();\n        }\n\n        String[] tokens=new String[2];\n        tokens[0]=tokensB[0]; tokens[1]=tokensB[1];\n\n        aPreparado = false;\n        notifyAll();\n        return tokens;\n    }\n\n    public synchronized String entraB(String token) throws InterruptedException {\n        esperandoB++;\n        notifyAll();\n\n        while (!aPreparado) {\n            wait();\n        }\n\n        int id;\n        tokensB[id=numBesperaA++]=token;\n        esperandoB--;\n        notifyAll();\n\n        while (aPreparado) {\n            wait();\n        }\n        return tokensA[id];\n    }\n}\n</code></pre>"},{"location":"exams/2025/extra/#problema-4","title":"Problema 4","text":"<p>Se dispone de un grafo no dirigido que relaciona ciudades y las personas que han viajado entre ellas.</p> <ul> <li>Nodo representa a una ciudad.</li> <li>Arista representa a una persona que ha realizado un viaje entre dos ciudades.</li> </ul> <p>En el grafo no existe m\u00e1s de una arista entre las mismas dos ciudades con la misma persona.</p> <p>\\FloatBarrier \\noindent \\begin{center} \\includegraphics[width=\\textwidth]{diagram.pdf} \\end{center} \\FloatBarrier</p> <ul> <li>(a) (5 puntos) Se pide implementar el siguiente m\u00e9todo:</li> </ul> <pre><code>/**\n * Devuelve una lista con todas las ciudades que ha visitado la persona cuyo\n * nombre se pasa por par\u00e1metro.\n * El resultado no debe contener ciudades repetidas.\n *\n * @param nombre Nombre de la persona de la que se quiere saber qu\u00e9 ciudades ha visitado.\n * @param grafo Grafo no dirigido que modela los viajes.\n * @return Lista de nombres de ciudades visitadas (sin repeticiones).\n */\npublic List&lt;String&gt; ciudadesDePersona(String nombre, GrafoNoDirigido grafo)\n</code></pre> Mostrar soluci\u00f3n <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CiudadesDePersona {\n\n    /**\n     * Genera una lista de las ciudades que ha visitado la persona indicada,\n     * sin ciudades repetidas.\n     *\n     * @param nombre nombre de la persona\n     * @param grafo  grafo de ciudades y viajes\n     * @return lista (sin repeticiones) de ciudades visitadas\n     */\n    public List&lt;String&gt; ciudadesDePersona(String nombre, GrafoNoDirigido grafo) {\n\n        List&lt;String&gt; listaCiudades = new ArrayList&lt;&gt;();\n        Set&lt;Nodo&gt; nodos = grafo.getNodos();\n\n        for (Nodo nodo : nodos) {\n            for (EnlaceNoDirigido enlace : nodo.getEnlaces()) {\n                if (nombre.equals(enlace.getPersona().getNombre())) {\n                    /* A\u00f1adimos ambas ciudades del viaje */\n                    addCiudad(enlace.getUno(), listaCiudades);\n                    addCiudad(enlace.getOtro(enlace.getUno()), listaCiudades);\n                }\n            }\n        }\n        return listaCiudades;\n    }\n\n    /** A\u00f1ade la ciudad del nodo si todav\u00eda no est\u00e1 en la lista. */\n    private void addCiudad(Nodo nodo, List&lt;String&gt; lista) {\n        String ciudad = nodo.getCiudad();\n        if (!lista.contains(ciudad)) {\n            lista.add(ciudad);\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2025/extra/#problema-5","title":"Problema 5","text":"<ul> <li>(a) (6 puntos) Desarrolle un m\u00e9todo que permita saber cual es la pieza (el tipo de pieza) que se usa en el movimiento m\u00e1s utilizado como apertura de las blancas (primera pieza que mueven) en el conjunto de partidas cargadas. De la misma manera, desarrolle un m\u00e9todo que permita saber cual es el movimiento m\u00e1s utilizado como apertura de las negras (primera pieza que mueven) en contestaci\u00f3n a la apertura de las blancas m\u00e1s utilizada. Consejo: piense qu\u00e9 piezas se pueden mover al inicio de una partida de ajedrez.</li> </ul> Mostrar soluci\u00f3n <p>M\u00e9todos a incluir en la clase <code>AnalizadorGrafos</code>:</p> <pre><code>public TipoPieza getAperturaBlancas() {\n  Nodo nodoBasico = nodos.get(Tablero.getTableroBasico());\n  Enlace enlaceMayorPeso = obtenerEnlaceMayorPeso(nodoBasico);\n  Tablero destino = enlaceMayorPeso.getDestino().getTablero();\n  return detectarTipoPiezaMovida(destino, 7); // Fila 7 para peones blancos\n}\n\npublic TipoPieza getAperturaNegras() {\n  Nodo nodoBasico = nodos.get(Tablero.getTableroBasico());\n  Enlace primerEnlace = obtenerEnlaceMayorPeso(nodoBasico);\n  Nodo nodoDestino = primerEnlace.getDestino();\n  Enlace segundoEnlace = obtenerEnlaceMayorPeso(nodoDestino);\n  Tablero destino = segundoEnlace.getDestino().getTablero();\n  return detectarTipoPiezaMovida(destino, 2); // Fila 2 para peones negros\n}\n\nprivate Enlace obtenerEnlaceMayorPeso(Nodo nodo) {\n  Enlace enlaceMayorPeso = null;\n  for (Enlace enlace : nodo.getEnlaces()) {\n    if (enlaceMayorPeso == null || enlace.getPeso() &gt; enlaceMayorPeso.getPeso()) {\n      enlaceMayorPeso = enlace;\n    }\n  }\n  return enlaceMayorPeso;\n}\n\nprivate TipoPieza detectarTipoPiezaMovida(Tablero tablero, int fila) {\n  Pieza matriz[][] = tablero.getMatrizPiezas();\n  for (int col = 0; col &lt; 8; col++) {\n    Pieza pieza = matriz[fila][col];\n    if (pieza == null) {\n      return TipoPieza.PEON; // Si falta algun pe\u00f3n, se habr\u00e1 movido\n    }\n  }\n  return TipoPieza.CABALLO; // Si est\u00e1n todos, ser\u00e1 un caballo\n}\n</code></pre>"},{"location":"exams/2025/extra/#problema-6","title":"Problema 6","text":"<ul> <li>(a) (4 puntos) Modifique el c\u00f3digo de sus pr\u00e1cticas para que las hebras resuelvan primero las tareas (TareaCamino) que tengan un camino m\u00e1s corto.</li> </ul> Mostrar soluci\u00f3n <p>Modificaciones necesarias: 1. En la clase <code>TareaCamino</code>: - Implementar la interfaz <code>Comparable&lt;TareaCamino&gt;</code></p> <pre><code>class TareaCamino implements Comparable&lt;TareaCamino&gt; {\n    public final Nodo nodoAVisitar;\n    public final List&lt;Nodo&gt; caminoRecorrido;\n\n    public TareaCamino(Nodo nodoAVisitar, List&lt;Nodo&gt; caminoRecorrido) {\n        this.nodoAVisitar = nodoAVisitar;\n        this.caminoRecorrido = caminoRecorrido;\n    }\n\n    @Override\n    public int compareTo(TareaCamino otra) {\n        return Integer.compare(this.caminoRecorrido.size(), \n                              otra.caminoRecorrido.size());\n    }\n}\n</code></pre> <p>2. En el m\u00e9todo <code>getTarea()</code> de <code>PoolHebras</code>: - Ordenar la lista antes de extraer la tarea</p> <pre><code>public synchronized TareaCamino getTarea(HebraWorker hw) throws InterruptedException {\n    while (tareas.isEmpty() &amp;&amp; hw.keepWorking) {\n        wait();\n    }\n    if (!hw.keepWorking) {\n        return null;\n    }\n\n    // Ordenar tareas por longitud de camino antes de extraer\n    Collections.sort(tareas);\n    return tareas.remove(0);\n}\n</code></pre>"},{"location":"exams/2025/extra_ex01/","title":"Extra ex01","text":"<p>Se quiere desarrollar un algoritmo al que llamaremos split sort. Este algoritmo es similar a la fase de merge en merge sort. Se parte de dos arrays <code>a</code> y <code>b</code>, de igual tama\u00f1o, sin elementos repetidos y ya ordenados de menor a mayor. A diferencia de merge, nuestro split sort funciona en el sitio (in place). Tras aplicar el algoritmo:</p> <ul> <li>Los menores elementos deben quedar en <code>a</code></li> <li>Los mayores elementos deben quedar en <code>b</code></li> <li>Tanto <code>a</code> como <code>b</code> siguen estando ordenados correctamente</li> <li>El conjunto de n\u00fameros (es decir, n\u00fameros contenidos en <code>a</code> o <code>b</code>) siguen siendo los mismos</li> </ul> <p>Por ejemplo, si partimos de <code>a = [1, 3, 5, 7]; b = [2, 4, 6, 8]</code>, el resultado ser\u00eda <code>a = [1, 2, 3, 4]; b = [5, 6, 7, 8]</code>.</p> <p>Se pide:</p> <ul> <li>(a) (0.5 puntos) Describir al menos 5 casos en los que probar este c\u00f3digo y el resultado esperado. Se valorar\u00e1 que los casos sean distintos y representativos.</li> </ul> Mostrar soluci\u00f3n <p>Casos de prueba para el m\u00e9todo <code>splitSort</code>:</p> <ul> <li>Caso 1: <code>a = [1, 3, 5, 7]</code>, <code>b = [2, 4, 6, 8]</code> \u2192 Resultado esperado: <code>a = [1, 2, 3, 4]</code>, <code>b = [5, 6, 7, 8]</code></li> <li>Caso 2: <code>a = [10, 20, 30]</code>, <code>b = [15, 25, 35]</code> \u2192 Resultado esperado: <code>a = [10, 15, 20]</code>, <code>b = [25, 30, 35]</code></li> <li>Caso 3: <code>a = [5, 10]</code>, <code>b = [1, 2]</code> \u2192 Resultado esperado: <code>a = [1, 2]</code>, <code>b = [5, 10]</code></li> <li>Caso 4: <code>a = [1000, 2000]</code>, <code>b = [1500, 2500]</code> \u2192 Resultado esperado: <code>a = [1000, 1500]</code>, <code>b = [2000, 2500]</code></li> <li>Caso 5: <code>a = [3]</code>, <code>b = [4]</code> \u2192 Resultado esperado: <code>a = [3]</code>, <code>b = [4]</code></li> </ul> <ul> <li> <p>(b) (4 puntos) Desarrollar el c\u00f3digo del m\u00e9todo <code>void splitSort(int[] a, int[] b)</code>. Se valorar\u00e1:</p> <ul> <li>Que los arrays contengan los mismos elementos al final</li> <li>Que <code>a</code> contenga los elementos menores y <code>b</code> los mayores</li> <li>Que ambos arrays est\u00e9n ordenados al terminar</li> <li>No se permite crear nuevos arrays ni listas. Solo pueden modificarse <code>a</code> y <code>b</code>.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n del m\u00e9todo <code>splitSort</code> en Java: <pre><code>public static void splitSort(int[] a, int[] b) {\n  int n = a.length;\n  int m = b.length;\n\n  for (int i = 0; i &lt; n; i++) {\n    if (a[i] &gt; b[0]) {\n      // Intercambiar a[i] con el menor de b\n      int temp = a[i];\n      a[i] = b[0];\n      b[0] = temp;\n\n      // Reordenar b (insertion sort para mantenerlo ordenado)\n      int j = 0;\n      while (j + 1 &lt; m &amp;&amp; b[j] &gt; b[j + 1]) {\n        int aux = b[j];\n        b[j] = b[j + 1];\n        b[j + 1] = aux;\n        j++;\n      }\n    }\n  }\n}\n</code></pre></p> <ul> <li>(c) (0.5 puntos) Escribir el c\u00f3digo necesario para probar el m\u00e9todo <code>splitSort</code> en al menos 1 caso. </li> </ul> Mostrar soluci\u00f3n <pre><code>@Test\npublic void testTodosMenoresEnB() {\n  int[] a = {10, 12, 14};\n  int[] b = {1, 2, 3};\n  Ejercicio4.splitSort(a, b);\n  assertSortedSplit(new int[]{1, 2, 3}, new int[]{10, 12, 14}, a, b);\n}\n\n@Test\npublic void testYaOrdenado() {\n  int[] a = {1, 2, 3};\n  int[] b = {4, 5, 6};\n  Ejercicio4.splitSort(a, b);\n  assertSortedSplit(new int[]{1, 2, 3}, new int[]{4, 5, 6}, a, b);\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2025/extra_ex02/","title":"Extra ex02","text":"<p>La multiplicaci\u00f3n de n\u00fameros enteros grandes es costosa para los ordenadores, por lo que existen t\u00e9cnicas como el algoritmo de Karatsuba que hacen m\u00e1s eficiente este c\u00e1lculo. El algoritmo de Karatsuba utiliza la t\u00e9cnica de divide y vencer\u00e1s. Se basa en dividir los n\u00fameros a multiplicar en partes m\u00e1s peque\u00f1as (m\u00e1s sencillas de manejar), operar sobre ellas y luego combinar los resultados para obtener el producto final. Por simplicidad, se asume que todas las operaciones se realizan con variables de tipo <code>int</code>.</p> <p>Dados dos n\u00fameros enteros \\(x\\) e \\(y\\), se pueden representar como: \\vspace{-0.2cm} \\begin{equation} x = a \\cdot 10^n + b \\hspace{3cm} y = c \\cdot 10^n + d \\end{equation} \\vspace{-0.2cm} donde \\(a\\), \\(b\\), \\(c\\) y \\(d\\) son enteros, y \\(2n\\) es el n\u00famero total de d\u00edgitos que tienen tanto \\(x\\) como \\(y\\).</p> <p>El algoritmo de Karatsuba nos indica que: \\vspace{-0.2cm} \\begin{equation} x \\cdot y = ac \\cdot 10^{2n} + (ad + bc) \\cdot 10^n + bd \\end{equation} \\vspace{-0.2cm} Esto se puede reescribir como: \\vspace{-0.2cm} \\begin{equation} x \\cdot y = z_1 \\cdot 10^{2n} + z_2 \\cdot 10^n + z_3 \\end{equation} \\vspace{-0.2cm} donde\\footnotemark: \\(z_1 = ac\\), \\(z_3 = bd\\), \\(z_2 = (a + b)(c + d) - z_1 - z_3\\)</p> <p>\\footnotetext{No es necesario para resolver el ejercicio. Para obtener \\(z_2\\), partimos de la identidad \\((a + b)(c + d) = ac + ad + bc + bd = z_1 + ad + bc + z_3\\). Despejando, \\(ad + bc = (a + b)(c + d) - z_1 - z_3\\), por tanto, \\(z_2 = ad + bc = (a + b)(c + d) - z_1 - z_3\\).}</p> <p>As\u00ed, en lugar de realizar 4 multiplicaciones (\\(ac\\), \\(ad\\), \\(bc\\), y \\(bd\\)), solo se hacen 3 multiplicaciones (\\(z_1\\), \\(z_3\\), y \\((a+b)(c+d)\\)) y algunas operaciones m\u00e1s r\u00e1pidas como sumas y restas. Esta idea se puede aplicar de forma recursiva, hasta que se multipliquen \u00fanicamente n\u00fameros de un solo d\u00edgito.</p>","tags":["complejidad"]},{"location":"exams/2025/extra_ex02/#ejemplo","title":"Ejemplo","text":"<p>Supongamos que se desea multiplicar los n\u00fameros \\(x = 56341032\\) e \\(y = 72916764\\). Primero, se dividen ambos n\u00fameros en dos partes:</p> <ul> <li>\\(x = 56341032 = 5634 \\cdot 10^4 + 1032 \\Rightarrow a = 5634,\\, b = 1032\\)</li> <li>\\(y = 72916764 = 7291 \\cdot 10^4 + 6764 \\Rightarrow c = 7291,\\, d = 6764\\)</li> </ul> <p>Entonces, aplicamos la f\u00f3rmula anterior:</p> <ul> <li>\\(z_1 = ac = 5634 \\cdot 7291\\)</li> <li>\\(z_3 = bd = 1032 \\cdot 6764\\)</li> <li>\\(z_2 = (a + b)(c + d) - z_1 - z_3 = (5634 + 1032)(7291 + 6764) - z_1 - z_3 = 6666 \\cdot 14055 - z_1 - z_3\\)</li> </ul> <p>Finalmente, el resultado se obtiene como: \\vspace{-0.2cm} \\begin{equation} x \\cdot y = z_1 \\cdot 10^8 + z_2 \\cdot 10^4 + z_3 \\end{equation} \\vspace{-0.2cm} Para calcular \\(z_1\\), \\(z_2\\) y \\(z_3\\), se aplicar\u00eda recursivamente el algoritmo de Karatsuba a las parejas: \\vspace{-0.1cm} \\begin{equation} (5634, 7291)\\hspace{2cm}(1032, 6764)\\hspace{2cm}(6666, 14055) \\end{equation} \\vspace{-1.0cm}</p> <p>\\subsection*{Preguntas}</p> <ul> <li>(a) (1 punto) Razone c\u00f3mo se aplicar\u00eda este algoritmo para multiplicar los n\u00fameros 34 y 78. \u00bfCu\u00e1ntas veces deber\u00eda llamarse al m\u00e9todo <code>karatsuba(int x, int y)</code> y con qu\u00e9 par\u00e1metros?</li> </ul> Mostrar soluci\u00f3n <p>Para multiplicar los n\u00fameros 34 y 78 utilizando el algoritmo de Karatsuba, primero dividimos ambos n\u00fameros en dos partes: \\begin{itemize}   \\item \\(x = 34 = 3 \\cdot 10 + 4 \\Rightarrow a = 3, b = 4\\)   \\item \\(y = 78 = 7 \\cdot 10 + 8 \\Rightarrow c = 7, d = 8\\) \\end{itemize} Calculamos: \\begin{itemize}   \\item \\(z_1 = ac = 3 \\cdot 7 \\Rightarrow karatsuba(3,7) = 21\\)    \\item \\(z_3 = bd = 4 \\cdot 8 \\Rightarrow karatsuba(4,8) = 32\\)   \\item \\(z_2 = (a+b)(c+d) - z_1 - z_3 = (3 + 4)(7 + 8) - z_1 - z_3 = 7 \\cdot 15 - z_1 - z_3 \\Rightarrow karatsuba(7,15) = 105\\) \\end{itemize}</p> <p>Expandiendo <code>karatsuba(7,15)</code>: \\begin{itemize}   \\item \\(x = 7 = 0 \\cdot 10 + 7 \\Rightarrow a = 0, b = 7\\)   \\item \\(y = 15 = 1 \\cdot 10 + 5 \\Rightarrow c = 1, d = 5\\)   \\item \\(z_1 = ac = 0 \\cdot 1 \\Rightarrow karatsuba(0,1) = 0\\)    \\item \\(z_3 = bd = 7 \\cdot 5 \\Rightarrow karatsuba(7,5) = 35\\)    \\item \\(z_2 = (a+b)(c+d) - z_1 - z_3 = (0 + 7)(1 + 5) - z_1 - z_3 = 7 \\cdot 6 - z_1 - z_3 \\Rightarrow karatsuba(7,6) = 42\\)  \\end{itemize}</p> <p>Con esto ya contestar\u00edamos a la pregunta ya que tenemos todas las llamadas recursivas a <code>karatsuba</code>:</p> \\[\\begin{center} \\texttt{karatsuba(34,78)} \\hspace{1cm} \\texttt{karatsuba(3,7)} \\hspace{1cm} \\texttt{karatsuba(4,8)} \\hspace{1cm} \\texttt{karatsuba(7,15)}\\\\ \\texttt{karatsuba(0,1)} \\hspace{1cm} \\texttt{karatsuba(7,5)} \\hspace{1cm} \\texttt{karatsuba(7,6)} \\end{center}\\] <p>En total, se llama al m\u00e9todo <code>karatsuba</code> 7 veces, la original m\u00e1s 6 llamadas recursivas.</p> <p>Si queremos completar el c\u00e1lculo (no se pide en el ejercicio), reconstruimos primero karatsuba(7,15) como:</p> <ul> <li>\\(z_2 = 42 - 35 = 7\\)</li> <li>\\(7 \\cdot 15 = z_1\\cdot 100 + z_2 \\cdot 10 + z_3 = 0 \\cdot 100 + 7 \\cdot 10 + 35 = 0 + 70 + 35 = 105\\)</li> </ul> <p>Finalmente, reconstruimos el resultado de la multiplicaci\u00f3n original:</p> <ul> <li>\\(z_2 = 105 - 21 - 32 = 52\\)</li> <li>\\(34 \\cdot 78 = z_1 \\cdot 100 + z_2 \\cdot 10 + z_3 = 21 \\cdot 100 + 52 \\cdot 10 + 32 = 2100 + 520 + 32 = 2652\\)</li> </ul> <ul> <li> <p>(b) (2 puntos) Realice una implementaci\u00f3n del algoritmo de Karatsuba en Java. Para ello, implemente un m\u00e9todo <code>karatsuba</code> que reciba como par\u00e1metros dos n\u00fameros enteros <code>x</code> e <code>y</code> y devuelva el resultado de la multiplicaci\u00f3n utilizando dicho algoritmo. La cabecera del m\u00e9todo es <code>public int karatsuba(int x, int y)</code>. El m\u00e9todo no puede realizar multiplicaciones de n\u00fameros de m\u00e1s de un d\u00edgito y todas las multiplicaciones se realizan utilizando el algoritmo de Karatsuba. Se asume que los n\u00fameros <code>x</code> e <code>y</code>, con los que se invoca inicialmente el m\u00e9todo, tendr\u00e1n el mismo n\u00famero de d\u00edgitos. Suponga que existen los siguientes m\u00e9todos auxiliares:</p> </li> <li> <p><code>static int[] splitint(int num, int digitos)</code> que recibe un n\u00famero entero <code>num</code> y un n\u00famero de d\u00edgitos. El m\u00e9todo parte el n\u00famero <code>num</code> en dos partes de <code>digitos</code> d\u00edgitos cada una y devuelve un array con las dos partes. Por ejemplo, si <code>num = 12345678</code> y <code>digitos = 4</code>, el m\u00e9todo devolver\u00e1 el array <code>[1234, 5678]</code>. El m\u00e9todo rellena con ceros a la izquierda si es necesario. Si <code>num = 123</code> y <code>digitos = 2</code>, el m\u00e9todo devolver\u00e1 el array <code>[01, 23]</code>.</p> </li> <li><code>static int length(int num)</code> que recibe un n\u00famero entero <code>num</code> y devuelve el n\u00famero de d\u00edgitos que tiene. Por ejemplo, si <code>num = 12345</code>, el m\u00e9todo devolver\u00e1 <code>5</code>.</li> <li><code>static int pow10(int num, int exp)</code> que recibe un n\u00famero entero <code>num</code> y un exponente <code>exp</code>, y devuelve como resultado <code>num</code> con <code>exp</code> ceros a la izquierda. Por ejemplo, si <code>num = 123</code> y <code>exp = 2</code>, el m\u00e9todo devolver\u00e1 <code>12300</code>.</li> </ul> Mostrar soluci\u00f3n <p>Implementaci\u00f3n en Java:</p> <pre><code>public static int karatsuba(int x, int y) {\n  if (x &lt; 10 &amp;&amp; y &lt; 10) {\n    return x * y;\n  }\n\n  int n = (Math.max(length(x), length(y))+1) / 2; // Redondeamos hacia arriba para dividir en dos partes\n\n  int[] xParts = splitint(x, n);\n  int[] yParts = splitint(y, n);\n  int a = xParts[0];\n  int b = xParts[1];\n  int c = yParts[0];\n  int d = yParts[1];\n\n  int z1 = karatsuba(a, c);\n  int z3 = karatsuba(b, d);\n  int z2 = karatsuba(a + b, c + d) - z1 - z3;\n\n  return z1 * pow10(1, 2 * n) + z2 * pow10(1, n) + z3;\n}\n</code></pre> <ul> <li>(c) (2 puntos) En este tipo de algoritmos recursivos, es com\u00fan que se realicen m\u00faltiples llamadas al mismo m\u00e9todo con los mismos par\u00e1metros. Una forma de optimizar estos algoritmos es a\u00f1adir una cache para evitar estos c\u00e1lculos repetidos. Esto significa que, si se llama al m\u00e9todo <code>karatsuba</code> con los mismos par\u00e1metros que en una llamada anterior, se devolver\u00e1 el resultado ya calculado en lugar de volver a calcularlo. Sin repetir el c\u00f3digo del m\u00e9todo del apartado anterior, indique que modificaciones har\u00eda para implementar esta cache. </li> </ul> <p>Nota: No es necesario preocuparse por posibles desbordamientos del tipo <code>int</code>. Se asume que los casos de prueba no exceder\u00e1n su l\u00edmite.</p> Mostrar soluci\u00f3n <p>Para implementar una cache, se puede utilizar un <code>Map</code> para almacenar los resultados ya calculados. Aqu\u00ed est\u00e1 la modificaci\u00f3n del m\u00e9todo <code>karatsuba</code>:</p> <pre><code>  // Fuera del m\u00e9todo\n  private static Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;();\n\n  public static int karatsuba(int x, int y) {\n    String key = x + \",\" + y;\n    if (cache.containsKey(key)) {\n      return cache.get(key);\n    }\n\n    // el resto del c\u00f3digo es igual al anterior\n\n    cache.put(key, result); \n    return result;\n  }\n</code></pre>","tags":["complejidad"]},{"location":"exams/2025/extra_ex03/","title":"Extra ex03","text":"<p>Tres hebras Java de dos tipos diferentes, tipos A y B, entran en una sala para intercambiar tokens. Las hebras de tipo A solo salen de la sala cuando han intercambiado tokens con las dos hebras de tipo B, y las hebras de tipo B intercambian un solo token, cada una, con la hebra de tipo A. Las tres hebras no salen de la sala mientras que todas no han intercambiado sus tokens, y cuando las tres han intercambiado deben salir de la sala y m\u00e1s adelante volver a entrar para iniciar nuevos intercambios. Las hebras solo empiezan a intercambiar tokens cuando est\u00e1n las tres en la sala.</p> <ul> <li>(a) (5 puntos) Desarrollar un monitor Java que represente la ejecuci\u00f3n de las hebras en la sala. En esta implementaci\u00f3n, para que una hebra B salga de la sala, la hebra A con la que intercambian token debe haber intercambiado con dos hebras de tipo B. Mientras las 3 hebras est\u00e1n realizando el intercambio, ninguna otra hebra puede entrar en la sala. El monitor Java de la sala debe implementar el siguiente interfaz Java:</li> </ul> <pre><code> public interface ISalaTokens {\n\n    // Entrada en la sala de la hebra A. Entra con 2 tokens y el resultado es un array \n    // con los dos tokens que le dan las hebras B\n    String[] entraA(String token1, String token2) throws InterruptedException;\n\n    // Entrada en la sala de las hebras B con 1 token cada una y el resultado es el token\n    // que le ha dado la hebra A\n    String entraB(String token) throws InterruptedException;    \n}\n</code></pre> <p>Podemos suponer que el c\u00f3digo de las hebras es el siguiente: <pre><code>\\noindent\n\\begin{minipage}[t]{0.48\\linewidth}\n\\raggedright\n\\begin{lstlisting}[\n  language=Java,\n  keywordstyle=\\color{blue}\\bfseries,\n  commentstyle=\\color{gray}\\itshape,\n  stringstyle=\\color{red},\n  identifierstyle=\\color{black},\n  basicstyle=\\ttfamily\\small,\n  frame=single,\n  breaklines=true\n]\n// Hebra de tipo A\nprivate Set&lt;String&gt; colec=new HashSet&lt;String&gt;();\nprivate ISalaTokens sala;\nprivate String[] tokens = new String[2]; \npublic void run() {\n  while (true) {\n    tokens=buscarTokensA();\n    if (!colec.contains(tokens[0]) &amp;&amp; \n        !colec.contains(tokens[1]))\n      tokens=sala.entraA(tokens[0],tokens[1]);\n    colec.add(tokens[0]); colec.add(tokens[1]);\n  }\n}\n\\end{lstlisting}\n\\end{minipage}%\n\\hfill\n\\begin{minipage}[t]{0.48\\linewidth}\n\\raggedleft\n\\begin{lstlisting}[\n  language=Java,\n  keywordstyle=\\color{blue}\\bfseries,\n  commentstyle=\\color{gray}\\itshape,\n  stringstyle=\\color{red},\n  identifierstyle=\\color{black},\n  basicstyle=\\ttfamily\\small,\n  frame=single,\n  breaklines=true\n]\n// Hebra de tipo B\nprivate Set&lt;String&gt; colec=new HashSet&lt;String&gt;();\nprivate ISalaTokens sala;\nprivate String token=null;\npublic void run() {\n  while (true) {\n    token=buscarTokenB();\n    if (!colec.contains(token))\n      token=sala.entraB(token);\n    colec.add(token);\n  }\n}\n\\end{lstlisting}\n\\end{minipage}%\n</code></pre></p> <p>Nota: Suponga que los m\u00e9todos <code>buscarTokensA</code> y <code>buscarTokenB</code> est\u00e1n implementados y devuelven los tokens necesarios para el intercambio.</p> Mostrar soluci\u00f3n <pre><code>public class SalaTokens implements ISalaTokens {\n    private boolean esperandoA= false;\n    private int esperandoB = 0;\n    private String[] tokensB=new String[2];\n    private String[] tokensA=new String[2];\n\n    private boolean aPreparado = false;\n    private int numBesperaA = 0;\n\n    public synchronized String[] entraA(String token1, String token2) throws InterruptedException {\n        esperandoA=true;\n        while (esperandoB &lt; 2) {\n            wait();\n        }\n\n        aPreparado = true;\n        tokensA[0]=token1;\n        tokensA[1]=token2;\n        numBesperaA = 0;\n        notifyAll();\n\n        while (numBesperaA &lt; 2) {\n            wait();\n        }\n\n        String[] tokens=new String[2];\n        tokens[0]=tokensB[0]; tokens[1]=tokensB[1];\n\n        aPreparado = false;\n        notifyAll();\n        return tokens;\n    }\n\n    public synchronized String entraB(String token) throws InterruptedException {\n        esperandoB++;\n        notifyAll();\n\n        while (!aPreparado) {\n            wait();\n        }\n\n        int id;\n        tokensB[id=numBesperaA++]=token;\n        esperandoB--;\n        notifyAll();\n\n        while (aPreparado) {\n            wait();\n        }\n        return tokensA[id];\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2025/extra_ex04/","title":"Extra ex04","text":"<p>Se dispone de un grafo no dirigido que relaciona ciudades y las personas que han viajado entre ellas.</p> <ul> <li>Nodo representa a una ciudad.</li> <li>Arista representa a una persona que ha realizado un viaje entre dos ciudades.</li> </ul> <p>En el grafo no existe m\u00e1s de una arista entre las mismas dos ciudades con la misma persona.</p> <p>\\FloatBarrier \\noindent \\begin{center} \\includegraphics[width=\\textwidth]{diagram.pdf} \\end{center} \\FloatBarrier</p> <ul> <li>(a) (5 puntos) Se pide implementar el siguiente m\u00e9todo:</li> </ul> <pre><code>/**\n * Devuelve una lista con todas las ciudades que ha visitado la persona cuyo\n * nombre se pasa por par\u00e1metro.\n * El resultado no debe contener ciudades repetidas.\n *\n * @param nombre Nombre de la persona de la que se quiere saber qu\u00e9 ciudades ha visitado.\n * @param grafo Grafo no dirigido que modela los viajes.\n * @return Lista de nombres de ciudades visitadas (sin repeticiones).\n */\npublic List&lt;String&gt; ciudadesDePersona(String nombre, GrafoNoDirigido grafo)\n</code></pre> Mostrar soluci\u00f3n <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CiudadesDePersona {\n\n    /**\n     * Genera una lista de las ciudades que ha visitado la persona indicada,\n     * sin ciudades repetidas.\n     *\n     * @param nombre nombre de la persona\n     * @param grafo  grafo de ciudades y viajes\n     * @return lista (sin repeticiones) de ciudades visitadas\n     */\n    public List&lt;String&gt; ciudadesDePersona(String nombre, GrafoNoDirigido grafo) {\n\n        List&lt;String&gt; listaCiudades = new ArrayList&lt;&gt;();\n        Set&lt;Nodo&gt; nodos = grafo.getNodos();\n\n        for (Nodo nodo : nodos) {\n            for (EnlaceNoDirigido enlace : nodo.getEnlaces()) {\n                if (nombre.equals(enlace.getPersona().getNombre())) {\n                    /* A\u00f1adimos ambas ciudades del viaje */\n                    addCiudad(enlace.getUno(), listaCiudades);\n                    addCiudad(enlace.getOtro(enlace.getUno()), listaCiudades);\n                }\n            }\n        }\n        return listaCiudades;\n    }\n\n    /** A\u00f1ade la ciudad del nodo si todav\u00eda no est\u00e1 en la lista. */\n    private void addCiudad(Nodo nodo, List&lt;String&gt; lista) {\n        String ciudad = nodo.getCiudad();\n        if (!lista.contains(ciudad)) {\n            lista.add(ciudad);\n        }\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2025/extra_ex05/","title":"Extra ex05","text":"<ul> <li>(a) (6 puntos) Desarrolle un m\u00e9todo que permita saber cual es la pieza (el tipo de pieza) que se usa en el movimiento m\u00e1s utilizado como apertura de las blancas (primera pieza que mueven) en el conjunto de partidas cargadas. De la misma manera, desarrolle un m\u00e9todo que permita saber cual es el movimiento m\u00e1s utilizado como apertura de las negras (primera pieza que mueven) en contestaci\u00f3n a la apertura de las blancas m\u00e1s utilizada. Consejo: piense qu\u00e9 piezas se pueden mover al inicio de una partida de ajedrez.</li> </ul> Mostrar soluci\u00f3n <p>M\u00e9todos a incluir en la clase <code>AnalizadorGrafos</code>:</p> <pre><code>public TipoPieza getAperturaBlancas() {\n  Nodo nodoBasico = nodos.get(Tablero.getTableroBasico());\n  Enlace enlaceMayorPeso = obtenerEnlaceMayorPeso(nodoBasico);\n  Tablero destino = enlaceMayorPeso.getDestino().getTablero();\n  return detectarTipoPiezaMovida(destino, 7); // Fila 7 para peones blancos\n}\n\npublic TipoPieza getAperturaNegras() {\n  Nodo nodoBasico = nodos.get(Tablero.getTableroBasico());\n  Enlace primerEnlace = obtenerEnlaceMayorPeso(nodoBasico);\n  Nodo nodoDestino = primerEnlace.getDestino();\n  Enlace segundoEnlace = obtenerEnlaceMayorPeso(nodoDestino);\n  Tablero destino = segundoEnlace.getDestino().getTablero();\n  return detectarTipoPiezaMovida(destino, 2); // Fila 2 para peones negros\n}\n\nprivate Enlace obtenerEnlaceMayorPeso(Nodo nodo) {\n  Enlace enlaceMayorPeso = null;\n  for (Enlace enlace : nodo.getEnlaces()) {\n    if (enlaceMayorPeso == null || enlace.getPeso() &gt; enlaceMayorPeso.getPeso()) {\n      enlaceMayorPeso = enlace;\n    }\n  }\n  return enlaceMayorPeso;\n}\n\nprivate TipoPieza detectarTipoPiezaMovida(Tablero tablero, int fila) {\n  Pieza matriz[][] = tablero.getMatrizPiezas();\n  for (int col = 0; col &lt; 8; col++) {\n    Pieza pieza = matriz[fila][col];\n    if (pieza == null) {\n      return TipoPieza.PEON; // Si falta algun pe\u00f3n, se habr\u00e1 movido\n    }\n  }\n  return TipoPieza.CABALLO; // Si est\u00e1n todos, ser\u00e1 un caballo\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2025/extra_ex06/","title":"Extra ex06","text":"<ul> <li>(a) (4 puntos) Modifique el c\u00f3digo de sus pr\u00e1cticas para que las hebras resuelvan primero las tareas (TareaCamino) que tengan un camino m\u00e1s corto.</li> </ul> Mostrar soluci\u00f3n <p>Modificaciones necesarias: 1. En la clase <code>TareaCamino</code>: - Implementar la interfaz <code>Comparable&lt;TareaCamino&gt;</code></p> <pre><code>class TareaCamino implements Comparable&lt;TareaCamino&gt; {\n    public final Nodo nodoAVisitar;\n    public final List&lt;Nodo&gt; caminoRecorrido;\n\n    public TareaCamino(Nodo nodoAVisitar, List&lt;Nodo&gt; caminoRecorrido) {\n        this.nodoAVisitar = nodoAVisitar;\n        this.caminoRecorrido = caminoRecorrido;\n    }\n\n    @Override\n    public int compareTo(TareaCamino otra) {\n        return Integer.compare(this.caminoRecorrido.size(), \n                              otra.caminoRecorrido.size());\n    }\n}\n</code></pre> <p>2. En el m\u00e9todo <code>getTarea()</code> de <code>PoolHebras</code>: - Ordenar la lista antes de extraer la tarea</p> <pre><code>public synchronized TareaCamino getTarea(HebraWorker hw) throws InterruptedException {\n    while (tareas.isEmpty() &amp;&amp; hw.keepWorking) {\n        wait();\n    }\n    if (!hw.keepWorking) {\n        return null;\n    }\n\n    // Ordenar tareas por longitud de camino antes de extraer\n    Collections.sort(tareas);\n    return tareas.remove(0);\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2025/p1/","title":"Examen 2025 \u2014 Parcial 1","text":""},{"location":"exams/2025/p1/#problema-1","title":"Problema 1","text":""},{"location":"exams/2025/p1/#ejercicio-1-algoritmo-de-seleccion","title":"Ejercicio 1: Algoritmo de selecci\u00f3n","text":"<p>Una estudiante de Teleco est\u00e1 preparando sus planes para hacer un Erasmus el curso que viene. Analizando la oferta de destinos, ha decidido una serie de preferencias:</p> <ul> <li>El pa\u00eds al que m\u00e1s le gustar\u00eda ir es Polonia, sobre cualquier otra variable.</li> <li>Prefiere ir a un destino en el que pueda estar al menos 9 meses de estancia.</li> <li>Si hay varias opciones con una duraci\u00f3n de al menos 9 meses, priorizar\u00e1 los destinos con m\u00e1s plazas disponibles.</li> <li>Est\u00e1 segura de que necesita una beca, as\u00ed que los destinos que no la ofrezcan ir\u00e1n al final de la lista.</li> <li>Si con todos los criterios anteriores no se puede decidir entre dos destinos, se quedar\u00e1 con la universidad cuyo nombre sea mayor lexicogr\u00e1ficamente (la mayor por orden alfab\u00e9tico).</li> </ul> <p>Con esos criterios en mente, ha creado una clase en Java con toda la informaci\u00f3n de los destinos. Ahora necesita implementar un algoritmo que le permita seleccionar el destino que m\u00e1s le conviene. Para empezar, tiene que poder ordenar los destinos seg\u00fan sus preferencias.</p> <pre><code>\\end{minipage}\n\\begin{minipage}[b]{5cm}\n</code></pre> <p></p> <pre><code>\\end{minipage}\n</code></pre> <ol> <li>[ 1.5 puntos ] Modifique la clase <code>DestinoErasmus</code> de forma que pueda ser ordenada seg\u00fan los criterios de la estudiante. No es necesario escribir los constructores, getters y setters, ni los m\u00e9todos toString y equals. </li> </ol> <p>La estudiante est\u00e1 ahora evaluando sus posibilidades y decide que en vez de intentar aplicar al primer destino de su lista, lo har\u00e1 en uno que est\u00e9 menos solicitado. Para ello, suponiendo que a\u00fan no ha ordenado la lista de destinos, quiere saber cual es el destino que estar\u00eda en la posici\u00f3n i-esima despu\u00e9s de ordenarlos.</p> <ol> <li>[ 2 puntos ] Implemente un algoritmo que permita encontrar, en una lista desordenada, el elemento que ocupar\u00eda la posici\u00f3n <code>i</code> si la lista estuviera ordenada. La nota de este ejercicio depender\u00e1 de la eficiencia del algoritmo propuesto. Utilice la siguiente cabecera de m\u00e9todo:</li> </ol> <pre><code>public DestinoErasmus destinoEnPosicion(List&lt;DestinoErasmus&gt; destinos, int i)\n</code></pre> <ol> <li> <p>[ 1 punto ] Analice la complejidad del algoritmo desarrollado en funci\u00f3n de <code>n</code>, el n\u00famero de destinos en la lista, y de <code>i</code>, la posici\u00f3n del destino que se quiere encontrar. Nota: La respuesta debe estar justificada y solo se valorar\u00e1 si el algoritmo cumple con el enunciado.</p> </li> <li> <p>[ 0.5 puntos ] Existe una soluci\u00f3n para el algoritmo pedido llamada <code>QuickSelect</code>, que se basa en el algoritmo de ordenaci\u00f3n <code>QuickSort</code>. Sin necesidad de escribir el c\u00f3digo, razone qu\u00e9 complejidad tendr\u00e1 esta soluci\u00f3n, en media, en funci\u00f3n de <code>n</code> e <code>i</code>.</p> </li> </ol> Mostrar soluci\u00f3n <ol> <li></li> </ol> <p>Para hacer que los objetos <code>DestinoErasmus</code> sean ordenables, hay que implementar la interfaz <code>Comparable</code> y se sobrecargar el m\u00e9todo <code>compareTo</code>:</p> <pre><code>public class DestinoErasmus implements Comparable&lt;DestinoErasmus&gt; {\n\n    @Override\n    public int compareTo(DestinoErasmus otro) {\n        if (this.pais.equals(\"Polonia\") &amp;&amp; !otro.pais.equals(\"Polonia\")) return -1;\n        if (!this.pais.equals(\"Polonia\") &amp;&amp; otro.pais.equals(\"Polonia\")) return 1;\n        if (this.duracion &lt; 9 &amp;&amp; otro.duracion &gt;= 9) return 1;\n        if (this.duracion &gt;= 9 &amp;&amp; otro.duracion &lt; 9) return -1;\n        if (this.plazas &lt; otro.plazas) return 1;\n        if (this.plazas &gt; otro.plazas) return -1;\n        if (!this.beca &amp;&amp; otro.beca) return 1;\n        if (this.beca &amp;&amp; !otro.beca) return -1;\n        return this.universidad.compareTo(otro.universidad);\n    }\n}\n</code></pre> <ol> <li></li> </ol> <p>Existen varias maneras de resolver el problema. La m\u00e1s sencilla es ordenar la lista y devolver el elemento en la posici\u00f3n <code>i</code>. Sin embargo, esto no es eficiente, ya que los algoritmos de ordenaci\u00f3n vistos tienen una complejidad de <code>O(n log n)</code> u <code>O(n^2)</code>. Para resolver el problema sin tener que ordenar la lista completa, se puede ir ordenando la lista hasta llegar a la posici\u00f3n <code>i</code> deseada. Un ejemplo basado en la ordenaci\u00f3n por selecci\u00f3n ser\u00eda:</p> <pre><code>public DestinoErasmus destinoEnPosicion(List&lt;DestinoErasmus&gt; destinos, int i) {\n        if (i &lt; 0 || i &gt;= destinos.size()) return null;\n        List&lt;DestinoErasmus&gt; copia = new ArrayList&lt;&gt;(destinos);\n        for (int j = 0; j &lt;= i; j++) {\n            int minIndex = j;\n            for (int k = j + 1; k &lt; copia.size(); k++) {\n                if (copia.get(k).compareTo(copia.get(minIndex)) &lt; 0) {\n                    minIndex = k;\n                }\n            }\n            DestinoErasmus temp = copia.get(j);\n            copia.set(j, copia.get(minIndex));\n            copia.set(minIndex, temp);\n        }\n        return copia.get(i);\n    }\n</code></pre> <ol> <li></li> </ol> <p>Con la soluci\u00f3n anterior, el algoritmo tiene una complejidad de <code>O(i*n)</code>, ya que se recorre la lista <code>i</code> veces, y en cada iteraci\u00f3n se recorre el resto de la lista (<code>n</code> elementos) para encontrar el m\u00ednimo.</p> <ol> <li></li> </ol> <p>La soluci\u00f3n <code>QuickSelect</code> tiene una complejidad media de <code>O(n)</code>. El algoritmo se basa en <code>Quicksort</code>, que va dividiendo la lista en dos partes seg\u00fan un pivote. Para este problema no ser\u00eda necesario ordenar toda la lista, sino que se podr\u00eda parar cuando se encuentra el pivote que acabe en la posici\u00f3n <code>i</code> deseada. </p>"},{"location":"exams/2025/p1/#problema-2","title":"Problema 2","text":""},{"location":"exams/2025/p1/#ejercicio-2-diccionariotrie","title":"Ejercicio 2: <code>DiccionarioTrie</code>","text":"<p>Se requiere implementar <code>DiccionarioTrie</code>, un tipo de diccionario que almacena valores de tipo <code>int</code> asociados a claves de tipo <code>String</code>. Esta clase ser\u00e1 similar a <code>DiccionarioArbol</code>, salvo que los nodos estar\u00e1n representados por la clase <code>NodoTrie</code>. Se proporciona el siguiente c\u00f3digo:</p> <pre><code>class NodoTrie {\n    public Map&lt;char, NodoTrie&gt; hijos;\n    public int valor;\n    public NodoTrie(int valor) {\n        this.valor = valor;\n        this.hijos = new ArrayMap&lt;char, NodoTrie&gt;();\n    }\n}\nclass DiccionarioTrie {\n    private NodoTrie raiz;\n    public DiccionarioTrie() {\n        this.raiz = new NodoTrie(0);\n    } ...\n}\n</code></pre> <p>Adem\u00e1s, se muestra la estructura de un <code>DiccionarioTrie</code> con 3 palabras (<code>CASA</code>, <code>CALLE</code> y <code>CERO</code>):</p> <p></p> <p>El n\u00famero de cada nodo representa su valor. Las letrasFuerzaBruta en las relaciones entre nodos corresponden a una clave en el diccionario <code>hijos</code> de cada nodo, cuyo valor es el nodo representado a la derecha. N\u00f3tese que, adem\u00e1s de los nodos correspondientes a cada palabra, la estructura muestra varios nodos intermedios con valor <code>0</code>. Estos nodos corresponden a prefijos de alguna de las palabras guardadas (p.e., <code>CAS</code>, <code>CAL</code>, <code>CE</code>).</p> <p>Se pide:</p> <ol> <li>[ 0.5 puntos ] Dibuje el estado de un <code>DiccionarioTrie</code> en que se han a\u00f1adido las palabras <code>aprobar</code>, <code>adsw</code> y <code>nota</code>, con valores <code>100</code>, <code>200</code> y <code>300</code>, respectivamente.</li> <li>[ 1.5 puntos ] Implemente el m\u00e9todo <code>put(String clave, int valor)</code>. El m\u00e9todo debe asignar el valor dado a la clave dada. Si el diccionario ya conten\u00eda esa clave, su valor se sobreescribe.</li> <li>[ 2 puntos ] Implemente el m\u00e9todo <code>Integer sum(String clave)</code>. El m\u00e9todo devuelve la suma de los valores asociados a todas las palabras que empiecen por la clave dada (prefijo). Para el diccionario mostrado en el ejemplo, la operaci\u00f3n <code>sum(\"ca\")</code> devolver\u00eda el valor <code>2</code>, y <code>sum(\"\")</code> devolver\u00eda <code>4</code>.</li> <li>[ 1 punto ] Razone el orden de complejidad en tiempo de ejecuci\u00f3n en el caso peor para los m\u00e9todos <code>put</code> y <code>sum</code> en funci\u00f3n de: el n\u00famero de palabras (<code>n</code>), la longitud de la palabra m\u00e1s larga (<code>l</code>) y la longitud de la clave dada como argumento (<code>k</code>). Es decir, calcule <code>T(n, l, k)</code>.</li> </ol> Mostrar soluci\u00f3n <ol> <li></li> </ol> <p></p> <p>2.</p> <pre><code>    public void put(String palabra, int valor) {\n        NodoTrie target = this.raiz;\n        for(int i=0; i&lt;palabra.length(); i++) {\n            char c = palabra.getCharAt(i);\n            if (!target.hijos.contains(c)) {\n                target.hijos.insert(c, new NodoTrie(c, 0));\n            }\n            target = target.hijos.get(c);\n        }\n        target.valor = valor;\n    }\n</code></pre> <p>3.</p> <p>Hay que encontrar el nodo correspondiente al prefijo, y despu\u00e9s sumar todos los valores a partir de ese nodo (<code>sumFrom</code>).</p> <pre><code>    public int sum(String prefijo) {\n        NodoTrie target = this.raiz;\n        for(int i=0; i&lt;prefijo.length(); i++) {\n            char c = palabra.getCharAt(i);\n            if (!target.hijos.contains(c)) {\n                return 0;\n            }\n            target = target.hijos.get(c);\n        }\n        return this.sumFrom(prefijo, target);\n    }\n\n    public int sumFrom(NodoTrie nodo) {\n        int cuenta = nodo.valor;\n        for(NodoTrie hijo: nodo.hijos.values()) {\n            cuenta += sumFrom(hijo);\n        }\n        return cuenta;\n    }\n</code></pre> <p>4.</p> <ul> <li><code>put</code>: <code>T(n, l, k) = O(k)</code> en todos los casos, porque se recorre o a\u00f1ade un nodo por cada letra en la palabra clave.</li> <li><code>sum</code>: El caso peor es aquel en que todas las palabras tienen la longitud m\u00e1xima (<code>l</code>), y coinciden en prefijo con la clave dada (<code>k</code>), pero no coinciden en ninguna otra letra. En ese caso, se recorren <code>k</code> nodos hasta llegar al prefijo (profundidad <code>k</code>), y luego <code>n</code> ramas de profundidad <code>l</code>, por lo que: <code>T(n, l, k) = O(k + n * (l-k))</code>. Tambi\u00e9n se aceptan respuestas del tipo <code>O(l * n)</code>.</li> </ul>"},{"location":"exams/2025/p1_ex01/","title":"Ejercicio 1: Algoritmo de selecci\u00f3n","text":"<p>Una estudiante de Teleco est\u00e1 preparando sus planes para hacer un Erasmus el curso que viene. Analizando la oferta de destinos, ha decidido una serie de preferencias:</p> <ul> <li>El pa\u00eds al que m\u00e1s le gustar\u00eda ir es Polonia, sobre cualquier otra variable.</li> <li>Prefiere ir a un destino en el que pueda estar al menos 9 meses de estancia.</li> <li>Si hay varias opciones con una duraci\u00f3n de al menos 9 meses, priorizar\u00e1 los destinos con m\u00e1s plazas disponibles.</li> <li>Est\u00e1 segura de que necesita una beca, as\u00ed que los destinos que no la ofrezcan ir\u00e1n al final de la lista.</li> <li>Si con todos los criterios anteriores no se puede decidir entre dos destinos, se quedar\u00e1 con la universidad cuyo nombre sea mayor lexicogr\u00e1ficamente (la mayor por orden alfab\u00e9tico).</li> </ul> <p>Con esos criterios en mente, ha creado una clase en Java con toda la informaci\u00f3n de los destinos. Ahora necesita implementar un algoritmo que le permita seleccionar el destino que m\u00e1s le conviene. Para empezar, tiene que poder ordenar los destinos seg\u00fan sus preferencias.</p> <pre><code>\\end{minipage}\n\\begin{minipage}[b]{5cm}\n</code></pre> <p></p> <pre><code>\\end{minipage}\n</code></pre> <ol> <li>[ 1.5 puntos ] Modifique la clase <code>DestinoErasmus</code> de forma que pueda ser ordenada seg\u00fan los criterios de la estudiante. No es necesario escribir los constructores, getters y setters, ni los m\u00e9todos toString y equals. </li> </ol> <p>La estudiante est\u00e1 ahora evaluando sus posibilidades y decide que en vez de intentar aplicar al primer destino de su lista, lo har\u00e1 en uno que est\u00e9 menos solicitado. Para ello, suponiendo que a\u00fan no ha ordenado la lista de destinos, quiere saber cual es el destino que estar\u00eda en la posici\u00f3n i-esima despu\u00e9s de ordenarlos.</p> <ol> <li>[ 2 puntos ] Implemente un algoritmo que permita encontrar, en una lista desordenada, el elemento que ocupar\u00eda la posici\u00f3n <code>i</code> si la lista estuviera ordenada. La nota de este ejercicio depender\u00e1 de la eficiencia del algoritmo propuesto. Utilice la siguiente cabecera de m\u00e9todo:</li> </ol> <pre><code>public DestinoErasmus destinoEnPosicion(List&lt;DestinoErasmus&gt; destinos, int i)\n</code></pre> <ol> <li> <p>[ 1 punto ] Analice la complejidad del algoritmo desarrollado en funci\u00f3n de <code>n</code>, el n\u00famero de destinos en la lista, y de <code>i</code>, la posici\u00f3n del destino que se quiere encontrar. Nota: La respuesta debe estar justificada y solo se valorar\u00e1 si el algoritmo cumple con el enunciado.</p> </li> <li> <p>[ 0.5 puntos ] Existe una soluci\u00f3n para el algoritmo pedido llamada <code>QuickSelect</code>, que se basa en el algoritmo de ordenaci\u00f3n <code>QuickSort</code>. Sin necesidad de escribir el c\u00f3digo, razone qu\u00e9 complejidad tendr\u00e1 esta soluci\u00f3n, en media, en funci\u00f3n de <code>n</code> e <code>i</code>.</p> </li> </ol> Mostrar soluci\u00f3n <ol> <li></li> </ol> <p>Para hacer que los objetos <code>DestinoErasmus</code> sean ordenables, hay que implementar la interfaz <code>Comparable</code> y se sobrecargar el m\u00e9todo <code>compareTo</code>:</p> <pre><code>public class DestinoErasmus implements Comparable&lt;DestinoErasmus&gt; {\n\n    @Override\n    public int compareTo(DestinoErasmus otro) {\n        if (this.pais.equals(\"Polonia\") &amp;&amp; !otro.pais.equals(\"Polonia\")) return -1;\n        if (!this.pais.equals(\"Polonia\") &amp;&amp; otro.pais.equals(\"Polonia\")) return 1;\n        if (this.duracion &lt; 9 &amp;&amp; otro.duracion &gt;= 9) return 1;\n        if (this.duracion &gt;= 9 &amp;&amp; otro.duracion &lt; 9) return -1;\n        if (this.plazas &lt; otro.plazas) return 1;\n        if (this.plazas &gt; otro.plazas) return -1;\n        if (!this.beca &amp;&amp; otro.beca) return 1;\n        if (this.beca &amp;&amp; !otro.beca) return -1;\n        return this.universidad.compareTo(otro.universidad);\n    }\n}\n</code></pre> <ol> <li></li> </ol> <p>Existen varias maneras de resolver el problema. La m\u00e1s sencilla es ordenar la lista y devolver el elemento en la posici\u00f3n <code>i</code>. Sin embargo, esto no es eficiente, ya que los algoritmos de ordenaci\u00f3n vistos tienen una complejidad de <code>O(n log n)</code> u <code>O(n^2)</code>. Para resolver el problema sin tener que ordenar la lista completa, se puede ir ordenando la lista hasta llegar a la posici\u00f3n <code>i</code> deseada. Un ejemplo basado en la ordenaci\u00f3n por selecci\u00f3n ser\u00eda:</p> <pre><code>public DestinoErasmus destinoEnPosicion(List&lt;DestinoErasmus&gt; destinos, int i) {\n        if (i &lt; 0 || i &gt;= destinos.size()) return null;\n        List&lt;DestinoErasmus&gt; copia = new ArrayList&lt;&gt;(destinos);\n        for (int j = 0; j &lt;= i; j++) {\n            int minIndex = j;\n            for (int k = j + 1; k &lt; copia.size(); k++) {\n                if (copia.get(k).compareTo(copia.get(minIndex)) &lt; 0) {\n                    minIndex = k;\n                }\n            }\n            DestinoErasmus temp = copia.get(j);\n            copia.set(j, copia.get(minIndex));\n            copia.set(minIndex, temp);\n        }\n        return copia.get(i);\n    }\n</code></pre> <ol> <li></li> </ol> <p>Con la soluci\u00f3n anterior, el algoritmo tiene una complejidad de <code>O(i*n)</code>, ya que se recorre la lista <code>i</code> veces, y en cada iteraci\u00f3n se recorre el resto de la lista (<code>n</code> elementos) para encontrar el m\u00ednimo.</p> <ol> <li></li> </ol> <p>La soluci\u00f3n <code>QuickSelect</code> tiene una complejidad media de <code>O(n)</code>. El algoritmo se basa en <code>Quicksort</code>, que va dividiendo la lista en dos partes seg\u00fan un pivote. Para este problema no ser\u00eda necesario ordenar toda la lista, sino que se podr\u00eda parar cuando se encuentra el pivote que acabe en la posici\u00f3n <code>i</code> deseada. </p>","tags":["???"]},{"location":"exams/2025/p1_ex02/","title":"Ejercicio 2: <code>DiccionarioTrie</code>","text":"<p>Se requiere implementar <code>DiccionarioTrie</code>, un tipo de diccionario que almacena valores de tipo <code>int</code> asociados a claves de tipo <code>String</code>. Esta clase ser\u00e1 similar a <code>DiccionarioArbol</code>, salvo que los nodos estar\u00e1n representados por la clase <code>NodoTrie</code>. Se proporciona el siguiente c\u00f3digo:</p> <pre><code>class NodoTrie {\n    public Map&lt;char, NodoTrie&gt; hijos;\n    public int valor;\n    public NodoTrie(int valor) {\n        this.valor = valor;\n        this.hijos = new ArrayMap&lt;char, NodoTrie&gt;();\n    }\n}\nclass DiccionarioTrie {\n    private NodoTrie raiz;\n    public DiccionarioTrie() {\n        this.raiz = new NodoTrie(0);\n    } ...\n}\n</code></pre> <p>Adem\u00e1s, se muestra la estructura de un <code>DiccionarioTrie</code> con 3 palabras (<code>CASA</code>, <code>CALLE</code> y <code>CERO</code>):</p> <p></p> <p>El n\u00famero de cada nodo representa su valor. Las letrasFuerzaBruta en las relaciones entre nodos corresponden a una clave en el diccionario <code>hijos</code> de cada nodo, cuyo valor es el nodo representado a la derecha. N\u00f3tese que, adem\u00e1s de los nodos correspondientes a cada palabra, la estructura muestra varios nodos intermedios con valor <code>0</code>. Estos nodos corresponden a prefijos de alguna de las palabras guardadas (p.e., <code>CAS</code>, <code>CAL</code>, <code>CE</code>).</p> <p>Se pide:</p> <ol> <li>[ 0.5 puntos ] Dibuje el estado de un <code>DiccionarioTrie</code> en que se han a\u00f1adido las palabras <code>aprobar</code>, <code>adsw</code> y <code>nota</code>, con valores <code>100</code>, <code>200</code> y <code>300</code>, respectivamente.</li> <li>[ 1.5 puntos ] Implemente el m\u00e9todo <code>put(String clave, int valor)</code>. El m\u00e9todo debe asignar el valor dado a la clave dada. Si el diccionario ya conten\u00eda esa clave, su valor se sobreescribe.</li> <li>[ 2 puntos ] Implemente el m\u00e9todo <code>Integer sum(String clave)</code>. El m\u00e9todo devuelve la suma de los valores asociados a todas las palabras que empiecen por la clave dada (prefijo). Para el diccionario mostrado en el ejemplo, la operaci\u00f3n <code>sum(\"ca\")</code> devolver\u00eda el valor <code>2</code>, y <code>sum(\"\")</code> devolver\u00eda <code>4</code>.</li> <li>[ 1 punto ] Razone el orden de complejidad en tiempo de ejecuci\u00f3n en el caso peor para los m\u00e9todos <code>put</code> y <code>sum</code> en funci\u00f3n de: el n\u00famero de palabras (<code>n</code>), la longitud de la palabra m\u00e1s larga (<code>l</code>) y la longitud de la clave dada como argumento (<code>k</code>). Es decir, calcule <code>T(n, l, k)</code>.</li> </ol> Mostrar soluci\u00f3n <ol> <li></li> </ol> <p></p> <p>2.</p> <pre><code>    public void put(String palabra, int valor) {\n        NodoTrie target = this.raiz;\n        for(int i=0; i&lt;palabra.length(); i++) {\n            char c = palabra.getCharAt(i);\n            if (!target.hijos.contains(c)) {\n                target.hijos.insert(c, new NodoTrie(c, 0));\n            }\n            target = target.hijos.get(c);\n        }\n        target.valor = valor;\n    }\n</code></pre> <p>3.</p> <p>Hay que encontrar el nodo correspondiente al prefijo, y despu\u00e9s sumar todos los valores a partir de ese nodo (<code>sumFrom</code>).</p> <pre><code>    public int sum(String prefijo) {\n        NodoTrie target = this.raiz;\n        for(int i=0; i&lt;prefijo.length(); i++) {\n            char c = palabra.getCharAt(i);\n            if (!target.hijos.contains(c)) {\n                return 0;\n            }\n            target = target.hijos.get(c);\n        }\n        return this.sumFrom(prefijo, target);\n    }\n\n    public int sumFrom(NodoTrie nodo) {\n        int cuenta = nodo.valor;\n        for(NodoTrie hijo: nodo.hijos.values()) {\n            cuenta += sumFrom(hijo);\n        }\n        return cuenta;\n    }\n</code></pre> <p>4.</p> <ul> <li><code>put</code>: <code>T(n, l, k) = O(k)</code> en todos los casos, porque se recorre o a\u00f1ade un nodo por cada letra en la palabra clave.</li> <li><code>sum</code>: El caso peor es aquel en que todas las palabras tienen la longitud m\u00e1xima (<code>l</code>), y coinciden en prefijo con la clave dada (<code>k</code>), pero no coinciden en ninguna otra letra. En ese caso, se recorren <code>k</code> nodos hasta llegar al prefijo (profundidad <code>k</code>), y luego <code>n</code> ramas de profundidad <code>l</code>, por lo que: <code>T(n, l, k) = O(k + n * (l-k))</code>. Tambi\u00e9n se aceptan respuestas del tipo <code>O(l * n)</code>.</li> </ul>","tags":["???"]},{"location":"exams/2025/p1r/","title":"Examen 2025 \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/2025/p1r/#problema-1","title":"Problema 1","text":"<p>Tenemos arrays de <code>2n</code> n\u00fameros enteros dispuestos de forma capic\u00faa y ordenados en sentido ascendente-descendente. En la primera mitad del array hay <code>n</code> n\u00fameros ordenados de forma ascendente, y en la segunda mitad, los mismos <code>n</code> n\u00fameros pero ordenados de forma descendente. El valor de <code>n</code> siempre es una potencia de 2.</p> <p>Un ejemplo de este tipo de arrays ser\u00eda:  <code>[1 3 6 9 10 12 14 16 16 14 12 10 9 6 3 1]</code>. En este ejemplo, <code>n = 8</code>. Otro ejemplo con <code>n = 4</code> ser\u00eda: <code>[1 2 3 4 4 3 2 1]</code>.</p> <ul> <li>(a) (1,5 puntos) Queremos utilizar el algoritmo de ordenaci\u00f3n por burbuja como el incluido en las transparencias de la asignatura para ordenar estos arrays. A continuaci\u00f3n se incluye una copia del algoritmo adaptado a estos arrays. \u00bfCu\u00e1l es el n\u00famero de veces que se eval\u00faa la condici\u00f3n del <code>if</code> en la l\u00ednea 6, para este tipo de arrays en concreto?. Indique la respuesta en funci\u00f3n del tama\u00f1o del array y justif\u00edquela brevemente.</li> </ul> <pre><code>public void burbuja(int[] data) { \n  boolean changed;\n  do {\n    changed = false;\n    for (int i = 0; i &lt; data.length - 1;i++) {\n      if (data[i] &gt; data[i + 1]) {\n        swap(data, i, i + 1);\n        changed = true;\n      }\n    }\n  } while (changed);\n}\n</code></pre> Mostrar soluci\u00f3n <p>La complejidad de peor caso de burbuja es \\(O(n^2)\\) y mejor caso \\(O(n)\\), donde \\(n\\) es el tama\u00f1o del array. Para estos arrays de tama\u00f1o \\(2n\\), el algoritmo de burbuja tiene que recolocar todos los n\u00fameros menos el primero. El bucle externo se ejecuta \\(2n - 1\\) veces. El bucle interno tambi\u00e9n se ejecuta \\(2n - 1\\) veces. El n\u00famero total de comparaciones es \\((2n - 1)^2\\).</p> <ul> <li>(b) (2,5 puntos) Implemente un m\u00e9todo que reciba como par\u00e1metro un array (con la misma estructura descrita anteriormente) y ordene sus elementos en orden ascendente.</li> </ul> <p>La puntuaci\u00f3n de este apartado se asignar\u00e1 seg\u00fan los criterios siguientes:</p> <ul> <li>Si la soluci\u00f3n no deja ordenado el array recibido, la puntuaci\u00f3n no superar\u00e1 0.5 puntos.</li> <li>Si la complejidad es mayor que \\(O(n^2)\\), la puntuaci\u00f3n no superar\u00e1 0.5 puntos.</li> <li>Si la complejidad es mayor que \\(O(n\\cdot log(n))\\), la puntuaci\u00f3n no superar\u00e1 1 punto.</li> <li>Si la complejidad es mayor que \\(O(n)\\), la puntuaci\u00f3n no superar\u00e1 1.5 puntos.</li> <li>Se valorar\u00e1 positivamente no utilizar arrays ni listas auxiliares o adicionales. En caso de emplearlos, la puntuaci\u00f3n se reducir\u00e1 al menos 1 punto.</li> </ul> <p>No es necesario comprobar que el array recibido est\u00e9 construido correctamente</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n para ordenar el array de forma ascendente es la siguiente:</p> <pre><code> public static void ordenaCapicuaAscendenteArray(int[] arr) {\n   int dest = arr.length - 1;\n   for (int org = arr.length / 2 - 1; org &gt;= 0; org--) {\n       arr[dest--] = arr[org];\n       arr[dest--] = arr[org];\n   }\n }\n</code></pre> <ul> <li>(c) (1 punto) Calcule la complejidad del algoritmo implementado en el apartado 2, justificando su razonamiento y mostrando los pasos seguidos hasta llegar a la expresi\u00f3n final.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad de esta soluci\u00f3n es \\(O(n)\\), donde \\(2n\\) es el tama\u00f1o del array. El bucle <code>for</code> de la l\u00ednea 3 se ejecuta \\(n\\) veces y las sentencias del cuerpo del bucle son de coste constante \\(O(1)\\).</p>"},{"location":"exams/2025/p1r/#problema-2","title":"Problema 2","text":"<p>En un sistema de gesti\u00f3n de la informaci\u00f3n de personas, se quieren implementar los m\u00e9todos que se describen a continuaci\u00f3n. Se pide:</p> <ul> <li> <p>(a) (2,5 puntos)  El sistema proporciona el m\u00e9todo <code>personasEnCiudad</code>, que permite obtener la lista de las personas de una ciudad. El n\u00famero de accesos a este m\u00e9todo es muy elevado, por lo que es importante tener una respuesta muy eficiente. Para ello, se pide determinar una estructura de datos en la clase adecuada para satisfacer este requisito. Justifique brevemente su decisi\u00f3n y desarrolle el c\u00f3digo necesario para crear la estructura de datos seleccionada e implementar el m\u00e9todo <code>personasEnCiudad</code>. </p> </li> <li> <p>(b) (2,5 puntos) Se quiere obtener una lista de las ciudades que tengan el mayor n\u00famero de personas con un nombre. En este caso no es cr\u00edtico el rendimiento, pero se considerar\u00e1 su comportamiento. </p> </li> </ul>"},{"location":"exams/2025/p1r/#documentacion-de-la-clase-gestorpersonas","title":"Documentaci\u00f3n de la clase GestorPersonas","text":"<p><pre><code>\\begin{minipage}[thp]{13cm}\n</code></pre> <pre><code>/**\n * Constructor de la clase GestorPersonas\n * \n * @param arrayPersonas array con todas las personas\n */\npublic GestorPersonas(Persona[] arrayPersonas)\n\n/**\n * Retorna una lista de las personas en una ciudad.\n * \n * @param ciudad la ciudad para la b\u00fasqueda\n * @return una lista con las personas en esa ciudad\n */\npublic List&lt;Persona&gt; personasEnCiudad(String ciudad)\n\n/**\n * Retorna una lista de las ciudades que contengan alguna persona que se \n * llame como el nombre pasado como par\u00e1metro. La lista estar\u00e1 ordenada \n * de mayor a menor, seg\u00fan el n\u00famero de personas que cuenten con ese nombre.\n * \n * Si ninguna ciudad tiene personas con ese nombre, se retornar\u00e1 una \n * lista con todas las ciudades.\n * \n * @param nombre el nombre de la persona para la b\u00fasqueda\n * @return lista de ciudades\n */\npublic List&lt;String&gt; masCiudadNombre(String nombre)\n</code></pre></p> <p><pre><code>\\end{minipage}\n\\begin{minipage}[thp]{5cm}\n\\begin{center}\n</code></pre> </p> <pre><code>\\end{center}\n\\end{minipage}\n\n\\vspace{-0.2cm}\n</code></pre>"},{"location":"exams/2025/p1r/#referencia-rapida-de-colecciones","title":"Referencia r\u00e1pida de colecciones","text":"<pre><code>\\vspace{-0.2cm}\n\\begin{table}[h!]\n  \\centering\n  \\begin{footnotesize}\n\n  \\begin{minipage}{.48\\linewidth}\n    \\centering\n    \\textbf{List}\\\\[6pt]\n    \\begin{tabular}{|l|p{6.5cm}|}\n      \\hline\n      \\textbf{Type} &amp; \\textbf{Method and Description} \\\\\n      \\hline\n      boolean &amp; \\texttt{add(E e)} \u2013 Appends the specified element to the end of this list (optional). \\\\\n      \\hline\n      void &amp; \\texttt{add(int index, E element)} \u2013 Inserts the specified element at the specified position in this list (optional). \\\\\n      \\hline\n      boolean &amp; \\texttt{contains(Object o)} \u2013 Returns \\texttt{true} if this list contains the specified element. \\\\\n      \\hline\n      \\texttt{E} &amp; \\texttt{get(int index)} \u2013 Returns the element at the specified position in this list. \\\\\n      \\hline\n      boolean &amp; \\texttt{isEmpty()} \u2013 Returns \\texttt{true} if this list contains no elements. \\\\\n      \\hline\n      \\texttt{E} &amp; \\texttt{remove(int index)} \u2013 Removes the element at the specified position in this list (optional). \\\\\n      \\hline\n      int &amp; \\texttt{size()} \u2013 Returns the number of elements in this list. \\\\\n      \\hline\n    \\end{tabular}\n  \\end{minipage}\n  \\hfill\n  \\begin{minipage}{.48\\linewidth}\n    \\centering\n    \\textbf{Map}\\\\[6pt]\n    \\begin{tabular}{|l|p{6.5cm}|}\n      \\hline\n      \\textbf{Type} &amp; \\textbf{Method and Description} \\\\\n      \\hline\n      boolean &amp; \\texttt{containsKey(Object key)} \u2013 Returns \\texttt{true} if this map contains a mapping for the specified key. \\\\\n      \\hline\n      \\texttt{V} &amp; \\texttt{get(Object key)} \u2013 Returns the value mapped to the key, or \\texttt{null} if none exists. \\\\\n      \\hline\n      \\texttt{Set&lt;K&gt;} &amp; \\texttt{keySet()} \u2013 Returns a \\texttt{Set} view of the keys contained in this map. \\\\\n      \\hline\n      \\texttt{V} &amp; \\texttt{put(K key, V value)} \u2013 Associates the specified value with the specified key in this map (optional). \\\\\n      \\hline\n      \\texttt{V} &amp; \\texttt{remove(Object key)} \u2013 Removes the mapping for a key from this map if present (optional). \\\\\n      \\hline\n      int &amp; \\texttt{size()} \u2013 Returns the number of key-value mappings in this map. \\\\\n      \\hline\n    \\end{tabular}\n  \\end{minipage}\n  \\end{footnotesize}\n\\end{table}\n</code></pre> <p>Nota: Se pueden utilizar colecciones adicionales con otras estructuras de datos, como podr\u00eda ser un <code>Set</code> en un <code>for</code> para recorrer las claves de un <code>Map</code>.</p> Mostrar soluci\u00f3n <pre><code>import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class GestorPersonas {\n\n  Map&lt;String, List&lt;Persona&gt;&gt; mapCiudadPersona = new HashMap&lt;String, List&lt;Persona&gt;&gt;();\n\n  public GestorPersonas(Persona[] arrayPersonas) {\n    for(Persona persona : arrayPersonas) {\n      if (mapCiudadPersona.get(persona.getCiudad()) == null) {\n        List&lt;Persona&gt; personas = new ArrayList&lt;Persona&gt;();\n        personas.add(persona);\n        mapCiudadPersona.put(persona.getCiudad(), personas);\n      } else {\n        List&lt;Persona&gt; personas = mapCiudadPersona.get(persona.getCiudad());\n        personas.add(persona);\n      }\n    }\n  }\n\n  public List&lt;Persona&gt; PersonasEnCiudad(String ciudad) {\n    return mapCiudadPersona.get(ciudad);\n  }\n\n  public List &lt;String&gt; masCiudadNombre (String nombre) {\n\n    int nMaxPersonas = 0;\n    List&lt;String&gt; ciudadesMas = new ArrayList&lt;String&gt;();\n    Set&lt;String&gt; ciudades = mapCiudadPersona.keySet();\n\n    for(String ciudad : ciudades) {\n      int nPersonas = 0;\n      for(Persona persona : mapCiudadPersona.get(ciudad)) {\n        if (persona.getNombre() == nombre) {\n          nPersonas ++;\n        }\n      }\n\n      if (nPersonas == nMaxPersonas) {\n        ciudadesMas.add(ciudad);\n      } \n      if (nPersonas &gt; nMaxPersonas) {\n        nMaxPersonas = nPersonas;\n        ciudadesMas = new ArrayList&lt;String&gt;();\n        ciudadesMas.add(ciudad);\n      }\n    }\n    return ciudadesMas;\n  }\n}\n</code></pre> <p>La documentaci\u00f3n de la funci\u00f3n describe un proceso diferente. Una opci\u00f3n para resolverlo es esta:</p> <pre><code>import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class GestorPersonas {\n\n  Map&lt;String, List&lt;Persona&gt;&gt; mapCiudadPersona = new HashMap&lt;String, List&lt;Persona&gt;&gt;();\n\n  public GestorPersonas(Persona[] arrayPersonas) {\n    for(Persona persona : arrayPersonas) {\n      if (mapCiudadPersona.get(persona.getCiudad()) == null) {\n        List&lt;Persona&gt; personas = new ArrayList&lt;Persona&gt;();\n        personas.add(persona);\n        mapCiudadPersona.put(persona.getCiudad(), personas);\n      } else {\n        List&lt;Persona&gt; personas = mapCiudadPersona.get(persona.getCiudad());\n        personas.add(persona);\n      }\n    }\n  }\n\n  public List&lt;Persona&gt; PersonasEnCiudad(String ciudad) {\n    return mapCiudadPersona.get(ciudad);\n  }\n\n  public List &lt;String&gt; masCiudadNombre (String nombre) {\n    int nMaxPersonas = 0;\n    List&lt;String&gt; ciudades = new ArrayList&lt;String&gt;();\n    List&lt;Integer&gt; contadores = new ArrayList&lt;Integer&gt;();\n\n    for(String ciudad: mapCiudadPersona.keySet()) {\n      int nPersonas = 0;\n      for(Persona persona : mapCiudadPersona.get(ciudad)) {\n        if (persona.getNombre() == nombre) {\n          nPersonas++;\n        }\n      }\n      int pos = ciudades.size();\n      while(pos &gt; 0 &amp;&amp; contadores.get(pos-1) &lt; nPersonas) {\n          pos--;\n      }\n      ciudades.add(pos, ciudad);\n      contadores.add(pos, nPersonas);\n    }\n    if(ciudades.isEmpty() {\n        ciudades.addAll(mapCiudadPersona.keySet());\n    }\n    return ciudades;\n  }\n}\n</code></pre>"},{"location":"exams/2025/p1r_ex01/","title":"P1r ex01","text":"<p>Tenemos arrays de <code>2n</code> n\u00fameros enteros dispuestos de forma capic\u00faa y ordenados en sentido ascendente-descendente. En la primera mitad del array hay <code>n</code> n\u00fameros ordenados de forma ascendente, y en la segunda mitad, los mismos <code>n</code> n\u00fameros pero ordenados de forma descendente. El valor de <code>n</code> siempre es una potencia de 2.</p> <p>Un ejemplo de este tipo de arrays ser\u00eda:  <code>[1 3 6 9 10 12 14 16 16 14 12 10 9 6 3 1]</code>. En este ejemplo, <code>n = 8</code>. Otro ejemplo con <code>n = 4</code> ser\u00eda: <code>[1 2 3 4 4 3 2 1]</code>.</p> <ul> <li>(a) (1,5 puntos) Queremos utilizar el algoritmo de ordenaci\u00f3n por burbuja como el incluido en las transparencias de la asignatura para ordenar estos arrays. A continuaci\u00f3n se incluye una copia del algoritmo adaptado a estos arrays. \u00bfCu\u00e1l es el n\u00famero de veces que se eval\u00faa la condici\u00f3n del <code>if</code> en la l\u00ednea 6, para este tipo de arrays en concreto?. Indique la respuesta en funci\u00f3n del tama\u00f1o del array y justif\u00edquela brevemente.</li> </ul> <pre><code>public void burbuja(int[] data) { \n  boolean changed;\n  do {\n    changed = false;\n    for (int i = 0; i &lt; data.length - 1;i++) {\n      if (data[i] &gt; data[i + 1]) {\n        swap(data, i, i + 1);\n        changed = true;\n      }\n    }\n  } while (changed);\n}\n</code></pre> Mostrar soluci\u00f3n <p>La complejidad de peor caso de burbuja es \\(O(n^2)\\) y mejor caso \\(O(n)\\), donde \\(n\\) es el tama\u00f1o del array. Para estos arrays de tama\u00f1o \\(2n\\), el algoritmo de burbuja tiene que recolocar todos los n\u00fameros menos el primero. El bucle externo se ejecuta \\(2n - 1\\) veces. El bucle interno tambi\u00e9n se ejecuta \\(2n - 1\\) veces. El n\u00famero total de comparaciones es \\((2n - 1)^2\\).</p> <ul> <li>(b) (2,5 puntos) Implemente un m\u00e9todo que reciba como par\u00e1metro un array (con la misma estructura descrita anteriormente) y ordene sus elementos en orden ascendente.</li> </ul> <p>La puntuaci\u00f3n de este apartado se asignar\u00e1 seg\u00fan los criterios siguientes:</p> <ul> <li>Si la soluci\u00f3n no deja ordenado el array recibido, la puntuaci\u00f3n no superar\u00e1 0.5 puntos.</li> <li>Si la complejidad es mayor que \\(O(n^2)\\), la puntuaci\u00f3n no superar\u00e1 0.5 puntos.</li> <li>Si la complejidad es mayor que \\(O(n\\cdot log(n))\\), la puntuaci\u00f3n no superar\u00e1 1 punto.</li> <li>Si la complejidad es mayor que \\(O(n)\\), la puntuaci\u00f3n no superar\u00e1 1.5 puntos.</li> <li>Se valorar\u00e1 positivamente no utilizar arrays ni listas auxiliares o adicionales. En caso de emplearlos, la puntuaci\u00f3n se reducir\u00e1 al menos 1 punto.</li> </ul> <p>No es necesario comprobar que el array recibido est\u00e9 construido correctamente</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n para ordenar el array de forma ascendente es la siguiente:</p> <pre><code> public static void ordenaCapicuaAscendenteArray(int[] arr) {\n   int dest = arr.length - 1;\n   for (int org = arr.length / 2 - 1; org &gt;= 0; org--) {\n       arr[dest--] = arr[org];\n       arr[dest--] = arr[org];\n   }\n }\n</code></pre> <ul> <li>(c) (1 punto) Calcule la complejidad del algoritmo implementado en el apartado 2, justificando su razonamiento y mostrando los pasos seguidos hasta llegar a la expresi\u00f3n final.</li> </ul> Mostrar soluci\u00f3n <p>La complejidad de esta soluci\u00f3n es \\(O(n)\\), donde \\(2n\\) es el tama\u00f1o del array. El bucle <code>for</code> de la l\u00ednea 3 se ejecuta \\(n\\) veces y las sentencias del cuerpo del bucle son de coste constante \\(O(1)\\).</p>","tags":["complejidad"]},{"location":"exams/2025/p1r_ex02/","title":"P1r ex02","text":"<p>En un sistema de gesti\u00f3n de la informaci\u00f3n de personas, se quieren implementar los m\u00e9todos que se describen a continuaci\u00f3n. Se pide:</p> <ul> <li> <p>(a) (2,5 puntos)  El sistema proporciona el m\u00e9todo <code>personasEnCiudad</code>, que permite obtener la lista de las personas de una ciudad. El n\u00famero de accesos a este m\u00e9todo es muy elevado, por lo que es importante tener una respuesta muy eficiente. Para ello, se pide determinar una estructura de datos en la clase adecuada para satisfacer este requisito. Justifique brevemente su decisi\u00f3n y desarrolle el c\u00f3digo necesario para crear la estructura de datos seleccionada e implementar el m\u00e9todo <code>personasEnCiudad</code>. </p> </li> <li> <p>(b) (2,5 puntos) Se quiere obtener una lista de las ciudades que tengan el mayor n\u00famero de personas con un nombre. En este caso no es cr\u00edtico el rendimiento, pero se considerar\u00e1 su comportamiento. </p> </li> </ul>","tags":["complejidad"]},{"location":"exams/2025/p1r_ex02/#documentacion-de-la-clase-gestorpersonas","title":"Documentaci\u00f3n de la clase GestorPersonas","text":"<p><pre><code>\\begin{minipage}[thp]{13cm}\n</code></pre> <pre><code>/**\n * Constructor de la clase GestorPersonas\n * \n * @param arrayPersonas array con todas las personas\n */\npublic GestorPersonas(Persona[] arrayPersonas)\n\n/**\n * Retorna una lista de las personas en una ciudad.\n * \n * @param ciudad la ciudad para la b\u00fasqueda\n * @return una lista con las personas en esa ciudad\n */\npublic List&lt;Persona&gt; personasEnCiudad(String ciudad)\n\n/**\n * Retorna una lista de las ciudades que contengan alguna persona que se \n * llame como el nombre pasado como par\u00e1metro. La lista estar\u00e1 ordenada \n * de mayor a menor, seg\u00fan el n\u00famero de personas que cuenten con ese nombre.\n * \n * Si ninguna ciudad tiene personas con ese nombre, se retornar\u00e1 una \n * lista con todas las ciudades.\n * \n * @param nombre el nombre de la persona para la b\u00fasqueda\n * @return lista de ciudades\n */\npublic List&lt;String&gt; masCiudadNombre(String nombre)\n</code></pre></p> <p><pre><code>\\end{minipage}\n\\begin{minipage}[thp]{5cm}\n\\begin{center}\n</code></pre> </p> <pre><code>\\end{center}\n\\end{minipage}\n\n\\vspace{-0.2cm}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2025/p1r_ex02/#referencia-rapida-de-colecciones","title":"Referencia r\u00e1pida de colecciones","text":"<pre><code>\\vspace{-0.2cm}\n\\begin{table}[h!]\n  \\centering\n  \\begin{footnotesize}\n\n  \\begin{minipage}{.48\\linewidth}\n    \\centering\n    \\textbf{List}\\\\[6pt]\n    \\begin{tabular}{|l|p{6.5cm}|}\n      \\hline\n      \\textbf{Type} &amp; \\textbf{Method and Description} \\\\\n      \\hline\n      boolean &amp; \\texttt{add(E e)} \u2013 Appends the specified element to the end of this list (optional). \\\\\n      \\hline\n      void &amp; \\texttt{add(int index, E element)} \u2013 Inserts the specified element at the specified position in this list (optional). \\\\\n      \\hline\n      boolean &amp; \\texttt{contains(Object o)} \u2013 Returns \\texttt{true} if this list contains the specified element. \\\\\n      \\hline\n      \\texttt{E} &amp; \\texttt{get(int index)} \u2013 Returns the element at the specified position in this list. \\\\\n      \\hline\n      boolean &amp; \\texttt{isEmpty()} \u2013 Returns \\texttt{true} if this list contains no elements. \\\\\n      \\hline\n      \\texttt{E} &amp; \\texttt{remove(int index)} \u2013 Removes the element at the specified position in this list (optional). \\\\\n      \\hline\n      int &amp; \\texttt{size()} \u2013 Returns the number of elements in this list. \\\\\n      \\hline\n    \\end{tabular}\n  \\end{minipage}\n  \\hfill\n  \\begin{minipage}{.48\\linewidth}\n    \\centering\n    \\textbf{Map}\\\\[6pt]\n    \\begin{tabular}{|l|p{6.5cm}|}\n      \\hline\n      \\textbf{Type} &amp; \\textbf{Method and Description} \\\\\n      \\hline\n      boolean &amp; \\texttt{containsKey(Object key)} \u2013 Returns \\texttt{true} if this map contains a mapping for the specified key. \\\\\n      \\hline\n      \\texttt{V} &amp; \\texttt{get(Object key)} \u2013 Returns the value mapped to the key, or \\texttt{null} if none exists. \\\\\n      \\hline\n      \\texttt{Set&lt;K&gt;} &amp; \\texttt{keySet()} \u2013 Returns a \\texttt{Set} view of the keys contained in this map. \\\\\n      \\hline\n      \\texttt{V} &amp; \\texttt{put(K key, V value)} \u2013 Associates the specified value with the specified key in this map (optional). \\\\\n      \\hline\n      \\texttt{V} &amp; \\texttt{remove(Object key)} \u2013 Removes the mapping for a key from this map if present (optional). \\\\\n      \\hline\n      int &amp; \\texttt{size()} \u2013 Returns the number of key-value mappings in this map. \\\\\n      \\hline\n    \\end{tabular}\n  \\end{minipage}\n  \\end{footnotesize}\n\\end{table}\n</code></pre> <p>Nota: Se pueden utilizar colecciones adicionales con otras estructuras de datos, como podr\u00eda ser un <code>Set</code> en un <code>for</code> para recorrer las claves de un <code>Map</code>.</p> Mostrar soluci\u00f3n <pre><code>import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class GestorPersonas {\n\n  Map&lt;String, List&lt;Persona&gt;&gt; mapCiudadPersona = new HashMap&lt;String, List&lt;Persona&gt;&gt;();\n\n  public GestorPersonas(Persona[] arrayPersonas) {\n    for(Persona persona : arrayPersonas) {\n      if (mapCiudadPersona.get(persona.getCiudad()) == null) {\n        List&lt;Persona&gt; personas = new ArrayList&lt;Persona&gt;();\n        personas.add(persona);\n        mapCiudadPersona.put(persona.getCiudad(), personas);\n      } else {\n        List&lt;Persona&gt; personas = mapCiudadPersona.get(persona.getCiudad());\n        personas.add(persona);\n      }\n    }\n  }\n\n  public List&lt;Persona&gt; PersonasEnCiudad(String ciudad) {\n    return mapCiudadPersona.get(ciudad);\n  }\n\n  public List &lt;String&gt; masCiudadNombre (String nombre) {\n\n    int nMaxPersonas = 0;\n    List&lt;String&gt; ciudadesMas = new ArrayList&lt;String&gt;();\n    Set&lt;String&gt; ciudades = mapCiudadPersona.keySet();\n\n    for(String ciudad : ciudades) {\n      int nPersonas = 0;\n      for(Persona persona : mapCiudadPersona.get(ciudad)) {\n        if (persona.getNombre() == nombre) {\n          nPersonas ++;\n        }\n      }\n\n      if (nPersonas == nMaxPersonas) {\n        ciudadesMas.add(ciudad);\n      } \n      if (nPersonas &gt; nMaxPersonas) {\n        nMaxPersonas = nPersonas;\n        ciudadesMas = new ArrayList&lt;String&gt;();\n        ciudadesMas.add(ciudad);\n      }\n    }\n    return ciudadesMas;\n  }\n}\n</code></pre> <p>La documentaci\u00f3n de la funci\u00f3n describe un proceso diferente. Una opci\u00f3n para resolverlo es esta:</p> <pre><code>import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class GestorPersonas {\n\n  Map&lt;String, List&lt;Persona&gt;&gt; mapCiudadPersona = new HashMap&lt;String, List&lt;Persona&gt;&gt;();\n\n  public GestorPersonas(Persona[] arrayPersonas) {\n    for(Persona persona : arrayPersonas) {\n      if (mapCiudadPersona.get(persona.getCiudad()) == null) {\n        List&lt;Persona&gt; personas = new ArrayList&lt;Persona&gt;();\n        personas.add(persona);\n        mapCiudadPersona.put(persona.getCiudad(), personas);\n      } else {\n        List&lt;Persona&gt; personas = mapCiudadPersona.get(persona.getCiudad());\n        personas.add(persona);\n      }\n    }\n  }\n\n  public List&lt;Persona&gt; PersonasEnCiudad(String ciudad) {\n    return mapCiudadPersona.get(ciudad);\n  }\n\n  public List &lt;String&gt; masCiudadNombre (String nombre) {\n    int nMaxPersonas = 0;\n    List&lt;String&gt; ciudades = new ArrayList&lt;String&gt;();\n    List&lt;Integer&gt; contadores = new ArrayList&lt;Integer&gt;();\n\n    for(String ciudad: mapCiudadPersona.keySet()) {\n      int nPersonas = 0;\n      for(Persona persona : mapCiudadPersona.get(ciudad)) {\n        if (persona.getNombre() == nombre) {\n          nPersonas++;\n        }\n      }\n      int pos = ciudades.size();\n      while(pos &gt; 0 &amp;&amp; contadores.get(pos-1) &lt; nPersonas) {\n          pos--;\n      }\n      ciudades.add(pos, ciudad);\n      contadores.add(pos, nPersonas);\n    }\n    if(ciudades.isEmpty() {\n        ciudades.addAll(mapCiudadPersona.keySet());\n    }\n    return ciudades;\n  }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2025/p2/","title":"Examen 2025 \u2014 Parcial 2","text":""},{"location":"exams/2025/p2/#problema-1","title":"Problema 1","text":"<p>Se quiere simular un sistema de impresi\u00f3n con una impresora a la que varios usuarios pueden pedir impresiones. Los usuarios pueden pedir imprimir un texto (una cadena de caracteres). La impresora debe imprimir un texto solo cuando no est\u00e9 ocupada, y siempre debe dar prioridad al texto m\u00e1s corto. Los usuarios se modelan como hebras independientes.</p> <p>Se proporciona el siguiente diagrama de clases como referencia, y se pide:</p> <pre><code>\\begin{minipage}[thp]{12cm}\n</code></pre> <ul> <li>(a) (1 punto) Implementar la clase <code>Usuario</code>, que ser\u00e1 una hebra con un nombre, un texto a imprimir y una referencia a la impresora, y su \u00fanica labor es imprimir el texto dado en la impresora.</li> </ul> Mostrar soluci\u00f3n <pre><code>class Usuario extends Thread {\n  private String nombre;\n  private Impresora impresora;\n  private String texto;\n  public Usuario(String nombre, Impresora impresora, String texto) {\n    this.nombre = nombre;\n    this.impresora = impresora;\n    this.texto = texto;\n  }\n  public void run() {\n    try {\n      impresora.imprimir(texto, nombre);\n    } catch (InterruptedException e) {}\n  }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Implementa una clase <code>Impresora</code> que contenga un m\u00e9todo <code>imprimir</code> que asegure que:<ul> <li>Solo se permite imprimir un texto en cada momento</li> <li>Los textos se imprimen a una velocidad de un car\u00e1cter por milisegundo. Para simular la impresi\u00f3n, se debe usar el m\u00e9todo <code>Thread.sleep(long millis)</code>, que puede lanzar excepciones del tipo <code>InterruptedException</code>.</li> <li>Una vez comienza la impresi\u00f3n de un texto, no se podr\u00e1 empezar con otro hasta haberlo terminado</li> <li>Si varias hebras intentan imprimir, los textos m\u00e1s cortos tendr\u00e1n prioridad</li> <li>Se guarda un registro (<code>registro</code>) de todos los caracteres impresos hasta el momento por la impresora</li> <li>Se debe mostrar por consola un mensaje en los siguientes momentos: 1) cuando un usuario intenta imprimir; 2) tras imprimir cada car\u00e1cter; y 3) cuando se ha terminado de imprimir un texto completo. Los mensajes deben contener el nombre de la hebra que ha realizado la acci\u00f3n.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Se acepta como v\u00e1lida la siguiente soluci\u00f3n:</p> <pre><code>    static class Impresora {\n        private List&lt;String&gt; cola = new ArrayList&lt;String&gt;();\n        private String registro = \"\";\n        private boolean imprimiendo = false;\n\n        public synchronized void imprimir(String texto, String usuario) throws InterruptedException {\n            System.out.println(usuario + \" quiere imprimir: \" + texto);\n            int pos = 0;\n            while(pos &lt; cola.size()) {\n                if(cola.get(i).lengt() &gt; texto.length()) {\n                    break;\n                }\n                pos++;\n            }\n            cola.add(pos, texto);\n\n            while (imprimiendo || cola.get(0) != texto) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {}\n            }\n\n            imprimiendo = true;\n            cola.remove(0);\n            System.out.println(usuario + \" empieza a imprimir: \" + texto);\n            int i = 0;\n            while(i &lt; texto.length()) {\n                System.out.println(usuario + \" imprime: \" + texto.charAt(i));\n                registro = registro + texto.charAt(i);\n                i++;\n                Thread.sleep(10);\n            }\n            imprimiendo = false;\n            System.out.println(usuario + \" termina de imprimir\");\n            notifyAll();\n        }\n    }\n</code></pre> <p>No obstante, la soluci\u00f3n correcta incluir\u00eda liberar el cerrojo durante el <code>sleep</code>. Por ejemplo:</p> <pre><code>class Impresora {\n  private List&lt;String&gt; cola = new ArrayList&lt;String&gt;();\n  private boolean imprimiendo = false;\n  public String registro = \"\";\n  public void imprimir(String texto, String usuario) throws InterruptedException {\n    ponerEnCola(texto, usuario);\n    intentarImprimir(texto, usuario);\n    int i = 0;\n    while(i &lt; texto.length()) {\n      System.out.println(usuario + \" imprime: \" + texto.charAt(i));\n      registro = registro + texto.charAt(i);\n      i++;\n      Thread.sleep(10);\n    }\n    dejarDeImprimir(texto, usuario);\n  }\n  public synchronized void ponerEnCola(String texto, String usuario) {\n    System.out.println(usuario + \" quiere imprimir: \" + texto + \" [ \" + texto.length() + \" caracteres]\");\n    int pos = 0;\n    while(pos &lt; cola.size()) {\n      if(cola.get(pos).length() &gt; texto.length()) {\n        break;\n      }\n      pos++;\n    }\n    cola.add(pos, texto);\n  }\n  public synchronized void intentarImprimir(String texto, String usuario) {\n    while (imprimiendo || !cola.get(0).equals(texto)) {\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n    }\n    cola.remove(0);\n    imprimiendo = true;\n    System.out.println(usuario + \" empieza a imprimir: \" + texto);\n  }\n  public synchronized void dejarDeImprimir(String texto, String usuario) {\n    System.out.println(usuario + \" termina de imprimir\");\n    imprimiendo = false;\n    notifyAll();\n  }\n}\n</code></pre> <ul> <li>(c) (1 punto) Implementa el m\u00e9todo <code>main</code> para que sirva de prueba r\u00e1pida la implementaci\u00f3n (<code>smoketest</code>). Se deben crear al menos 4 usuarios que impriman textos diferentes en la misma impresora, y mostrar un texto al finalizar todas las impresiones.</li> </ul> Mostrar soluci\u00f3n <pre><code>public static void main(String[] args) throws InterruptedException {\n    Impresora impresora = new Impresora();\n    String[] textos = { \"hola\\n\", \"buenos d\u00edas\\n\", \"adi\u00f3s\\n\", \"s\u00ed\\n\" };\n    Usuario[] usuarios = new Usuario[textos.length];\n    for (int i = 0; i &lt; textos.length; i++) {\n        usuarios[i] = new Usuario(\"Usuario \" + (char)('A' + i), impresora, textos[i]);\n    }\n    for (Usuario u : usuarios) {\n        u.start();\n    }\n    for (Usuario u : usuarios) {\n        try {\n            u.join();\n        } catch (InterruptedException e) {}\n    }\n    System.out.println(\"Todos los trabajos han terminado. Texto final: \" + impresora.registro());\n}\n</code></pre> <ul> <li>(d) (1 punto) Explica qu\u00e9 modificaciones se podr\u00edan realizar en el c\u00f3digo para que una impresora permita imprimir a 2 usuarios a la vez.</li> </ul> Mostrar soluci\u00f3n <p>Habr\u00eda que cambiar el flag de imprimiendo para que fuera un entero con el n\u00famero de usuarios imprimiendo en ese momento. Tambi\u00e9n habr\u00eda que sacar el <code>sleep</code> de la zona cr\u00edtica. De lo contrario, mientras una hebra est\u00e1 imprimiendo el resto quedar\u00edan bloqueadas.</p> <p></p>"},{"location":"exams/2025/p2/#problema-2","title":"Problema 2","text":"<p>En las pr\u00e1cticas de la asignatura se ha trabajado con un grafo creado a partir de un archivo que contiene un hist\u00f3rico de partidas de ajedrez. En el grafo cada nodo representa un estado del tablero de ajedrez. Dos nodos est\u00e1n conectados por una arista dirigida si en el archivo de partidas aparece alguna jugada que lleva del tablero que representa el primer nodo al tablero que representa el segundo nodo. El peso de cada arista representa el n\u00famero de veces que esa jugada aparece en el archivo de partidas. El modelo de datos utilizado para representar el grafo es el siguiente:</p> <p></p> <p>Una de las peculiaridades de este grafo es que puede contener ciclos, y esto dificulta la aplicaci\u00f3n de algunos algoritmos. El primer objetivo de este ejercicio es dise\u00f1ar e implementar un algoritmo que borre el m\u00ednimo n\u00famero de aristas necesarias para eliminar todos los ciclos. Para ello, se puede ignorar la direccionalidad de las aristas, es decir, se puede considerar que el grafo es no dirigido. Eliminaremos los ciclos de forma que se sigan manteniendo las jugadas m\u00e1s repetidas, es decir, las de mayor peso.</p> <ul> <li>(a) (3 puntos) Implementar el m\u00e9todo <code>public void eliminarCiclos()</code> para la clase <code>GrafoPartidas</code> que borra del grafo el m\u00ednimo n\u00famero de aristas para eliminar todos los ciclos. </li> </ul> <p>Al no tener en cuenta la direccionalidad de las aristas, la soluci\u00f3n obtenida puede contener nodos que no son alcanzables desde el tablero inicial del ajedrez. </p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n para el m\u00e9todo <code>eliminarCiclos()</code> basada en el algoritmo de Prim (o Jarnik) es la siguiente:</p> <pre><code>public void eliminarCiclos() {\n  Nodo inicio = nodos.get(Tablero.tableroBasico()); \n  Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n  Set&lt;Enlace&gt; nuevosEnlaces = new HashSet&lt;&gt;();\n  Set&lt;Enlace&gt; porVisitar = new HashSet&lt;&gt;(inicio.getEnlaces());\n  visitados.add(inicio);\n  while (!porVisitar.isEmpty()) {\n    Enlace mejor = null;\n    int maxPeso = Integer.MIN_VALUE;\n    for (Enlace enlace : porVisitar) {\n      if (enlace.getPeso() &gt; maxPeso) {\n        maxPeso = enlace.getPeso();\n        mejor = enlace;\n      }\n    }\n    porVisitar.remove(mejor);\n    Nodo nodoA = mejor.getOrigen();\n    Nodo nodoB = mejor.getDestino();\n    if (visitados.contains(nodoA) &amp;&amp; visitados.contains(nodoB)) continue;\n    nuevosEnlaces.add(mejor);\n    Nodo nuevo = visitados.contains(nodoA) ? nodoB : nodoA;\n    visitados.add(nuevo);\n    for (Enlace e : nuevo.getEnlaces()) {\n      Nodo otro = e.getOtro(nuevo);\n      if (!visitados.contains(otro)) {\n        porVisitar.add(e);\n      }\n    }\n  }\n  this.enlaces = nuevosEnlaces;\n  for (Nodo nodo : nodos.values()) {\n    Set&lt;Enlace&gt; filtrados = new HashSet&lt;&gt;();\n    for (Enlace e : nodo.getEnlaces()) {\n      if (nuevosEnlaces.contains(e)) {\n        filtrados.add(e);\n      }\n    }\n    nodo.getEnlaces().clear();\n    nodo.getEnlaces().addAll(filtrados);\n  }\n}\n</code></pre> <p>Si se utilizan estructuras de datos adecuadas, como un <code>PriorityQueue</code> para los enlaces, se puede optimizar a\u00fan m\u00e1s el proceso de selecci\u00f3n del enlace con mayor peso.</p> <ul> <li>(b) (2 puntos) Implementar el m\u00e9todo <code>public void eliminarNodosInalcanzables()</code> para la clase <code>GrafoPartidas</code> que elimina del grafo todos los nodos que no son alcanzables desde el tablero inicial del ajedrez.</li> </ul> <p>Nota: en ambos apartados se eliminar\u00e1n elementos del grafo, y cuando esto suceda, se deben eliminar todas las referencias a esos elementos. Por ejemplo, si se elimina un nodo, se deben eliminar todas las aristas que lo referencian. O si se elimina una arista, habr\u00e1 que eliminarla tanto del conjunto de aristas del grafo como de todos los nodos que la referencian.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n para el m\u00e9todo <code>eliminarNodosInalcanzables()</code> es la siguiente (tanto BFS como Dijkstra son adecuados para este prop\u00f3sito):</p> <pre><code>public void eliminarNodosInalcanzables() {\n    Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n    Stack&lt;Nodo&gt; pila = new Stack&lt;&gt;();\n    Nodo inicio = nodos.get(Tablero.tableroBasico());\n    pila.push(inicio);\n    visitados.add(inicio);\n\n    while (!pila.isEmpty()) {\n        Nodo nodo = pila.pop();\n        for (Enlace e : nodo.getEnlacesSalientes()) {\n            Nodo otro = e.getDestino();\n            if (!visitados.contains(otro)) {\n                visitados.add(otro);\n                pila.push(otro);\n            }\n        }\n    }\n\n    Set&lt;Tablero&gt; nodosAEliminar = new HashSet&lt;&gt;();\n    for (Map.Entry&lt;Tablero, Nodo&gt; entry : nodos.entrySet()) {\n        if (!visitados.contains(entry.getValue())) {\n            nodosAEliminar.add(entry.getKey());\n        }\n    }\n\n    for (Tablero t : nodosAEliminar) {\n        Nodo nodo = nodos.get(t);\n        for (Enlace e : nodo.getEnlaces()) {\n            enlaces.remove(e);\n            Nodo otro = e.getOtro(nodo);\n            otro.getEnlaces().remove(e);\n        }\n        nodos.remove(t);\n    }\n}\n</code></pre>"},{"location":"exams/2025/p2_ex01/","title":"P2 ex01","text":"<p>Se quiere simular un sistema de impresi\u00f3n con una impresora a la que varios usuarios pueden pedir impresiones. Los usuarios pueden pedir imprimir un texto (una cadena de caracteres). La impresora debe imprimir un texto solo cuando no est\u00e9 ocupada, y siempre debe dar prioridad al texto m\u00e1s corto. Los usuarios se modelan como hebras independientes.</p> <p>Se proporciona el siguiente diagrama de clases como referencia, y se pide:</p> <pre><code>\\begin{minipage}[thp]{12cm}\n</code></pre> <ul> <li>(a) (1 punto) Implementar la clase <code>Usuario</code>, que ser\u00e1 una hebra con un nombre, un texto a imprimir y una referencia a la impresora, y su \u00fanica labor es imprimir el texto dado en la impresora.</li> </ul> Mostrar soluci\u00f3n <pre><code>class Usuario extends Thread {\n  private String nombre;\n  private Impresora impresora;\n  private String texto;\n  public Usuario(String nombre, Impresora impresora, String texto) {\n    this.nombre = nombre;\n    this.impresora = impresora;\n    this.texto = texto;\n  }\n  public void run() {\n    try {\n      impresora.imprimir(texto, nombre);\n    } catch (InterruptedException e) {}\n  }\n}\n</code></pre> <ul> <li>(b) (2 puntos) Implementa una clase <code>Impresora</code> que contenga un m\u00e9todo <code>imprimir</code> que asegure que:<ul> <li>Solo se permite imprimir un texto en cada momento</li> <li>Los textos se imprimen a una velocidad de un car\u00e1cter por milisegundo. Para simular la impresi\u00f3n, se debe usar el m\u00e9todo <code>Thread.sleep(long millis)</code>, que puede lanzar excepciones del tipo <code>InterruptedException</code>.</li> <li>Una vez comienza la impresi\u00f3n de un texto, no se podr\u00e1 empezar con otro hasta haberlo terminado</li> <li>Si varias hebras intentan imprimir, los textos m\u00e1s cortos tendr\u00e1n prioridad</li> <li>Se guarda un registro (<code>registro</code>) de todos los caracteres impresos hasta el momento por la impresora</li> <li>Se debe mostrar por consola un mensaje en los siguientes momentos: 1) cuando un usuario intenta imprimir; 2) tras imprimir cada car\u00e1cter; y 3) cuando se ha terminado de imprimir un texto completo. Los mensajes deben contener el nombre de la hebra que ha realizado la acci\u00f3n.</li> </ul> </li> </ul> Mostrar soluci\u00f3n <p>Se acepta como v\u00e1lida la siguiente soluci\u00f3n:</p> <pre><code>    static class Impresora {\n        private List&lt;String&gt; cola = new ArrayList&lt;String&gt;();\n        private String registro = \"\";\n        private boolean imprimiendo = false;\n\n        public synchronized void imprimir(String texto, String usuario) throws InterruptedException {\n            System.out.println(usuario + \" quiere imprimir: \" + texto);\n            int pos = 0;\n            while(pos &lt; cola.size()) {\n                if(cola.get(i).lengt() &gt; texto.length()) {\n                    break;\n                }\n                pos++;\n            }\n            cola.add(pos, texto);\n\n            while (imprimiendo || cola.get(0) != texto) {\n                try {\n                    wait();\n                } catch (InterruptedException e) {}\n            }\n\n            imprimiendo = true;\n            cola.remove(0);\n            System.out.println(usuario + \" empieza a imprimir: \" + texto);\n            int i = 0;\n            while(i &lt; texto.length()) {\n                System.out.println(usuario + \" imprime: \" + texto.charAt(i));\n                registro = registro + texto.charAt(i);\n                i++;\n                Thread.sleep(10);\n            }\n            imprimiendo = false;\n            System.out.println(usuario + \" termina de imprimir\");\n            notifyAll();\n        }\n    }\n</code></pre> <p>No obstante, la soluci\u00f3n correcta incluir\u00eda liberar el cerrojo durante el <code>sleep</code>. Por ejemplo:</p> <pre><code>class Impresora {\n  private List&lt;String&gt; cola = new ArrayList&lt;String&gt;();\n  private boolean imprimiendo = false;\n  public String registro = \"\";\n  public void imprimir(String texto, String usuario) throws InterruptedException {\n    ponerEnCola(texto, usuario);\n    intentarImprimir(texto, usuario);\n    int i = 0;\n    while(i &lt; texto.length()) {\n      System.out.println(usuario + \" imprime: \" + texto.charAt(i));\n      registro = registro + texto.charAt(i);\n      i++;\n      Thread.sleep(10);\n    }\n    dejarDeImprimir(texto, usuario);\n  }\n  public synchronized void ponerEnCola(String texto, String usuario) {\n    System.out.println(usuario + \" quiere imprimir: \" + texto + \" [ \" + texto.length() + \" caracteres]\");\n    int pos = 0;\n    while(pos &lt; cola.size()) {\n      if(cola.get(pos).length() &gt; texto.length()) {\n        break;\n      }\n      pos++;\n    }\n    cola.add(pos, texto);\n  }\n  public synchronized void intentarImprimir(String texto, String usuario) {\n    while (imprimiendo || !cola.get(0).equals(texto)) {\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n    }\n    cola.remove(0);\n    imprimiendo = true;\n    System.out.println(usuario + \" empieza a imprimir: \" + texto);\n  }\n  public synchronized void dejarDeImprimir(String texto, String usuario) {\n    System.out.println(usuario + \" termina de imprimir\");\n    imprimiendo = false;\n    notifyAll();\n  }\n}\n</code></pre> <ul> <li>(c) (1 punto) Implementa el m\u00e9todo <code>main</code> para que sirva de prueba r\u00e1pida la implementaci\u00f3n (<code>smoketest</code>). Se deben crear al menos 4 usuarios que impriman textos diferentes en la misma impresora, y mostrar un texto al finalizar todas las impresiones.</li> </ul> Mostrar soluci\u00f3n <pre><code>public static void main(String[] args) throws InterruptedException {\n    Impresora impresora = new Impresora();\n    String[] textos = { \"hola\\n\", \"buenos d\u00edas\\n\", \"adi\u00f3s\\n\", \"s\u00ed\\n\" };\n    Usuario[] usuarios = new Usuario[textos.length];\n    for (int i = 0; i &lt; textos.length; i++) {\n        usuarios[i] = new Usuario(\"Usuario \" + (char)('A' + i), impresora, textos[i]);\n    }\n    for (Usuario u : usuarios) {\n        u.start();\n    }\n    for (Usuario u : usuarios) {\n        try {\n            u.join();\n        } catch (InterruptedException e) {}\n    }\n    System.out.println(\"Todos los trabajos han terminado. Texto final: \" + impresora.registro());\n}\n</code></pre> <ul> <li>(d) (1 punto) Explica qu\u00e9 modificaciones se podr\u00edan realizar en el c\u00f3digo para que una impresora permita imprimir a 2 usuarios a la vez.</li> </ul> Mostrar soluci\u00f3n <p>Habr\u00eda que cambiar el flag de imprimiendo para que fuera un entero con el n\u00famero de usuarios imprimiendo en ese momento. Tambi\u00e9n habr\u00eda que sacar el <code>sleep</code> de la zona cr\u00edtica. De lo contrario, mientras una hebra est\u00e1 imprimiendo el resto quedar\u00edan bloqueadas.</p> <p></p>","tags":["concurrencia"]},{"location":"exams/2025/p2_ex02/","title":"P2 ex02","text":"<p>En las pr\u00e1cticas de la asignatura se ha trabajado con un grafo creado a partir de un archivo que contiene un hist\u00f3rico de partidas de ajedrez. En el grafo cada nodo representa un estado del tablero de ajedrez. Dos nodos est\u00e1n conectados por una arista dirigida si en el archivo de partidas aparece alguna jugada que lleva del tablero que representa el primer nodo al tablero que representa el segundo nodo. El peso de cada arista representa el n\u00famero de veces que esa jugada aparece en el archivo de partidas. El modelo de datos utilizado para representar el grafo es el siguiente:</p> <p></p> <p>Una de las peculiaridades de este grafo es que puede contener ciclos, y esto dificulta la aplicaci\u00f3n de algunos algoritmos. El primer objetivo de este ejercicio es dise\u00f1ar e implementar un algoritmo que borre el m\u00ednimo n\u00famero de aristas necesarias para eliminar todos los ciclos. Para ello, se puede ignorar la direccionalidad de las aristas, es decir, se puede considerar que el grafo es no dirigido. Eliminaremos los ciclos de forma que se sigan manteniendo las jugadas m\u00e1s repetidas, es decir, las de mayor peso.</p> <ul> <li>(a) (3 puntos) Implementar el m\u00e9todo <code>public void eliminarCiclos()</code> para la clase <code>GrafoPartidas</code> que borra del grafo el m\u00ednimo n\u00famero de aristas para eliminar todos los ciclos. </li> </ul> <p>Al no tener en cuenta la direccionalidad de las aristas, la soluci\u00f3n obtenida puede contener nodos que no son alcanzables desde el tablero inicial del ajedrez. </p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n para el m\u00e9todo <code>eliminarCiclos()</code> basada en el algoritmo de Prim (o Jarnik) es la siguiente:</p> <pre><code>public void eliminarCiclos() {\n  Nodo inicio = nodos.get(Tablero.tableroBasico()); \n  Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n  Set&lt;Enlace&gt; nuevosEnlaces = new HashSet&lt;&gt;();\n  Set&lt;Enlace&gt; porVisitar = new HashSet&lt;&gt;(inicio.getEnlaces());\n  visitados.add(inicio);\n  while (!porVisitar.isEmpty()) {\n    Enlace mejor = null;\n    int maxPeso = Integer.MIN_VALUE;\n    for (Enlace enlace : porVisitar) {\n      if (enlace.getPeso() &gt; maxPeso) {\n        maxPeso = enlace.getPeso();\n        mejor = enlace;\n      }\n    }\n    porVisitar.remove(mejor);\n    Nodo nodoA = mejor.getOrigen();\n    Nodo nodoB = mejor.getDestino();\n    if (visitados.contains(nodoA) &amp;&amp; visitados.contains(nodoB)) continue;\n    nuevosEnlaces.add(mejor);\n    Nodo nuevo = visitados.contains(nodoA) ? nodoB : nodoA;\n    visitados.add(nuevo);\n    for (Enlace e : nuevo.getEnlaces()) {\n      Nodo otro = e.getOtro(nuevo);\n      if (!visitados.contains(otro)) {\n        porVisitar.add(e);\n      }\n    }\n  }\n  this.enlaces = nuevosEnlaces;\n  for (Nodo nodo : nodos.values()) {\n    Set&lt;Enlace&gt; filtrados = new HashSet&lt;&gt;();\n    for (Enlace e : nodo.getEnlaces()) {\n      if (nuevosEnlaces.contains(e)) {\n        filtrados.add(e);\n      }\n    }\n    nodo.getEnlaces().clear();\n    nodo.getEnlaces().addAll(filtrados);\n  }\n}\n</code></pre> <p>Si se utilizan estructuras de datos adecuadas, como un <code>PriorityQueue</code> para los enlaces, se puede optimizar a\u00fan m\u00e1s el proceso de selecci\u00f3n del enlace con mayor peso.</p> <ul> <li>(b) (2 puntos) Implementar el m\u00e9todo <code>public void eliminarNodosInalcanzables()</code> para la clase <code>GrafoPartidas</code> que elimina del grafo todos los nodos que no son alcanzables desde el tablero inicial del ajedrez.</li> </ul> <p>Nota: en ambos apartados se eliminar\u00e1n elementos del grafo, y cuando esto suceda, se deben eliminar todas las referencias a esos elementos. Por ejemplo, si se elimina un nodo, se deben eliminar todas las aristas que lo referencian. O si se elimina una arista, habr\u00e1 que eliminarla tanto del conjunto de aristas del grafo como de todos los nodos que la referencian.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n para el m\u00e9todo <code>eliminarNodosInalcanzables()</code> es la siguiente (tanto BFS como Dijkstra son adecuados para este prop\u00f3sito):</p> <pre><code>public void eliminarNodosInalcanzables() {\n    Set&lt;Nodo&gt; visitados = new HashSet&lt;&gt;();\n    Stack&lt;Nodo&gt; pila = new Stack&lt;&gt;();\n    Nodo inicio = nodos.get(Tablero.tableroBasico());\n    pila.push(inicio);\n    visitados.add(inicio);\n\n    while (!pila.isEmpty()) {\n        Nodo nodo = pila.pop();\n        for (Enlace e : nodo.getEnlacesSalientes()) {\n            Nodo otro = e.getDestino();\n            if (!visitados.contains(otro)) {\n                visitados.add(otro);\n                pila.push(otro);\n            }\n        }\n    }\n\n    Set&lt;Tablero&gt; nodosAEliminar = new HashSet&lt;&gt;();\n    for (Map.Entry&lt;Tablero, Nodo&gt; entry : nodos.entrySet()) {\n        if (!visitados.contains(entry.getValue())) {\n            nodosAEliminar.add(entry.getKey());\n        }\n    }\n\n    for (Tablero t : nodosAEliminar) {\n        Nodo nodo = nodos.get(t);\n        for (Enlace e : nodo.getEnlaces()) {\n            enlaces.remove(e);\n            Nodo otro = e.getOtro(nodo);\n            otro.getEnlaces().remove(e);\n        }\n        nodos.remove(t);\n    }\n}\n</code></pre>","tags":["grafos"]},{"location":"exams/2025/pract/","title":"Examen 2025 \u2014 Pr\u00e1cticas","text":""},{"location":"exams/2025/pract/#problema-1","title":"Problema 1","text":"<p>En ajedrez, coronar un pe\u00f3n ocurre cuando un pe\u00f3n alcanza la \u00faltima fila del tablero. Entonces, puede sustituir al pe\u00f3n por cualquier otra pieza, excepto el rey. Normalmente, la pieza elegida es la dama. </p> <ul> <li>(a) (10 puntos) En este ejercicio, se pide desarrollar el m\u00e9todo <code>sonVariasDamas</code>, con la siguiente signatura. <pre><code>public boolean sonVariasDamas(Tablero unTablero)\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>public boolean sonVariasDamas(Tablero unTablero) {\n    Pieza[][] matrizPiezas = unTablero.getMatrizPiezas();\n    int nDamasBlancas = 0;\n    int nDamasNegras = 0;\n\n    for (int fila = 0; fila &lt; 8; fila++) {\n        for (int columna = 0; columna &lt; 8; columna++) {\n            Pieza pieza = matrizPiezas[fila][columna];\n            if (pieza != null) {\n                if (pieza.getTipo() == TipoPieza.REINA) {\n                    if (pieza.getBando() == Bando.BLANCAS) {\n                        nDamasBlancas ++;\n                    } else {\n                        nDamasNegras ++;\n                    }\n                }\n            }\n        }\n    }\n    return nDamasBlancas &gt; 1 || nDamasNegras &gt; 1;\n}\n</code></pre>"},{"location":"exams/2025/pract/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) Desarrollar el m\u00e9todo <code>public Tablero[] movimientoMasRepetido()</code> que devuelve un array con los dos tableros que representan el movimiento m\u00e1s repetido en el grafo.</li> </ul> Mostrar soluci\u00f3n <pre><code>public Tablero[] movimientoMasRepetido() {\n  Enlace maxEnlace = null;\n  for (Enlace enlace : this.enlaces) {\n    if (maxEnlace == null || enlace.getPeso() &gt; maxEnlace.getPeso()) {\n      maxEnlace = enlace;\n    }\n  }\n  return new Tablero[] {maxEnlace.getOrigen().getTablero(),\n                       maxEnlace.getDestino().getTablero()};\n}\n</code></pre> <ul> <li>(b) (5 puntos) Desarrolle un m\u00e9todo que reciba como par\u00e1metro dos tableros y calcule el camino de longitud impar m\u00e1s corto, entre ellos. El m\u00e9todo debe devolver una secuencia de <code>Nodo</code> que represente el camino encontrado.</li> <li>Si no existe un camino entre los dos tableros, el m\u00e9todo debe devolver <code>null</code>.</li> <li>Si hay varios caminos de la misma longitud, devolver\u00e1 el primero que se encuentre.</li> </ul> Mostrar soluci\u00f3n <p>Usamos el mismo algoritmo que hayamos implementado en la pr\u00e1ctica 2. Solo se debe a\u00f1adir la condici\u00f3n de longitud impar para considerar un camino v\u00e1lido</p> <p>Si es BFS, basta con a\u00f1adir una condici\u00f3n que compruebe si la longitud del camino es impar antes de devolver el camino encontrado. Si es Dijkstra, se debe modificar la l\u00f3gica del m\u00e9todo relax para que solo actualice la distancia al destino si la longitud del camino es impar.</p>"},{"location":"exams/2025/pract/#problema-3","title":"Problema 3","text":"<ul> <li>(a) (6 puntos) Escriba las modificaciones necesarias en <code>AnalizadorConcurrente</code> para asegurar que nunca haya m\u00e1s m\u00e1s tareas pendientes (en la cola) que hebras procesadoras de tareas.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo <code>addTarea</code> debe bloquear cuando haya demasiadas tareas en cola. Adem\u00e1s, el m\u00e9todo <code>getTarea</code> debe notificar cuando libera una tarea.</p> <pre><code>public synchronized void addTarea(TareaCamino tarea) {\n  while(tareas.size() &gt;= numHebras) {\n    wait();\n  }\n  tareas.add(tarea);\n  notifyAll();\n}\n\npublic synchronized TareaCamino getTarea(HebraWorker hw) throws InterruptedException {\n  while (tareas.isEmpty() &amp;&amp; hw.keepWorking) {\n    wait();\n  }\n  if (!hw.keepWorking) {\n    return null;\n  }\n  Tarea t = tareas.remove(0);\n  notifyAll();\n  return t;\n}\n</code></pre> <ul> <li>(b) (4 puntos) Explique con detalle c\u00f3mo comprobar\u00eda que las modificaciones realizadas funcionan correctamente.</li> </ul> Mostrar soluci\u00f3n <p>Realizar\u00eda una o varias pruebas unitarias, y/o un smoketest. El c\u00f3digo tendr\u00eda que implementar el caso que queremos probar: intentar a\u00f1adir m\u00e1s tareas que hebras disponibles, y comprobar que realmente se bloqu\u00e9e la ejecuci\u00f3n.</p> <p>Por ejemplo, se podr\u00edan a\u00f1adir manualmente m\u00e1s tareas que <code>NUM_HEBRAS</code> a un pool de hebras. Las tareas podr\u00edan ser simples, como un tablero con jaque mate, para que no resulten en m\u00e1s tareas. La comprobaci\u00f3n tendr\u00eda que asegurar que se ha bloqueado la ejecuci\u00f3n de <code>addTarea</code>.</p> <p>Una forma sencilla de hacer la comprobaci\u00f3n ser\u00eda a\u00f1adir aserciones tras la l\u00ednea en <code>addTarea</code> que a\u00f1ade la tarea a la cola: <code>assert tareas.size() &lt;= NUM_HEBRAS</code>.</p> <p>Nota: en este caso el pool de hebras arranca las hebras procesadoras en el constructor, lo que implica que las hebras procesadoras estar\u00e1n constantemente intentando consumir tareas. Debemos asegurar que se a\u00f1aden suficientes tareas suficientemente r\u00e1pido. Por ejemplo, a\u00f1adiendo <code>10*NUM_HEBRAS</code> tareas en bucle.</p> <p>Otras formas incluyen: - Modificar el c\u00f3digo en <code>addTarea</code> para mantener un contador de veces en que se ha bloqueado (antes del <code>.wait()</code>). Se puede comprobar este contador en la prueba.  (f\u00e1cil) - Suspender manualmente las hebras proceadoras con <code>suspend</code> mientras se a\u00f1aden las tareas. Para ello hace falta acceso a la lista de hebras. Una forma ser\u00eda implementar los m\u00e9todos <code>pararHebras</code> y <code>reanudarHebras</code> en <code>PoolHebras</code>. (medio) - Usar hebras que consuman tareas mucho m\u00e1s lentamente para poder medir los bloqueos con tiempo. Para ello, habr\u00eda que permitir a <code>PoolHebras</code> utilizar hebras distintas de <code>HebraWorker</code>. Por ejemplo, pasando la clase como argumento al constructor. (dif\u00edcil)</p>"},{"location":"exams/2025/pract_ex01/","title":"Pract ex01","text":"<p>En ajedrez, coronar un pe\u00f3n ocurre cuando un pe\u00f3n alcanza la \u00faltima fila del tablero. Entonces, puede sustituir al pe\u00f3n por cualquier otra pieza, excepto el rey. Normalmente, la pieza elegida es la dama. </p> <ul> <li>(a) (10 puntos) En este ejercicio, se pide desarrollar el m\u00e9todo <code>sonVariasDamas</code>, con la siguiente signatura. <pre><code>public boolean sonVariasDamas(Tablero unTablero)\n</code></pre></li> </ul> Mostrar soluci\u00f3n <pre><code>public boolean sonVariasDamas(Tablero unTablero) {\n    Pieza[][] matrizPiezas = unTablero.getMatrizPiezas();\n    int nDamasBlancas = 0;\n    int nDamasNegras = 0;\n\n    for (int fila = 0; fila &lt; 8; fila++) {\n        for (int columna = 0; columna &lt; 8; columna++) {\n            Pieza pieza = matrizPiezas[fila][columna];\n            if (pieza != null) {\n                if (pieza.getTipo() == TipoPieza.REINA) {\n                    if (pieza.getBando() == Bando.BLANCAS) {\n                        nDamasBlancas ++;\n                    } else {\n                        nDamasNegras ++;\n                    }\n                }\n            }\n        }\n    }\n    return nDamasBlancas &gt; 1 || nDamasNegras &gt; 1;\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2025/pract_ex02/","title":"Pract ex02","text":"<ul> <li>(a) (5 puntos) Desarrollar el m\u00e9todo <code>public Tablero[] movimientoMasRepetido()</code> que devuelve un array con los dos tableros que representan el movimiento m\u00e1s repetido en el grafo.</li> </ul> Mostrar soluci\u00f3n <pre><code>public Tablero[] movimientoMasRepetido() {\n  Enlace maxEnlace = null;\n  for (Enlace enlace : this.enlaces) {\n    if (maxEnlace == null || enlace.getPeso() &gt; maxEnlace.getPeso()) {\n      maxEnlace = enlace;\n    }\n  }\n  return new Tablero[] {maxEnlace.getOrigen().getTablero(),\n                       maxEnlace.getDestino().getTablero()};\n}\n</code></pre> <ul> <li>(b) (5 puntos) Desarrolle un m\u00e9todo que reciba como par\u00e1metro dos tableros y calcule el camino de longitud impar m\u00e1s corto, entre ellos. El m\u00e9todo debe devolver una secuencia de <code>Nodo</code> que represente el camino encontrado.</li> <li>Si no existe un camino entre los dos tableros, el m\u00e9todo debe devolver <code>null</code>.</li> <li>Si hay varios caminos de la misma longitud, devolver\u00e1 el primero que se encuentre.</li> </ul> Mostrar soluci\u00f3n <p>Usamos el mismo algoritmo que hayamos implementado en la pr\u00e1ctica 2. Solo se debe a\u00f1adir la condici\u00f3n de longitud impar para considerar un camino v\u00e1lido</p> <p>Si es BFS, basta con a\u00f1adir una condici\u00f3n que compruebe si la longitud del camino es impar antes de devolver el camino encontrado. Si es Dijkstra, se debe modificar la l\u00f3gica del m\u00e9todo relax para que solo actualice la distancia al destino si la longitud del camino es impar.</p>","tags":["complejidad"]},{"location":"exams/2025/pract_ex03/","title":"Pract ex03","text":"<ul> <li>(a) (6 puntos) Escriba las modificaciones necesarias en <code>AnalizadorConcurrente</code> para asegurar que nunca haya m\u00e1s m\u00e1s tareas pendientes (en la cola) que hebras procesadoras de tareas.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo <code>addTarea</code> debe bloquear cuando haya demasiadas tareas en cola. Adem\u00e1s, el m\u00e9todo <code>getTarea</code> debe notificar cuando libera una tarea.</p> <pre><code>public synchronized void addTarea(TareaCamino tarea) {\n  while(tareas.size() &gt;= numHebras) {\n    wait();\n  }\n  tareas.add(tarea);\n  notifyAll();\n}\n\npublic synchronized TareaCamino getTarea(HebraWorker hw) throws InterruptedException {\n  while (tareas.isEmpty() &amp;&amp; hw.keepWorking) {\n    wait();\n  }\n  if (!hw.keepWorking) {\n    return null;\n  }\n  Tarea t = tareas.remove(0);\n  notifyAll();\n  return t;\n}\n</code></pre> <ul> <li>(b) (4 puntos) Explique con detalle c\u00f3mo comprobar\u00eda que las modificaciones realizadas funcionan correctamente.</li> </ul> Mostrar soluci\u00f3n <p>Realizar\u00eda una o varias pruebas unitarias, y/o un smoketest. El c\u00f3digo tendr\u00eda que implementar el caso que queremos probar: intentar a\u00f1adir m\u00e1s tareas que hebras disponibles, y comprobar que realmente se bloqu\u00e9e la ejecuci\u00f3n.</p> <p>Por ejemplo, se podr\u00edan a\u00f1adir manualmente m\u00e1s tareas que <code>NUM_HEBRAS</code> a un pool de hebras. Las tareas podr\u00edan ser simples, como un tablero con jaque mate, para que no resulten en m\u00e1s tareas. La comprobaci\u00f3n tendr\u00eda que asegurar que se ha bloqueado la ejecuci\u00f3n de <code>addTarea</code>.</p> <p>Una forma sencilla de hacer la comprobaci\u00f3n ser\u00eda a\u00f1adir aserciones tras la l\u00ednea en <code>addTarea</code> que a\u00f1ade la tarea a la cola: <code>assert tareas.size() &lt;= NUM_HEBRAS</code>.</p> <p>Nota: en este caso el pool de hebras arranca las hebras procesadoras en el constructor, lo que implica que las hebras procesadoras estar\u00e1n constantemente intentando consumir tareas. Debemos asegurar que se a\u00f1aden suficientes tareas suficientemente r\u00e1pido. Por ejemplo, a\u00f1adiendo <code>10*NUM_HEBRAS</code> tareas en bucle.</p> <p>Otras formas incluyen: - Modificar el c\u00f3digo en <code>addTarea</code> para mantener un contador de veces en que se ha bloqueado (antes del <code>.wait()</code>). Se puede comprobar este contador en la prueba.  (f\u00e1cil) - Suspender manualmente las hebras proceadoras con <code>suspend</code> mientras se a\u00f1aden las tareas. Para ello hace falta acceso a la lista de hebras. Una forma ser\u00eda implementar los m\u00e9todos <code>pararHebras</code> y <code>reanudarHebras</code> en <code>PoolHebras</code>. (medio) - Usar hebras que consuman tareas mucho m\u00e1s lentamente para poder medir los bloqueos con tiempo. Para ello, habr\u00eda que permitir a <code>PoolHebras</code> utilizar hebras distintas de <code>HebraWorker</code>. Por ejemplo, pasando la clase como argumento al constructor. (dif\u00edcil)</p>","tags":["hebras"]},{"location":"exams/20XXTemplate/extra/","title":"Examen 20XX \u2014 Extraordinario","text":""},{"location":"exams/20XXTemplate/extra/#problema-1","title":"Problema 1","text":""},{"location":"exams/20XXTemplate/extra/#problema-2","title":"Problema 2","text":""},{"location":"exams/20XXTemplate/p1/","title":"Examen 20XX \u2014 Parcial 1","text":""},{"location":"exams/20XXTemplate/p1/#problema-1","title":"Problema 1","text":""},{"location":"exams/20XXTemplate/p1/#problema-2","title":"Problema 2","text":""},{"location":"exams/20XXTemplate/p1r/","title":"Examen 20XX \u2014 Parcial 1 Recuperaci\u00f3n","text":""},{"location":"exams/20XXTemplate/p1r/#problema-1","title":"Problema 1","text":""},{"location":"exams/20XXTemplate/p1r/#problema-2","title":"Problema 2","text":""},{"location":"exams/20XXTemplate/p2/","title":"Examen 20XX \u2014 Parcial 2","text":""},{"location":"exams/20XXTemplate/p2/#problema-1","title":"Problema 1","text":""},{"location":"exams/20XXTemplate/p2/#problema-2","title":"Problema 2","text":""}]}