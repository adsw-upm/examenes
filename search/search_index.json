{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cat\u00e1logo de Ejercicios","text":"<p>Bienvenido al cat\u00e1logo.</p>"},{"location":"tags/","title":"Tags","text":"<p> Listado de tags</p> <p>La siguiente p\u00e1gina muestra autom\u00e1ticamente todos los ejercicios agrupados por tag.</p> <p>[TAGS]</p>"},{"location":"exams/2012/ex01/","title":"Ex01","text":"","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex01/#a-15-puntos","title":"A. (1.5 puntos)","text":"<p>Se pide escribir un algoritmo de ordenaci\u00f3n con la siguiente interfaz</p> <p><pre><code>int[] ordena(long[] datos)\n</code></pre> de tal forma que los datos de entrada no se modifican y el m\u00e9todo devuelve un array que contiene en qu\u00e9 posici\u00f3n deber\u00eda ir del dato correspondiente para estar en orden ascendente. Por ejemplo: <pre><code>datos:   [8, 42, 46, 24, 29, 7]\nindices: [1,  4,  5,  2,  3, 0]\n</code></pre> que se lee como que</p> <ul> <li>datos[0] se ordenar\u00eda en la posici\u00f3n 1</li> <li>datos[1] se ordenar\u00eda en la posici\u00f3n 4</li> <li>datos[2] se ordenar\u00eda en la posici\u00f3n 5</li> <li>etc.</li> </ul> <p>NOTA: Si hubiera 2 datos de igual valor, da igual cual de ellos va antes o despu\u00e9s. Elija lo que le sea m\u00e1s c\u00f3modo.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre></p>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex01/#b-15-puntos","title":"B. (1.5 puntos)","text":"<p>Estime la complejidad del  algoritmo  del  punto anterior,  contando  el  n\u00famero  de  comparaciones entre datos (enteros <code>long</code>) que hay que hacer en el caso peor.</p> Mostrar soluci\u00f3n <p>Hay 2 bucles, uno dentro del otro. El bucle exterior se hace \\(N\\) veces. En el bucle interior, la primera vez se hacen \\(N-1\\) comparaciones; la segunda vez, \\(N-2\\); la tercera \\(N-3\\), etc.  En total \\((N-1) + (N-2) + ... + 1 \\leftarrow \\mathcal{O}(N^2)\\)</p>","tags":["ordenaci\u00f3n","complejidad"]},{"location":"exams/2012/ex02/","title":"Ex02","text":"","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex02/#a-3-puntos","title":"A. (3 puntos)","text":"<p>Sea un puente con capacidad para un veh\u00edculo y dos accesos: norte y sur. En caso de que haya veh\u00edculos intentando entrar por los dos accesos, debe entrar un veh\u00edculo por el extremo en el que haya m\u00e1s esperando (si el n\u00famero de veh\u00edculos esperando en cada extremo es el mismo, no es necesario imponer un orden). En el caso de que intente entrar una ambulancia, tendr\u00e1 prioridad sobre el resto de veh\u00edculos. No es necesario considerar el caso en que dos ambulancias intenten acceder simult\u00e1neamente al puente.  Se  pide  desarrollar  una  clase  monitor  GestorPuente  que  gestione  el  acceso  al  puente,  seg\u00fan  la especificaci\u00f3n  previa.  Los  m\u00e9todos  de  esta  clase  no  retornan  valores.  El  esqueleto  de  la  clase  es  el siguiente:</p> <pre><code>public class GestorPuente {\n    ... void entrarNorte () { ...}\n    ... void entrarSur () { ...}\n    ... void entrarAmbulancia () { ...}\n    ... void salirPuente(){...}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>package es.upm.dit.adsw.puenteTurnoEspera;\n/**\n* @author Alejandro Alonso\n* Monitor que gestiona la entrada a un puente de coches\n* por sus dos extremos (norte y sur). Dentro el puente s\u00f3lo puede\n* haber un coche. Si hay coches esperando en sus dos extremos, entra\n* uno por el extremos con m\u00e1s coches esperando. Si intenta entrar una\n* ambulancia, tendr\u00e1 prioridad. No pueden intentar dos ambulancias\n* simultaneamente.\n*/\npublic class GestorPuente { // monitor\n/**\n* Indica si hay un coche dentro del puente\n*/\nprivate boolean hayCocheEnPuente = false;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Norte\n*/\nprivate int nCochesNorte = 0;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Sur\n*/\nprivate int nCochesSur = 0;\n/**\n    Indica si hay una ambulancia esperando.\n\n*/\nprivate boolean hayAmbulancia = false;\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el norte.\n*  El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n*  coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarNorte() throws InterruptedException {\n    nCochesNorte++;\n    !!while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur)\n        wait();\n    hayCocheEnPuente = true;\n    nCochesNorte--;\n}\n\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el sur.\n* El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n* coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarSur() throws InterruptedException {\n    nCochesSur++;\n    while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte)\n    wait();\n    hayCocheEnPuente = true;\n    nCochesSur--;\n}\n/**\n* M\u00e9todo que ejecutan las ambulancias\n*/\npublic synchronized void entrarAmbulancia() throws InterruptedException {\n    hayAmbulancia = true;\n    while (hayCocheEnPuente) wait();\n    hayCocheEnPuente = true;\n    hayAmbulancia = false;\n}\n\n/**\n* M\u00e9todo que invoca un coche que est\u00e1 en el puente al salir de \u00e9l.\n*/\npublic synchronized void salirPuente() {\n    hayCocheEnPuente = false;\n    notifyAll();\n}\n}\n</code></pre></p>","tags":["concurrencia","monitores"]},{"location":"exams/2012/ex03/","title":"Ex03","text":"<p>Tenemos una aplicaci\u00f3n de Android que calcula la nota de ADSW como se muestra a continuaci\u00f3n.</p> <p>Como hemos visto, la aplicaci\u00f3n consta de dos pantallas, un formulario inicial (<code>NotaMediaActivity</code>) y  una pantalla que muestra  una foto y  el resultado (<code>ResultadoActivity</code>). Ambas clases est\u00e1n en el paquete <code>es.upm.dit.adsw</code>.</p> <p>El c\u00e1lculo de  la nota media se realiza de la siguiente forma:</p> <ul> <li>S\u00f3lo se hace media si ambas notas  son mayores o iguales a 4. </li> <li>La nota es 0.6 * nota de de examen + 0.4 * nota de trabajo</li> </ul>","tags":["android","actividades"]},{"location":"exams/2012/ex03/#a-1-punto","title":"A. (1 punto)","text":"<p>Complete el c\u00f3digo del fichero de manifiesto del listado 1 para que la aplicaci\u00f3n muestre la pantalla inicial (formulario) y pueda pasar a la segunda de resultado con la media.</p>","tags":["android","actividades"]},{"location":"exams/2012/ex03/#b-2-puntos","title":"B. (2 puntos)","text":"<p>Programe la actividad <code>NotaMediaActivity</code>. Debe tener en cuenta:</p> <ul> <li>Si el usuario no rellena un campo o introduce un valor no num\u00e9rico, debe mostrar un mensaje indic\u00e1ndole que debe introducir valores num\u00e9ricos (use un Toast).</li> <li>La actividad ResultadoActivity espera recibir una intenci\u00f3n con dos par\u00e1metros extra: <ul> <li>un primer par\u00e1metro de tipo boolean denominado \u201caprobado\u201d (true si cumple umbrales y media &gt; = 5; false en caso contrario)</li> <li>un segundo par\u00e1metro de tipo String denominado valor (contiene un mensaje indicando qu\u00e9 umbral no se ha superado si no se puede hacer la media, o bien el valor de la nota media).</li> </ul> </li> <li>Los listados 2 y 3 le proporcionan informaci\u00f3n del layout de NotaMediaActivity y las cadenas string.xml de la aplicaci\u00f3n.</li> </ul> <p>Listado 1. C\u00f3digo de AndroidManifest.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"COMPLETAR POR EL ALUMMNO\" &lt;!-- COMPLETAR --&gt;\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n     &gt;\n       &lt;!-- COMPLETAR POR EL ALUMNO --&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>Listado 2.  C\u00f3digo de layout/ notamedia_final.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;TableLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" \n    android:background=\"@drawable/notebook\"\n    android:paddingLeft=\"40dp\"\n    android:paddingRight=\"5dp\" &gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_examen\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_examen_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n            &lt;requestFocus /&gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_trabajo\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_trabajo_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow\n        android:gravity=\"center\"&gt;\n        &lt;Button\n            android:id=\"@+id/button_calcular\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/calcular\" /&gt;\n    &lt;/TableRow&gt;\n&lt;/TableLayout&gt;\n</code></pre></p> <p>Listado 3. C\u00f3digo de values/strings.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;NotaMediaADSW&lt;/string&gt;\n    &lt;string name=\"nota_trabajo\"&gt;Nota trabajo final&lt;/string&gt;\n    &lt;string name=\"nota_examen\"&gt;Nota examen final&lt;/string&gt;\n    &lt;string name=\"nota_media\"&gt;Nota media&lt;/string&gt;\n    &lt;string name=\"calcular\"&gt;Calcular&lt;/string&gt;\n    &lt;string name=\"error_numero\"&gt;Los campos deben ser num\u00e9ricos&lt;/string&gt;\n    &lt;string name=\"umbral_trabajo\"&gt;No has superado el umbral de 4.0 en la pr\u00e1ctica&lt;/string&gt;\n    &lt;string name=\"umbral_examen\"&gt;No has superado el umbral de 4.0 en el examen&lt;/string&gt;        \n     &lt;string name=\"enhorabuena\"&gt;Enhorabuena, que pases un buen verano.&lt;/string&gt;\n    &lt;string name=\"julio\"&gt;Hay otra oportunidad en julio. &lt;/string&gt;\n    &lt;string name=\"nota\"&gt;La nota es &lt;/string&gt;\n    &lt;string name=\"problema_nota\"&gt;Hay un problema para mostrar la nota&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre></p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n    &gt;\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\" &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <pre><code>public class NotaMediaActivity extends Activity {\npublic static final String APROBADO = \"nota\";\npublic static final String VALOR = \"valor\";\nprivate static final String TAG = NotaMediaActivity.class.getSimpleName();\nprivate EditText editNotaFinal;\nprivate EditText editTrabajoFinal;\nprivate Button buttonGuardar;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    Log.d(TAG, \"onCreate\");\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.notamedia_final);\n    editNotaFinal = (EditText) findViewById(R.id.editText_examen_final);\n    editTrabajoFinal = (EditText) findViewById(R.id.editText_trabajo_final);\n    buttonGuardar = (Button) findViewById(R.id.button_calcular);\n    buttonGuardar.setOnClickListener(new ProcesaMedia());\n}\n\nprivate class ProcesaMedia implements OnClickListener {\n    @Override\n    public void onClick(View v) {\n    try {\n        float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n        float notaTrabajo =\n            Float.parseFloat(editTrabajoFinal.getText().toString());\n        if ((notaFinal &lt; 0) || (notaFinal &gt; 10) || (notaTrabajo &lt; 0)\n            || (notaTrabajo &gt; 10)) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n        return;\n        }\n        float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String mediaString = df.format(media);\n        boolean aprobado = false;\n        String valor = \"\";\n        if ((notaTrabajo &lt; 4) || (notaFinal &lt; 4)) {\n        aprobado = false;\n        if (notaTrabajo &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_trabajo);\n        }\n        if (notaFinal &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_examen);\n        }\n        } else {\n        valor = mediaString;\n        aprobado = (media &gt;= 5);\n        }\n        Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n        intent.putExtra(APROBADO, aprobado);\n        intent.putExtra(VALOR, valor);\n        Log.d(TAG, \"Nota \" + aprobado + \" \" + valor);\n        startActivity(intent);\n    } catch (NumberFormatException e) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n    }\n    }\n}\n}\n</code></pre>","tags":["android","actividades"]},{"location":"exams/2012/exam/","title":"Examen 2012 \u2014 Final","text":""},{"location":"exams/2012/exam/#ejercicio-1","title":"Ejercicio 1","text":""},{"location":"exams/2012/exam/#a-15-puntos","title":"A. (1.5 puntos)","text":"<p>Se pide escribir un algoritmo de ordenaci\u00f3n con la siguiente interfaz</p> <p><pre><code>int[] ordena(long[] datos)\n</code></pre> de tal forma que los datos de entrada no se modifican y el m\u00e9todo devuelve un array que contiene en qu\u00e9 posici\u00f3n deber\u00eda ir del dato correspondiente para estar en orden ascendente. Por ejemplo: <pre><code>datos:   [8, 42, 46, 24, 29, 7]\nindices: [1,  4,  5,  2,  3, 0]\n</code></pre> que se lee como que</p> <ul> <li>datos[0] se ordenar\u00eda en la posici\u00f3n 1</li> <li>datos[1] se ordenar\u00eda en la posici\u00f3n 4</li> <li>datos[2] se ordenar\u00eda en la posici\u00f3n 5</li> <li>etc.</li> </ul> <p>NOTA: Si hubiera 2 datos de igual valor, da igual cual de ellos va antes o despu\u00e9s. Elija lo que le sea m\u00e1s c\u00f3modo.</p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>public int[] sort(long[] datos) {\n    int[] indices = new int[datos.length];\n    Arrays.fill(indices, -1);\n    for (int i = 0; i &lt; indices.length; i++) {\n        int iMenor = -1;\n        long menor = Long.MAX_VALUE;\n        for (int j = 0; j &lt; datos.length; j++) {\n            if (indices[j] &lt; 0 &amp;&amp; datos[j] &lt; menor) {\n                iMenor = j;\n                menor = datos[j];\n            }\n        }\n        indices[iMenor] = i;\n    }\n    return indices;\n}\n</code></pre></p>"},{"location":"exams/2012/exam/#b-15-puntos","title":"B. (1.5 puntos)","text":"<p>Estime la complejidad del  algoritmo  del  punto anterior,  contando  el  n\u00famero  de  comparaciones entre datos (enteros <code>long</code>) que hay que hacer en el caso peor.</p> Mostrar soluci\u00f3n <p>Hay 2 bucles, uno dentro del otro. El bucle exterior se hace \\(N\\) veces. En el bucle interior, la primera vez se hacen \\(N-1\\) comparaciones; la segunda vez, \\(N-2\\); la tercera \\(N-3\\), etc.  En total \\((N-1) + (N-2) + ... + 1 \\leftarrow \\mathcal{O}(N^2)\\)</p>"},{"location":"exams/2012/exam/#ejercicio-2","title":"Ejercicio 2","text":""},{"location":"exams/2012/exam/#a-3-puntos","title":"A. (3 puntos)","text":"<p>Sea un puente con capacidad para un veh\u00edculo y dos accesos: norte y sur. En caso de que haya veh\u00edculos intentando entrar por los dos accesos, debe entrar un veh\u00edculo por el extremo en el que haya m\u00e1s esperando (si el n\u00famero de veh\u00edculos esperando en cada extremo es el mismo, no es necesario imponer un orden). En el caso de que intente entrar una ambulancia, tendr\u00e1 prioridad sobre el resto de veh\u00edculos. No es necesario considerar el caso en que dos ambulancias intenten acceder simult\u00e1neamente al puente.  Se  pide  desarrollar  una  clase  monitor  GestorPuente  que  gestione  el  acceso  al  puente,  seg\u00fan  la especificaci\u00f3n  previa.  Los  m\u00e9todos  de  esta  clase  no  retornan  valores.  El  esqueleto  de  la  clase  es  el siguiente:</p> <pre><code>public class GestorPuente {\n    ... void entrarNorte () { ...}\n    ... void entrarSur () { ...}\n    ... void entrarAmbulancia () { ...}\n    ... void salirPuente(){...}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es: <pre><code>package es.upm.dit.adsw.puenteTurnoEspera;\n/**\n* @author Alejandro Alonso\n* Monitor que gestiona la entrada a un puente de coches\n* por sus dos extremos (norte y sur). Dentro el puente s\u00f3lo puede\n* haber un coche. Si hay coches esperando en sus dos extremos, entra\n* uno por el extremos con m\u00e1s coches esperando. Si intenta entrar una\n* ambulancia, tendr\u00e1 prioridad. No pueden intentar dos ambulancias\n* simultaneamente.\n*/\npublic class GestorPuente { // monitor\n/**\n* Indica si hay un coche dentro del puente\n*/\nprivate boolean hayCocheEnPuente = false;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Norte\n*/\nprivate int nCochesNorte = 0;\n/**\n* Indica el n\u00famero de coches que est\u00e1n esperando\n*  para entrar en el puente por el Sur\n*/\nprivate int nCochesSur = 0;\n/**\n    Indica si hay una ambulancia esperando.\n\n*/\nprivate boolean hayAmbulancia = false;\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el norte.\n*  El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n*  coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarNorte() throws InterruptedException {\n    nCochesNorte++;\n    !!while (hayCocheEnPuente || hayAmbulancia || nCochesNorte &lt; nCochesSur)\n        wait();\n    hayCocheEnPuente = true;\n    nCochesNorte--;\n}\n\n/**\n* M\u00e9todo que ejecutan los coches que quiere entrar por el sur.\n* El coche entrar\u00e1 en el puente cuando est\u00e9 vac\u00edo, no haya m\u00e1s\n* coches esperando en el sur y no haya ambulancias.\n*/\npublic synchronized void entrarSur() throws InterruptedException {\n    nCochesSur++;\n    while (hayCocheEnPuente || hayAmbulancia || nCochesSur &lt; nCochesNorte)\n    wait();\n    hayCocheEnPuente = true;\n    nCochesSur--;\n}\n/**\n* M\u00e9todo que ejecutan las ambulancias\n*/\npublic synchronized void entrarAmbulancia() throws InterruptedException {\n    hayAmbulancia = true;\n    while (hayCocheEnPuente) wait();\n    hayCocheEnPuente = true;\n    hayAmbulancia = false;\n}\n\n/**\n* M\u00e9todo que invoca un coche que est\u00e1 en el puente al salir de \u00e9l.\n*/\npublic synchronized void salirPuente() {\n    hayCocheEnPuente = false;\n    notifyAll();\n}\n}\n</code></pre></p>"},{"location":"exams/2012/exam/#ejercicio-3","title":"Ejercicio 3","text":"<p>Tenemos una aplicaci\u00f3n de Android que calcula la nota de ADSW como se muestra a continuaci\u00f3n.</p> <p>Como hemos visto, la aplicaci\u00f3n consta de dos pantallas, un formulario inicial (<code>NotaMediaActivity</code>) y  una pantalla que muestra  una foto y  el resultado (<code>ResultadoActivity</code>). Ambas clases est\u00e1n en el paquete <code>es.upm.dit.adsw</code>.</p> <p>El c\u00e1lculo de  la nota media se realiza de la siguiente forma:</p> <ul> <li>S\u00f3lo se hace media si ambas notas  son mayores o iguales a 4. </li> <li>La nota es 0.6 * nota de de examen + 0.4 * nota de trabajo</li> </ul>"},{"location":"exams/2012/exam/#a-1-punto","title":"A. (1 punto)","text":"<p>Complete el c\u00f3digo del fichero de manifiesto del listado 1 para que la aplicaci\u00f3n muestre la pantalla inicial (formulario) y pueda pasar a la segunda de resultado con la media.</p>"},{"location":"exams/2012/exam/#b-2-puntos","title":"B. (2 puntos)","text":"<p>Programe la actividad <code>NotaMediaActivity</code>. Debe tener en cuenta:</p> <ul> <li>Si el usuario no rellena un campo o introduce un valor no num\u00e9rico, debe mostrar un mensaje indic\u00e1ndole que debe introducir valores num\u00e9ricos (use un Toast).</li> <li>La actividad ResultadoActivity espera recibir una intenci\u00f3n con dos par\u00e1metros extra: <ul> <li>un primer par\u00e1metro de tipo boolean denominado \u201caprobado\u201d (true si cumple umbrales y media &gt; = 5; false en caso contrario)</li> <li>un segundo par\u00e1metro de tipo String denominado valor (contiene un mensaje indicando qu\u00e9 umbral no se ha superado si no se puede hacer la media, o bien el valor de la nota media).</li> </ul> </li> <li>Los listados 2 y 3 le proporcionan informaci\u00f3n del layout de NotaMediaActivity y las cadenas string.xml de la aplicaci\u00f3n.</li> </ul> <p>Listado 1. C\u00f3digo de AndroidManifest.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"COMPLETAR POR EL ALUMMNO\" &lt;!-- COMPLETAR --&gt;\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n     &gt;\n       &lt;!-- COMPLETAR POR EL ALUMNO --&gt;\n&lt;/manifest&gt;\n</code></pre></p> <p>Listado 2.  C\u00f3digo de layout/ notamedia_final.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;TableLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" \n    android:background=\"@drawable/notebook\"\n    android:paddingLeft=\"40dp\"\n    android:paddingRight=\"5dp\" &gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_examen\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_examen_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n            &lt;requestFocus /&gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow&gt;\n        &lt;TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/nota_trabajo\" /&gt;\n        &lt;EditText\n            android:id=\"@+id/editText_trabajo_final\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:ems=\"10\"\n            android:inputType=\"number|numberDecimal\" &gt;\n        &lt;/EditText&gt;\n    &lt;/TableRow&gt;\n    &lt;TableRow\n        android:gravity=\"center\"&gt;\n        &lt;Button\n            android:id=\"@+id/button_calcular\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@string/calcular\" /&gt;\n    &lt;/TableRow&gt;\n&lt;/TableLayout&gt;\n</code></pre></p> <p>Listado 3. C\u00f3digo de values/strings.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;NotaMediaADSW&lt;/string&gt;\n    &lt;string name=\"nota_trabajo\"&gt;Nota trabajo final&lt;/string&gt;\n    &lt;string name=\"nota_examen\"&gt;Nota examen final&lt;/string&gt;\n    &lt;string name=\"nota_media\"&gt;Nota media&lt;/string&gt;\n    &lt;string name=\"calcular\"&gt;Calcular&lt;/string&gt;\n    &lt;string name=\"error_numero\"&gt;Los campos deben ser num\u00e9ricos&lt;/string&gt;\n    &lt;string name=\"umbral_trabajo\"&gt;No has superado el umbral de 4.0 en la pr\u00e1ctica&lt;/string&gt;\n    &lt;string name=\"umbral_examen\"&gt;No has superado el umbral de 4.0 en el examen&lt;/string&gt;        \n     &lt;string name=\"enhorabuena\"&gt;Enhorabuena, que pases un buen verano.&lt;/string&gt;\n    &lt;string name=\"julio\"&gt;Hay otra oportunidad en julio. &lt;/string&gt;\n    &lt;string name=\"nota\"&gt;La nota es &lt;/string&gt;\n    &lt;string name=\"problema_nota\"&gt;Hay un problema para mostrar la nota&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre></p> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n es:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"es.upm.dit.adsw\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" &gt;\n    &lt;uses-sdk android:minSdkVersion=\"10\" /&gt;\n    &lt;application\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" \n    &gt;\n        &lt;activity\n            android:name=\".NotaMediaActivity\"\n            android:label=\"@string/app_name\" &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;activity\n            android:name=\".ResultadoActivity\"\n            android:label=\"@string/app_name\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <pre><code>public class NotaMediaActivity extends Activity {\npublic static final String APROBADO = \"nota\";\npublic static final String VALOR = \"valor\";\nprivate static final String TAG = NotaMediaActivity.class.getSimpleName();\nprivate EditText editNotaFinal;\nprivate EditText editTrabajoFinal;\nprivate Button buttonGuardar;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    Log.d(TAG, \"onCreate\");\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.notamedia_final);\n    editNotaFinal = (EditText) findViewById(R.id.editText_examen_final);\n    editTrabajoFinal = (EditText) findViewById(R.id.editText_trabajo_final);\n    buttonGuardar = (Button) findViewById(R.id.button_calcular);\n    buttonGuardar.setOnClickListener(new ProcesaMedia());\n}\n\nprivate class ProcesaMedia implements OnClickListener {\n    @Override\n    public void onClick(View v) {\n    try {\n        float notaFinal = Float.parseFloat(editNotaFinal.getText().toString());\n        float notaTrabajo =\n            Float.parseFloat(editTrabajoFinal.getText().toString());\n        if ((notaFinal &lt; 0) || (notaFinal &gt; 10) || (notaTrabajo &lt; 0)\n            || (notaTrabajo &gt; 10)) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n        return;\n        }\n        float media = (0.6f * notaFinal) + (0.4f * notaTrabajo);\n        DecimalFormat df = new DecimalFormat(\"#.##\");\n        String mediaString = df.format(media);\n        boolean aprobado = false;\n        String valor = \"\";\n        if ((notaTrabajo &lt; 4) || (notaFinal &lt; 4)) {\n        aprobado = false;\n        if (notaTrabajo &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_trabajo);\n        }\n        if (notaFinal &lt; 4) {\n            valor += \" \" + getString(R.string.umbral_examen);\n        }\n        } else {\n        valor = mediaString;\n        aprobado = (media &gt;= 5);\n        }\n        Intent intent = new Intent(getApplication(), ResultadoActivity.class);\n        intent.putExtra(APROBADO, aprobado);\n        intent.putExtra(VALOR, valor);\n        Log.d(TAG, \"Nota \" + aprobado + \" \" + valor);\n        startActivity(intent);\n    } catch (NumberFormatException e) {\n        Toast\n            .makeText(getApplication(), getString(R.string.error_numero),\n                Toast.LENGTH_LONG)\n            .show();\n    }\n    }\n}\n}\n</code></pre>"},{"location":"exams/2012/extra/","title":"Examen 2012 \u2014 Extraordinario","text":""},{"location":"exams/2012/extra/#ejercicio-1","title":"Ejercicio 1","text":"<p>Se pide escribir un algoritmo para extraer la mediana de los valores de un array. Si un array de \\(N\\) datos est\u00e1 ordenado, la mediana es el valor del medio, \\(\\text{array}[N/2]\\).</p> <p>El objetivo es preparar un m\u00e9todo:</p> <pre><code>public long mediana(long[] datos)\n</code></pre> <p>que devuelve la mediana del array que se le pasa.</p> <p>Debe partir del algoritmo de quicksort y modificarlo de forma que, cuando se separan los datos en dos partes, solo se siga procesando la parte que contiene la mediana, sin ordenar la otra.</p> <p>Se pide:</p> <ol> <li>escribir el algoritmo de forma recursiva.</li> <li>escribirlo de forma iterativa.</li> <li>calcular la complejidad razonando el por qu\u00e9.</li> </ol> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\n````\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana1(long[] datos, int a, int z) {\n        long pivote = datos[(a + z) / 2];\n        int inf = a;\n        int sup = z;\n        while (inf &lt; sup) {\n            while (datos[inf] &lt; pivote)\n                inf++;\n            while (pivote &lt; datos[sup - 1])\n                sup--;\n            if (inf &lt; sup) {\n                long tmp = datos[inf];\n                datos[inf] = datos[sup - 1];\n                datos[sup - 1] = tmp;\n                inf++;\n                sup--;\n            }\n        }\n        int mitad = datos.length / 2;\n        if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n            mediana1(datos, a, sup);\n        if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n            mediana1(datos, inf, z);\n    }\n\n    private void mediana2(long[] datos, int a, int z) {\n        while (a &lt; z) {\n            long pivote = datos[(a + z) / 2];\n            int inf = a;\n            int sup = z;\n            while (inf &lt; sup) {\n                while (datos[inf] &lt; pivote)\n                    inf++;\n                while (pivote &lt; datos[sup - 1])\n                    sup--;\n                if (inf &lt; sup) {\n                    long tmp = datos[inf];\n                    datos[inf] = datos[sup - 1];\n                    datos[sup - 1] = tmp;\n                    inf++;\n                    sup--;\n                }\n            }\n            int mitad = datos.length / 2;\n            if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n                z = sup;\n            else if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n                a = inf;\n            else\n                return;\n        }\n    }\n}\n</code></pre> <p>Complejidad:</p> <ul> <li> <p>Caso peor: el comportamiento es equivalente a quicksort cuando siempre se elige un pivote p\u00e9simo. La partici\u00f3n genera tama\u00f1os \\(1\\) y \\(n-1\\), por lo que el coste es:   $\\(n + (n-1) + (n-2) + \\dots + 1 = O(n^2)\\)$</p> </li> <li> <p>Caso medio: cada paso divide el array aproximadamente por la mitad, y solo se sigue por la parte donde est\u00e1 la mediana:   $\\(n + \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} + \\dots = 2n = O(n)\\)$</p> </li> </ul> <p>Por tanto: - Caso peor: \\(O(n^2)\\) - Caso medio: \\(O(n)\\) ````</p>"},{"location":"exams/2012/extra/#ejercicio-2","title":"Ejercicio 2","text":""},{"location":"exams/2012/extra/#ejercicio-3","title":"Ejercicio 3","text":""},{"location":"exams/2012/extra01/","title":"Extra01","text":"<p>Se pide escribir un algoritmo para extraer la mediana de los valores de un array. Si un array de \\(N\\) datos est\u00e1 ordenado, la mediana es el valor del medio, \\(\\text{array}[N/2]\\).</p> <p>El objetivo es preparar un m\u00e9todo:</p> <pre><code>public long mediana(long[] datos)\n</code></pre> <p>que devuelve la mediana del array que se le pasa.</p> <p>Debe partir del algoritmo de quicksort y modificarlo de forma que, cuando se separan los datos en dos partes, solo se siga procesando la parte que contiene la mediana, sin ordenar la otra.</p> <p>Se pide:</p> <ol> <li>escribir el algoritmo de forma recursiva.</li> <li>escribirlo de forma iterativa.</li> <li>calcular la complejidad razonando el por qu\u00e9.</li> </ol> Mostrar soluci\u00f3n <pre><code>package examen_20120702;\nimport java.util.Arrays;\nimport java.util.Random;\n\n````\npublic class P1 {\n    public long mediana1(long[] datos) {\n        mediana1(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    public long mediana2(long[] datos) {\n        mediana2(datos, 0, datos.length);\n        return datos[datos.length / 2];\n    }\n\n    private void mediana1(long[] datos, int a, int z) {\n        long pivote = datos[(a + z) / 2];\n        int inf = a;\n        int sup = z;\n        while (inf &lt; sup) {\n            while (datos[inf] &lt; pivote)\n                inf++;\n            while (pivote &lt; datos[sup - 1])\n                sup--;\n            if (inf &lt; sup) {\n                long tmp = datos[inf];\n                datos[inf] = datos[sup - 1];\n                datos[sup - 1] = tmp;\n                inf++;\n                sup--;\n            }\n        }\n        int mitad = datos.length / 2;\n        if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n            mediana1(datos, a, sup);\n        if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n            mediana1(datos, inf, z);\n    }\n\n    private void mediana2(long[] datos, int a, int z) {\n        while (a &lt; z) {\n            long pivote = datos[(a + z) / 2];\n            int inf = a;\n            int sup = z;\n            while (inf &lt; sup) {\n                while (datos[inf] &lt; pivote)\n                    inf++;\n                while (pivote &lt; datos[sup - 1])\n                    sup--;\n                if (inf &lt; sup) {\n                    long tmp = datos[inf];\n                    datos[inf] = datos[sup - 1];\n                    datos[sup - 1] = tmp;\n                    inf++;\n                    sup--;\n                }\n            }\n            int mitad = datos.length / 2;\n            if (a &lt;= mitad &amp;&amp; mitad &lt; sup)\n                z = sup;\n            else if (inf &lt;= mitad &amp;&amp; mitad &lt; z)\n                a = inf;\n            else\n                return;\n        }\n    }\n}\n</code></pre> <p>Complejidad:</p> <ul> <li> <p>Caso peor: el comportamiento es equivalente a quicksort cuando siempre se elige un pivote p\u00e9simo. La partici\u00f3n genera tama\u00f1os \\(1\\) y \\(n-1\\), por lo que el coste es:   $\\(n + (n-1) + (n-2) + \\dots + 1 = O(n^2)\\)$</p> </li> <li> <p>Caso medio: cada paso divide el array aproximadamente por la mitad, y solo se sigue por la parte donde est\u00e1 la mediana:   $\\(n + \\frac{n}{2} + \\frac{n}{4} + \\frac{n}{8} + \\dots = 2n = O(n)\\)$</p> </li> </ul> <p>Por tanto: - Caso peor: \\(O(n^2)\\) - Caso medio: \\(O(n)\\) ````</p>","tags":["android"]},{"location":"exams/2012/p1/","title":"Examen 2012 \u2014 Parcial 1","text":""},{"location":"exams/2012/p1/#problema-1","title":"Problema 1","text":"<p>A continuaci\u00f3n se describe el m\u00e9todo cuantasVeces de la clase P1. No programe la clase P1. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo cuantasVeces. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo cuantasVeces. . Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo cuantasVeces invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p>"},{"location":"exams/2012/p1/#problema-2","title":"Problema 2","text":""},{"location":"exams/2012/p1/#problema-2-5-puntos","title":"Problema 2 (5 puntos)","text":"<p>Dado el siguiente algoritmo de ordenaci\u00f3n:</p> <pre><code>public void sort(long[] datos) {\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n            datos[j] = datos[j - 1];\n            j--;\n        }\n        datos[j] = x;\n    }\n}\n</code></pre>"},{"location":"exams/2012/p1/#05-puntos-indique-el-nombre-del-algoritmo","title":"(0.5 puntos) Indique el nombre del algoritmo","text":"Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00f3n por inserci\u00f3n.</p>"},{"location":"exams/2012/p1/#3-puntos-indique-que-cambios-haria-en-el-codigo-indicando-el-numero-de-linea-para-conseguir-que-el-metodo-devolviera-el-numero-de-veces-que-compara-dos-elementos-del-array","title":"(3 puntos) Indique qu\u00e9 cambios har\u00eda en el c\u00f3digo, indicando el n\u00famero de l\u00ednea, para conseguir que el m\u00e9todo devolviera el n\u00famero de veces que compara dos elementos del array.","text":"Mostrar soluci\u00f3n <p>La comparaci\u00f3n se efect\u00faa al comprobar la condici\u00f3n del bucle en la l\u00ednea <code>5</code>. El cuerpo del bucle se ejecuta si <code>j &gt; 0</code> y adem\u00e1s <code>x &lt; datos[j - 1]</code>. Por tanto, en ese caso se ha efectuado una comparaci\u00f3n entre <code>x</code> y un elemento del array.</p> <p>Sin embargo, si el bucle no se ejecuta puede ser por dos causas:</p> <ol> <li><code>j == 0</code>, en cuyo caso no se llega a efectuar la comparaci\u00f3n, ya que el operador <code>&amp;&amp;</code> no eval\u00faa el segundo t\u00e9rmino.  </li> <li><code>j &gt; 0</code> y <code>x &gt;= datos[j - 1]</code>, en cuyo caso s\u00ed se efect\u00faa la comparaci\u00f3n.</li> </ol> <p>Para contar correctamente las comparaciones, hay que desdoblar la condici\u00f3n del bucle. Una forma de hacerlo es:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                break;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <p>L\u00edneas modificadas:</p> <ul> <li>L\u00ednea 1 sustituida por:</li> </ul> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n</code></pre> <ul> <li>L\u00edneas 5\u20138 sustituidas por:</li> </ul> <pre><code>while (j &gt; 0) {\n    ++numeroComparaciones;\n    if (x &lt; datos[j - 1]) {\n        datos[j] = datos[j - 1];\n        j--;\n    } else {\n        break;\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s de la l\u00ednea 10 se a\u00f1ade:</li> </ul> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00f3n alternativa con una variable auxiliar:</p> <pre><code>public int sort2(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        boolean menor = true;\n        while (j &gt; 0 &amp;&amp; menor) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                menor = false;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre>"},{"location":"exams/2012/p1/#15-puntos-programe-una-prueba-en-junit3-de-la-modificacion-realizada-en-el-apartado-b-para-el-caso-3-1-2","title":"(1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00f3n realizada en el apartado b), para el caso <code>{3, 1, 2}</code>.","text":"Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es:</p> <pre><code>public void test() {\n    long[] datos = {3, 1, 2};\n    P2 algoritmo = new P2();\n    assertEquals(3, algoritmo.sort(datos));\n}\n</code></pre>"},{"location":"exams/2012/p1_ex01/","title":"P1 ex01","text":"<p>A continuaci\u00f3n se describe el m\u00e9todo cuantasVeces de la clase P1. No programe la clase P1. <pre><code>/**\n * Determina cu\u00e1ntas veces aparece n\u00famero en la lista de enteros\n * @param lista lista de enteros en que buscamos\n * @param numero n\u00famero buscado\n * @return n\u00famero de veces que aparece numero en lista. Si el n\u00famero\n * no est\u00e1 en la lista, devuelve 0.\n */\npublic int cuantasVeces(int [] lista, int numero)\n</code></pre></p> <ul> <li>(2 puntos) Programe una versi\u00f3n iterativa del m\u00e9todo cuantasVeces. \u00bfEncuentra alguna similitud de esta versi\u00f3n iterativa con alg\u00fan algoritmo conocido, con cu\u00e1l? </li> </ul> Mostrar soluci\u00f3n <pre><code>public int cuantasVeces(int[] lista, int numero) {\n    int contador = 0;\n        for (int elem : lista) {\n            if (elem == numero) {contador++;}\n        }\n    return contador;\n}\n</code></pre> <ul> <li>(3 puntos) Programe una versi\u00f3n recursiva del m\u00e9todo cuantasVeces. . Pista: puede utilizar un m\u00e9todo auxiliar privado (que ser\u00e1 el recursivo) para recorrer  el  array  de forma  recursiva,  comparando  en  cada  recursi\u00f3n  un  elemento  del  array.  Por  ejemplo,  podr\u00eda  programar  y llamar a un m\u00e9todo privado como el que sigue:  <pre><code>private int cuantasVeces(int [] lista, int numero, int indice). \n</code></pre> El par\u00e1metro indice es el \u00edndice para recorrer el array de forma recursiva.</li> </ul> Mostrar soluci\u00f3n <p>El m\u00e9todo cuantasVeces invoca el m\u00e9todo auxiliar. <pre><code>public int cuantasVecesRecursivo(int [] lista, int numero) {\n    return cuantasVeces(lista, numero, 0);\n}\n</code></pre> Y el m\u00e9todo auxiliar es: <pre><code>private int cuantasVeces(int [] lista, int numero, int indice) {\n    if (indice &gt;= lista.length) {\n        return 0;\n    } else if (numero == lista[indice]) {\n        return 1 + cuantasVeces(lista, numero, ++indice);\n    } else {\n        return cuantasVeces(lista, numero, ++indice);\n    }\n}\n</code></pre> Se puede probar, por ejemplo, con: <pre><code>public void testCuantasVeces() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVeces(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVeces(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVeces(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVeces(l1, 3));  // otro caso en que est\u00e1!\n}\npublic void testCuantasVecesRecursivo() {\n    P1 p1 = new P1();\n    int [] l0 = new int[0];  // vac\u00edo\n    int [] l1 = {1, 2, 2, 3, 3, 3};\n    assertEquals(0, p1.cuantasVecesRecursivo(l0, 0));  // array vac\u00edo\n    assertEquals(0, p1.cuantasVecesRecursivo(l1, 4));  // caso en que no est\u00e1\n    assertEquals(1, p1.cuantasVecesRecursivo(l1, 1));  // caso l\u00edmite cuando est\u00e1\n    assertEquals(3, p1.cuantasVecesRecursivo(l1, 3));  // otro caso en que est\u00e1\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/","title":"Problema 2 (5 puntos)","text":"<p>Dado el siguiente algoritmo de ordenaci\u00f3n:</p> <pre><code>public void sort(long[] datos) {\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0 &amp;&amp; x &lt; datos[j - 1]) {\n            datos[j] = datos[j - 1];\n            j--;\n        }\n        datos[j] = x;\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/#05-puntos-indique-el-nombre-del-algoritmo","title":"(0.5 puntos) Indique el nombre del algoritmo","text":"Mostrar soluci\u00f3n <p>Se trata del algoritmo de ordenaci\u00f3n por inserci\u00f3n.</p>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/#3-puntos-indique-que-cambios-haria-en-el-codigo-indicando-el-numero-de-linea-para-conseguir-que-el-metodo-devolviera-el-numero-de-veces-que-compara-dos-elementos-del-array","title":"(3 puntos) Indique qu\u00e9 cambios har\u00eda en el c\u00f3digo, indicando el n\u00famero de l\u00ednea, para conseguir que el m\u00e9todo devolviera el n\u00famero de veces que compara dos elementos del array.","text":"Mostrar soluci\u00f3n <p>La comparaci\u00f3n se efect\u00faa al comprobar la condici\u00f3n del bucle en la l\u00ednea <code>5</code>. El cuerpo del bucle se ejecuta si <code>j &gt; 0</code> y adem\u00e1s <code>x &lt; datos[j - 1]</code>. Por tanto, en ese caso se ha efectuado una comparaci\u00f3n entre <code>x</code> y un elemento del array.</p> <p>Sin embargo, si el bucle no se ejecuta puede ser por dos causas:</p> <ol> <li><code>j == 0</code>, en cuyo caso no se llega a efectuar la comparaci\u00f3n, ya que el operador <code>&amp;&amp;</code> no eval\u00faa el segundo t\u00e9rmino.  </li> <li><code>j &gt; 0</code> y <code>x &gt;= datos[j - 1]</code>, en cuyo caso s\u00ed se efect\u00faa la comparaci\u00f3n.</li> </ol> <p>Para contar correctamente las comparaciones, hay que desdoblar la condici\u00f3n del bucle. Una forma de hacerlo es:</p> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        while (j &gt; 0) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                break;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre> <p>L\u00edneas modificadas:</p> <ul> <li>L\u00ednea 1 sustituida por:</li> </ul> <pre><code>public int sort(long[] datos) {\n    int numeroComparaciones = 0;\n</code></pre> <ul> <li>L\u00edneas 5\u20138 sustituidas por:</li> </ul> <pre><code>while (j &gt; 0) {\n    ++numeroComparaciones;\n    if (x &lt; datos[j - 1]) {\n        datos[j] = datos[j - 1];\n        j--;\n    } else {\n        break;\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s de la l\u00ednea 10 se a\u00f1ade:</li> </ul> <pre><code>return numeroComparaciones;\n</code></pre> <p>Otra soluci\u00f3n alternativa con una variable auxiliar:</p> <pre><code>public int sort2(long[] datos) {\n    int numeroComparaciones = 0;\n    for (int i = 1; i &lt; datos.length; i++) {\n        long x = datos[i];\n        int j = i;\n        boolean menor = true;\n        while (j &gt; 0 &amp;&amp; menor) {\n            ++numeroComparaciones;\n            if (x &lt; datos[j - 1]) {\n                datos[j] = datos[j - 1];\n                j--;\n            } else {\n                menor = false;\n            }\n        }\n        datos[j] = x;\n    }\n    return numeroComparaciones;\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p1_ex02/#15-puntos-programe-una-prueba-en-junit3-de-la-modificacion-realizada-en-el-apartado-b-para-el-caso-3-1-2","title":"(1.5 puntos) Programe una prueba en JUnit3 de la modificaci\u00f3n realizada en el apartado b), para el caso <code>{3, 1, 2}</code>.","text":"Mostrar soluci\u00f3n <p>En este caso se efect\u00faan 3 comparaciones. La prueba es:</p> <pre><code>public void test() {\n    long[] datos = {3, 1, 2};\n    P2 algoritmo = new P2();\n    assertEquals(3, algoritmo.sort(datos));\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p2/","title":"Examen 2012 \u2014 Parcial 2","text":""},{"location":"exams/2012/p2/#problema-1","title":"Problema 1","text":""},{"location":"exams/2012/p2/#a-2-puntos","title":"A. (2 puntos)","text":"<p>Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads). <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre></p> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase Swap1 pueden utilizar simult\u00e1neamente la variable aux al invocar el m\u00e9todo swap. Por tanto, swap deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a aux.</p> <p>Por el contrario, en Swap2 la variable aux es local al m\u00e9todo swap, y cada hebra que lo invoca usa su propia copia de aux. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p>"},{"location":"exams/2012/p2/#problema-2","title":"Problema 2","text":""},{"location":"exams/2012/p2/#a-4-puntos","title":"A. (4 puntos)","text":"<p>Escriba una clase con un contador interno, que se incrementa cada vez que se invoca el m\u00e9todo <code>siguiente()</code>. La clase debe poderse utilizar en un programa concurrente. Adem\u00e1s, la clase proporciona otros dos m\u00e9todos, <code>esperarPar()</code> y <code>esperarImpar()</code>, que hacen que la hebra (thread) que los invoca se quede bloqueada hasta que el valor del contador sea par o impar, respectivamente.</p> <p>Se supone que el intervalo entre dos invocaciones consecutivas de <code>siguiente()</code> es suficiente para que todas las hebras que estuvieran bloqueadas puedan continuar.</p> <p>El esquema de la clase es el siguiente:</p> <pre><code>public class Secuenciador  {\n    private int numero = 0;\n\n    public int siguiente() {...}\n    // devuelve 1 la primera vez que se invoca, 2 la segunda, etc.\n\n    public void esperarPar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea par\n\n    public void esperarImpar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea impar\n}\n</code></pre> Mostrar soluci\u00f3n <p>Los m\u00e9todos deben ser todos sincronizados. Adem\u00e1s, se deben incluir esperas condicionales en <code>esperarPar</code> y <code>esperarImpar</code>. Como el \u00fanico m\u00e9todo que modifica el valor del contador es <code>siguiente</code>, el aviso (<code>notifyAll</code>) para que las hebras bloqueadas vuelvan a comprobar la condici\u00f3n debe estar en este m\u00e9todo.</p> <p>Una posible implementaci\u00f3n es:</p> <pre><code>public class Secuenciador {\n    private int numero = 0;\n\n    public synchronized int siguiente() {\n        numero++;\n        notifyAll();\n        return numero;\n    }\n\n    public synchronized void esperarPar() {\n        while (numero % 2 != 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n\n    public synchronized void esperarImpar() {\n        while (numero % 2 == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"exams/2012/p2/#problema-3","title":"Problema 3","text":""},{"location":"exams/2012/p2/#a-4-puntos_1","title":"A. (4 puntos)","text":"<p>Modifique la clase <code>Monitor.java</code> de la pr\u00e1ctica 1 donde se han definido una serie de celdas como zona exclusiva en la que s\u00f3lo puede haber una pieza dentro (o un marciano, o un jugador). Por ejemplo,</p> <p></p> <p>Suponga que las celdas tienen un m\u00e9todo:</p> <pre><code>public boolean isZonaExclusiva()\n</code></pre> <p>El comportamiento de las piezas del juego es as\u00ed:</p> <ul> <li> <p>Cuando un jugador intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, debe buscar otra celda.</p> </li> <li> <p>Cuando un marciano intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, espera a que se libere.</p> </li> <li> <p>Tanto marcianos como jugador, cuando salen de la zona exclusiva hacia una celda que no lo es, liberan a los marcianos que pudieran estar esperando.</p> </li> </ul> <p>Sugerencia: se recomienda disponer de un campo</p> <pre><code>private Object ocupado;\n</code></pre> <p>que se inicia a <code>null</code> y sirve para indicar qu\u00e9 objeto (jugador o marciano) est\u00e1 dentro de la zona. Sirve para comprobar si hay alguien dentro:</p> <pre><code>private boolean estaZonaOcupada() { return ocupado != null; }\n</code></pre> <p>y para saber si salen:</p> <pre><code>private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n    return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n}\n\nprivate boolean estoySaliendo(Marciano marciano, Celda celda2) {\n    return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.pract1;\npublic class MonitorExtendido extends Monitor {\n\n    private final Laberinto laberinto;\n    private Object ocupado;\n\n    public MonitorExtendido(Laberinto laberinto) {\n        super(laberinto);\n        this.laberinto = laberinto;\n    }\n\n    public synchronized void mueveJugador(Jugador jugador, Celda celda2)\n            throws JugadorComido {\n\n        if (celda2.isZonaExclusiva()) {\n            if (estaZonaOcupada() &amp;&amp; ocupado != jugador)\n                return;\n            else\n                ocupado = jugador;\n        }\n\n        if (estoySaliendo(jugador, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            throw new JugadorComido();\n        }\n\n        jugador.setCelda(celda2);\n\n        if (celda2.getTipo() == Tipo.LLAVE) {\n            laberinto.limpiaCepos();\n            notifyAll();\n        }\n    }\n\n    public synchronized void mueveMarciano(Marciano marciano, Celda celda2)\n            throws JugadorComido, InterruptedException {\n\n        if (celda2.isZonaExclusiva()) {\n            while (estaZonaOcupada() &amp;&amp; ocupado != marciano)\n                wait();\n            ocupado = marciano;\n        }\n\n        if (estoySaliendo(marciano, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            return;\n        }\n\n        if (celda2.getEstado() == Estado.JUGADOR) {\n            throw new JugadorComido();\n        }\n\n        marciano.setCelda(celda2);\n\n        while (celda2.getTipo() == Tipo.CEPO) {\n            wait();\n        }\n    }\n\n    private boolean estaZonaOcupada() {\n        return ocupado != null;\n    }\n\n    private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n        return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n    }\n\n    private boolean estoySaliendo(Marciano marciano, Celda celda2) {\n        return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n    }\n}\n</code></pre></p>"},{"location":"exams/2012/p2_ex01/","title":"P2 ex01","text":"","tags":["complejidad"]},{"location":"exams/2012/p2_ex01/#a-2-puntos","title":"A. (2 puntos)","text":"<p>Sean las dos clases siguientes, con dos implementaciones de un m\u00e9todo que intercambia el valor de dos variables. Explique, justificando la respuesta, si estas implementaciones son adecuadas para ser invocadas concurrentemente por un conjunto de hebras (threads). <pre><code>public class Swap1 {\n    private int aux;\n    public void swap (int a, int b) {\n        aux = a;\n        a = b;\n        b = aux;\n    }\n}\npublic class Swap2 {\n    public void swap (int a, int b) {\n        int aux = a;\n        a = b;\n        b = aux;\n    }\n}\n</code></pre></p> Mostrar soluci\u00f3n <p>Cuando varias hebras comparten un objeto de la clase Swap1 pueden utilizar simult\u00e1neamente la variable aux al invocar el m\u00e9todo swap. Por tanto, swap deber\u00eda ser un m\u00e9todo sincronizado, y esta implementaci\u00f3n es inadecuada para usarla en un contexto concurrente, ya que se pueden producir condiciones de carrera en el acceso a aux.</p> <p>Por el contrario, en Swap2 la variable aux es local al m\u00e9todo swap, y cada hebra que lo invoca usa su propia copia de aux. Por tanto, no hay variables compartidas y no es necesario que swap sea sincronizado. Esta implementaci\u00f3n puede usarse sin problemas en un contexto concurrente.</p>","tags":["complejidad"]},{"location":"exams/2012/p2_ex02/","title":"P2 ex02","text":"","tags":["complejidad"]},{"location":"exams/2012/p2_ex02/#a-4-puntos","title":"A. (4 puntos)","text":"<p>Escriba una clase con un contador interno, que se incrementa cada vez que se invoca el m\u00e9todo <code>siguiente()</code>. La clase debe poderse utilizar en un programa concurrente. Adem\u00e1s, la clase proporciona otros dos m\u00e9todos, <code>esperarPar()</code> y <code>esperarImpar()</code>, que hacen que la hebra (thread) que los invoca se quede bloqueada hasta que el valor del contador sea par o impar, respectivamente.</p> <p>Se supone que el intervalo entre dos invocaciones consecutivas de <code>siguiente()</code> es suficiente para que todas las hebras que estuvieran bloqueadas puedan continuar.</p> <p>El esquema de la clase es el siguiente:</p> <pre><code>public class Secuenciador  {\n    private int numero = 0;\n\n    public int siguiente() {...}\n    // devuelve 1 la primera vez que se invoca, 2 la segunda, etc.\n\n    public void esperarPar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea par\n\n    public void esperarImpar() {...}\n    // suspende la ejecuci\u00f3n de la hebra hasta que el valor sea impar\n}\n</code></pre> Mostrar soluci\u00f3n <p>Los m\u00e9todos deben ser todos sincronizados. Adem\u00e1s, se deben incluir esperas condicionales en <code>esperarPar</code> y <code>esperarImpar</code>. Como el \u00fanico m\u00e9todo que modifica el valor del contador es <code>siguiente</code>, el aviso (<code>notifyAll</code>) para que las hebras bloqueadas vuelvan a comprobar la condici\u00f3n debe estar en este m\u00e9todo.</p> <p>Una posible implementaci\u00f3n es:</p> <pre><code>public class Secuenciador {\n    private int numero = 0;\n\n    public synchronized int siguiente() {\n        numero++;\n        notifyAll();\n        return numero;\n    }\n\n    public synchronized void esperarPar() {\n        while (numero % 2 != 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n\n    public synchronized void esperarImpar() {\n        while (numero % 2 == 0) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                // manejar excepci\u00f3n\n            }\n        }\n    }\n}\n</code></pre>","tags":["complejidad"]},{"location":"exams/2012/p2_ex03/","title":"P2 ex03","text":"","tags":["complejidad"]},{"location":"exams/2012/p2_ex03/#a-4-puntos","title":"A. (4 puntos)","text":"<p>Modifique la clase <code>Monitor.java</code> de la pr\u00e1ctica 1 donde se han definido una serie de celdas como zona exclusiva en la que s\u00f3lo puede haber una pieza dentro (o un marciano, o un jugador). Por ejemplo,</p> <p></p> <p>Suponga que las celdas tienen un m\u00e9todo:</p> <pre><code>public boolean isZonaExclusiva()\n</code></pre> <p>El comportamiento de las piezas del juego es as\u00ed:</p> <ul> <li> <p>Cuando un jugador intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, debe buscar otra celda.</p> </li> <li> <p>Cuando un marciano intenta pasar a una celda exclusiva:</p> </li> <li> <p>si la zona exclusiva est\u00e1 vac\u00eda, entra;</p> </li> <li> <p>si est\u00e1 ocupada, espera a que se libere.</p> </li> <li> <p>Tanto marcianos como jugador, cuando salen de la zona exclusiva hacia una celda que no lo es, liberan a los marcianos que pudieran estar esperando.</p> </li> </ul> <p>Sugerencia: se recomienda disponer de un campo</p> <pre><code>private Object ocupado;\n</code></pre> <p>que se inicia a <code>null</code> y sirve para indicar qu\u00e9 objeto (jugador o marciano) est\u00e1 dentro de la zona. Sirve para comprobar si hay alguien dentro:</p> <pre><code>private boolean estaZonaOcupada() { return ocupado != null; }\n</code></pre> <p>y para saber si salen:</p> <pre><code>private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n    return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n}\n\nprivate boolean estoySaliendo(Marciano marciano, Celda celda2) {\n    return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible implementaci\u00f3n es: <pre><code>package es.upm.dit.adsw.pract1;\npublic class MonitorExtendido extends Monitor {\n\n    private final Laberinto laberinto;\n    private Object ocupado;\n\n    public MonitorExtendido(Laberinto laberinto) {\n        super(laberinto);\n        this.laberinto = laberinto;\n    }\n\n    public synchronized void mueveJugador(Jugador jugador, Celda celda2)\n            throws JugadorComido {\n\n        if (celda2.isZonaExclusiva()) {\n            if (estaZonaOcupada() &amp;&amp; ocupado != jugador)\n                return;\n            else\n                ocupado = jugador;\n        }\n\n        if (estoySaliendo(jugador, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            throw new JugadorComido();\n        }\n\n        jugador.setCelda(celda2);\n\n        if (celda2.getTipo() == Tipo.LLAVE) {\n            laberinto.limpiaCepos();\n            notifyAll();\n        }\n    }\n\n    public synchronized void mueveMarciano(Marciano marciano, Celda celda2)\n            throws JugadorComido, InterruptedException {\n\n        if (celda2.isZonaExclusiva()) {\n            while (estaZonaOcupada() &amp;&amp; ocupado != marciano)\n                wait();\n            ocupado = marciano;\n        }\n\n        if (estoySaliendo(marciano, celda2)) {\n            ocupado = null;\n            notifyAll();\n        }\n\n        if (celda2.getEstado() == Estado.BICHO) {\n            return;\n        }\n\n        if (celda2.getEstado() == Estado.JUGADOR) {\n            throw new JugadorComido();\n        }\n\n        marciano.setCelda(celda2);\n\n        while (celda2.getTipo() == Tipo.CEPO) {\n            wait();\n        }\n    }\n\n    private boolean estaZonaOcupada() {\n        return ocupado != null;\n    }\n\n    private boolean estoySaliendo(Jugador jugador, Celda celda2) {\n        return ocupado == jugador &amp;&amp; !celda2.isZonaExclusiva();\n    }\n\n    private boolean estoySaliendo(Marciano marciano, Celda celda2) {\n        return ocupado == marciano &amp;&amp; !celda2.isZonaExclusiva();\n    }\n}\n</code></pre></p>","tags":["complejidad"]},{"location":"exams/2013/p1/","title":"Examen 2013 \u2014 Parcial 1","text":""},{"location":"exams/2013/p1/#problema-1","title":"Problema 1","text":"<p>Tenemos arrays de datos que est\u00e1n ordenados en orden ascendente, pero con los datos desplazados una distancia \\( h \\ge 0 \\). Por ejemplo:</p> h array 0 [1, 3, 5, 7, 11, 13] 1 [13, 1, 3, 5, 7, 11] 2 [11, 13, 1, 3, 5, 7] 3 [7, 11, 13, 1, 3, 5] \u2026 \u2026 <p>Supondremos que todos los datos del array son distintos.</p> <ul> <li>(a) (1,5 puntos) Dados un array y el desplazamiento \\( h \\), desarrolle un algoritmo de complejidad O(1) que devuelva el n\u00famero mayor conociendo el array y el desplazamiento: <pre><code>int getMayor1(int[] array, int h)\n</code></pre> Demuestre que el algoritmo es efectivamente de complejidad O(1).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor1(int[] array, int h) {\n    return array[(array.length - 1 + h) % array.length];\n}\n</code></pre> El algoritmo es de complejidad O(1) porque el n\u00famero de pasos del algoritmo es independiente de n.</p> <ul> <li>(b) (1,5 puntos) Desarrolle un algoritmo de complejidad O(n) que devuelva el n\u00famero mayor conociendo el array, pero sin saber el desplazamiento: <pre><code>int getMayor2(int[] array)\n</code></pre> Demuestre que el algoritmo es de complejidad O(n)</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor2(int[] array) {\n    int mayor = Integer.MIN_VALUE;\n    for (int num : array) {\n        if (mayor &lt; num)\n            mayor = num;\n    }\n    return mayor;\n}\n</code></pre> El algoritmo es de complejidad O(n) porque es un bucle que se ejecuta n veces.</p> <ul> <li>(c) (2 puntos) Desarrolle un algoritmo de complejidad O(log n) que devuelva el n\u00famero mayor conociendo el array, pero sin conocer el desplazamiento: <pre><code>int getMayor3(int[] array)\n</code></pre></li> </ul> <p>Pista:</p> <p>Hay que usar el algoritmo del apartado a) probando con diferentes valores de h. Para un valor de h: - Sabemos que es el correcto si el n\u00famero siguiente es menor que <code>array[h]</code>. - Sabemos si hay que aumentar o disminuir h comparando <code>array[h]</code> con <code>array[0]</code>.</p> Mostrar soluci\u00f3n <p>La siguiente soluci\u00f3n utiliza un m\u00e9todo auxiliar, <code>busca</code>:</p> <p><pre><code>private static int getMayor3(int[] array) {\n    return busca(array, 0, array.length);\n    }\n\n    private static int busca(int[] array, int a, int z) {\n        if (a &gt;= z)\n            return array[a];\n        int h = (a + z) / 2;\n        int num = array[h];\n        int num_1 = array[(h + 1) % array.length];\n        if (num &gt; num_1)\n            return num;\n        if (array[0] &lt; num)\n            return busca(array, h + 1, z);\n        else\n            return busca(array, a, h);\n    }\n</code></pre> El algoritmo es de complejidad O(log n) porque es un esquema de divisi\u00f3n sucesiva. M\u00e1s desarrollado: - Al principio, h puede estar entre O y N-1 - Tras 1 paso, h puede estar entre (O y N/2) o entre (N/2 y N); es decir, hemos reducido las opciones a la mitad (N/2) - Tras k pasos, el rango es N/2<sup>k</sup>; de forma que el rango se reduce a 1 (h encontrado) cuando 1 &lt;= N/2<sup>k</sup> -&gt; k=log(N)1 &lt;= N / 2^k  \u279c  k = log\u2082(N) \u2282 O(log N)</p>"},{"location":"exams/2013/p1/#problema-2","title":"Problema 2","text":"<ul> <li>(a) (5 puntos) Sean tres hebras (threads), T1, T2 y T3, que utilizan tres recursos, R1, R2 y R3.</li> </ul> <p>La hebra T1 s\u00f3lo necesita el recurso R1.  </p> <p>La hebra T2 necesita los recursos R2 y R3.  </p> <p>Por \u00faltimo, la hebra T3 requiere los tres recursos, R1, R2 y R3.</p> <p>Escriba un monitor que controle el acceso de las hebras a los recursos. Cada hebra solicita los recursos que necesita invocando un m\u00e9todo del monitor. Cuando una hebra termina de usar los recursos que necesita, lo indica para que otras hebras puedan usarlos. El monitor ha de asegurar que ning\u00fan recurso es utilizado por m\u00e1s de una hebra a la vez.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es:</p> <pre><code>class Monitor {\n    \u2026\n    \u2026 requiereR1 (\u2026) { \u2026 }\n    \u2026 requiereR2_R3 (\u2026) { \u2026 }\n    \u2026 requiereR1_R2_R3 ( \u2026) { \u2026}\n    \u2026 liberaR1(\u2026) { \u2026 }\n    \u2026 liberaR2_R3 (\u2026) { \u2026 }\n    \u2026 liberaR1_R2_R3 ( \u2026) { \u2026}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n ser\u00eda:</p> <pre><code>public class Monitor {\n    private boolean ocupadoR1 = false;\n    private boolean ocupadoR2 = false;\n    private boolean ocupadoR3 = false;\n\n    public synchronized void requiereR1 () \n               throws InterruptedException {\n        while (ocupadoR1) wait();\n        ocupadoR1 = true;\n    }\n\n    public synchronized void requiereR2_R3() \n               throws InterruptedException {\n        while (ocupadoR2 || ocupadoR3) wait();\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void requiereR1_R2_R3 () \n                   throws InterruptedException { \n        while (ocupadoR1 || ocupadoR2 || ocupadoR3) wait();\n        ocupadoR1 = true;\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void liberaR1() {\n        ocupadoR1 = false;\n        notifyAll();\n    }\n\n    public synchronized void libreraR2_R3 () {\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll();\n    }\n\n    public synchronized void liberaR1_R2_R3 () {\n        ocupadoR1 = false;\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll(); \n    }\n}\n</code></pre>"},{"location":"exams/2013/p1_ex01/","title":"P1 ex01","text":"<p>Tenemos arrays de datos que est\u00e1n ordenados en orden ascendente, pero con los datos desplazados una distancia \\( h \\ge 0 \\). Por ejemplo:</p> h array 0 [1, 3, 5, 7, 11, 13] 1 [13, 1, 3, 5, 7, 11] 2 [11, 13, 1, 3, 5, 7] 3 [7, 11, 13, 1, 3, 5] \u2026 \u2026 <p>Supondremos que todos los datos del array son distintos.</p> <ul> <li>(a) (1,5 puntos) Dados un array y el desplazamiento \\( h \\), desarrolle un algoritmo de complejidad O(1) que devuelva el n\u00famero mayor conociendo el array y el desplazamiento: <pre><code>int getMayor1(int[] array, int h)\n</code></pre> Demuestre que el algoritmo es efectivamente de complejidad O(1).</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor1(int[] array, int h) {\n    return array[(array.length - 1 + h) % array.length];\n}\n</code></pre> El algoritmo es de complejidad O(1) porque el n\u00famero de pasos del algoritmo es independiente de n.</p> <ul> <li>(b) (1,5 puntos) Desarrolle un algoritmo de complejidad O(n) que devuelva el n\u00famero mayor conociendo el array, pero sin saber el desplazamiento: <pre><code>int getMayor2(int[] array)\n</code></pre> Demuestre que el algoritmo es de complejidad O(n)</li> </ul> Mostrar soluci\u00f3n <p>Una soluci\u00f3n ser\u00eda: <pre><code>private static int getMayor2(int[] array) {\n    int mayor = Integer.MIN_VALUE;\n    for (int num : array) {\n        if (mayor &lt; num)\n            mayor = num;\n    }\n    return mayor;\n}\n</code></pre> El algoritmo es de complejidad O(n) porque es un bucle que se ejecuta n veces.</p> <ul> <li>(c) (2 puntos) Desarrolle un algoritmo de complejidad O(log n) que devuelva el n\u00famero mayor conociendo el array, pero sin conocer el desplazamiento: <pre><code>int getMayor3(int[] array)\n</code></pre></li> </ul> <p>Pista:</p> <p>Hay que usar el algoritmo del apartado a) probando con diferentes valores de h. Para un valor de h: - Sabemos que es el correcto si el n\u00famero siguiente es menor que <code>array[h]</code>. - Sabemos si hay que aumentar o disminuir h comparando <code>array[h]</code> con <code>array[0]</code>.</p> Mostrar soluci\u00f3n <p>La siguiente soluci\u00f3n utiliza un m\u00e9todo auxiliar, <code>busca</code>:</p> <p><pre><code>private static int getMayor3(int[] array) {\n    return busca(array, 0, array.length);\n    }\n\n    private static int busca(int[] array, int a, int z) {\n        if (a &gt;= z)\n            return array[a];\n        int h = (a + z) / 2;\n        int num = array[h];\n        int num_1 = array[(h + 1) % array.length];\n        if (num &gt; num_1)\n            return num;\n        if (array[0] &lt; num)\n            return busca(array, h + 1, z);\n        else\n            return busca(array, a, h);\n    }\n</code></pre> El algoritmo es de complejidad O(log n) porque es un esquema de divisi\u00f3n sucesiva. M\u00e1s desarrollado: - Al principio, h puede estar entre O y N-1 - Tras 1 paso, h puede estar entre (O y N/2) o entre (N/2 y N); es decir, hemos reducido las opciones a la mitad (N/2) - Tras k pasos, el rango es N/2<sup>k</sup>; de forma que el rango se reduce a 1 (h encontrado) cuando 1 &lt;= N/2<sup>k</sup> -&gt; k=log(N)1 &lt;= N / 2^k  \u279c  k = log\u2082(N) \u2282 O(log N)</p>","tags":["complejidad"]},{"location":"exams/2013/p1_ex02/","title":"P1 ex02","text":"<ul> <li>(a) (5 puntos) Sean tres hebras (threads), T1, T2 y T3, que utilizan tres recursos, R1, R2 y R3.</li> </ul> <p>La hebra T1 s\u00f3lo necesita el recurso R1.  </p> <p>La hebra T2 necesita los recursos R2 y R3.  </p> <p>Por \u00faltimo, la hebra T3 requiere los tres recursos, R1, R2 y R3.</p> <p>Escriba un monitor que controle el acceso de las hebras a los recursos. Cada hebra solicita los recursos que necesita invocando un m\u00e9todo del monitor. Cuando una hebra termina de usar los recursos que necesita, lo indica para que otras hebras puedan usarlos. El monitor ha de asegurar que ning\u00fan recurso es utilizado por m\u00e1s de una hebra a la vez.</p> <p>El esqueleto del monitor con los nombres de los m\u00e9todos es:</p> <pre><code>class Monitor {\n    \u2026\n    \u2026 requiereR1 (\u2026) { \u2026 }\n    \u2026 requiereR2_R3 (\u2026) { \u2026 }\n    \u2026 requiereR1_R2_R3 ( \u2026) { \u2026}\n    \u2026 liberaR1(\u2026) { \u2026 }\n    \u2026 liberaR2_R3 (\u2026) { \u2026 }\n    \u2026 liberaR1_R2_R3 ( \u2026) { \u2026}\n}\n</code></pre> Mostrar soluci\u00f3n <p>Una posible soluci\u00f3n ser\u00eda:</p> <pre><code>public class Monitor {\n    private boolean ocupadoR1 = false;\n    private boolean ocupadoR2 = false;\n    private boolean ocupadoR3 = false;\n\n    public synchronized void requiereR1 () \n               throws InterruptedException {\n        while (ocupadoR1) wait();\n        ocupadoR1 = true;\n    }\n\n    public synchronized void requiereR2_R3() \n               throws InterruptedException {\n        while (ocupadoR2 || ocupadoR3) wait();\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void requiereR1_R2_R3 () \n                   throws InterruptedException { \n        while (ocupadoR1 || ocupadoR2 || ocupadoR3) wait();\n        ocupadoR1 = true;\n        ocupadoR2 = true;\n        ocupadoR3 = true;\n    }\n\n    public synchronized void liberaR1() {\n        ocupadoR1 = false;\n        notifyAll();\n    }\n\n    public synchronized void libreraR2_R3 () {\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll();\n    }\n\n    public synchronized void liberaR1_R2_R3 () {\n        ocupadoR1 = false;\n        ocupadoR2 = false;\n        ocupadoR3 = false;\n        notifyAll(); \n    }\n}\n</code></pre>","tags":["monitores"]},{"location":"exams/2021/exam/","title":"Ejercicio X \u2014 T\u00edtulo breve","text":"","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#enunciado","title":"Enunciado","text":"<p>Escribe aqu\u00ed el enunciado completo del ejercicio.</p> <p>Puedes incluir c\u00f3digo:</p> <p><pre><code>for (int i = 0; i &lt; n; i++) {\n    // ...\n}\n</code></pre> O diagramas, pseudoc\u00f3digo, tablas, etc.</p>","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#solucion","title":"Soluci\u00f3n","text":"Mostrar soluci\u00f3n","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#razonamiento","title":"Razonamiento","text":"<p>Explica los pasos o la deducci\u00f3n necesaria. Puedes subdividir la explicaci\u00f3n en apartados.</p>","tags":["complejidad","ordenaci\u00f3n"]},{"location":"exams/2021/exam/#solucion-final","title":"Soluci\u00f3n final","text":"<p>Indica directamente la respuesta, demostraci\u00f3n o c\u00f3digo.</p> <pre><code>def solve():\n    return ...\n</code></pre>","tags":["complejidad","ordenaci\u00f3n"]}]}